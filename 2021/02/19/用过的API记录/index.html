<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>记录一下用过的c++ windows api | ConsT27's Blog</title><meta name="keywords" content="windows相关"><meta name="author" content="ConsT27"><meta name="copyright" content="ConsT27"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="API:收录一下调过的API进程与内存打开一个已存在的本地进程:OpenProcessHANDLE OpenProcess(  DWORD dwDesiredAccess,  BOOL  bInheritHandle,  DWORD dwProcessId); dwdesiredaccess 指定能获得指定进程哪些权限。可选值如下 PROCESS_ALL_ACCESS  &#x2F;&#x2F;所">
<meta property="og:type" content="article">
<meta property="og:title" content="记录一下用过的c++ windows api">
<meta property="og:url" content="http://const27.com/2021/02/19/%E7%94%A8%E8%BF%87%E7%9A%84API%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="ConsT27&#39;s Blog">
<meta property="og:description" content="API:收录一下调过的API进程与内存打开一个已存在的本地进程:OpenProcessHANDLE OpenProcess(  DWORD dwDesiredAccess,  BOOL  bInheritHandle,  DWORD dwProcessId); dwdesiredaccess 指定能获得指定进程哪些权限。可选值如下 PROCESS_ALL_ACCESS  &#x2F;&#x2F;所">
<meta property="og:locale">
<meta property="og:image" content="https://const27blog.oss-cn-beijing.aliyuncs.com/img/ca.png">
<meta property="article:published_time" content="2021-02-19T09:22:00.344Z">
<meta property="article:modified_time" content="2021-02-19T08:47:36.378Z">
<meta property="article:author" content="ConsT27">
<meta property="article:tag" content="windows相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://const27blog.oss-cn-beijing.aliyuncs.com/img/ca.png"><link rel="shortcut icon" href="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210219183209.png"><link rel="canonical" href="http://const27.com/2021/02/19/%E7%94%A8%E8%BF%87%E7%9A%84API%E8%AE%B0%E5%BD%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-02-19 16:47:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="ConsT27's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210219183209.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">30</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/2021/02/19/%E5%8F%8B%E9%93%BE/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://const27blog.oss-cn-beijing.aliyuncs.com/img/ca.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ConsT27's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/2021/02/19/%E5%8F%8B%E9%93%BE/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">记录一下用过的c++ windows api</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-02-19T09:22:00.344Z" title="Created 2021-02-19 17:22:00">2021-02-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-02-19T08:47:36.378Z" title="Updated 2021-02-19 16:47:36">2021-02-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="API-收录一下调过的API"><a href="#API-收录一下调过的API" class="headerlink" title="API:收录一下调过的API"></a>API:收录一下调过的API</h2><h3 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h3><h4 id="打开一个已存在的本地进程-OpenProcess"><a href="#打开一个已存在的本地进程-OpenProcess" class="headerlink" title="打开一个已存在的本地进程:OpenProcess"></a>打开一个已存在的本地进程:OpenProcess</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">  DWORD dwDesiredAccess,</span><br><span class="line">  BOOL  bInheritHandle,</span><br><span class="line">  DWORD dwProcessId</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>dwdesiredaccess 指定能获得指定进程哪些权限。可选值如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROCESS_ALL_ACCESS  &#x2F;&#x2F;所有能获得的权限</span><br><span class="line">PROCESS_CREATE_PROCESS  &#x2F;&#x2F;需要创建一个进程</span><br><span class="line">PROCESS_CREATE_THREAD   &#x2F;&#x2F;需要创建一个线程</span><br><span class="line">PROCESS_DUP_HANDLE      &#x2F;&#x2F;重复使用DuplicateHandle句柄</span><br><span class="line">PROCESS_QUERY_INFORMATION   &#x2F;&#x2F;获得进程信息的权限，如它的退出代码、优先级</span><br><span class="line">PROCESS_QUERY_LIMITED_INFORMATION  &#x2F;*获得某些信息的权限，如果获得了PROCESS_QUERY_INFORMATION，也拥有PROCESS_QUERY_LIMITED_INFORMATION权限*&#x2F;</span><br><span class="line">PROCESS_SET_INFORMATION    &#x2F;&#x2F;设置某些信息的权限，如进程优先级</span><br><span class="line">PROCESS_SET_QUOTA          &#x2F;&#x2F;设置内存限制的权限，使用SetProcessWorkingSetSize</span><br><span class="line">PROCESS_SUSPEND_RESUME     &#x2F;&#x2F;暂停或恢复进程的权限</span><br><span class="line">PROCESS_TERMINATE          &#x2F;&#x2F;终止一个进程的权限，使用TerminateProcess</span><br><span class="line">PROCESS_VM_OPERATION       &#x2F;&#x2F;操作进程内存空间的权限(可用VirtualProtectEx和WriteProcessMemory) </span><br><span class="line">PROCESS_VM_READ            &#x2F;&#x2F;读取进程内存空间的权限，可使用ReadProcessMemory</span><br><span class="line">PROCESS_VM_WRITE           &#x2F;&#x2F;读取进程内存空间的权限，可使用WriteProcessMemory</span><br><span class="line">SYNCHRONIZE                &#x2F;&#x2F;等待进程终止</span><br></pre></td></tr></table></figure>
<p>bInheritHandle 若为TRUE，则表示所得到的进程句柄可被进程<br>dwProcessId 表示要获取的进程的PID</p>
<p>函数成功执行，则返回指定进程的句柄。反之则NULL。</p>
<h4 id="在指定进程的虚拟地址空间中保留，开辟，禁用一段区域-VirtualAllocEx"><a href="#在指定进程的虚拟地址空间中保留，开辟，禁用一段区域-VirtualAllocEx" class="headerlink" title="在指定进程的虚拟地址空间中保留，开辟，禁用一段区域 : VirtualAllocEx"></a>在指定进程的虚拟地址空间中保留，开辟，禁用一段区域 : VirtualAllocEx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPVOID VirtualAllocEx(</span><br><span class="line">  HANDLE hProcess,</span><br><span class="line">  LPVOID lpAddress,</span><br><span class="line">  SIZE_T dwSize,</span><br><span class="line">  DWORD  flAllocationType,</span><br><span class="line">  DWORD  flProtect</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hProcess 指定的进程的句柄。该句柄需有<strong>PROCESS_VM_OPERATION</strong>权限（操作进程内存空间的权限）</p>
<p>lpAddress 一个指针，用于选择你想分配的内存的开始地址。如果填NULL，则由dwsize的设置来自动分配。</p>
<p>dwSize 欲分配的内存大小（字节单位）。实际分配的大小是该值与页内存对齐后的结果。如果lpAddress为NULL，则会选中从进程首地址到dwSize的页对齐后的内存区域<br>如果lpAddress不为NULL，则选定lpaddress到lpaddress+dwsize的按照页对齐后的内存区域。</p>
<p>flAllocationType 内存分配的类型。有很多值，MSDN上有记录。<br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex</a><br>这个值用来确定一段内存区域用于被置0(commit)还是保留(reserve)还是禁用(reset)</p>
<p>flProtect 内存保护常数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PAGE_NOACCESS</span><br><span class="line">PAGE_GUARD</span><br><span class="line">PAGE_NOCACHE</span><br><span class="line">PAGE_WRITECOMBINE</span><br></pre></td></tr></table></figure>
<p>若函数执行成功，则返回分配的内存地址的基地址。</p>
<h4 id="在指定进程的虚拟地址空间中释放或decommit一段区域-VirtualFreeEx"><a href="#在指定进程的虚拟地址空间中释放或decommit一段区域-VirtualFreeEx" class="headerlink" title="在指定进程的虚拟地址空间中释放或decommit一段区域 : VirtualFreeEx"></a>在指定进程的虚拟地址空间中释放或decommit一段区域 : VirtualFreeEx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL VirtualFreeEx(</span><br><span class="line">  HANDLE hProcess,</span><br><span class="line">  LPVOID lpAddress,</span><br><span class="line">  SIZE_T dwSize,</span><br><span class="line">  DWORD  dwFreeType</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hprocess 进程句柄，需有<strong>PROCESS_VM_OPERATION</strong>权限</p>
<p>lpaddress 一个指向需要被释放或decommit内存区域首地址的指针。若dwfreetype为mem_release(释放),则这里应该填入VirtualAllocEx方法返回的保留的内存区域的基地址。</p>
<p>dwsize 需要被decommit的内存大小。<br>若dwfreetype为MEM_RELEASE 则此处填0<br>若为MEM_DECOMMIT，则此处填内存大小。 选定lpaddress到lpaddress+dwsize的按照页对齐后的内存区域。</p>
<p>dwfreetype 需要对内存区域进行的操作。有MEM_DECOMMIT和MEM_RELEASE，更多参数参考MSDN<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfreeex">https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfreeex</a></p>
<p>若函数执行成功则返回一个非零值，不成功则返回0</p>
<h4 id="向指定进程的内存区域写入-WriteProcessMemory"><a href="#向指定进程的内存区域写入-WriteProcessMemory" class="headerlink" title="向指定进程的内存区域写入: WriteProcessMemory"></a>向指定进程的内存区域写入: WriteProcessMemory</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">  HANDLE  hProcess,</span><br><span class="line">  LPVOID  lpBaseAddress,</span><br><span class="line">  LPCVOID lpBuffer,</span><br><span class="line">  SIZE_T  nSize,</span><br><span class="line">  SIZE_T  *lpNumberOfBytesWritten</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hprocess 进程句柄</p>
<p>lpbaseaddress 需要写入的内存区域的起始地址指针</p>
<p>lpbuffer 指向缓冲区的指针，该缓冲区包含要在指定进程的地址空间中写入的数据。</p>
<p>nsize 需要写入的数据大小（字节单位）</p>
<p>lpNumberOfBytesWritten 可选，用来存放”要被写入的数据“的变量</p>
<p>若成功则返回非0值，反之则0</p>
<h4 id="在一个进程内存空间中创建一个线程：CreateRemoteThread"><a href="#在一个进程内存空间中创建一个线程：CreateRemoteThread" class="headerlink" title="在一个进程内存空间中创建一个线程：CreateRemoteThread"></a>在一个进程内存空间中创建一个线程：CreateRemoteThread</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE CreateRemoteThread(</span><br><span class="line">  HANDLE                 hProcess,</span><br><span class="line">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span><br><span class="line">  SIZE_T                 dwStackSize,</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="line">  LPVOID                 lpParameter,</span><br><span class="line">  DWORD                  dwCreationFlags,</span><br><span class="line">  LPDWORD                lpThreadId</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hprocess 进程句柄</p>
<p>lpThreadAttributes 安全描述符</p>
<p>dwStackSize 栈大小，若为0则为默认值</p>
<p>lpStartAddress 要创建的线程的实现函数的首地址</p>
<p>lpParameter 传递给线程函数的参数</p>
<p>dwCreationFlags 线程控制参数</p>
<table>
<thead>
<tr>
<th>0</th>
<th align="left">The thread runs immediately after creation.</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CREATE_SUSPENDED</strong>0x00000004</td>
<td align="left">The thread is created in a suspended state, and does not run until the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-resumethread">ResumeThread</a> function is called.</td>
</tr>
<tr>
<td><strong>STACK_SIZE_PARAM_IS_A_RESERVATION</strong>0x00010000</td>
<td align="left">The <em>dwStackSize</em> parameter specifies the initial reserve size of the stack. If this flag is not specified, <em>dwStackSize</em> specifies the commit size.</td>
</tr>
</tbody></table>
<p>lpThreadId 线程标识符，如果线程不返回标识符则此项填NULL</p>
<h4 id="关闭一个句柄-CloseHandle"><a href="#关闭一个句柄-CloseHandle" class="headerlink" title="关闭一个句柄:CloseHandle"></a>关闭一个句柄:CloseHandle</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL CloseHandle(</span><br><span class="line">  HANDLE hObject</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hobject 要被关闭的句柄</p>
<p>成功则返回非0值，反之则0</p>
<h3 id="令牌与命名管道"><a href="#令牌与命名管道" class="headerlink" title="令牌与命名管道"></a>令牌与命名管道</h3><h4 id="创建命名管道句柄-CreateNamedPipeA"><a href="#创建命名管道句柄-CreateNamedPipeA" class="headerlink" title="创建命名管道句柄:CreateNamedPipeA"></a>创建命名管道句柄:CreateNamedPipeA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE CreateNamedPipeA(</span><br><span class="line">  LPCSTR                lpName,</span><br><span class="line">  DWORD                 dwOpenMode,</span><br><span class="line">  DWORD                 dwPipeMode,</span><br><span class="line">  DWORD                 nMaxInstances,</span><br><span class="line">  DWORD                 nOutBufferSize,</span><br><span class="line">  DWORD                 nInBufferSize,</span><br><span class="line">  DWORD                 nDefaultTimeOut,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpSecurityAttributes</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>lpName 唯一的管道名。格式是固定的: \.\pipe*pipename*</p>
<p>dwOpenMode 管道的开启方式。有三种：1.数据在服务器和客户机双向流通 <strong>PIPE_ACCESS_DUPLEX</strong>。2.数据只能从服务器流向客户机 <strong>PIPE_ACCESS_OUTBOUND</strong>。3.数据只能从客户机流向服务器 <strong>PIPE_ACCESS_INBOUND</strong>。具体请参考官方文档。以及一些附加参数，详情参考官方文档 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea">https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea</a></p>
<p>dwPipeMode 管道通信方式。指定字节流或者消息流通信，指定远程链接的访问方式，指定等待方式，详情参考官方文档</p>
<p>nMaxInstancees 管道的最大实例数</p>
<p>nOutBufferSize&amp;nInBufferSize 为输出&amp;输入缓存区保留的内存字节大小</p>
<p>nDefaultTimeOut 设定超时值。置0则为50ms</p>
<p>lpSecurityAttributes 设置安全描述符</p>
<p>若函数执行成功则返回管道服务器句柄。反之则返回<strong>INVALID_HANDLE_VALUE</strong></p>
<h4 id="开启一个命名管道等待链接-ConnectNamedPipe"><a href="#开启一个命名管道等待链接-ConnectNamedPipe" class="headerlink" title="开启一个命名管道等待链接: ConnectNamedPipe"></a>开启一个命名管道等待链接: ConnectNamedPipe</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL ConnectNamedPipe(</span><br><span class="line">  HANDLE       hNamedPipe,</span><br><span class="line">  LPOVERLAPPED lpOverlapped</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hNamedPipe 指定一个命名管道句柄，该句柄由CreateNamedPipe函数返回</p>
<p>lpOverlapped 一个指向重叠结构的指针，一般为NULL。详情参考官方文档<br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe">https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe</a></p>
<p>一般来说，当由客户机连上时返回true，没有客户机链接或链接丢失返回false</p>
<h4 id="模拟一个命名管道客户端-ImpersonateNamedPipeClient"><a href="#模拟一个命名管道客户端-ImpersonateNamedPipeClient" class="headerlink" title="模拟一个命名管道客户端:ImpersonateNamedPipeClient"></a>模拟一个命名管道客户端:ImpersonateNamedPipeClient</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL ImpersonateNamedPipeClient(</span><br><span class="line">  HANDLE hNamedPipe</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hNamedPipe 即指定的命名管道服务端。</p>
<p>这个函数有个坑点是，服务端才能用这个函数，且必须在服务端读取客户端传来的数据后才能成功，否则就会返回1368错误。</p>
<h4 id="获取当前线程令牌句柄-GetCurrentThreadToken"><a href="#获取当前线程令牌句柄-GetCurrentThreadToken" class="headerlink" title="获取当前线程令牌句柄: GetCurrentThreadToken"></a>获取当前线程令牌句柄: GetCurrentThreadToken</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE GetCurrentThreadToken();</span><br></pre></td></tr></table></figure>
<p>无参数，直接返回当前线程虚拟句柄</p>
<h4 id="以令牌创建一个进程（1）-CreateProcessWithTokenW"><a href="#以令牌创建一个进程（1）-CreateProcessWithTokenW" class="headerlink" title="以令牌创建一个进程（1）: CreateProcessWithTokenW"></a>以令牌创建一个进程（1）: CreateProcessWithTokenW</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL CreateProcessWithTokenW(</span><br><span class="line">  HANDLE                hToken,</span><br><span class="line">  DWORD                 dwLogonFlags,</span><br><span class="line">  LPCWSTR               lpApplicationName,</span><br><span class="line">  LPWSTR                lpCommandLine,</span><br><span class="line">  DWORD                 dwCreationFlags,</span><br><span class="line">  LPVOID                lpEnvironment,</span><br><span class="line">  LPCWSTR               lpCurrentDirectory,</span><br><span class="line">  LPSTARTUPINFOW        lpStartupInfo,</span><br><span class="line">  LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>有点不懂，链接在这里<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw">https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw</a></p>
<p>hToken 表示用户的令牌 必须有 TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY 权限</p>
<p>dwLogonFlags 登陆选项。<strong>LOGON_WITH_PROFILE</strong>或<strong>LOGON_NETCREDENTIALS_ONLY</strong></p>
<p>lpApplicationName 要被执行的模块。（比如 C:\Windows\system32\notepad.exe )</p>
<p>lpCommandLine 要被执行的命令。如果为NULL则把 lpApplicationName 当作要执行的命令</p>
<p>dwCreationFlags 控制进程的创建方式。参考MSDN</p>
<p>lpEnvironment 指向新进程环境块的指针。</p>
<p>lpCurrentDirectory 指向进程的“当前目录”路径。若NULL则“当前目录”为调用程序的“当前目录”</p>
<p>lpStartUpInfo 指向  <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a>或<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/ns-winbase-startupinfoexa">STARTUPINFOEX</a> 结构体</p>
<p>lpProcessInformation 指向  <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> 结果的指针</p>
<p>坑点：调用该函数的进程必须有 SE_IMPERSONATE_NAME 权限，不然会返回ERROR:1314</p>
<h4 id="以令牌创建一个进程（2）-CreateProcessAsUserA"><a href="#以令牌创建一个进程（2）-CreateProcessAsUserA" class="headerlink" title="以令牌创建一个进程（2）: CreateProcessAsUserA"></a>以令牌创建一个进程（2）: CreateProcessAsUserA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL CreateProcessAsUserA(</span><br><span class="line">  HANDLE                hToken,</span><br><span class="line">  LPCSTR                lpApplicationName,</span><br><span class="line">  LPSTR                 lpCommandLine,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">  BOOL                  bInheritHandles,</span><br><span class="line">  DWORD                 dwCreationFlags,</span><br><span class="line">  LPVOID                lpEnvironment,</span><br><span class="line">  LPCSTR                lpCurrentDirectory,</span><br><span class="line">  LPSTARTUPINFOA        lpStartupInfo,</span><br><span class="line">  LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>大致上与CreateProcessWithTokenW一样。<br>但是调用这个函数的进程必须有<strong>SE_INCREASE_QUOTA_NAME</strong>，或者<strong>SE_ASSIGNPRIMARYTOKEN_NAME</strong>权限，不然会返回ERROR:1314</p>
<h4 id="为已存在的Token创建副本-DuplicateTokenEx"><a href="#为已存在的Token创建副本-DuplicateTokenEx" class="headerlink" title="为已存在的Token创建副本: DuplicateTokenEx"></a>为已存在的Token创建副本: DuplicateTokenEx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL DuplicateTokenEx(</span><br><span class="line">  HANDLE                       hExistingToken,</span><br><span class="line">  DWORD                        dwDesiredAccess,</span><br><span class="line">  LPSECURITY_ATTRIBUTES        lpTokenAttributes,</span><br><span class="line">  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,</span><br><span class="line">  TOKEN_TYPE                   TokenType,</span><br><span class="line">  PHANDLE                      phNewToken</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hExistingToken 一个指针，指向一个有 TOKEN_DUPLICATE 权的Token</p>
<p>dwDesiredAccess 为新Token设置权限。若置0则表示权限与原Token相同。<br>下面是权限列表 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects">https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects</a></p>
<p>lpTokenAttributes 指向安全描述符的指针。若为NULL，则为默认安全描述符且句柄不能被继承</p>
<p>ImpersonationLevel 从 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ne-winnt-security_impersonation_level">SECURITY_IMPERSONATION_LEVEL</a> 中选择一个值填入。决定模仿的程度。</p>
<p>TokenType 选择<strong>TokenPrimary</strong> or <strong>TokenImpersonation</strong>填入。决定Token是primary token（能被用来执行CreateProcessAsUser）还是impersonation token</p>
<p>phNewToken 指针，指向承载新Token的Handle变量。</p>
<h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><h4 id="获得文件句柄：GetMoudleHandleA"><a href="#获得文件句柄：GetMoudleHandleA" class="headerlink" title="获得文件句柄：GetMoudleHandleA"></a>获得文件句柄：GetMoudleHandleA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMODULE GetModuleHandleA(</span><br><span class="line">  LPCSTR lpModuleName</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>lpModuleName即要获取的文件句柄的文件名，可为exe或dll。<br>若文件名没有后缀名则默认视为dll文件。<br>若该项为NULL，则返回当前进程的文件句柄。<br>存在于Kerner32.dll中<br>这里介绍一些HMOUDLE是个什么玩意<br>一般就是一个线性地址，用于记录一个文件句柄的地址。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217151436.png" alt="QQ截图20210217151436"></p>
<h4 id="从dll文件句柄中获得函数：GetProcAddress"><a href="#从dll文件句柄中获得函数：GetProcAddress" class="headerlink" title="从dll文件句柄中获得函数：GetProcAddress"></a>从dll文件句柄中获得函数：GetProcAddress</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">  HMODULE hModule,</span><br><span class="line">  LPCSTR  lpProcName</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hmodule 表示要传入的dll文件句柄。这个句柄可以由  <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-loadpackagedlibrary">LoadPackagedLibrary</a>, or <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> 等方法得到。</p>
<p>lpProcName表示要从dll文件中获得的函数没或者变量名。<br>若函数执行不成功，则返回NULL，否则返回函数或者变量的地址</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217151441.png" alt="QQ截图20210217151441"></p>
<h4 id="获得一个已存在文件句柄或者新建文件句柄-CreateFile"><a href="#获得一个已存在文件句柄或者新建文件句柄-CreateFile" class="headerlink" title="获得一个已存在文件句柄或者新建文件句柄:CreateFile"></a>获得一个已存在文件句柄或者新建文件句柄:CreateFile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE CreateFileW(</span><br><span class="line">  LPCWSTR               lpFileName,</span><br><span class="line">  DWORD                 dwDesiredAccess,</span><br><span class="line">  DWORD                 dwShareMode,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span><br><span class="line">  DWORD                 dwCreationDisposition,</span><br><span class="line">  DWORD                 dwFlagsAndAttributes,</span><br><span class="line">  HANDLE                hTemplateFile</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>lpFileName 文件路径</p>
<p>dwDesiredAccess 对文件的访问控制：读，写。<strong>GENERIC_READ</strong>, <strong>GENERIC_WRITE</strong>, or both (<code>GENERIC_READ | GENERIC_WRITE</code>)</p>
<p>dwShareMode 零表示不共享； FILE_SHARE_READ 和 / 或 FILE_SHARE_WRITE 表示允许对文件进行共享访问</p>
<p>lpSecurityAttributes 安全描述符</p>
<p>dwCreationDisposition 在文件不存在或存在时采取的操作</p>
<p>dwFlagsAndAttributes 设置文件标志位</p>
<p>hTemplateFile 多数情况下为NULL</p>
<h4 id="写文件-ReadFile"><a href="#写文件-ReadFile" class="headerlink" title="写文件: ReadFile"></a>写文件: ReadFile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL WriteFile(</span><br><span class="line">  HANDLE       hFile,</span><br><span class="line">  LPCVOID      lpBuffer,</span><br><span class="line">  DWORD        nNumberOfBytesToWrite,</span><br><span class="line">  LPDWORD      lpNumberOfBytesWritten,</span><br><span class="line">  LPOVERLAPPED lpOverlapped</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hFile 文件句柄</p>
<p>lpBuffer 要写入的数据缓存区</p>
<p>nNumberOfBytesToWrite 要写入的字节数</p>
<p>lpNumberOfBytesWritten 设置一个变量，用来接收写入的内容</p>
<p>lpOverlapped 通常为NULL</p>
<h4 id="读文件-ReadFile"><a href="#读文件-ReadFile" class="headerlink" title="读文件: ReadFile"></a>读文件: ReadFile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL ReadFile(</span><br><span class="line">  HANDLE       hFile,</span><br><span class="line">  LPVOID       lpBuffer,</span><br><span class="line">  DWORD        nNumberOfBytesToRead,</span><br><span class="line">  LPDWORD      lpNumberOfBytesRead,</span><br><span class="line">  LPOVERLAPPED lpOverlapped</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>和WriteFile差不多，8说了</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h4 id="建立与指定计算机服务控制管理器的联络并打开其数据库-OpenSCManagerA"><a href="#建立与指定计算机服务控制管理器的联络并打开其数据库-OpenSCManagerA" class="headerlink" title="建立与指定计算机服务控制管理器的联络并打开其数据库: OpenSCManagerA"></a>建立与指定计算机服务控制管理器的联络并打开其数据库: OpenSCManagerA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SC_HANDLE OpenSCManagerA(</span><br><span class="line">  LPCSTR lpMachineName,</span><br><span class="line">  LPCSTR lpDatabaseName,</span><br><span class="line">  DWORD  dwDesiredAccess</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>lpMachineName 指定计算机的名字。若为NULL则指向本地服务控制管理器</p>
<p>lpDatabaseName 服务控制管理器的数据库名。一般设为 SERVICES_ACTIVE_DATABASE 。若为NULL则默认打开 SERVICES_ACTIVE_DATABASE </p>
<p>dwDesiredAccess 对服务控制管理器的权限设置。参数清单:<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights</a></p>
<p>若执行成功则返回服务管理器数据库的句柄。反之则NULL。</p>
<h4 id="创建一个服务并把它加入到服务管理器数据库：-CreateServiceA"><a href="#创建一个服务并把它加入到服务管理器数据库：-CreateServiceA" class="headerlink" title="创建一个服务并把它加入到服务管理器数据库： CreateServiceA"></a>创建一个服务并把它加入到服务管理器数据库： CreateServiceA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SC_HANDLE CreateServiceA(</span><br><span class="line">  SC_HANDLE hSCManager,</span><br><span class="line">  LPCSTR    lpServiceName,</span><br><span class="line">  LPCSTR    lpDisplayName,</span><br><span class="line">  DWORD     dwDesiredAccess,</span><br><span class="line">  DWORD     dwServiceType,</span><br><span class="line">  DWORD     dwStartType,</span><br><span class="line">  DWORD     dwErrorControl,</span><br><span class="line">  LPCSTR    lpBinaryPathName,</span><br><span class="line">  LPCSTR    lpLoadOrderGroup,</span><br><span class="line">  LPDWORD   lpdwTagId,</span><br><span class="line">  LPCSTR    lpDependencies,</span><br><span class="line">  LPCSTR    lpServiceStartName,</span><br><span class="line">  LPCSTR    lpPassword</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hSCManager 服务管理器数据库句柄。可由OpenSCManagerA获得。句柄权限必须有<strong>SC_MANAGER_CREATE_SERVICE</strong></p>
<p>lpServiceName 要创建的服务名。</p>
<p>lpDisplayName 用户界面程序 用来标识服务的 显示名称 ，可与lpServiceName一致</p>
<p>dwDesiredAccess 对服务管理器的权限。参数清单在上面</p>
<p>dwServiceType 创建的服务的类型。（直接复制粘贴参数吧</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE_ADAPTER</strong>0x00000004</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_FILE_SYSTEM_DRIVER</strong>0x00000002</td>
<td align="left">File system driver service.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_KERNEL_DRIVER</strong>0x00000001</td>
<td align="left">Driver service.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_RECOGNIZER_DRIVER</strong>0x00000008</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_WIN32_OWN_PROCESS</strong>0x00000010</td>
<td align="left">Service that runs in its own process.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_WIN32_SHARE_PROCESS</strong>0x00000020</td>
<td align="left">Service that shares a process with one or more other services. For more information, see <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/Services/service-programs">Service Programs</a>.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_USER_OWN_PROCESS</strong>0x00000050</td>
<td align="left">The service runs in its own process under the logged-on user account.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_USER_SHARE_PROCESS</strong>0x00000060</td>
<td align="left">The service shares a process with one or more other services that run under the logged-on user account.</td>
</tr>
</tbody></table>
<p>If you specify either <strong>SERVICE_WIN32_OWN_PROCESS</strong> or <strong>SERVICE_WIN32_SHARE_PROCESS</strong>, and the service is running in the context of the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/Services/localsystem-account">LocalSystem account</a>, you can also specify the following value.</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE_INTERACTIVE_PROCESS</strong>0x00000100</td>
<td align="left">The service can interact with the desktop.For more information, see <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/Services/interactive-services">Interactive Services</a>.</td>
</tr>
</tbody></table>
<p>dwStartType 服务的开始选项，参数如下</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE_AUTO_START</strong>0x00000002</td>
<td align="left">A service started automatically by the service control manager during system startup. For more information, see <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/Services/automatically-starting-services">Automatically Starting Services</a>.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_BOOT_START</strong>0x00000000</td>
<td align="left">A device driver started by the system loader. This value is valid only for driver services.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_DEMAND_START</strong>0x00000003</td>
<td align="left">A service started by the service control manager when a process calls the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-startservicea">StartService</a> function. For more information, see <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/Services/starting-services-on-demand">Starting Services on Demand</a>.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_DISABLED</strong>0x00000004</td>
<td align="left">A service that cannot be started. Attempts to start the service result in the error code <strong>ERROR_SERVICE_DISABLED</strong>.</td>
</tr>
<tr>
<td align="left"><strong>SERVICE_SYSTEM_START</strong>0x00000001</td>
<td align="left">A device driver started by the <strong>IoInitSystem</strong> function. This value is valid only for driver services.</td>
</tr>
</tbody></table>
<p>dwErrorContriol 服务对于错误的容忍程度。</p>
<p><img src="http://www.const27.com/wp-content/uploads/2020/11/image-43.png" alt="img"></p>
<p>lpBinaryPathName 服务的绝对路径。</p>
<p>lpLoadOrderGroup 服务所属的加载排序组名称。如果服务不属于任何一个组则填NULL或空字符</p>
<p>lpdwTagId 一个指向变量的指针，该变量接收在lpLoadOrderGroup参数中指定的组中唯一的标记值。 一般置NULL</p>
<p>lpDependencies 一个以null结尾的指向服务或者加载顺序组的指针，在当前服务启动前必须先启动该项指向的服务或加载顺序组，即启动当前服务的依赖项。若服务不需要依赖项则置NULL</p>
<p>lpServiceStartName 服务运行的账户。若为NULL则用LocalSystem Account账户（即SYSTEM)</p>
<p>lpPassword 账户的密码。若为LocalSystemAccount则填NULL（SYSTEM账户没有密码）</p>
<p>成功则返回服务句柄，反之则NULL</p>
<h4 id="打开一个服务并获得句柄-OpenServiceA"><a href="#打开一个服务并获得句柄-OpenServiceA" class="headerlink" title="打开一个服务并获得句柄: OpenServiceA"></a>打开一个服务并获得句柄: OpenServiceA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SC_HANDLE OpenServiceA(</span><br><span class="line">  SC_HANDLE hSCManager,</span><br><span class="line">  LPCSTR    lpServiceName,</span><br><span class="line">  DWORD     dwDesiredAccess</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hSCManager 指向服务控制管理器数据库的句柄。</p>
<p>lpServiceName 服务名，注意不是lpDisplayName</p>
<p>dwDesiredAccess 对服务控制管理器的权限</p>
<p>成功则返回服务句柄，反之则NULL</p>
<h4 id="向一个服务发送控制指令-ControlService"><a href="#向一个服务发送控制指令-ControlService" class="headerlink" title="向一个服务发送控制指令:ControlService"></a>向一个服务发送控制指令:ControlService</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL ControlService(</span><br><span class="line">  SC_HANDLE        hService,</span><br><span class="line">  DWORD            dwControl,</span><br><span class="line">  LPSERVICE_STATUS lpServiceStatus</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hService 指向服务的句柄</p>
<p>dwControl 控制指令。详情参考 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-controlservice?f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINSVC/ControlService);k(ControlService);k(DevLang-C++);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-controlservice?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINSVC%252FControlService);k(ControlService);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p>
<p>lpServiceStatus 指向  <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_status">SERVICE_STATUS</a> 结构的指针，该结构用于接收服务报告给服务管理器的最新状态。</p>
<h4 id="使服务与SCM链接：-StartServiceCtrlDispatcherA"><a href="#使服务与SCM链接：-StartServiceCtrlDispatcherA" class="headerlink" title="使服务与SCM链接： StartServiceCtrlDispatcherA"></a>使服务与SCM链接： StartServiceCtrlDispatcherA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL StartServiceCtrlDispatcherA(</span><br><span class="line">  const SERVICE_TABLE_ENTRYA *lpServiceStartTable</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>lpServiceStartTable 指向一个  <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_table_entrya">SERVICE_TABLE_ENTRY</a> 结构，其包含了每个服务的入口点。该结构最后一个入口点必须是NULL来表示该结构已结束。<br>这个结构的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _SERVICE_TABLE_ENTRYW &#123;</span><br><span class="line">    LPWSTR                      lpServiceName;</span><br><span class="line">    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;</span><br><span class="line">&#125;SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;</span><br></pre></td></tr></table></figure>
<p>当SCM开始一个服务进程时，便在等待服务调用StartServiceCtrlDispatcherA 函数，若该函数长时间没有调用（一般为30s)，则服务会被强行关闭。直到所有该函数指定的服务进入SERVICE_STOPPED阶段，这个函数才会返回值。</p>
<h4 id="注册一个函数来处理服务控制请求-RegisterServiceCtrlHandlerA"><a href="#注册一个函数来处理服务控制请求-RegisterServiceCtrlHandlerA" class="headerlink" title="注册一个函数来处理服务控制请求: RegisterServiceCtrlHandlerA"></a>注册一个函数来处理服务控制请求: RegisterServiceCtrlHandlerA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(</span><br><span class="line">  LPCSTR             lpServiceName,</span><br><span class="line">  LPHANDLER_FUNCTION lpHandlerProc</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>lpServiceName 服务的名字。</p>
<p>lpHandlerProc 一个指针，指向要被注册的handler函数</p>
<p>若成功，则返回服务状态句柄，若失败则返回0</p>
<p>这个函数的主要目的是 可以让一个服务在运行过程中被来自其他地方的控制指令所控制，并根据自己定义的函数做出对应的行为</p>
<h4 id="更新服务的状态信息-SetServiceStatus"><a href="#更新服务的状态信息-SetServiceStatus" class="headerlink" title="更新服务的状态信息: SetServiceStatus"></a>更新服务的状态信息: SetServiceStatus</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL SetServiceStatus(</span><br><span class="line">  SERVICE_STATUS_HANDLE hServiceStatus,</span><br><span class="line">  LPSERVICE_STATUS      lpServiceStatus</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hServiceStatus 指向服务状态句柄，这个句柄由RegisterServiceCtrlHandlerA 等函数返回</p>
<p>lpServiceStatus 一个指针，指向  <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_status">SERVICE_STATUS</a> 结构，这个结构记录了服务的状态</p>
<h3 id="快照-以下函数或结构基本上都用到了另一个头文件Tlhelp32-h"><a href="#快照-以下函数或结构基本上都用到了另一个头文件Tlhelp32-h" class="headerlink" title="快照 以下函数或结构基本上都用到了另一个头文件Tlhelp32.h"></a>快照 以下函数或结构基本上都用到了另一个头文件Tlhelp32.h</h3><h4 id="为进程创建快照文件-转储-CreateToolhelp32Snapshot"><a href="#为进程创建快照文件-转储-CreateToolhelp32Snapshot" class="headerlink" title="为进程创建快照文件(转储): CreateToolhelp32Snapshot"></a>为进程创建快照文件(转储): CreateToolhelp32Snapshot</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE CreateToolhelp32Snapshot(</span><br><span class="line">  DWORD dwFlags,</span><br><span class="line">  DWORD th32ProcessID</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>dwFlags 转储参数，用于指定转储哪些信息以及指定返回的句柄的一些信息<br>详细参数<br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot</a></p>
<p>th32ProcessID 要被转储的进程的PID。置0则指定当前进程，当dwFlags为<strong>TH32CS_SNAPHEAPLIST</strong>, <strong>TH32CS_SNAPMODULE</strong>, <strong>TH32CS_SNAPMODULE32</strong>, or <strong>TH32CS_SNAPALL</strong>时，该值才表示要被转储的进程PID，否则该值会被忽略并转储所有进程</p>
<p>函数成功返回快照的句柄，否则返回<strong>INVALID_HANDLE_VALUE</strong></p>
<h4 id="检索快照中遇到的第一个进程的信息：-Process32First"><a href="#检索快照中遇到的第一个进程的信息：-Process32First" class="headerlink" title="检索快照中遇到的第一个进程的信息： Process32First"></a>检索快照中遇到的第一个进程的信息： Process32First</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL Process32First(</span><br><span class="line">  HANDLE           hSnapshot,</span><br><span class="line">  LPPROCESSENTRY32 lppe</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hSnapshot 快照句柄，由CreateToolhelp32napshot返回</p>
<p>lppe 指向PROCESSENTRY32结构。该结构用于保存进程信息，在进行该函数前，PROCESSENTRY32的dwSize属性必须定义好。</p>
<h4 id="检索快照中下一个进程的信息-Process32Next"><a href="#检索快照中下一个进程的信息-Process32Next" class="headerlink" title="检索快照中下一个进程的信息: Process32Next"></a>检索快照中下一个进程的信息: Process32Next</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL Process32Next(</span><br><span class="line">  HANDLE           hSnapshot,</span><br><span class="line">  LPPROCESSENTRY32 lppe</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hSnapshot 快照句柄，由CreateToolhelp32napshot返回</p>
<p>lppe 指向PROCESSENTRY32结构。该结构用于保存进程信息，在进行该函数前，PROCESSENTRY32的dwSize属性必须定义好。</p>
<h4 id="将某个进程转储为快照写入文件-MiniDumpWriteDump"><a href="#将某个进程转储为快照写入文件-MiniDumpWriteDump" class="headerlink" title="将某个进程转储为快照写入文件: MiniDumpWriteDump"></a>将某个进程转储为快照写入文件: MiniDumpWriteDump</h4><p>头文件 DbgHelp.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL MiniDumpWriteDump(</span><br><span class="line">  HANDLE                            hProcess,</span><br><span class="line">  DWORD                             ProcessId,</span><br><span class="line">  HANDLE                            hFile,</span><br><span class="line">  MINIDUMP_TYPE                     DumpType,</span><br><span class="line">  PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam,</span><br><span class="line">  PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,</span><br><span class="line">  PMINIDUMP_CALLBACK_INFORMATION    CallbackParam</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hProcess 进程句柄</p>
<p>processid 进程的PID</p>
<p>hFile 文件句柄，指定写入那个文件</p>
<p>DumpType 指定以何种形式写入文件，参数参考:<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type">https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type</a></p>
<p>ExceptionParam 指针，指向  <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_exception_information">MINIDUMP_EXCEPTION_INFORMATION</a> 结构用于描述发生的异常。如果为NULL，则表示转储文件中不包含异常信息</p>
<p>UserStreamParam 指针，指向  <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_user_stream_information">MINIDUMP_USER_STREAM_INFORMATION</a> 结构，这个结构保存用户数据流信息。一般置NULL</p>
<p>CallbackParam 指针，指向 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_callback_information">MINIDUMP_CALLBACK_INFORMATION</a> 结构，该结构保存回调函数的信息，一般置NULL</p>
<h3 id="HTTP请求，多数函数包含在winhttp-h中"><a href="#HTTP请求，多数函数包含在winhttp-h中" class="headerlink" title="HTTP请求，多数函数包含在winhttp.h中"></a>HTTP请求，多数函数包含在winhttp.h中</h3><p>大流程</p>
<p><img src="https://docs.microsoft.com/en-us/windows/win32/winhttp/images/art-winhttp3.png" alt="functions that create handles"></p>
<h4 id="winhttpopen-返回-WinHTTP-session-句柄"><a href="#winhttpopen-返回-WinHTTP-session-句柄" class="headerlink" title="winhttpopen:返回 WinHTTP-session 句柄"></a>winhttpopen:返回 WinHTTP-session 句柄</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINHTTPAPI HINTERNET WinHttpOpen(</span><br><span class="line">  LPCWSTR pszAgentW,</span><br><span class="line">  DWORD   dwAccessType,</span><br><span class="line">  LPCWSTR pszProxyW,</span><br><span class="line">  LPCWSTR pszProxyBypassW,</span><br><span class="line">  DWORD   dwFlags</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>pszAgentW 指针，指向一个字符串.该字符串在http通信中被用作user agent</p>
<p>dwAccessType http请求方式，其值有如下，主要是代理相关</p>
<blockquote>
<p><strong>WINHTTP_ACCESS_TYPE_DEFAULT_PROXY</strong><br><strong>WINHTTP_ACCESS_TYPE_NAMED_PROXY</strong><br><strong>WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY</strong><br><strong>WINHTTP_ACCESS_TYPE_NO_PROXY</strong> 不使用代理进行通讯</p>
</blockquote>
<p>pszProxyW 指针，当dwAccessType为 <strong>WINHTTP_ACCESS_TYPE_NAMED_PROXY</strong> 时指向代理服务器名字。否则取<strong>WINHTTP_NO_PROXY_NAME</strong>值</p>
<p>pszProxyBypassW 指针，指向字符串， 当dwAccessType为 <strong>WINHTTP_ACCESS_TYPE_NAMED_PROXY</strong> 时指向不想走代理的IP地址或主机名。否则取<strong>WINHTTP_NO_PROXY_BYPASS</strong>值</p>
<p>dwFlags 一般取0</p>
<h4 id="WinHttpConnect-：返回-链接-句柄（-handle-to-an-HTTP-session-for-that-initial-target-）"><a href="#WinHttpConnect-：返回-链接-句柄（-handle-to-an-HTTP-session-for-that-initial-target-）" class="headerlink" title="WinHttpConnect ：返回 链接 句柄（ handle to an HTTP session for that initial target. ）"></a>WinHttpConnect ：返回 链接 句柄（ handle to an HTTP session for that initial target. ）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINHTTPAPI HINTERNET WinHttpConnect(</span><br><span class="line">  HINTERNET     hSession,</span><br><span class="line">  LPCWSTR       pswzServerName,</span><br><span class="line">  INTERNET_PORT nServerPort,</span><br><span class="line">  DWORD         dwReserved</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hSession WinHttpOpen 方法返回的句柄</p>
<p>pswzServerName 指针，指向需要请求的服务器的IP或主机名的字符串</p>
<p>nServerPort 指定请求端口</p>
<p>dwReserved 置0</p>
<h4 id="WinHttpOpenRequest-：创建HTTP请求句柄"><a href="#WinHttpOpenRequest-：创建HTTP请求句柄" class="headerlink" title="WinHttpOpenRequest ：创建HTTP请求句柄"></a>WinHttpOpenRequest ：创建HTTP请求句柄</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINHTTPAPI HINTERNET WinHttpOpenRequest(</span><br><span class="line">  HINTERNET hConnect,</span><br><span class="line">  LPCWSTR   pwszVerb,</span><br><span class="line">  LPCWSTR   pwszObjectName,</span><br><span class="line">  LPCWSTR   pwszVersion,</span><br><span class="line">  LPCWSTR   pwszReferrer,</span><br><span class="line">  LPCWSTR   *ppwszAcceptTypes,</span><br><span class="line">  DWORD     dwFlags</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hConnect WinHttpConnect返回的句柄</p>
<p>pwszVerb 指定HTTP请求方法</p>
<p>pwszObjectName 指定请求资源的路径</p>
<p>pwszVersion 指定HTTP版本</p>
<p>pwszReferrer 多数情况可设置为<strong>WINHTTP_NO_REFERER</strong></p>
<p>ppwszAcceptTypes 指定媒体类型，可设置为<strong>WINHTTP_DEFAULT_ACCEPT_TYPES</strong></p>
<p>dwFlags 通常置0</p>
<h4 id="WinHttpAddRequestHeaders-设置HTTP头"><a href="#WinHttpAddRequestHeaders-设置HTTP头" class="headerlink" title="WinHttpAddRequestHeaders 设置HTTP头"></a>WinHttpAddRequestHeaders 设置HTTP头</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOLAPI WinHttpAddRequestHeaders(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPCWSTR   lpszHeaders,</span><br><span class="line">  DWORD     dwHeadersLength,</span><br><span class="line">  DWORD     dwModifiers</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hRequest WinHttpOpenRequest返回的句柄</p>
<p>lpszHeaders 指向字符串的指针，字符串里包含了要附加到http请求上的头部信息。每个头部之间用 CR/LF 隔开</p>
<p>dwHeadersLength 头部的长度</p>
<p>dwModifiers 一些功能修饰，一般可以置 WINHTTP_ADDREQ_FLAG_ADD</p>
<h4 id="WinHttpSendRequest-发送HTTP请求"><a href="#WinHttpSendRequest-发送HTTP请求" class="headerlink" title="WinHttpSendRequest 发送HTTP请求"></a>WinHttpSendRequest 发送HTTP请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOLAPI WinHttpSendRequest(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPCWSTR   lpszHeaders,</span><br><span class="line">  DWORD     dwHeadersLength,</span><br><span class="line">  LPVOID    lpOptional,</span><br><span class="line">  DWORD     dwOptionalLength,</span><br><span class="line">  DWORD     dwTotalLength,</span><br><span class="line">  DWORD_PTR dwContext</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hRequest WinHttpOpenRequest返回的句柄</p>
<p>lpszHeaders 附加的HTTP头，如果没有想附加的头就置0</p>
<p>dwHeadersLength lpszHeaders 指定的头的字符串大小</p>
<p>lpOptional 一个指针。指向一个缓冲区，当中包括可选的数据发送后，马上请求标头。该參数通经常使用于POST和PUT操作。 （我理解为传的参数）</p>
<p>dwOptionalLength 额外内容的长度</p>
<p>dwTotalLength 总长度</p>
<p>dwContext 通常置0</p>
<h4 id="WinHttpReceiveResponse-：等待http回应"><a href="#WinHttpReceiveResponse-：等待http回应" class="headerlink" title="WinHttpReceiveResponse ：等待http回应"></a>WinHttpReceiveResponse ：等待http回应</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINHTTPAPI BOOL WinHttpReceiveResponse(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPVOID    lpReserved</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>hRequest WinHttpOpenRequest 返回的句柄</p>
<p>lpReserved 置NULL</p>
<p>主要作用是如果有回应，则会返回true。</p>
<h4 id="WinHttpQueryDataAvailable-：返回HTTP回应内容的大致信息"><a href="#WinHttpQueryDataAvailable-：返回HTTP回应内容的大致信息" class="headerlink" title="WinHttpQueryDataAvailable ：返回HTTP回应内容的大致信息"></a>WinHttpQueryDataAvailable ：返回HTTP回应内容的大致信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOLAPI WinHttpQueryDataAvailable(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPDWORD   lpdwNumberOfBytesAvailable</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>lpdwNumberOfBytesAvailable 置NULL，其用来接收内容长度</p>
<h4 id="WinHttpReadData-读取HTTP回应内容"><a href="#WinHttpReadData-读取HTTP回应内容" class="headerlink" title="WinHttpReadData 读取HTTP回应内容"></a>WinHttpReadData 读取HTTP回应内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOLAPI WinHttpReadData(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPVOID    lpBuffer,</span><br><span class="line">  DWORD     dwNumberOfBytesToRead,</span><br><span class="line">  LPDWORD   lpdwNumberOfBytesRead</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>lpBuffer 指定一片缓冲区，回应的数据会存放到此处</p>
<p>dwNumberOfBytesToRead 缓冲区大小长度</p>
<p>lpdwNumberOfBytesRead 用于存储回应的字节数，在使用该函数时该值须为NULL</p>
<p>说白了，就是以C或c++等语言为载体，调用各种Windows API完成编程<br>学这个的目的是因为要接触免杀，需要更深层次的了解Windows的一些机制。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ConsT27</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://const27.com/2021/02/19/%E7%94%A8%E8%BF%87%E7%9A%84API%E8%AE%B0%E5%BD%95/">http://const27.com/2021/02/19/%E7%94%A8%E8%BF%87%E7%9A%84API%E8%AE%B0%E5%BD%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/windows%E7%9B%B8%E5%85%B3/">windows相关</a></div><div class="post_share"><div class="social-share" data-image="https://const27blog.oss-cn-beijing.aliyuncs.com/img/ca.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://const27blog.oss-cn-beijing.aliyuncs.com/img/mm_facetoface_collect_qrcode_1613729678854.png" target="_blank"><img class="post-qr-code-img" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/mm_facetoface_collect_qrcode_1613729678854.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/19/DisableFunctions%E7%BB%95%E8%BF%87/"><img class="prev-cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/cv.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">PHP disablefunctions绕过</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/19/%E5%90%AF%E7%94%A8SeDebugPrivilege/"><img class="next-cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/fm.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">windows启用SeDebugPrivilege</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/02/19/Windows消息机制/" title="windows消息机制"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/az.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-19</div><div class="title">windows消息机制</div></div></a></div><div><a href="/2021/02/19/创建服务/" title="windows创建一个服务"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/jp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-19</div><div class="title">windows创建一个服务</div></div></a></div><div><a href="/2021/02/19/启用SeDebugPrivilege/" title="windows启用SeDebugPrivilege"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/fm.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-19</div><div class="title">windows启用SeDebugPrivilege</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#API-%E6%94%B6%E5%BD%95%E4%B8%80%E4%B8%8B%E8%B0%83%E8%BF%87%E7%9A%84API"><span class="toc-number">1.</span> <span class="toc-text">API:收录一下调过的API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-number">1.1.</span> <span class="toc-text">进程与内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B-OpenProcess"><span class="toc-number">1.1.1.</span> <span class="toc-text">打开一个已存在的本地进程:OpenProcess</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%AD%E4%BF%9D%E7%95%99%EF%BC%8C%E5%BC%80%E8%BE%9F%EF%BC%8C%E7%A6%81%E7%94%A8%E4%B8%80%E6%AE%B5%E5%8C%BA%E5%9F%9F-VirtualAllocEx"><span class="toc-number">1.1.2.</span> <span class="toc-text">在指定进程的虚拟地址空间中保留，开辟，禁用一段区域 : VirtualAllocEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%AD%E9%87%8A%E6%94%BE%E6%88%96decommit%E4%B8%80%E6%AE%B5%E5%8C%BA%E5%9F%9F-VirtualFreeEx"><span class="toc-number">1.1.3.</span> <span class="toc-text">在指定进程的虚拟地址空间中释放或decommit一段区域 : VirtualFreeEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%86%99%E5%85%A5-WriteProcessMemory"><span class="toc-number">1.1.4.</span> <span class="toc-text">向指定进程的内存区域写入: WriteProcessMemory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%9ACreateRemoteThread"><span class="toc-number">1.1.5.</span> <span class="toc-text">在一个进程内存空间中创建一个线程：CreateRemoteThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E4%B8%80%E4%B8%AA%E5%8F%A5%E6%9F%84-CloseHandle"><span class="toc-number">1.1.6.</span> <span class="toc-text">关闭一个句柄:CloseHandle</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E4%B8%8E%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.2.</span> <span class="toc-text">令牌与命名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E5%8F%A5%E6%9F%84-CreateNamedPipeA"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建命名管道句柄:CreateNamedPipeA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E7%AD%89%E5%BE%85%E9%93%BE%E6%8E%A5-ConnectNamedPipe"><span class="toc-number">1.2.2.</span> <span class="toc-text">开启一个命名管道等待链接: ConnectNamedPipe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E5%AE%A2%E6%88%B7%E7%AB%AF-ImpersonateNamedPipeClient"><span class="toc-number">1.2.3.</span> <span class="toc-text">模拟一个命名管道客户端:ImpersonateNamedPipeClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%BB%A4%E7%89%8C%E5%8F%A5%E6%9F%84-GetCurrentThreadToken"><span class="toc-number">1.2.4.</span> <span class="toc-text">获取当前线程令牌句柄: GetCurrentThreadToken</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E4%BB%A4%E7%89%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%881%EF%BC%89-CreateProcessWithTokenW"><span class="toc-number">1.2.5.</span> <span class="toc-text">以令牌创建一个进程（1）: CreateProcessWithTokenW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E4%BB%A4%E7%89%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%882%EF%BC%89-CreateProcessAsUserA"><span class="toc-number">1.2.6.</span> <span class="toc-text">以令牌创建一个进程（2）: CreateProcessAsUserA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84Token%E5%88%9B%E5%BB%BA%E5%89%AF%E6%9C%AC-DuplicateTokenEx"><span class="toc-number">1.2.7.</span> <span class="toc-text">为已存在的Token创建副本: DuplicateTokenEx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6IO"><span class="toc-number">1.3.</span> <span class="toc-text">文件IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%EF%BC%9AGetMoudleHandleA"><span class="toc-number">1.3.1.</span> <span class="toc-text">获得文件句柄：GetMoudleHandleA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Edll%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E4%B8%AD%E8%8E%B7%E5%BE%97%E5%87%BD%E6%95%B0%EF%BC%9AGetProcAddress"><span class="toc-number">1.3.2.</span> <span class="toc-text">从dll文件句柄中获得函数：GetProcAddress</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E5%B7%B2%E5%AD%98%E5%9C%A8%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%88%96%E8%80%85%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84-CreateFile"><span class="toc-number">1.3.3.</span> <span class="toc-text">获得一个已存在文件句柄或者新建文件句柄:CreateFile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6-ReadFile"><span class="toc-number">1.3.4.</span> <span class="toc-text">写文件: ReadFile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6-ReadFile"><span class="toc-number">1.3.5.</span> <span class="toc-text">读文件: ReadFile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%8C%87%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%8D%E5%8A%A1%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%81%94%E7%BB%9C%E5%B9%B6%E6%89%93%E5%BC%80%E5%85%B6%E6%95%B0%E6%8D%AE%E5%BA%93-OpenSCManagerA"><span class="toc-number">1.4.1.</span> <span class="toc-text">建立与指定计算机服务控制管理器的联络并打开其数据库: OpenSCManagerA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%B9%B6%E6%8A%8A%E5%AE%83%E5%8A%A0%E5%85%A5%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A-CreateServiceA"><span class="toc-number">1.4.2.</span> <span class="toc-text">创建一个服务并把它加入到服务管理器数据库： CreateServiceA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%8E%B7%E5%BE%97%E5%8F%A5%E6%9F%84-OpenServiceA"><span class="toc-number">1.4.3.</span> <span class="toc-text">打开一个服务并获得句柄: OpenServiceA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4-ControlService"><span class="toc-number">1.4.4.</span> <span class="toc-text">向一个服务发送控制指令:ControlService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E6%9C%8D%E5%8A%A1%E4%B8%8ESCM%E9%93%BE%E6%8E%A5%EF%BC%9A-StartServiceCtrlDispatcherA"><span class="toc-number">1.4.5.</span> <span class="toc-text">使服务与SCM链接： StartServiceCtrlDispatcherA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9D%A5%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82-RegisterServiceCtrlHandlerA"><span class="toc-number">1.4.6.</span> <span class="toc-text">注册一个函数来处理服务控制请求: RegisterServiceCtrlHandlerA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF-SetServiceStatus"><span class="toc-number">1.4.7.</span> <span class="toc-text">更新服务的状态信息: SetServiceStatus</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7-%E4%BB%A5%E4%B8%8B%E5%87%BD%E6%95%B0%E6%88%96%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E4%B8%8A%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%A4%B4%E6%96%87%E4%BB%B6Tlhelp32-h"><span class="toc-number">1.5.</span> <span class="toc-text">快照 以下函数或结构基本上都用到了另一个头文件Tlhelp32.h</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E6%96%87%E4%BB%B6-%E8%BD%AC%E5%82%A8-CreateToolhelp32Snapshot"><span class="toc-number">1.5.1.</span> <span class="toc-text">为进程创建快照文件(转储): CreateToolhelp32Snapshot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E5%BF%AB%E7%85%A7%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%9A-Process32First"><span class="toc-number">1.5.2.</span> <span class="toc-text">检索快照中遇到的第一个进程的信息： Process32First</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E5%BF%AB%E7%85%A7%E4%B8%AD%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BF%A1%E6%81%AF-Process32Next"><span class="toc-number">1.5.3.</span> <span class="toc-text">检索快照中下一个进程的信息: Process32Next</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%BD%AC%E5%82%A8%E4%B8%BA%E5%BF%AB%E7%85%A7%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6-MiniDumpWriteDump"><span class="toc-number">1.5.4.</span> <span class="toc-text">将某个进程转储为快照写入文件: MiniDumpWriteDump</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%A4%9A%E6%95%B0%E5%87%BD%E6%95%B0%E5%8C%85%E5%90%AB%E5%9C%A8winhttp-h%E4%B8%AD"><span class="toc-number">1.6.</span> <span class="toc-text">HTTP请求，多数函数包含在winhttp.h中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#winhttpopen-%E8%BF%94%E5%9B%9E-WinHTTP-session-%E5%8F%A5%E6%9F%84"><span class="toc-number">1.6.1.</span> <span class="toc-text">winhttpopen:返回 WinHTTP-session 句柄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WinHttpConnect-%EF%BC%9A%E8%BF%94%E5%9B%9E-%E9%93%BE%E6%8E%A5-%E5%8F%A5%E6%9F%84%EF%BC%88-handle-to-an-HTTP-session-for-that-initial-target-%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">WinHttpConnect ：返回 链接 句柄（ handle to an HTTP session for that initial target. ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WinHttpOpenRequest-%EF%BC%9A%E5%88%9B%E5%BB%BAHTTP%E8%AF%B7%E6%B1%82%E5%8F%A5%E6%9F%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">WinHttpOpenRequest ：创建HTTP请求句柄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WinHttpAddRequestHeaders-%E8%AE%BE%E7%BD%AEHTTP%E5%A4%B4"><span class="toc-number">1.6.4.</span> <span class="toc-text">WinHttpAddRequestHeaders 设置HTTP头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WinHttpSendRequest-%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82"><span class="toc-number">1.6.5.</span> <span class="toc-text">WinHttpSendRequest 发送HTTP请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WinHttpReceiveResponse-%EF%BC%9A%E7%AD%89%E5%BE%85http%E5%9B%9E%E5%BA%94"><span class="toc-number">1.6.6.</span> <span class="toc-text">WinHttpReceiveResponse ：等待http回应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WinHttpQueryDataAvailable-%EF%BC%9A%E8%BF%94%E5%9B%9EHTTP%E5%9B%9E%E5%BA%94%E5%86%85%E5%AE%B9%E7%9A%84%E5%A4%A7%E8%87%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">1.6.7.</span> <span class="toc-text">WinHttpQueryDataAvailable ：返回HTTP回应内容的大致信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WinHttpReadData-%E8%AF%BB%E5%8F%96HTTP%E5%9B%9E%E5%BA%94%E5%86%85%E5%AE%B9"><span class="toc-number">1.6.8.</span> <span class="toc-text">WinHttpReadData 读取HTTP回应内容</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ConsT27</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">怀念那一刹耀眼的火花</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>