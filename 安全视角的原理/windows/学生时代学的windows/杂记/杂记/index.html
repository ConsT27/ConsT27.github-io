<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>杂记 - ConsT27's Blog</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u6742\u8bb0", url: "#_top", children: [
              {title: "\u76ee\u5f55", url: "#_2" },
          ]},
          {title: "\u7ed3\u6784\u4f53\u4e0e\u5171\u7528\u4f53", url: "#_3", children: [
          ]},
          {title: "PE\u6587\u4ef6\u4e4b\u5bfc\u5165\u8868", url: "#pe", children: [
          ]},
          {title: "c++\u4e2d\u51e0\u4e2a\u5185\u5b58\u5206\u914d\u51fd\u6570\u7684\u533a\u522b", url: "#c", children: [
              {title: "VirtualAlloc", url: "#virtualalloc" },
              {title: "HeapAlloc", url: "#heapalloc" },
              {title: "malloc", url: "#malloc" },
              {title: "new", url: "#new" },
          ]},
          {title: "TEB PEB", url: "#teb-peb", children: [
              {title: "\u901a\u8fc7TEB\\\u0026amp;PEB \u52a8\u6001\u83b7\u53d6\u51fd\u6570\u5730\u5740", url: "#tebpeb" },
          ]},
          {title: "\u521b\u5efa\u670d\u52a1", url: "#_4", children: [
              {title: "\u670d\u52a1", url: "#_5" },
              {title: "\u5982\u4f55\u521b\u5efa\u4e00\u4e2aWindows\u670d\u52a1", url: "#windows" },
          ]},
          {title: "\u542f\u7528SeDebugPrivilege", url: "#sedebugprivilege", children: [
              {title: "Token PRIVILEGES\u7ed3\u6784\u6811", url: "#token-privileges" },
          ]},
          {title: "dll\u7f16\u5199", url: "#dll", children: [
              {title: "DLLMAIN", url: "#dllmain" },
              {title: "DLL \u5bfc\u51fa\u51fd\u6570", url: "#dll_1" },
              {title: "\u9898\u5916\u8bdd\uff1a\u600e\u4e48\u4f7f\u7528dll\u6216lib\u4e2d\u7684\u5bfc\u51fa\u51fd\u6570", url: "#dlllib" },
              {title: "rundll32", url: "#rundll32" },
          ]},
          {title: "\u6d88\u606f\u673a\u5236", url: "#_12", children: [
              {title: "\u4e8b\u4ef6\u9a71\u52a8", url: "#_13" },
              {title: "\u6d88\u606f\u673a\u5236", url: "#_14" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../%E7%94%A8%E8%BF%87%E7%9A%84WINDOWS_API%E8%AE%B0%E5%BD%95/%E7%94%A8%E8%BF%87%E7%9A%84WINDOWS_API%E8%AE%B0%E5%BD%95/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../%E7%94%A8%E8%BF%87%E7%9A%84WINDOWS_API%E8%AE%B0%E5%BD%95/%E7%94%A8%E8%BF%87%E7%9A%84WINDOWS_API%E8%AE%B0%E5%BD%95/" class="btn btn-xs btn-link">
        用过的WINDOWS_API记录
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84RPC%E5%85%A5%E9%97%A8/%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84RPC%E5%85%A5%E9%97%A8/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84RPC%E5%85%A5%E9%97%A8/%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84RPC%E5%85%A5%E9%97%A8/" class="btn btn-xs btn-link">
        安全视角下的RPC入门
      </a>
    </div>
    
  </div>

    

    <h1 id="_1">杂记</h1>
<h2 id="_2">目录</h2>
<ul>
<li><a href="#结构体与共用体">结构体与共用体</a></li>
<li><a href="#PE文件之导入表">PE文件之导入表</a></li>
<li><a href="#c中几个内存分配函数的区别">c++中几个内存分配函数的区别</a><ul>
<li><a href="#VirtualAlloc">VirtualAlloc</a></li>
<li><a href="#HeapAlloc">HeapAlloc</a></li>
<li><a href="#malloc">malloc</a></li>
<li><a href="#new">new</a></li>
</ul>
</li>
<li><a href="#TEB-PEB">TEB PEB</a><ul>
<li><a href="#通过TEBPEB-动态获取函数地址">通过TEB\&amp;PEB 动态获取函数地址</a></li>
</ul>
</li>
<li><a href="#创建服务">创建服务</a><ul>
<li><a href="#服务">服务</a></li>
<li><a href="#如何创建一个Windows服务">如何创建一个Windows服务</a><ul>
<li><a href="#服务程序主函数">服务程序主函数</a></li>
<li><a href="#完成服务程序内容主函数">完成服务程序内容主函数</a><ul>
<li><a href="#创建服务内容主函数">创建服务内容主函数</a></li>
<li><a href="#实现-SERVICE_STATUS-结构">实现 SERVICE_STATUS 结构</a></li>
<li><a href="#实现服务句柄改变状态信息">实现服务句柄&amp;改变状态信息</a></li>
</ul>
</li>
<li><a href="#DEMO">DEMO</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#启用SeDebugPrivilege">启用SeDebugPrivilege</a><ul>
<li><a href="#Token-PRIVILEGES结构树">Token PRIVILEGES结构树</a></li>
</ul>
</li>
<li><a href="#dll编写">dll编写</a><ul>
<li><a href="#DLLMAIN">DLLMAIN</a></li>
<li><a href="#DLL-导出函数">DLL 导出函数</a></li>
<li><a href="#题外话怎么使用dll或lib中的导出函数">题外话：怎么使用dll或lib中的导出函数</a><ul>
<li><a href="#静态链接">静态链接</a></li>
<li><a href="#动态链接">动态链接</a></li>
</ul>
</li>
<li><a href="#rundll32">rundll32</a></li>
</ul>
</li>
<li><a href="#消息机制">消息机制</a><ul>
<li><a href="#事件驱动">事件驱动</a></li>
<li><a href="#消息机制">消息机制</a></li>
</ul>
</li>
</ul>
<h1 id="_3">结构体与共用体</h1>
<h1 id="pe">PE文件之导入表</h1>
<p>导入表作为PE文件中重要的一环，在免杀中有诸多利用。</p>
<p>一个导入表的结构如下</p>
<p><img alt="image-20210722112317693" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210722112317693.png" title="image-20210722112317693" /></p>
<p>下面只说说重要的项</p>
<p>OriginalFirstThunk 指向导入名称表INT的RVA.
Name 存储函数名字的RVA。
FirstThunk 指向导入地址表IAT的RVA。</p>
<p>OriginalFirstThunk 和FirstThunk对应的INT和IAT是个什么样的概念呢？</p>
<p>首先，无论是INT还是IAT，在PE文件被加载前（即在文件形式时）都指向同一种结构：IMAGE_THUNK_DATA,其结构如下</p>
<pre><code class="language-纯文本">typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;      // PBYTE  指向一个转向者字符串的RVA
        DWORD Function;             // PDWORD 被输入的函数的内存地址
         DWORD Ordinal;              // 被输入的 API 的序数值
         DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME   指向 IMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;
</code></pre>
<p>是一个联合体结构(所以只占四个字节)，
当最高位为0时，就说明这四字节值为<strong>IMAGE_IMPORT_BY_NAME</strong>的RVA
当最高位为1时，则去掉最高位后剩下31位则为dll函数在导出表中的导出序号</p>
<p>我们通常取其AddressOfData值来获得另一个结构IMAGE_IMPORT_BY_NAME.</p>
<pre><code class="language-纯文本">ypedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;       //可能为0，编译器决定，如果不为0，是函数在导出表中的索引
    BYTE    Name[1];    //函数名称，以0结尾，由于不知道到底多长，所以干脆只给出第一个字符，找到0结束
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
</code></pre>
<p>以上则是基本的结构，下面分析其工作的时候的实现流程。</p>
<p>首先在加载前，IAT和INT是指向同一个结构IMAGE_THUNK_DATA,的</p>
<p><img alt="image-20210722115238741" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210722115238741.png" title="image-20210722115238741" /></p>
<p>而加载后，Windows会重写FirstThunk所指向的INT中的每一个IMAGE_THUNK_DATA32，使其直接指向函数地址，这也就是IAT输入地址表的名字由来。</p>
<p><img alt="image-20210722115608691" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210722115608691.png" title="image-20210722115608691" /></p>
<h1 id="c">c++中几个内存分配函数的区别</h1>
<h2 id="virtualalloc">VirtualAlloc</h2>
<p>用来分配大块内存。使用VirtualFree来释放</p>
<h2 id="heapalloc">HeapAlloc</h2>
<p>在进程初始化的时候，系统会在进程的地址空间中创建1M大小的堆，叫做默认堆。HeapAlloc用于从堆上分配内存块。
堆的使用可以更有效地进行内存管理,避免线程同步的开销以及快速释放内存。
此函数一般用于分配一般大小的内存空间，当分配内存块大于1M最好避免使用此函数。
使用HeapFree释放</p>
<h2 id="malloc">malloc</h2>
<p>C分配内存的方式，如果您使用C而不是C ++编写代码，并且您希望您的代码也可以在Unix计算机上工作，或者有人明确表示需要使用它，那么请选择此选项。用free解除分配。</p>
<p>值得一提的是，visual c++的malloc调用了HeapAlloc</p>
<h2 id="new">new</h2>
<p>c++分配内存的方式。用delete解除分配。</p>
<h1 id="teb-peb">TEB PEB</h1>
<p>TEB,即线程环境块。每一个线程都具有一个TEB结构，记录了相关线程的一些基本信息。
线程运行时，FS段寄存器记录了其TEB的位置，TEB结构的0x30处偏移即为PEB进程环境快。</p>
<pre><code class="language-纯文本">mov eax,fs:[0x30]
</code></pre>
<p>PEB结构很大，有0x210个字节。</p>
<h2 id="tebpeb">通过TEB\&amp;PEB 动态获取函数地址</h2>
<p>在PEB结构的0x0c偏移处，是一个指向PEB_LDR_DATA结构的指针。这个结构如下：</p>
<p><img alt="image-20210722221413525" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210722221413525.png" title="image-20210722221413525" /></p>
<p>他有三个LIST_ENTRY结构，每一个都按照不同顺序将进程加载的所有模块连接起来，通过遍历任意一个LIST_ENTRY我们就可以获得所有模块的基地址，获得每个模块基地址后通过DLL文件导出表就可以获得任一导出函数的地址了。</p>
<h1 id="_4">创建服务</h1>
<h2 id="_5">服务</h2>
<p>Windows服务，是指运行在windows nt操作系统后台的计算机程序.
Windows服务必须符合服务控制管理器的接口规则和协议（SCM)</p>
<h2 id="windows">如何创建一个Windows服务</h2>
<p>分为：
1.完成服务程序主函数（进程入口点（Main函数
2.完成服务程序内容主函数（ServiceMain
3.服务的注册器和卸载器</p>
<h3 id="_6">服务程序主函数</h3>
<p>这个阶段，主要干两件事：
1.设定好SERVICE_TABLE_ENTRY 结构变量，传入服务名和服务主函数
2.调用StartServiceCtrlDispatcher函数
以下是SERVICE_TABLE_ENTRY结构</p>
<pre><code class="language-纯文本">typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;
</code></pre>
<p>所以我们的服务程序的主函数只需要像这样写即可</p>
<pre><code class="language-纯文本">int main(){
  SERVICE_TABLE_ENTRY Table[] = { {L&quot;servicename&quot;,ServiceMain},{NULL,NULL} };
  StartServiceCtrlDispatcher(Table);
}
</code></pre>
<p>在SERVICE_TABLE_ENTRY里我们定义好了一个服务的名字以及其入口函数，然后使用StartServiceCtrlDispatcher去调用这个结构。
第一步就是这么简单，接下来让我们去实现服务的入口函数</p>
<h3 id="_7">完成服务程序内容主函数</h3>
<p>这一步主要要干这几个事情:
1.创建服务内容主函数
2在服务内容主函数里实现 <code>SERVICE_STATUS</code> 结构的填充，用于与SCM交流
3.实现服务句柄，并根据有服务句柄改变状态信息，从而实现SCM发来的控制请求
4.逻辑</p>
<h4 id="_8">创建服务内容主函数</h4>
<p>根据我们在 SERVICE_TABLE_ENTRY 结构中定义的服务入口函数，创建对应函数</p>
<pre><code class="language-纯文本">void WINAPI Servicename(DWORD argc, LPTSTR* argv)
</code></pre>
<h4 id="service_status">实现 <code>SERVICE_STATUS</code> 结构</h4>
<p><code>SERVICE_STATUS</code> 结构定义如下</p>
<pre><code class="language-纯文本">typedef struct _SERVICE_STATUS {
  DWORD dwServiceType;
  DWORD dwCurrentState;
  DWORD dwControlsAccepted;
  DWORD dwWin32ExitCode;
  DWORD dwServiceSpecificExitCode;
  DWORD dwCheckPoint;
  DWORD dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;
</code></pre>
<p>每个项都对应了参数…太多了，建议去官方文档对照
<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/ns-winsvc-service_status" title="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/ns-winsvc-service_status">https://docs.microsoft.com/en-us/windows/win32/api/winsvc/ns-winsvc-service_status</a></p>
<p>dwservicetype 指定了服务的类型
dwCurrentState 指定服务当前的状态（挂起，暂停，启动，停止…)
dwControlsAccepted 指定了服务句柄可以接受的参数
dwWin32ExitCode 服务用于报告错误的错误代码
dwServiceSpecificExitCode 服务特定的错误代码
dwCheckPoint 不太懂
dwWaitHint 挂起的 启动，停止，暂停或继续操作所需的估计时间，以毫秒为单位 。若指定时间已过去而dwCheckPoint未增加或者dwCurrentState尚未更改，则中止服务。</p>
<p>总而言之，就是创建一个结构用于收集服务的各个信息</p>
<h4 id="_9">实现服务句柄&amp;改变状态信息</h4>
<p>实现服务句柄主要是依靠RegisterServiceCtrlHandlerA函数实现的。
这个函数的作用是注册一个函数来处理指定服务控制请求。</p>
<p>这个函数的结构是这样</p>
<pre><code class="language-纯文本">SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(
  LPCSTR             lpServiceName,
  LPHANDLER_FUNCTION lpHandlerProc
);
</code></pre>
<p>lpservicename是指定服务名,lphandlerproc是被注册的函数。所以我们要使用这个函数来注册另一个函数，首先要完成被注册函数的内部逻辑。这里做个范例</p>
<pre><code class="language-纯文本">void WINAPI ctrl(DWORD Opcode)  //定义式固定
{
  switch (Opcode)
  {
  case SERVICE_CONTROL_PAUSE:
    m_ServiceStatus.dwCurrentState = SERVICE_PAUSED;
    break;
  case SERVICE_CONTROL_CONTINUE:
    m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    break;
  case SERVICE_CONTROL_STOP:
    m_ServiceStatus.dwWin32ExitCode = 0;
    m_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    m_ServiceStatus.dwCheckPoint = 0;
    m_ServiceStatus.dwWaitHint = 0;

    SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);
    bRunning = false;
    break;
  case SERVICE_CONTROL_INTERROGATE:
    break;
  }
  return;
}
</code></pre>
<p>我们发现这个函数会根据传入的值改变 <code>SERVICE_STATUS</code> 结构。
若把他注册，那么从服务管理控制器发来的控制指令会被当作参数传入该函数，然后该函数会修改 <code>SERVICE_STATUS</code> 。</p>
<p>那么改变状态信息的函数主要就是SetServiceStatus 了</p>
<pre><code class="language-纯文本">BOOL SetServiceStatus(
  SERVICE_STATUS_HANDLE hServiceStatus,
  LPSERVICE_STATUS      lpServiceStatus
);
</code></pre>
<p>hservicestatus 指向服务句柄 lpservicestatus 指向 <code>SERVICE_STATUS</code> 结构。
完成这个函数后，服务就会向服务控制管理器发送自己最新的状态信息（即 <code>SERVICE_STATUS</code> 里定义的东西）。</p>
<h3 id="demo">DEMO</h3>
<pre><code class="language-纯文本">#include&lt;Windows.h&gt;

SERVICE_STATUS m_ServiceStatus;
SERVICE_STATUS_HANDLE m_ServiceStatusHandle;
BOOL bRunning;
int main() {
  WCHAR Servicename[] = L&quot;ServiceA&quot;;
  SERVICE_TABLE_ENTRY Table[] = { {Servicename,ServiceMain},{NULL,NULL} };
  StartServiceCtrlDispatcher(Table);
}

void WINAPI ServiceMain(DWORD argc, LPTSTR* argv) {


  m_ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
  m_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
  m_ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
  m_ServiceStatus.dwWin32ExitCode = 0;
  m_ServiceStatus.dwServiceSpecificExitCode = 0;
  m_ServiceStatus.dwCheckPoint = 0;
  m_ServiceStatus.dwWaitHint = 0;

  m_ServiceStatusHandle = RegisterServiceCtrlHandler(L&quot;ServiceA&quot;, HandlerFunc);
  m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
  m_ServiceStatus.dwCheckPoint = 0;
  m_ServiceStatus.dwWaitHint = 0;
  SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);
  bRunning = true;
  while (bRunning) {
    //your code
  }
  return 0;
}

void WINAPI HandlerFunc(DWORD code) {
  switch (code) {
  case SERVICE_CONTROL_PAUSE:
    m_ServiceStatus.dwCurrentState = SERVICE_PAUSED;
    break;
  case SERVICE_CONTROL_CONTINUE:
    m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    break;
  case SERVICE_CONTROL_STOP:
    m_ServiceStatus.dwWin32ExitCode = 0;
    m_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    m_ServiceStatus.dwCheckPoint = 0;
    m_ServiceStatus.dwWaitHint = 0;

    SetServiceStatus(m_ServiceStatusHandle, &amp;m_ServiceStatus);
    bRunning = false;
    break;
  case SERVICE_CONTROL_INTERROGATE:
    break;
  }
}
</code></pre>
<h1 id="sedebugprivilege">启用SeDebugPrivilege</h1>
<p>有很多工具需要启用SeDebugPrivilege才能正常使用，比如mimikatz就有个很经典的 privilege::debug.如果没有这个权限，administrator用openprocess可能都会报错，所以需要提升，管理员组拥有该权限但默认禁用，普通用户不拥有该权限，也就是说仅仅只有管理员账户能启用该权限。这个权限提供了强大的能力以至于可以忽视安全上下文行动。</p>
<p>我们会用到AdjustTokenPrivileges和LookupPrivilegeValueA，以及Token PRIVILEGES结构树</p>
<h4 id="token-privileges">Token PRIVILEGES结构树</h4>
<pre><code class="language-纯文本">typedef struct _TOKEN_PRIVILEGES {
  DWORD               PrivilegeCount;
  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;
</code></pre>
<p>PrirvilegeCount 表示Privileges数组中有多少个元素 Privileges 指向LUID_AND_ATTRIBUTES结构，该结构用于具体表示某个权限的开启或关闭</p>
<pre><code class="language-纯文本">typedef struct _LUID_AND_ATTRIBUTES {
  LUID  Luid;
  DWORD Attributes;
} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;`
</code></pre>
<p>Luid 选择一个LUID值，该值对应一个权限 Attributes 选择指定LUID的权限的开放或关闭，其详细参数如下</p>
<table>
<thead>
<tr>
<th>​<strong>SE_PRIVILEGE_ENABLED</strong></th>
<th>The privilege is enabled.</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>SE_PRIVILEGE_ENABLED_BY_DEFAULT</strong></td>
<td>The privilege is enabled by default.</td>
</tr>
<tr>
<td>​<strong>SE_PRIVILEGE_REMOVED</strong></td>
<td>Used to remove a privilege. For details, see <a href="https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges"></a><a href="https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges" title="AdjustTokenPrivileges">AdjustTokenPrivileges</a>.</td>
</tr>
<tr>
<td>​<strong>SE_PRIVILEGE_USED_FOR_ACCESS</strong></td>
<td>The privilege was used to gain access to an object or service. This flag is used to identify the relevant privileges in a set passed by a client application that may contain unnecessary privileges.</td>
</tr>
</tbody>
</table>
<p>下面我们来展示如何利用windows 编程获取该权限。</p>
<p>这只是一个函数demo，修改当前进程的权限。</p>
<pre><code class="language-纯文本">BOOL GetDebugPriv() {
  HANDLE Token;
  TOKEN_PRIVILEGES tp;
  LUID Luid;
  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;Token)) { //TOKEN_ADJUST_PRIVILEGES代表要修改令牌权限
    std::cout &lt;&lt; &quot;OpenProcessToken ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;
    return false;
  }

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
  if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;Luid)) {
    std::cout &lt;&lt; &quot;LookupPrivilegeValue ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;
    return false;
  }
  tp.Privileges[0].Luid = Luid;
  if (!AdjustTokenPrivileges(Token, FALSE, &amp;tp, sizeof(tp), NULL, NULL) ){
    std::cout &lt;&lt; &quot;AdjustTokenPrivileges ERROR&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;
    return false;
  }
  if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {  //ERROR_NOT_ALL_ASSIGNED的出现原因是，用户权限本身就没有sedebugprivilege
    return false;
  }
  else {
    return true;
  }
}
</code></pre>
<h1 id="dll">dll编写</h1>
<p>DLL文件，即动态链接库文件，在windows中许多pe文件运行时需要将一些dll文件加载进内存，从而调用dll文件里的内容。</p>
<h2 id="dllmain">DLLMAIN</h2>
<p>dllmain，是dll在被加载时执行的函数（dllmain在dll文件中不是必须的）</p>
<pre><code class="language-纯文本">BOOL WINAPI DLLMain(
//指向自身句柄
_In_HINSTANCE hinstDLL,
//载入状态
_In_DWORD fdwReason,
//加载方式（隐式、显式）
_In_LPVOID IpvReserved
);
</code></pre>
<p>其中，载入状态有四种，如下</p>
<p>DLL_PROCESS_ATTACH：进程进入时</p>
<p>DLL_PROCESS_DETACH：进程退出时</p>
<p>DLL_THREAD_ATTACH：线程进入时</p>
<p>DLL_THREAD_DETACH：线程退出时</p>
<p>dllmain根据载入状态的不同，可以做出不同的反应。就像这样</p>
<pre><code class="language-纯文本">#include &lt;iostream&gt;

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
  case DLL_PROCESS_ATTACH:
    std::cout &lt;&lt; &quot;Process attach. \n&quot;;
    break;
  case DLL_PROCESS_DETACH:
    std::cout &lt;&lt; &quot;Process exit. \n&quot;;
    break;
  case DLL_THREAD_ATTACH:
    std::cout &lt;&lt; &quot;Thread attach. \n&quot;;
    break;
  case DLL_THREAD_DETACH:
    std::cout &lt;&lt; &quot;Thread exit. \n&quot;;
    break;
  }
    return TRUE;
}

</code></pre>
<h2 id="dll_1">DLL 导出函数</h2>
<p>dll编写时，要用__declspec关键字标明哪些函数是要导出的,_</p>
<p>__declspec(dllexport) 用于Windows中的动态库中，声明导出函数、类、对象等供外面调用,像这样</p>
<pre><code class="language-纯文本">extern &quot;C&quot; int _declspec(dllexport) go() {
    std::cout&lt;&lt;&quot;gogo&quot;
}
</code></pre>
<p>这样就设置好一个用于导出的函数了。</p>
<h2 id="dlllib">题外话：怎么使用dll或lib中的导出函数</h2>
<p>对于lib（静态链接库）来说，使用静态链接  dll（动态链接库）来说使用动态链接</p>
<h3 id="_10">静态链接</h3>
<p>又叫隐式链接。链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件(.EXE文件)，所以组成的exe文件体积较大</p>
<pre><code class="language-纯文本">#pragma comment(lib,&quot;testDLL.lib&quot;)  //在此处通过静态链接，此之前把生成的lib文件放入loadDLL工程文件夹下面，并设置编译器的附加依赖项中增加此lib
extern &quot;C&quot;_declspec(dllimport) int go(); //声明函数

int main(){
go();
}
</code></pre>
<h3 id="_11">动态链接</h3>
<p>又叫显示链接，将一些api函数写入到一个dll文件中，在程序在程序运行时再加载到程序的进程空间中使用，这样可以让运行程序本身体积较小，方便模块化编程。</p>
<pre><code class="language-##">int TestDLL()

{

      HMODULE hModule = NULL;

      typedef int (*Func)(int a, int b);

      // 动态加载 DLL 文件
      hModule = LoadLibrary(_TEXT(&quot;..//Debug//FuncDll.dll&quot; ));

      // 获取 fun函数地址
      Func fAdd = (Func)GetProcAddress(hModule, &quot;fun&quot; );

      // 使用函数指针
      printf(&quot;%d/n&quot; , fAdd(3, 1));

      // 释放指针
      FreeLibrary(hModule);
      return 0;

}
</code></pre>
<h2 id="rundll32">rundll32</h2>
<p>用rundll32.exe 可以执行dll中的某一导出函数</p>
<p>但是不是所有函数都能通过rundll32调用，函数必须符合如下定义</p>
<pre><code class="language-纯文本">VOID CALLBACK FunctionName (HWND hwnd,HINSTANCE hinst,LPTSTR lpCmdLine,INT nCmdShow);
</code></pre>
<p>这里随便写了个</p>
<pre><code class="language-纯文本">extern &quot;C&quot; __declspec(dllexport) void rundll(HWND hwnd, HINSTANCE hinst, LPTSTR lpCmdLine, INT nCmdShow) {

    MessageBox(NULL, TEXT(&quot;-Test-&quot;), TEXT(&quot;Rundll32&quot;), MB_OK);

}
</code></pre>
<p><img alt="image-20210301194831320" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301194831320.png" title="image-20210301194831320" /></p>
<h1 id="_12">消息机制</h1>
<h2 id="_13">事件驱动</h2>
<p>Windows是基于事件驱动的.
一般来讲， 服务器处理模型有三种:
1每收到一个请求，创建一个新的进程，来处理该请求；
2每收到一个请求，创建一个新的线程，来处理该请求；
3每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求</p>
<p>1 开销较大:每处理一个事件就要新建一个进程，开销太大，但是实现起来很简单
2 死锁问题:多线程调节容易遇到死锁问题，程序直接卡死
3 逻辑复杂</p>
<p>那么事件驱动的优势在哪里呢。
打个比方，我们要获取一个鼠标点击的动作。
如果我们通过创建线程或者进程的方法，去循环扫描当前是否有鼠标点击事件那么可能会造成资源浪费（鼠标一直不点击，但仍在进行扫描），响应缓慢（扫描的设备有很多，会造成响应缓慢的问题）等问题。
但是事件驱动就不一样了，它的核心原理是以消息队列为核心，当捕获到一个事件（如鼠标点击）时把他放进消息队列，然后当该事件从队列中被取出时，根据事件类型调用不同的函数来进行处理,其中每个事件一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数 。</p>
<h2 id="_14">消息机制</h2>
<p>事件驱动在Windows下的具象化就是消息机制。
事件队列对应过来就是消息队列.</p>
<p>它会为每一个应用程序新开一个对应的消息队列，用于捕获其消息。</p>
<p>我们以一个简单的窗口实现来看看消息机制。 注意下方注释处即可。</p>
<pre><code class="language-纯文本">#include&lt;Windows.h&gt;


LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);


int WINAPI WinMain(HINSTANCE hinstance, HINSTANCE hPrevInStance, LPSTR lpCmdLine, int nShowCmd) {

  static TCHAR szAppName[] = TEXT(&quot;窗口类名称&quot;);
  HWND         hwnd;
  MSG          msg;
  WNDCLASSEX   wndclass = { 0 };

  //设计窗口类
  wndclass.cbSize = sizeof(WNDCLASSEX);
  wndclass.style = CS_HREDRAW | CS_VREDRAW;
  wndclass.lpfnWndProc = WndProc;
  wndclass.cbClsExtra = 0;
  wndclass.cbWndExtra = 0;
  wndclass.hInstance = hinstance;
  wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
  wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
  wndclass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
  wndclass.lpszMenuName = NULL;
  wndclass.lpszClassName = szAppName;


  if (!RegisterClassEx(&amp;wndclass))
  {
    MessageBox(NULL, TEXT(&quot;RegisterClassEx failed!&quot;),TEXT(&quot;title&quot;), MB_ICONERROR);
    return 0;
  }

  hwnd = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW,
    szAppName,
    TEXT(&quot;窗口名称&quot;),
    WS_OVERLAPPEDWINDOW,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    NULL,
    NULL,
    hinstance,
    NULL);

  ShowWindow(hwnd, nShowCmd);
  UpdateWindow(hwnd);

  while (GetMessage(&amp;msg, hwnd, 0, 0)) {  #从消息队列中获取消息，若存在消息待处理，则进行窗口过程。同时通过句柄得到需要捕捉消息的应用程序。
    TranslateMessage(&amp;msg);
    DispatchMessage(&amp;msg);
  }
  return msg.wParam;
}
LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
  HDC hdc;
  PAINTSTRUCT ps;
  RECT rect;

  switch (message)
  {
  case WM_PAINT:
    hdc = BeginPaint(hwnd, &amp;ps);
    GetClientRect(hwnd, &amp;rect);
    DrawText(hdc, TEXT(&quot;FUCK&quot;), -1, &amp;rect, DT_CENTER);
    EndPaint(hwnd, &amp;ps);
    return 0;

  case WM_LBUTTONUP:
    MessageBox(NULL, TEXT(&quot;老子被点了&quot;), TEXT(&quot;tick&quot;), 0);
    return 0;
  }

  return DefWindowProc(hwnd, message, wParam, lParam);
}
</code></pre>
<p>对于消息机制，有几个点需要特别关注。</p>
<p>1.WM_PAINT,WM_TIMER,WM_QUIT 这几个消息永远被放在消息队列最后。
究其原因很简单，就拿WM_QUIT举例，他是意思是退出，若不放在最后，WM_QUIT后面的消息也就无法处理了。
2.也有部分消息是非队列消息，可以无视队列顺序首先被处理。</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../%E7%94%A8%E8%BF%87%E7%9A%84WINDOWS_API%E8%AE%B0%E5%BD%95/%E7%94%A8%E8%BF%87%E7%9A%84WINDOWS_API%E8%AE%B0%E5%BD%95/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../%E7%94%A8%E8%BF%87%E7%9A%84WINDOWS_API%E8%AE%B0%E5%BD%95/%E7%94%A8%E8%BF%87%E7%9A%84WINDOWS_API%E8%AE%B0%E5%BD%95/" class="btn btn-xs btn-link">
        用过的WINDOWS_API记录
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84RPC%E5%85%A5%E9%97%A8/%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84RPC%E5%85%A5%E9%97%A8/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84RPC%E5%85%A5%E9%97%A8/%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84RPC%E5%85%A5%E9%97%A8/" class="btn btn-xs btn-link">
        安全视角下的RPC入门
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>