<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>用过的WINDOWS_API记录 - ConsT27's Blog</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u7528\u8fc7\u7684WINDOWS_API\u8bb0\u5f55", url: "#_top", children: [
              {title: "\u76ee\u5f55", url: "#_1" },
              {title: "API:\u6536\u5f55\u4e00\u4e0b\u8c03\u8fc7\u7684API", url: "#apiapi" },
              {title: "COM\u76f8\u5173", url: "#com" },
              {title: "\u4e00\u4e9b\u6570\u636e\u7c7b\u578b", url: "#_5" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../../%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../../%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="btn btn-xs btn-link">
        网络协议
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../%E6%9D%82%E8%AE%B0/%E6%9D%82%E8%AE%B0/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../%E6%9D%82%E8%AE%B0/%E6%9D%82%E8%AE%B0/" class="btn btn-xs btn-link">
        杂记
      </a>
    </div>
    
  </div>

    

    <h1 id="windows_api">用过的WINDOWS_API记录</h1>
<h2 id="_1">目录</h2>
<ul>
<li><a href="#API收录一下调过的API">API:收录一下调过的API</a><ul>
<li><a href="#进程与内存">进程与内存</a><ul>
<li><a href="#打开一个已存在的本地进程OpenProcess">打开一个已存在的本地进程:OpenProcess</a></li>
<li><a href="#在指定进程的虚拟地址空间中保留开辟禁用一段区域--VirtualAllocEx">在指定进程的虚拟地址空间中保留，开辟，禁用一段区域 : VirtualAllocEx</a></li>
<li><a href="#在指定进程的虚拟地址空间中释放或decommit一段区域--VirtualFreeEx">在指定进程的虚拟地址空间中释放或decommit一段区域 : VirtualFreeEx</a></li>
<li><a href="#向指定进程的内存区域写入-WriteProcessMemory">向指定进程的内存区域写入: WriteProcessMemory</a></li>
<li><a href="#在一个进程内存空间中创建一个线程CreateRemoteThread">在一个进程内存空间中创建一个线程：CreateRemoteThread</a></li>
<li><a href="#关闭一个句柄CloseHandle">关闭一个句柄:CloseHandle</a></li>
<li><a href="#RtlSecureZeroMemory-以安全方式用0填充内存">RtlSecureZeroMemory ：以安全方式用0填充内存</a></li>
</ul>
</li>
<li><a href="#令牌与命名管道">令牌与命名管道</a><ul>
<li><a href="#创建命名管道句柄CreateNamedPipeA">创建命名管道句柄:CreateNamedPipeA</a></li>
<li><a href="#开启一个命名管道等待链接-ConnectNamedPipe">开启一个命名管道等待链接: ConnectNamedPipe</a></li>
<li><a href="#模拟一个命名管道客户端ImpersonateNamedPipeClient">模拟一个命名管道客户端:ImpersonateNamedPipeClient</a></li>
<li><a href="#获取当前线程令牌句柄-GetCurrentThreadToken">获取当前线程令牌句柄: GetCurrentThreadToken</a></li>
<li><a href="#以令牌创建一个进程1-CreateProcessWithTokenW">以令牌创建一个进程（1）: CreateProcessWithTokenW</a></li>
<li><a href="#以令牌创建一个进程2-CreateProcessAsUserA">以令牌创建一个进程（2）: CreateProcessAsUserA</a></li>
<li><a href="#为已存在的Token创建副本-DuplicateTokenEx">为已存在的Token创建副本: DuplicateTokenEx</a></li>
</ul>
</li>
<li><a href="#文件IO">文件IO</a><ul>
<li><a href="#获得文件句柄GetMoudleHandleA">获得文件句柄：GetMoudleHandleA</a></li>
<li><a href="#从dll文件句柄中获得函数GetProcAddress">从dll文件句柄中获得函数：GetProcAddress</a></li>
<li><a href="#获得一个已存在文件句柄或者新建文件句柄CreateFile">获得一个已存在文件句柄或者新建文件句柄:CreateFile</a></li>
<li><a href="#写文件-ReadFile">写文件: ReadFile</a></li>
<li><a href="#读文件-ReadFile">读文件: ReadFile</a></li>
</ul>
</li>
<li><a href="#服务">服务</a><ul>
<li><a href="#建立与指定计算机服务控制管理器的联络并打开其数据库-OpenSCManagerA">建立与指定计算机服务控制管理器的联络并打开其数据库: OpenSCManagerA</a></li>
<li><a href="#创建一个服务并把它加入到服务管理器数据库-CreateServiceA">创建一个服务并把它加入到服务管理器数据库： CreateServiceA</a></li>
<li><a href="#打开一个服务并获得句柄-OpenServiceA">打开一个服务并获得句柄: OpenServiceA</a></li>
<li><a href="#向一个服务发送控制指令ControlService">向一个服务发送控制指令:ControlService</a></li>
<li><a href="#使服务与SCM链接-StartServiceCtrlDispatcherA">使服务与SCM链接： StartServiceCtrlDispatcherA</a></li>
<li><a href="#注册一个函数来处理服务控制请求-RegisterServiceCtrlHandlerA">注册一个函数来处理服务控制请求: RegisterServiceCtrlHandlerA</a></li>
<li><a href="#更新服务的状态信息-SetServiceStatus">更新服务的状态信息: SetServiceStatus</a></li>
</ul>
</li>
<li><a href="#快照-以下函数或结构基本上都用到了另一个头文件Tlhelp32h">快照 以下函数或结构基本上都用到了另一个头文件Tlhelp32.h</a><ul>
<li><a href="#为进程创建快照文件转储-CreateToolhelp32Snapshot">为进程创建快照文件(转储): CreateToolhelp32Snapshot</a></li>
<li><a href="#检索快照中遇到的第一个进程的信息-Process32First">检索快照中遇到的第一个进程的信息： Process32First</a></li>
<li><a href="#检索快照中下一个进程的信息-Process32Next">检索快照中下一个进程的信息: Process32Next</a></li>
<li><a href="#将某个进程转储为快照写入文件-MiniDumpWriteDump">将某个进程转储为快照写入文件: MiniDumpWriteDump</a></li>
</ul>
</li>
<li><a href="#HTTP请求多数函数包含在winhttph中">HTTP请求，多数函数包含在winhttp.h中</a><ul>
<li><a href="#winhttpopen返回-WinHTTP-session-句柄">winhttpopen:返回 WinHTTP-session 句柄</a></li>
<li><a href="#WinHttpConnect-返回-链接-句柄-handle-to-an-HTTP-session-for-that-initial-target-">WinHttpConnect ：返回 链接 句柄（ handle to an HTTP session for that initial target. ）</a></li>
<li><a href="#WinHttpOpenRequest-创建HTTP请求句柄">WinHttpOpenRequest ：创建HTTP请求句柄</a></li>
<li><a href="#WinHttpAddRequestHeaders-设置HTTP头">WinHttpAddRequestHeaders 设置HTTP头</a></li>
<li><a href="#WinHttpSendRequest-发送HTTP请求">WinHttpSendRequest 发送HTTP请求</a></li>
<li><a href="#WinHttpReceiveResponse-等待http回应">WinHttpReceiveResponse ：等待http回应</a></li>
<li><a href="#WinHttpQueryDataAvailable-返回HTTP回应内容的大致信息">WinHttpQueryDataAvailable ：返回HTTP回应内容的大致信息</a></li>
<li><a href="#WinHttpReadData-读取HTTP回应内容">WinHttpReadData 读取HTTP回应内容</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#COM相关">COM相关</a><ul>
<li><a href="#CoInitializeEx-创建COM环境">CoInitializeEx ：创建COM环境</a></li>
</ul>
</li>
<li><a href="#一些数据类型">一些数据类型</a><ul>
<li><a href="#NTSTATUS">NTSTATUS</a></li>
<li><a href="#HRESULT">HRESULT</a></li>
</ul>
</li>
</ul>
<hr />
<p>title: 记录一下用过的c++ windows api
date:
tags: windows相关</p>
<hr />
<h2 id="apiapi">API:收录一下调过的API</h2>
<h3 id="_2">进程与内存</h3>
<h4 id="openprocess">打开一个已存在的本地进程:OpenProcess</h4>
<pre><code class="language-纯文本">HANDLE OpenProcess(
  DWORD dwDesiredAccess,
  BOOL  bInheritHandle,
  DWORD dwProcessId
);
</code></pre>
<p>dwdesiredaccess 指定能获得指定进程哪些权限。可选值如下</p>
<pre><code class="language-纯文本">PROCESS_ALL_ACCESS  //所有能获得的权限
PROCESS_CREATE_PROCESS  //需要创建一个进程
PROCESS_CREATE_THREAD   //需要创建一个线程
PROCESS_DUP_HANDLE      //重复使用DuplicateHandle句柄
PROCESS_QUERY_INFORMATION   //获得进程信息的权限，如它的退出代码、优先级
PROCESS_QUERY_LIMITED_INFORMATION  /*获得某些信息的权限，如果获得了PROCESS_QUERY_INFORMATION，也拥有PROCESS_QUERY_LIMITED_INFORMATION权限*/
PROCESS_SET_INFORMATION    //设置某些信息的权限，如进程优先级
PROCESS_SET_QUOTA          //设置内存限制的权限，使用SetProcessWorkingSetSize
PROCESS_SUSPEND_RESUME     //暂停或恢复进程的权限
PROCESS_TERMINATE          //终止一个进程的权限，使用TerminateProcess
PROCESS_VM_OPERATION       //操作进程内存空间的权限(可用VirtualProtectEx和WriteProcessMemory) 
PROCESS_VM_READ            //读取进程内存空间的权限，可使用ReadProcessMemory
PROCESS_VM_WRITE           //读取进程内存空间的权限，可使用WriteProcessMemory
SYNCHRONIZE                //等待进程终止
</code></pre>
<p>bInheritHandle 若为TRUE，则表示所得到的进程句柄可被继承
dwProcessId 表示要获取的进程的PID</p>
<p>函数成功执行，则返回指定进程的句柄。反之则NULL。</p>
<h4 id="virtualallocex">在指定进程的虚拟地址空间中保留，开辟，禁用一段区域 : VirtualAllocEx</h4>
<pre><code class="language-纯文本">LPVOID VirtualAllocEx(
  HANDLE hProcess,
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flAllocationType,
  DWORD  flProtect
);
</code></pre>
<p>hProcess 指定的进程的句柄。该句柄需有<strong>PROCESS_VM_OPERATION</strong>权限（操作进程内存空间的权限）</p>
<p>lpAddress 一个指针，用于选择你想分配的内存的开始地址。如果填NULL，则由dwsize的设置来自动分配。</p>
<p>dwSize 欲分配的内存大小（字节单位）。实际分配的大小是该值与页内存对齐后的结果。如果lpAddress为NULL，则会选中从进程首地址到dwSize的页对齐后的内存区域
如果lpAddress不为NULL，则选定lpaddress到lpaddress+dwsize的按照页对齐后的内存区域。</p>
<p>flAllocationType 内存分配的类型。有很多值，MSDN上有记录。
<a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex" title="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex</a>
这个值用来确定一段内存区域用于被置0(commit)还是保留(reserve)还是禁用(reset)</p>
<p>flProtect 内存保护常数</p>
<pre><code class="language-纯文本">PAGE_NOACCESS
PAGE_GUARD
PAGE_NOCACHE
PAGE_WRITECOMBINE
</code></pre>
<p>若函数执行成功，则返回分配的内存地址的基地址。</p>
<h4 id="decommit-virtualfreeex">在指定进程的虚拟地址空间中释放或decommit一段区域 : VirtualFreeEx</h4>
<pre><code class="language-纯文本">BOOL VirtualFreeEx(
  HANDLE hProcess,
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  dwFreeType
);
</code></pre>
<p>hprocess 进程句柄，需有<strong>PROCESS_VM_OPERATION</strong>权限</p>
<p>lpaddress 一个指向需要被释放或decommit内存区域首地址的指针。若dwfreetype为mem_release(释放),则这里应该填入VirtualAllocEx方法返回的保留的内存区域的基地址。</p>
<p>dwsize 需要被decommit的内存大小。
若dwfreetype为MEM_RELEASE 则此处填0
若为MEM_DECOMMIT，则此处填内存大小。 选定lpaddress到lpaddress+dwsize的按照页对齐后的内存区域。</p>
<p>dwfreetype 需要对内存区域进行的操作。有MEM_DECOMMIT和MEM_RELEASE，更多参数参考MSDNhttps\://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfreeex</p>
<p>若函数执行成功则返回一个非零值，不成功则返回0</p>
<h4 id="writeprocessmemory">向指定进程的内存区域写入: WriteProcessMemory</h4>
<pre><code class="language-纯文本">BOOL WriteProcessMemory(
  HANDLE  hProcess,
  LPVOID  lpBaseAddress,
  LPCVOID lpBuffer,
  SIZE_T  nSize,
  SIZE_T  *lpNumberOfBytesWritten
);
</code></pre>
<p>hprocess 进程句柄</p>
<p>lpbaseaddress 需要写入的内存区域的起始地址指针</p>
<p>lpbuffer 指向缓冲区的指针，该缓冲区包含要在指定进程的地址空间中写入的数据。</p>
<p>nsize 需要写入的数据大小（字节单位）</p>
<p>lpNumberOfBytesWritten 可选，用来存放”要被写入的数据“的变量</p>
<p>若成功则返回非0值，反之则0</p>
<h4 id="createremotethread">在一个进程内存空间中创建一个线程：CreateRemoteThread</h4>
<pre><code class="language-纯文本">HANDLE CreateRemoteThread(
  HANDLE                 hProcess,
  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  SIZE_T                 dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID                 lpParameter,
  DWORD                  dwCreationFlags,
  LPDWORD                lpThreadId
);
</code></pre>
<p>hprocess 进程句柄</p>
<p>lpThreadAttributes 安全描述符</p>
<p>dwStackSize 栈大小，若为0则为默认值</p>
<p>lpStartAddress 要创建的线程的实现函数的首地址</p>
<p>lpParameter 传递给线程函数的参数</p>
<p>dwCreationFlags 线程控制参数</p>
<table>
<thead>
<tr>
<th>0</th>
<th>The thread runs immediately after creation.</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>CREATE_SUSPENDED</strong>0x00000004</td>
<td>The thread is created in a suspended state, and does not run until the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-resumethread"></a><a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-resumethread" title="ResumeThread">ResumeThread</a> function is called.</td>
</tr>
<tr>
<td>​<strong>STACK_SIZE_PARAM_IS_A_RESERVATION</strong>0x00010000</td>
<td>The **<em>dwStackSize</em> parameter specifies the initial reserve size of the stack. If this flag is not specified, **<em>dwStackSize</em> specifies the commit size.</td>
</tr>
</tbody>
</table>
<p>lpThreadId 线程标识符，如果线程不返回标识符则此项填NULL</p>
<h4 id="closehandle">关闭一个句柄:CloseHandle</h4>
<pre><code class="language-纯文本">BOOL CloseHandle(
  HANDLE hObject
);
</code></pre>
<p>hobject 要被关闭的句柄</p>
<p>成功则返回非0值，反之则0</p>
<h4 id="rtlsecurezeromemory-0">RtlSecureZeroMemory ：以安全方式用0填充内存</h4>
<pre><code class="language-纯文本">PVOID RtlSecureZeroMemory(
  PVOID  ptr,
  SIZE_T cnt
);
</code></pre>
<p>ptr 指向内存的指针</p>
<p>cnt 填充的字节数</p>
<h3 id="_3">令牌与命名管道</h3>
<h4 id="createnamedpipea">创建命名管道句柄:CreateNamedPipeA</h4>
<pre><code class="language-纯文本">HANDLE CreateNamedPipeA(
  LPCSTR                lpName,
  DWORD                 dwOpenMode,
  DWORD                 dwPipeMode,
  DWORD                 nMaxInstances,
  DWORD                 nOutBufferSize,
  DWORD                 nInBufferSize,
  DWORD                 nDefaultTimeOut,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
);
</code></pre>
<p>lpName 唯一的管道名。格式是固定的: \.\pipe*pipename*</p>
<p>dwOpenMode 管道的开启方式。有三种：1.数据在服务器和客户机双向流通 <strong>PIPE_ACCESS_DUPLEX</strong>。2.数据只能从服务器流向客户机 <strong>PIPE_ACCESS_OUTBOUND</strong>。3.数据只能从客户机流向服务器 <strong>PIPE_ACCESS_INBOUND</strong>。具体请参考官方文档。以及一些附加参数，详情参考官方文档 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea" title="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea">https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea</a></p>
<p>dwPipeMode 管道通信方式。指定字节流或者消息流通信，指定远程链接的访问方式，指定等待方式，详情参考官方文档</p>
<p>nMaxInstancees 管道的最大实例数</p>
<p>nOutBufferSize\&amp;nInBufferSize 为输出&amp;输入缓存区保留的内存字节大小</p>
<p>nDefaultTimeOut 设定超时值。置0则为50ms</p>
<p>lpSecurityAttributes 设置安全描述符</p>
<p>若函数执行成功则返回管道服务器句柄。反之则返回<strong>INVALID_HANDLE_VALUE</strong></p>
<h4 id="connectnamedpipe">开启一个命名管道等待链接: ConnectNamedPipe</h4>
<pre><code class="language-纯文本">BOOL ConnectNamedPipe(
  HANDLE       hNamedPipe,
  LPOVERLAPPED lpOverlapped
);
</code></pre>
<p>hNamedPipe 指定一个命名管道句柄，该句柄由CreateNamedPipe函数返回</p>
<p>lpOverlapped 一个指向重叠结构的指针，一般为NULL。详情参考官方文档
<a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe" title="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe">https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe</a></p>
<p>一般来说，当由客户机连上时返回true，没有客户机链接或链接丢失返回false</p>
<h4 id="impersonatenamedpipeclient">模拟一个命名管道客户端:ImpersonateNamedPipeClient</h4>
<pre><code class="language-纯文本">BOOL ImpersonateNamedPipeClient(
  HANDLE hNamedPipe
);
</code></pre>
<p>hNamedPipe 即指定的命名管道服务端。</p>
<p>这个函数有个坑点是，服务端才能用这个函数，且必须在服务端读取客户端传来的数据后才能成功，否则就会返回1368错误。</p>
<h4 id="getcurrentthreadtoken">获取当前线程令牌句柄: GetCurrentThreadToken</h4>
<pre><code class="language-纯文本">HANDLE GetCurrentThreadToken();
</code></pre>
<p>无参数，直接返回当前线程虚拟句柄</p>
<h4 id="1-createprocesswithtokenw">以令牌创建一个进程（1）: CreateProcessWithTokenW</h4>
<pre><code class="language-纯文本">BOOL CreateProcessWithTokenW(
  HANDLE                hToken,
  DWORD                 dwLogonFlags,
  LPCWSTR               lpApplicationName,
  LPWSTR                lpCommandLine,
  DWORD                 dwCreationFlags,
  LPVOID                lpEnvironment,
  LPCWSTR               lpCurrentDirectory,
  LPSTARTUPINFOW        lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre>
<p>有点不懂，链接在这里<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw" title="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw">https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw</a></p>
<p>hToken 表示用户的令牌 必须有 TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY 权限</p>
<p>dwLogonFlags 登陆选项。<strong>LOGON_WITH_PROFILE</strong>或<strong>LOGON_NETCREDENTIALS_ONLY</strong></p>
<p>lpApplicationName 要被执行的模块。（比如 C:\Windows\system32\notepad.exe )</p>
<p>lpCommandLine 要被执行的命令。如果为NULL则把 lpApplicationName 当作要执行的命令</p>
<p>dwCreationFlags 控制进程的创建方式。参考MSDN</p>
<p>lpEnvironment 指向新进程环境块的指针。</p>
<p>lpCurrentDirectory 指向进程的“当前目录”路径。若NULL则“当前目录”为调用程序的“当前目录”</p>
<p>lpStartUpInfo 指向  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa" title="STARTUPINFO">STARTUPINFO</a>或<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/ns-winbase-startupinfoexa" title="STARTUPINFOEX">STARTUPINFOEX</a> 结构体</p>
<p>lpProcessInformation 指向  <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information" title="PROCESS_INFORMATION">PROCESS_INFORMATION</a> 结果的指针</p>
<p>坑点：调用该函数的进程必须有 SE_IMPERSONATE_NAME 权限，不然会返回ERROR:1314</p>
<h4 id="2-createprocessasusera">以令牌创建一个进程（2）: CreateProcessAsUserA</h4>
<pre><code class="language-纯文本">BOOL CreateProcessAsUserA(
  HANDLE                hToken,
  LPCSTR                lpApplicationName,
  LPSTR                 lpCommandLine,
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL                  bInheritHandles,
  DWORD                 dwCreationFlags,
  LPVOID                lpEnvironment,
  LPCSTR                lpCurrentDirectory,
  LPSTARTUPINFOA        lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre>
<p>大致上与CreateProcessWithTokenW一样。
但是调用这个函数的进程必须有<strong>SE_INCREASE_QUOTA_NAME</strong>，或者<strong>SE_ASSIGNPRIMARYTOKEN_NAME</strong>权限，不然会返回ERROR:1314</p>
<h4 id="token-duplicatetokenex">为已存在的Token创建副本: DuplicateTokenEx</h4>
<pre><code class="language-纯文本">BOOL DuplicateTokenEx(
  HANDLE                       hExistingToken,
  DWORD                        dwDesiredAccess,
  LPSECURITY_ATTRIBUTES        lpTokenAttributes,
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
  TOKEN_TYPE                   TokenType,
  PHANDLE                      phNewToken
);
</code></pre>
<p>hExistingToken 一个指针，指向一个有 TOKEN_DUPLICATE 权的Token</p>
<p>dwDesiredAccess 为新Token设置权限。若置0则表示权限与原Token相同。
下面是权限列表 <a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects" title="https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects">https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects</a></p>
<p>lpTokenAttributes 指向安全描述符的指针。若为NULL，则为默认安全描述符且句柄不能被继承</p>
<p>ImpersonationLevel 从 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ne-winnt-security_impersonation_level" title="SECURITY_IMPERSONATION_LEVEL">SECURITY_IMPERSONATION_LEVEL</a> 中选择一个值填入。决定模仿的程度。</p>
<p>TokenType 选择<strong>TokenPrimary</strong> or <strong>TokenImpersonation</strong>填入。决定Token是primary token（能被用来执行CreateProcessAsUser）还是impersonation token</p>
<p>phNewToken 指针，指向承载新Token的Handle变量。</p>
<h3 id="io">文件IO</h3>
<h4 id="getmoudlehandlea">获得文件句柄：GetMoudleHandleA</h4>
<pre><code class="language-纯文本">HMODULE GetModuleHandleA(
  LPCSTR lpModuleName
);
</code></pre>
<p>lpModuleName即要获取的文件句柄的文件名，可为exe或dll。
若文件名没有后缀名则默认视为dll文件。
若该项为NULL，则返回当前进程的文件句柄。
存在于Kerner32.dll中
这里介绍一些HMOUDLE是个什么玩意
一般就是一个线性地址，用于记录一个文件句柄的地址。</p>
<p><img alt="QQ截图20210217151436" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217151436.png" title="QQ截图20210217151436" /></p>
<h4 id="dllgetprocaddress">从dll文件句柄中获得函数：GetProcAddress</h4>
<pre><code class="language-纯文本">FARPROC GetProcAddress(
  HMODULE hModule,
  LPCSTR  lpProcName
);
</code></pre>
<p>hmodule 表示要传入的dll文件句柄。这个句柄可以由  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya" title="LoadLibrary">LoadLibrary</a>, <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa" title="LoadLibraryEx">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-loadpackagedlibrary" title="LoadPackagedLibrary">LoadPackagedLibrary</a>, or <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea" title="GetModuleHandle">GetModuleHandle</a> 等方法得到。</p>
<p>lpProcName表示要从dll文件中获得的函数没或者变量名。
若函数执行不成功，则返回NULL，否则返回函数或者变量的地址</p>
<p><img alt="QQ截图20210217151441" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217151441.png" title="QQ截图20210217151441" /></p>
<h4 id="createfile">获得一个已存在文件句柄或者新建文件句柄:CreateFile</h4>
<pre><code class="language-纯文本">HANDLE CreateFileW(
  LPCWSTR               lpFileName,
  DWORD                 dwDesiredAccess,
  DWORD                 dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD                 dwCreationDisposition,
  DWORD                 dwFlagsAndAttributes,
  HANDLE                hTemplateFile
);
</code></pre>
<p>lpFileName 文件路径</p>
<p>dwDesiredAccess 对文件的访问控制：读，写。<strong>GENERIC_READ</strong>, <strong>GENERIC_WRITE</strong>, or both (<code>GENERIC_READ | GENERIC_WRITE</code>)</p>
<p>dwShareMode 零表示不共享； FILE_SHARE_READ 和 / 或 FILE_SHARE_WRITE 表示允许对文件进行共享访问</p>
<p>lpSecurityAttributes 安全描述符</p>
<p>dwCreationDisposition 在文件不存在或存在时采取的操作</p>
<p>dwFlagsAndAttributes 设置文件标志位</p>
<p>hTemplateFile 多数情况下为NULL</p>
<h4 id="readfile">写文件: ReadFile</h4>
<pre><code class="language-纯文本">BOOL WriteFile(
  HANDLE       hFile,
  LPCVOID      lpBuffer,
  DWORD        nNumberOfBytesToWrite,
  LPDWORD      lpNumberOfBytesWritten,
  LPOVERLAPPED lpOverlapped
);
</code></pre>
<p>hFile 文件句柄</p>
<p>lpBuffer 要写入的数据缓存区</p>
<p>nNumberOfBytesToWrite 要写入的字节数</p>
<p>lpNumberOfBytesWritten 设置一个变量，用来接收写入的内容</p>
<p>lpOverlapped 通常为NULL</p>
<h4 id="readfile_1">读文件: ReadFile</h4>
<pre><code class="language-纯文本">BOOL ReadFile(
  HANDLE       hFile,
  LPVOID       lpBuffer,
  DWORD        nNumberOfBytesToRead,
  LPDWORD      lpNumberOfBytesRead,
  LPOVERLAPPED lpOverlapped
);
</code></pre>
<p>和WriteFile差不多，8说了</p>
<h3 id="_4">服务</h3>
<h4 id="openscmanagera">建立与指定计算机服务控制管理器的联络并打开其数据库: OpenSCManagerA</h4>
<pre><code class="language-纯文本">SC_HANDLE OpenSCManagerA(
  LPCSTR lpMachineName,
  LPCSTR lpDatabaseName,
  DWORD  dwDesiredAccess
);
</code></pre>
<p>lpMachineName 指定计算机的名字。若为NULL则指向本地服务控制管理器</p>
<p>lpDatabaseName 服务控制管理器的数据库名。一般设为 SERVICES_ACTIVE_DATABASE 。若为NULL则默认打开 SERVICES_ACTIVE_DATABASE</p>
<p>dwDesiredAccess 对服务控制管理器的权限设置。参数清单:<a href="https://docs.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights" title="https://docs.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights</a></p>
<p>若执行成功则返回服务管理器数据库的句柄。反之则NULL。</p>
<h4 id="createservicea">创建一个服务并把它加入到服务管理器数据库： CreateServiceA</h4>
<pre><code class="language-纯文本">SC_HANDLE CreateServiceA(
  SC_HANDLE hSCManager,
  LPCSTR    lpServiceName,
  LPCSTR    lpDisplayName,
  DWORD     dwDesiredAccess,
  DWORD     dwServiceType,
  DWORD     dwStartType,
  DWORD     dwErrorControl,
  LPCSTR    lpBinaryPathName,
  LPCSTR    lpLoadOrderGroup,
  LPDWORD   lpdwTagId,
  LPCSTR    lpDependencies,
  LPCSTR    lpServiceStartName,
  LPCSTR    lpPassword
);
</code></pre>
<p>hSCManager 服务管理器数据库句柄。可由OpenSCManagerA获得。句柄权限必须有<strong>SC_MANAGER_CREATE_SERVICE</strong></p>
<p>lpServiceName 要创建的服务名。</p>
<p>lpDisplayName 用户界面程序 用来标识服务的 显示名称 ，可与lpServiceName一致</p>
<p>dwDesiredAccess 对服务管理器的权限。参数清单在上面</p>
<p>dwServiceType 创建的服务的类型。（直接复制粘贴参数吧</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>SERVICE_ADAPTER</strong>0x00000004</td>
<td>Reserved.</td>
</tr>
<tr>
<td>​<strong>SERVICE_FILE_SYSTEM_DRIVER</strong>0x00000002</td>
<td>File system driver service.</td>
</tr>
<tr>
<td>​<strong>SERVICE_KERNEL_DRIVER</strong>0x00000001</td>
<td>Driver service.</td>
</tr>
<tr>
<td>​<strong>SERVICE_RECOGNIZER_DRIVER</strong>0x00000008</td>
<td>Reserved.</td>
</tr>
<tr>
<td>​<strong>SERVICE_WIN32_OWN_PROCESS</strong>0x00000010</td>
<td>Service that runs in its own process.</td>
</tr>
<tr>
<td>​<strong>SERVICE_WIN32_SHARE_PROCESS</strong>0x00000020</td>
<td>Service that shares a process with one or more other services. For more information, see <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/service-programs"></a><a href="https://docs.microsoft.com/en-us/windows/desktop/Services/service-programs" title="Service Programs">Service Programs</a>.</td>
</tr>
<tr>
<td>​<strong>SERVICE_USER_OWN_PROCESS</strong>0x00000050</td>
<td>The service runs in its own process under the logged-on user account.</td>
</tr>
<tr>
<td>​<strong>SERVICE_USER_SHARE_PROCESS</strong>0x00000060</td>
<td>The service shares a process with one or more other services that run under the logged-on user account.</td>
</tr>
</tbody>
</table>
<p>If you specify either <strong>SERVICE_WIN32_OWN_PROCESS</strong> or <strong>SERVICE_WIN32_SHARE_PROCESS</strong>, and the service is running in the context of the <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/localsystem-account" title="LocalSystem account">LocalSystem account</a>, you can also specify the following value.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>SERVICE_INTERACTIVE_PROCESS</strong>0x00000100</td>
<td>The service can interact with the desktop.For more information, see <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/interactive-services"></a><a href="https://docs.microsoft.com/en-us/windows/desktop/Services/interactive-services" title="Interactive Services">Interactive Services</a>.</td>
</tr>
</tbody>
</table>
<p>dwStartType 服务的开始选项，参数如下</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>SERVICE_AUTO_START</strong>0x00000002</td>
<td>A service started automatically by the service control manager during system startup. For more information, see <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/automatically-starting-services"></a><a href="https://docs.microsoft.com/en-us/windows/desktop/Services/automatically-starting-services" title="Automatically Starting Services">Automatically Starting Services</a>.</td>
</tr>
<tr>
<td>​<strong>SERVICE_BOOT_START</strong>0x00000000</td>
<td>A device driver started by the system loader. This value is valid only for driver services.</td>
</tr>
<tr>
<td>​<strong>SERVICE_DEMAND_START</strong>0x00000003</td>
<td>A service started by the service control manager when a process calls the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-startservicea"></a><a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-startservicea" title="StartService">StartService</a> function. For more information, see <a href="https://docs.microsoft.com/en-us/windows/desktop/Services/starting-services-on-demand"></a><a href="https://docs.microsoft.com/en-us/windows/desktop/Services/starting-services-on-demand" title="Starting Services on Demand">Starting Services on Demand</a>.</td>
</tr>
<tr>
<td>​<strong>SERVICE_DISABLED</strong>0x00000004</td>
<td>A service that cannot be started. Attempts to start the service result in the error code<strong>ERROR_SERVICE_DISABLED</strong>.</td>
</tr>
<tr>
<td>​<strong>SERVICE_SYSTEM_START</strong>0x00000001</td>
<td>A device driver started by the<strong>IoInitSystem</strong> function. This value is valid only for driver services.</td>
</tr>
</tbody>
</table>
<p>dwErrorContriol 服务对于错误的容忍程度。</p>
<p><img alt="img" src="http://www.const27.com/wp-content/uploads/2020/11/image-43.png" title="img" /></p>
<p>lpBinaryPathName 服务的绝对路径。</p>
<p>lpLoadOrderGroup 服务所属的加载排序组名称。如果服务不属于任何一个组则填NULL或空字符</p>
<p>lpdwTagId 一个指向变量的指针，该变量接收在lpLoadOrderGroup参数中指定的组中唯一的标记值。 一般置NULL</p>
<p>lpDependencies 一个以null结尾的指向服务或者加载顺序组的指针，在当前服务启动前必须先启动该项指向的服务或加载顺序组，即启动当前服务的依赖项。若服务不需要依赖项则置NULL</p>
<p>lpServiceStartName 服务运行的账户。若为NULL则用LocalSystem Account账户（即SYSTEM)</p>
<p>lpPassword 账户的密码。若为LocalSystemAccount则填NULL（SYSTEM账户没有密码）</p>
<p>成功则返回服务句柄，反之则NULL</p>
<h4 id="openservicea">打开一个服务并获得句柄: OpenServiceA</h4>
<pre><code class="language-纯文本">SC_HANDLE OpenServiceA(
  SC_HANDLE hSCManager,
  LPCSTR    lpServiceName,
  DWORD     dwDesiredAccess
);
</code></pre>
<p>hSCManager 指向服务控制管理器数据库的句柄。</p>
<p>lpServiceName 服务名，注意不是lpDisplayName</p>
<p>dwDesiredAccess 对服务控制管理器的权限</p>
<p>成功则返回服务句柄，反之则NULL</p>
<h4 id="controlservice">向一个服务发送控制指令:ControlService</h4>
<pre><code class="language-纯文本">BOOL ControlService(
  SC_HANDLE        hService,
  DWORD            dwControl,
  LPSERVICE_STATUS lpServiceStatus
);
</code></pre>
<p>hService 指向服务的句柄</p>
<p>dwControl 控制指令。详情参考 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-controlservice?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINSVC%2FControlService);k(ControlService);k(DevLang-C%2B%2B);k(TargetOS-Windows)%26rd%3Dtrue" title="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-controlservice?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINSVC%252FControlService);k(ControlService);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue">https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-controlservice?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINSVC%252FControlService);k(ControlService);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p>
<p>lpServiceStatus 指向  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_status" title="SERVICE_STATUS">SERVICE_STATUS</a> 结构的指针，该结构用于接收服务报告给服务管理器的最新状态。</p>
<h4 id="scm-startservicectrldispatchera">使服务与SCM链接： StartServiceCtrlDispatcherA</h4>
<pre><code class="language-纯文本">BOOL StartServiceCtrlDispatcherA(
  const SERVICE_TABLE_ENTRYA *lpServiceStartTable
);
</code></pre>
<p>lpServiceStartTable 指向一个  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_table_entrya" title="SERVICE_TABLE_ENTRY">SERVICE_TABLE_ENTRY</a> 结构，其包含了每个服务的入口点。该结构最后一个入口点必须是NULL来表示该结构已结束。
这个结构的定义如下</p>
<pre><code class="language-纯文本">typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;
</code></pre>
<p>当SCM开始一个服务进程时，便在等待服务调用StartServiceCtrlDispatcherA 函数，若该函数长时间没有调用（一般为30s)，则服务会被强行关闭。直到所有该函数指定的服务进入SERVICE_STOPPED阶段，这个函数才会返回值。</p>
<h4 id="registerservicectrlhandlera">注册一个函数来处理服务控制请求: RegisterServiceCtrlHandlerA</h4>
<pre><code class="language-纯文本">SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(
  LPCSTR             lpServiceName,
  LPHANDLER_FUNCTION lpHandlerProc
);
</code></pre>
<p>lpServiceName 服务的名字。</p>
<p>lpHandlerProc 一个指针，指向要被注册的handler函数</p>
<p>若成功，则返回服务状态句柄，若失败则返回0</p>
<p>这个函数的主要目的是 可以让一个服务在运行过程中被来自其他地方的控制指令所控制，并根据自己定义的函数做出对应的行为</p>
<h4 id="setservicestatus">更新服务的状态信息: SetServiceStatus</h4>
<pre><code class="language-纯文本">BOOL SetServiceStatus(
  SERVICE_STATUS_HANDLE hServiceStatus,
  LPSERVICE_STATUS      lpServiceStatus
);
</code></pre>
<p>hServiceStatus 指向服务状态句柄，这个句柄由RegisterServiceCtrlHandlerA 等函数返回</p>
<p>lpServiceStatus 一个指针，指向  <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_status" title="SERVICE_STATUS">SERVICE_STATUS</a> 结构，这个结构记录了服务的状态</p>
<h3 id="tlhelp32h">快照 以下函数或结构基本上都用到了另一个头文件Tlhelp32.h</h3>
<h4 id="createtoolhelp32snapshot">为进程创建快照文件(转储): CreateToolhelp32Snapshot</h4>
<pre><code class="language-纯文本">HANDLE CreateToolhelp32Snapshot(
  DWORD dwFlags,
  DWORD th32ProcessID
);
</code></pre>
<p>dwFlags 转储参数，用于指定转储哪些信息以及指定返回的句柄的一些信息
详细参数
<a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot" title="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot</a></p>
<p>th32ProcessID 要被转储的进程的PID。置0则指定当前进程，当dwFlags为<strong>TH32CS_SNAPHEAPLIST</strong>, <strong>TH32CS_SNAPMODULE</strong>, <strong>TH32CS_SNAPMODULE32</strong>, or <strong>TH32CS_SNAPALL</strong>时，该值才表示要被转储的进程PID，否则该值会被忽略并转储所有进程</p>
<p>函数成功返回快照的句柄，否则返回<strong>INVALID_HANDLE_VALUE</strong></p>
<h4 id="process32first">检索快照中遇到的第一个进程的信息： Process32First</h4>
<pre><code class="language-纯文本">BOOL Process32First(
  HANDLE           hSnapshot,
  LPPROCESSENTRY32 lppe
);
</code></pre>
<p>hSnapshot 快照句柄，由CreateToolhelp32napshot返回</p>
<p>lppe 指向PROCESSENTRY32结构。该结构用于保存进程信息，在进行该函数前，PROCESSENTRY32的dwSize属性必须定义好。</p>
<h4 id="process32next">检索快照中下一个进程的信息: Process32Next</h4>
<pre><code class="language-纯文本">BOOL Process32Next(
  HANDLE           hSnapshot,
  LPPROCESSENTRY32 lppe
);
</code></pre>
<p>hSnapshot 快照句柄，由CreateToolhelp32napshot返回</p>
<p>lppe 指向PROCESSENTRY32结构。该结构用于保存进程信息，在进行该函数前，PROCESSENTRY32的dwSize属性必须定义好。</p>
<h4 id="minidumpwritedump">将某个进程转储为快照写入文件: MiniDumpWriteDump</h4>
<p>头文件 DbgHelp.h</p>
<pre><code class="language-纯文本">BOOL MiniDumpWriteDump(
  HANDLE                            hProcess,
  DWORD                             ProcessId,
  HANDLE                            hFile,
  MINIDUMP_TYPE                     DumpType,
  PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam,
  PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
  PMINIDUMP_CALLBACK_INFORMATION    CallbackParam
);
</code></pre>
<p>hProcess 进程句柄</p>
<p>processid 进程的PID</p>
<p>hFile 文件句柄，指定写入那个文件</p>
<p>DumpType 指定以何种形式写入文件，参数参考:<a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type" title="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type">https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type</a></p>
<p>ExceptionParam 指针，指向  <a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_exception_information" title="MINIDUMP_EXCEPTION_INFORMATION">MINIDUMP_EXCEPTION_INFORMATION</a> 结构用于描述发生的异常。如果为NULL，则表示转储文件中不包含异常信息</p>
<p>UserStreamParam 指针，指向  <a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_user_stream_information" title="MINIDUMP_USER_STREAM_INFORMATION">MINIDUMP_USER_STREAM_INFORMATION</a> 结构，这个结构保存用户数据流信息。一般置NULL</p>
<p>CallbackParam 指针，指向 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_callback_information" title="MINIDUMP_CALLBACK_INFORMATION">MINIDUMP_CALLBACK_INFORMATION</a> 结构，该结构保存回调函数的信息，一般置NULL</p>
<h3 id="httpwinhttph">HTTP请求，多数函数包含在winhttp.h中</h3>
<p>大流程</p>
<p><img alt="functions that create handles" src="https://docs.microsoft.com/en-us/windows/win32/winhttp/images/art-winhttp3.png" title="functions that create handles" /></p>
<h4 id="winhttpopen-winhttp-session">winhttpopen:返回 WinHTTP-session 句柄</h4>
<pre><code class="language-纯文本">WINHTTPAPI HINTERNET WinHttpOpen(
  LPCWSTR pszAgentW,
  DWORD   dwAccessType,
  LPCWSTR pszProxyW,
  LPCWSTR pszProxyBypassW,
  DWORD   dwFlags
);
</code></pre>
<p>pszAgentW 指针，指向一个字符串.该字符串在http通信中被用作user agent</p>
<p>dwAccessType http请求方式，其值有如下，主要是代理相关</p>
<blockquote>
<p><strong>WINHTTP_ACCESS_TYPE_DEFAULT_PROXY</strong>
<strong>WINHTTP_ACCESS_TYPE_NAMED_PROXY</strong>
<strong>WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY</strong>
<strong>WINHTTP_ACCESS_TYPE_NO_PROXY</strong> 不使用代理进行通讯</p>
</blockquote>
<p>pszProxyW 指针，当dwAccessType为 <strong>WINHTTP_ACCESS_TYPE_NAMED_PROXY</strong> 时指向代理服务器名字。否则取<strong>WINHTTP_NO_PROXY_NAME</strong>值</p>
<p>pszProxyBypassW 指针，指向字符串， 当dwAccessType为 <strong>WINHTTP_ACCESS_TYPE_NAMED_PROXY</strong> 时指向不想走代理的IP地址或主机名。否则取<strong>WINHTTP_NO_PROXY_BYPASS</strong>值</p>
<p>dwFlags 一般取0</p>
<h4 id="winhttpconnect-handle-to-an-http-session-for-that-initial-target">WinHttpConnect ：返回 链接 句柄（ handle to an HTTP session for that initial target. ）</h4>
<pre><code class="language-纯文本">WINHTTPAPI HINTERNET WinHttpConnect(
  HINTERNET     hSession,
  LPCWSTR       pswzServerName,
  INTERNET_PORT nServerPort,
  DWORD         dwReserved
);
</code></pre>
<p>hSession WinHttpOpen 方法返回的句柄</p>
<p>pswzServerName 指针，指向需要请求的服务器的IP或主机名的字符串</p>
<p>nServerPort 指定请求端口</p>
<p>dwReserved 置0</p>
<h4 id="winhttpopenrequest-http">WinHttpOpenRequest ：创建HTTP请求句柄</h4>
<pre><code class="language-纯文本">WINHTTPAPI HINTERNET WinHttpOpenRequest(
  HINTERNET hConnect,
  LPCWSTR   pwszVerb,
  LPCWSTR   pwszObjectName,
  LPCWSTR   pwszVersion,
  LPCWSTR   pwszReferrer,
  LPCWSTR   *ppwszAcceptTypes,
  DWORD     dwFlags
);
</code></pre>
<p>hConnect WinHttpConnect返回的句柄</p>
<p>pwszVerb 指定HTTP请求方法</p>
<p>pwszObjectName 指定请求资源的路径</p>
<p>pwszVersion 指定HTTP版本</p>
<p>pwszReferrer 多数情况可设置为<strong>WINHTTP_NO_REFERER</strong></p>
<p>ppwszAcceptTypes 指定媒体类型，可设置为<strong>WINHTTP_DEFAULT_ACCEPT_TYPES</strong></p>
<p>dwFlags 通常置0</p>
<h4 id="winhttpaddrequestheaders-http">WinHttpAddRequestHeaders 设置HTTP头</h4>
<pre><code class="language-纯文本">BOOLAPI WinHttpAddRequestHeaders(
  HINTERNET hRequest,
  LPCWSTR   lpszHeaders,
  DWORD     dwHeadersLength,
  DWORD     dwModifiers
);
</code></pre>
<p>hRequest WinHttpOpenRequest返回的句柄</p>
<p>lpszHeaders 指向字符串的指针，字符串里包含了要附加到http请求上的头部信息。每个头部之间用 CR/LF 隔开</p>
<p>dwHeadersLength 头部的长度</p>
<p>dwModifiers 一些功能修饰，一般可以置 WINHTTP_ADDREQ_FLAG_ADD</p>
<h4 id="winhttpsendrequest-http">WinHttpSendRequest 发送HTTP请求</h4>
<pre><code class="language-纯文本">BOOLAPI WinHttpSendRequest(
  HINTERNET hRequest,
  LPCWSTR   lpszHeaders,
  DWORD     dwHeadersLength,
  LPVOID    lpOptional,
  DWORD     dwOptionalLength,
  DWORD     dwTotalLength,
  DWORD_PTR dwContext
);
</code></pre>
<p>hRequest WinHttpOpenRequest返回的句柄</p>
<p>lpszHeaders 附加的HTTP头，如果没有想附加的头就置0</p>
<p>dwHeadersLength lpszHeaders 指定的头的字符串大小</p>
<p>lpOptional 一个指针。指向一个缓冲区，当中包括可选的数据发送后，马上请求标头。该參数通经常使用于POST和PUT操作。 （我理解为传的参数）</p>
<p>dwOptionalLength 额外内容的长度</p>
<p>dwTotalLength 总长度</p>
<p>dwContext 通常置0</p>
<h4 id="winhttpreceiveresponse-http">WinHttpReceiveResponse ：等待http回应</h4>
<pre><code class="language-纯文本">WINHTTPAPI BOOL WinHttpReceiveResponse(
  HINTERNET hRequest,
  LPVOID    lpReserved
);
</code></pre>
<p>hRequest WinHttpOpenRequest 返回的句柄</p>
<p>lpReserved 置NULL</p>
<p>主要作用是如果有回应，则会返回true。</p>
<h4 id="winhttpquerydataavailable-http">WinHttpQueryDataAvailable ：返回HTTP回应内容的大致信息</h4>
<pre><code class="language-纯文本">BOOLAPI WinHttpQueryDataAvailable(
  HINTERNET hRequest,
  LPDWORD   lpdwNumberOfBytesAvailable
);
</code></pre>
<p>lpdwNumberOfBytesAvailable 置NULL，其用来接收内容长度</p>
<h4 id="winhttpreaddata-http">WinHttpReadData 读取HTTP回应内容</h4>
<pre><code class="language-纯文本">BOOLAPI WinHttpReadData(
  HINTERNET hRequest,
  LPVOID    lpBuffer,
  DWORD     dwNumberOfBytesToRead,
  LPDWORD   lpdwNumberOfBytesRead
);
</code></pre>
<p>lpBuffer 指定一片缓冲区，回应的数据会存放到此处</p>
<p>dwNumberOfBytesToRead 缓冲区大小长度</p>
<p>lpdwNumberOfBytesRead 用于存储回应的字节数，在使用该函数时该值须为NULL</p>
<p>说白了，就是以C或c++等语言为载体，调用各种Windows API完成编程
学这个的目的是因为要接触免杀，需要更深层次的了解Windows的一些机制。</p>
<h2 id="com">COM相关</h2>
<h3 id="coinitializeex-com">CoInitializeEx ：创建COM环境</h3>
<pre><code class="language-纯文本">HRESULT CoInitializeEx(
  LPVOID pvReserved,
  DWORD  dwCoInit
);
</code></pre>
<p>pvReserved 必须填NULL</p>
<p>dwCoInit 初始化选项：</p>
<table>
<thead>
<tr>
<th>COINIT_APARTMENTTHREADED</th>
<th>Initializes the thread for apartment-threaded object concurrency (see Remarks).（启动单线程对象）</th>
</tr>
</thead>
<tbody>
<tr>
<td>COINIT_MULTITHREADED</td>
<td>Initializes the thread for multithreaded object concurrency (see Remarks).（启动多线程对象）</td>
</tr>
<tr>
<td>COINIT_DISABLE_OLE1DDE</td>
<td>Disables DDE for OLE1 support.</td>
</tr>
<tr>
<td>COINIT_SPEED_OVER_MEMORY</td>
<td>Increase memory usage in an attempt to increase performance.</td>
</tr>
</tbody>
</table>
<h2 id="_5">一些数据类型</h2>
<h3 id="ntstatus">NTSTATUS</h3>
<p>NTSTATUS是用于系统提供的状态码值的标准32位数据类型。</p>
<table>
<thead>
<tr>
<th>STATUS_SEVERITY_SUCCESS0x0</th>
<th>Success</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATUS_SEVERITY_INFORMATIONAL0x1</td>
<td>Informational</td>
</tr>
<tr>
<td>STATUS_SEVERITY_WARNING0x2</td>
<td>Warning</td>
</tr>
<tr>
<td>STATUS_SEVERITY_ERROR0x3</td>
<td>Error</td>
</tr>
</tbody>
</table>
<h3 id="hresult">HRESULT</h3>
<p>用于描述错误或警告的32位值。</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../../%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../../%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="btn btn-xs btn-link">
        网络协议
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../%E6%9D%82%E8%AE%B0/%E6%9D%82%E8%AE%B0/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../%E6%9D%82%E8%AE%B0/%E6%9D%82%E8%AE%B0/" class="btn btn-xs btn-link">
        杂记
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>